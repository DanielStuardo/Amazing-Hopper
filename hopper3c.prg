/*

  HOPPER
  
  Es un lenguaje de programación prototipo, que presenta una propuesta de programación
  basada en la intuición del lenguaje natural.
  Posee un analizador léxico y sintáctico. No realiza análisis semántico, dado que no
  cuenta con declaración de tipos, y sus registros variables pueden cambiar de tipo en
  el transcurso de la ejecucion del programa.
  Los tipos se analizan dentro de la ejecucón. Es ahí donde existe un analizador semántico,
  en la ejecución.
  
  Esta idea está inspirada en las ideas de Grace Murray Hopper, más conocida como "Amazing
  Grace" (la sorprendente Grace): ella postuló y creó compiladores que permitiesen una
  comunicación más natural con el computador; Hopper, el lenguaje, va un poco más allá,
  centrándose en la intuición de la comunicación natural.
*/

/*REQUEST HB_LANG_ES
HB_LANGSELECT( "ES" )
REQUEST HB_CODEPAGE_UTF8
hb_cdpSelect( "UTF8" )
*/
function main()

public SW_ERROR:=.F.
public _CR:=HB_OSNewline()           //chr(13)+chr(10)
PUBLIC _arr_par:=array(0)
//public _sw_source:=.F.
//public _file
PUBLIC NULL:=""
PUBLIC numLine
PUBLIC filePhantom
PUBLIC swPrototipo:=.F.
PUBLIC swSoloSustituir:=.F.
//PUBLIC sourceFile:=NULL
PUBLIC file
PUBLIC fileTemp
PUBLIC filePhantom
///SETTYPEAHEAD(1)

// Chequea parametros y los asigna a un array (esto queda para la ejecucion)

numParam:=PCOUNT()
if numParam==0
    _header()
    _modo_de_uso()
    release all
    quit
end

//SetTypeahead( 1 )

msgError:=NULL

file:=hb_utf8tostr(hb_pValue(1))    // el nombre del archivo
if !file(file)
   msgError:="file not found or bad filename: "+GenMsg(chr(27)+"[1m"+file+chr(27)+"[0m")
   _error(msgError,0)
end
_arr_par:={}
aadd(_arr_par,file)

iParam:=2
swPreproceso:=.F.
swExec:=.T.
swDebug:=.F.
swGenExec:=.F.
swBinario:=.F.
swOutput:=.F.
swWarning:=.T.
swLibrary:=.F.
swOutDebug:=.F.

binFileOut:=""
libPathOut:=""
if numParam>=iParam
   //_arr_par:=array(numParam-(iParam-1))
   
  //  rellenar array de parametros para distribuir despues de la carga de variables
//   nParametro:=1

   WHILE iParam<=numParam
      if hb_pValue(iParam)=="-p"      // genera archivo de preproceso.
         swPreproceso:=.T.
      elseif hb_pValue(iParam)=="-l"  // genera librería #import. Nada más debe ser seteado
         swLibrary:=.T.
         swExec:=.F.
      elseif hb_pValue(iParam)=="-ne"  // no ejecuta el programa
         swExec:=.F.
      elseif hb_pValue(iParam)=="-d"  // salida de "return" se despliega en pantalla
         swDebug:=.T.
      elseif hb_pValue(iParam)=="-x"  // genera ejecutable, sin extensión. Incluye stack de numLine.
         swGenExec:=.T.
         swExec:=.F.
      elseif hb_pValue(iParam)=="-lb" // archivo de entrada es binario. por default: ejecuta.
         swBinario:=.T.
      elseif hb_pValue(iParam)=="-w" // desactiva los mensajes de warning.
         swWarning:=.F.
      elseif hb_pValue(iParam)=="-s"  // solo sustituye
         swSoloSustituir:=.T.
      elseif hb_pValue(iParam)=="-dbg"  // debug
         swOutDebug:=.T.
      elseif hb_pValue(iParam)=="-o" // salida del archivo binario
         swOutput:=.T.
         ++iParam
         binFileOut:=hb_pValue(iParam)
         libPathOut:=binFileOut
         if len(binFileOut)==0
            _error("Parameter "+GenMsg(chr(27)+"[1m"+"-o"+chr(27)+"[0m")+" need a [path/]filename",0)
         end
      else
         //_arr_par[nParametro]:=hb_pValue(iParam)
         vParametro:=valtype(hb_pValue(iParam))
         if vParametro=="C"
            aadd(_arr_par,hb_pValue(iParam))
         elseif vParametro=="N"
            aadd(_arr_par,val(hb_pValue(iParam)))
         end
//         ++nParametro
      end
      ++iParam
   END
//else
//   _arr_par:={}
end

set date french
set century on
set decimals to 16
set fixed on

SETCANCEL(.T.)

stackPrg:={}
numLine:={}
if swBinario  // carga y ejecuta el archivo binario
   if !GetBinary(file,@stackPrg,@numLine)
      _error("Binary has not been loaded!",0)
   end
   swExec:=.T.
else   // carga el archivo de texto
   //filePhantom := "tmpPreproceso.tmp" //"/tmp/tmpFilePreproMurray_"+alltrim(str(int(hb_random()*1000000000)))
   sufixFile:=alltrim(str(int(hb_random()*1000000000)))
   filePhantom := "/tmp/tmpFilePreproMurray_"+sufixFile
   ////Preproceso(file, filePhantom)
   fileTemp:="/tmp/tmpFileMurray_"+sufixFile
   FileCopy(file,fileTemp)
   Preproceso(fileTemp, filePhantom)

   if swSoloSustituir
      if filemove(filePhantom, file+".hpx") != 0
         msgError:="The file "+GenMsg(chr(27)+"[1m"+file+".ppo"+chr(27)+"[0m")+" can not moved from /tmp"
         _error(msgError,0)
      end
      if file(filePhantom)
         ferase(filePhantom)
      end
      Quit
   end
   
   // copio el archivo para su uso en caso de error en bhopper:
   ActualDir:=dirname()+"/log" 
   if makedir( ActualDir ) ==0
      printmsg("Directory [ ",ActualDir," ] successfully created"+_CR)
   end

   ActualDir+="/"+substr(file,rat("/",file)+1,len(file)) //+".log"
   ActualDir:=substr(ActualDir,1,at(".",ActualDir))+"log"
   FileCopy(fileTemp,ActualDir)
   
   stackPrg := Carga_archivo(filePhantom)

   if swLibrary  .and. !SW_ERROR   // genera archivo de libreria para #import
      libFile:=file
      if swOutput
         libFile:=substr(libFile,rat("/",libFile)+1,len(libFile))+".lib"
         libPathOut+="/"+libFile
      end
      if !GenLibrary(filePhantom, libPathOut) //+file+".lib")
         _error("Library (to #import) has not been created!",0)
      end
   end
   
   if swPreproceso  .and. !SW_ERROR
      if filemove(filePhantom, file+".ppo") != 0
         msgError:="The file "+GenMsg(chr(27)+"[1m"+file+".ppo"+chr(27)+"[0m")+" can not moved from /tmp"
         _error(msgError,0)
      end
   end

   ///   run("cp "+filePhantom+" "+file+".ppo")
   if file(filePhantom)
      ferase(filePhantom)
   end

   //quit

   set decimals to 2
   set fixed off
 /*  for i=1 to len(stackPrg)
      ? i," : ",stackPrg[i]
      ?? " : ", numLine[i]
   end*/
   if swGenExec  .and. !SW_ERROR  // genera ejecutable.
      if !swOutput
         binFileOut:=substr(file,rat("/",file)+1,len(file))
         binFileOut:=substr(binFileOut,1,at(".",binFileOut)-1)
      end
      if !GenExec(file,stackPrg,numLine,binFileOut)
         _error("Executable has not been created!",0)
      else
         cmdsystem("chmod a+x "+binFileOut)
      end
   end
end

if swExec .and. !SW_ERROR
  
  ret := XFUNCALL(_arr_par, stackPrg, numLine)

  if ret[2]==NIL
     msgError:="VM:PROGRAM RETURN NULL -- BAD KID, VERY BAD!"
     _error(msgError,0)
  
  elseif len(ret[2])>2
     _error("vm : "+lower(ret[2]+"(COD:"+hb_ntos(ret[7])+")"),ret[1])
  
  else   // devolvió un valor
     if swDebug
        if valtype(ret[1])=="A"
           print_matrix( ret[1] )
        else
           if valtype(ret[1])=="N"
              fwrite(1,hb_ntos(ret[1])+_CR)
           elseif valtype(ret[1])=="L"
              fwrite(1,iif(ret[1],"1","0")+_CR)
           else
              fwrite(1,ret[1]+_CR)
           end
        end
     end
  end
  
  release ret[1]
  release ret[2]
  release ret[3]
  release ret[4]
  release ret[5]
  release ret[6]
  release ret[7]
  release ret
  if file(fileTemp)
     ferase(fileTemp)
  end

end
release stackPrg  
release _arr_par

////delete_temporal()

///run("rm /tmp/tmpFilePreproMurray_*")

return nil

function GenLibrary(tmpFile, libFile)
LOCAL fl,fd,h_ini,h_fin,c,pLinea,swSave:=.F.
//,nSavePos

fwrite(1,"Generating library "+GenMsg(libFile)+"..."+_CR)
fl:=fcreate(libFile)
if ferror()!=0
   msgError:="Library file create error: "+GenMsg(chr(27)+"[1m"+libFile+chr(27)+"[0m")
   _error(msgError,0)
   return .F.
end
fd:=fopen(tmpFile,0)
if ferror()!=0
   printmsg("Open temporary file "+GenMsg(chr(27)+"[1m"+tmpFile+chr(27)+"[0m")+" error: #"+hb_ntos(ferror())+_CR)
   return .F.
else
   h_fin:=fseek(fd,0,2)
   h_ini:=fseek(fd,0,0)
   c:=" "

   while h_ini<=h_fin
      fread(fd,@c,1); ++h_ini
      if !swSave
         if c=="."
            pLinea:=NULL
            while c!=chr(10) .and. h_ini<=h_fin
               pLinea += c
               fread(fd,@c,1); ++h_ini
            end
            if pLinea==".local" .or. pLinea==".locals"
               swSave:=.T.
               pLinea:=NULL
            end
         end
      else
         fwrite(fl,c)
      end
   end
   fclose(fd)
   fclose(fl)
   if !swSave
      printmsg("Directive "+GenMsg(chr(27)+"[1m .locals"+chr(27)+"[0m")+" not found (i need for library)"+_CR)
      return .F.
   end
end
return

#define LBYTES 2
#define UBYTES 1

function GetBinary(archivoExec,stackPrg,numLine)
LOCAL fd,c
LOCAL _cnt_byte:=0,i,long:=0,cStr,nRegs,nLong,nResv,cntR:=0

fd:=fopen(archivoExec,0)
if ferror()!=0
   //fwrite(1,"Open program "+GenMsg(archivoExec)+" error: #"+hb_ntos(ferror())+_CR)
   printmsg("Open program "+GenMsg(chr(27)+"[1m"+archivoExec+chr(27)+"[0m")+" error: #"+hb_ntos(ferror())+_CR)
   return .F.
else

   // lee bang line, si es que la tiene, para ejecución a la shell
   c:=" "
   fread(fd,@c,UBYTES)
   nSavePos := fseek( fd, 0, 1 )
   if c=="#"
      fread(fd,@c,UBYTES)
      nSavePos := fseek( fd, 0, 1 )
      if c=="!"
        strShell:="#!"
        
        while c!=chr(10)   // lee todo #!/usr/bin/bhopper
           fread(fd,@c,UBYTES)
           nSavePos := fseek( fd, 0, 1 )
           if c!=chr(10)
              strShell+=c
           end
        end
        if strShell!="#!/usr/bin/bhopper"
            fwrite(1,"* "+GenMsg(archivoExec)+" is not a valid binary Hopper file! ("+strShell+")"+_CR)
            return .F.
        end
      else  // error!
         fwrite(1,"* "+GenMsg(archivoExec)+" is not a valid binary Hopper file!"+_CR)
         return .F.
      end
   else
      fseek(fd,nSavePos-1,0)
   end
   
   c:="    "
   fread(fd,@c,LBYTES)
   if c!="B"
      fclose(fd)
      //fwrite(1,"Binary "+GenMsg(archivoExec)+" is not a Hopper valid"+_CR)
      printmsg("Binary "+GenMsg(chr(27)+"[1m"+archivoExec+chr(27)+"[0m")+" is not a Hopper valid"+_CR)
      return .F.
   else
      fread(fd,@c,LBYTES)
      if c!="H"
         fclose(fd)
         //fwrite(1,"Binary "+GenMsg(archivoExec)+" is not a Hopper valid"+_CR)
         printmsg("Binary "+GenMsg(chr(27)+"[1m"+archivoExec+chr(27)+"[0m")+" is not a Hopper valid"+_CR)
         return .F.
      end
   end
   // lee longitud del programa
   c:="    "
   fread(fd,@c,LBYTES)
   long:=bin2I(c)
   stackPrg:=array(long)
   numLine:=array(long)
   // leo encabezado:
   fread(fd,@c,LBYTES); nRegs:=bin2I(c)  // numero de registros y cotes
   stackPrg[1]:=nRegs
   fread(fd,@c,LBYTES); nLong:=bin2I(c)  // long stack
   stackPrg[2]:=nLong
   fread(fd,@c,LBYTES); nResv:=bin2I(c)  // reservado
   stackPrg[3]:=nResv
   fread(fd,@c,LBYTES); nResv:=bin2I(c)  // sw ctrl+c
   stackPrg[4]:=nResv
   // lee stack de registros y constantes:
//   ? 1," : ",stackPrg[1]
//   ? 2," : ",stackPrg[2]
//   ? 3," : ",stackPrg[3]
   i:=5
   while !hb_feof(fd)
      fread(fd,@c,LBYTES); stackPrg[i]:=bin2I(c)   // leo '0'?
    //  ? i," COD: ",stackPrg[i]
      if stackPrg[i]!=255
         fread(fd,@c,LBYTES); stackPrg[++i]:=bin2I(c)   // leo pos
    //     ? i," POS: ",stackPrg[i]
         ++i          // avanzo a tipo de dato, y dato
         fread(fd,@c,LBYTES)   // leo tipo de dato
         if bin2I(c)==0   // es un numero
            c:="    "
            cStr:=""
            while c!=chr(255)
               fread(fd,@c,LBYTES)
               if c!=chr(255)
                  cStr+=chr(bin2I(c))
               end
            end
            stackPrg[i]:=val(cStr)
    //        ? i," NUM: ",stackPrg[i]

         elseif bin2I(c)==2   // debe ser string?
            c:="    "
            cStr:=""
            while c!=chr(255)
               fread(fd,@c,LBYTES)
               if c!=chr(255)
                  cStr+=chr(bin2I(c))
               end
            end
            stackPrg[i]:=cStr//hb_UTF8tostr(cStr)
    //        ? i," STR: ",stackPrg[i]
         else
            fclose(fd)
            //fwrite(1,"Binary "+GenMsg(archivoExec)+": register stack bad formed"+_CR)
            printmsg("Binary "+GenMsg(chr(27)+"[1m"+archivoExec+chr(27)+"[0m")+": register stack bad formed"+_CR)
            return .F.
         end
      else
         exit
      end
      ++i
   end
   cntR:=i+1
   // lee resto de programa:
   for i:=cntR to long
      fread(fd,@c,LBYTES); stackPrg[i]:=bin2I(c)
  //    ? i," PRG: ",stackPrg[i]
   end
   // lee numeros de línea
   for i:=1 to long
      fread(fd,@c,LBYTES)
      numLine[i]:=bin2I(c)
   end
end
fclose(fd)
return .T.

function GenExec(file,stackPrg,numLine,archivoExec)
LOCAL fd
LOCAL _cnt_byte:=0,i,j,long:=0,cad,nRegs,nLong,nResv,cNum,cntR:=0

fwrite(1,"Generating binary "+GenMsg(archivoExec)+"...")
fd:=fcreate(archivoExec)
long:=len(stackPrg)
// guardo bang line para ser ejecutado
fwrite(fd,I2bin(asc("#")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("!")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("/")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("u")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("s")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("r")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("/")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("b")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("i")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("n")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("/")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("b")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("h")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("o")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("p")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("p")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("e")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("r")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(asc("3")),UBYTES) ;++_cnt_Byte
fwrite(fd,I2bin(10),UBYTES) ;++_cnt_Byte
// guardo encabezado: identifica que se trata de un programa XU
fwrite(fd,I2bin(asc("B")),LBYTES) ;++_cnt_Byte   // binary
fwrite(fd,I2bin(asc("H")),LBYTES) ;++_cnt_Byte   // hopper
fwrite (fd,I2bin(long),LBYTES) ;++_cnt_Byte   // longitud del programa

nRegs:=stackPrg[1] // numero de registros y ctes
fwrite (fd,I2bin(nRegs),LBYTES) ;++_cnt_Byte        
fwrite (fd,I2bin(stackPrg[2]),LBYTES) ;++_cnt_Byte   // long stack
fwrite (fd,I2bin(stackPrg[3]),LBYTES) ;++_cnt_Byte   // reservado
fwrite (fd,I2bin(stackPrg[4]),LBYTES) ;++_cnt_Byte   // switch de ctrl+c

// guarda stack de registros y constantes
// OJO! HAY REGISTROS, ESTOS ESTÁN VACÍOS Y CAGAN EL BINARIO. TODO
// TODO: NO ES NREGS*3, PORQUE NO SE CUENTAN LOS REGISTROS. DEBO CONSIDERAR POSICION EN WHILE.
i:=5
while stackPrg[i]!=255
   fwrite (fd,I2bin(stackPrg[i]),LBYTES) ;++_cnt_Byte  // guardo '0'
   fwrite (fd,I2bin(stackPrg[++i]),LBYTES) ;++_cnt_Byte  // guardo pos.
   ++i     // avanzo al dato
   if valtype(stackPrg[i])=="N"
      fwrite (fd,I2bin(0),LBYTES) ;++_cnt_Byte   // 0=numero
      cNum:=alltrim(str(stackPrg[i]))
      for j:=1 to len(cNum)
         cad:=substr(cNum,j,1)
         fwrite(fd,I2bin(asc(cad)),LBYTES) ;++_cnt_Byte
      next
      fwrite (fd,I2bin(255),LBYTES) ;++_cnt_Byte   // termina de leer el string

   else
      fwrite (fd,I2bin(2),LBYTES) ;++_cnt_Byte    // 2=string
      for j:=1 to len(stackPrg[i])
         cad:=substr(stackPrg[i],j,1)
         fwrite(fd,I2bin(asc(cad)),LBYTES) ;++_cnt_Byte
      next
      fwrite (fd,I2bin(255),LBYTES) ;++_cnt_Byte   // termina de leer el string
   end
   ++i
end
cntR:=i
// guarda resto de programa:
for i:=cntR to long
   fwrite (fd,I2bin(stackPrg[i]),LBYTES) ;++_cnt_Byte
end

// guardo lista de numeros de lineas
for i:=1 to long
   fwrite (fd,I2bin(numLine[i]),LBYTES) ;++_cnt_Byte
next

fwrite(1,"Ok! "+_CR)
fwrite(1,"Symbols: "+hb_ntos(stackPrg[1])+_CR)
fwrite(1,"Total size: "+hb_ntos(_cnt_Byte/1024) + " Kb"+_CR)
fclose(fd)

return .T.

function GenMsg(msg)
LOCAL pLeft:="‘",pRight:="’" // no tienen un valor ascii definido, sino, un conjunto. OJO!
return pLeft+msg+pRight

function EvPolaca(cola, linErr, DEF,blkIF,blkELSE,blkEND,blkWHILE,blkEWHILE,lineStruct)  // cola=q, pila=pila
local sw,l,m,_i,k,lc, pila, p, orden, String,pilaIF,pilaELSE,i,funcion,simbolos,__swlogic
local dato, label

   #define AND    "&&"
   #define XOR    "|^"
   #define OR     "||"

/* saltos   :={"jmp"=>6, "jeq"=>7, "jneq"=>8, "jlt"=>9,;
             "jle"=>10, "jgt"=>11, "jge"=>12,;
             "jt"=>13, "jnt"=>14, "jv"=>15, ;
             "jnv"=>16, "jz"=>17, "jnz"=>18,;
             "jneg"=>19, "jpos"=>20,"gosub"=>21, "jsub"=>22} */

/*  funcion :={"iseq"=>23, "isneq"=>24, "isnoteq"=>24,;
             "islt"=>25, "isle"=>26, "isgt"=>27,  "isge"=>28, ;
             "isneg"=>29, "ispos"=>30,;
             "iscin"=>32,"isoccursin"=>32, "isecin"=>31, "isexactoccursin"=>31, ;
             "iszero"=>33, "isnotneg"=>361, "isnotpos"=>362,;
             "isvoid"=>34,  "isbetween"=>35, "isemptystack"=>36, "isenv"=>37, "isexist"=>38, "getstrerror"=>39,;
             "add"=>40,  "sub"=>41, "mul"=>42,  "div"=>43,  "idiv"=>44,  "pow"=>45, "power"=>45,"mod"=>46,"module"=>46,"round"=>47,;
             "max"=>48, "min"=>49, "xtobool"=>51, "kbfree"=>52, "keyput"=>53,;
             "rleft"=>54,"rright"=>55,"rall"=>56,"isinf"=>57,"isnan"=>58, "cut"=>59, ;
             "len"=>60, "upper"=>61, "lower"=>62, "trim"=>63, "asc"=>64, "trimright"=>65, "trimleft"=>66, "xtonum"=>67,;
             "isall"=>68, "isany"=>69,"elaptime"=>72, "elapsedtime"=>72,"daysdiff"=>73,;
             "dateadd"=>74,"$"=>75, "$$"=>76, "rcut"=>77, "regvalid"=>78, "regmatch"=>79, ;
             "exp"=>80, "int"=>81, "sign"=>82, "log"=>83, "log10"=>84, "sqrt"=>85, "sin"=>86, "cos"=>87, "tan"=>88,;
             "sinh"=>89, "cosh"=>90, "tanh"=>91, "xtostr"=>92, "floor"=>93, "abs"=>94, "chr"=>95, "ceil"=>96, ;
             "exp2"=>97, "log2"=>98, "exp10"=>99, "hex"=>100, "bin"=>101, "oct"=>102, "lennum"=>103, "fact"=>104,;
             "sci"=>105, "notation"=>105, "d2r"=>106, "r2d"=>107,;
             "cbrt"=>108, "rand"=>109, "trunc"=>110, "iseven"=>111, "neg"=>112, ;
             "if"=>113, "endif"=>114,"while"=>115,"until"=>50,"do"=>71, "wend"=>39, "else"=>139, "elseif"=>174, ;
             "break"=>178,"breakif"=>190,"continue"=>400,"continueif"=>401,"exitall"=>402,"exitallif"=>403,;
             "sizestack"=>116,;
             "clr"=>117,"cartesian"=>118,"loc2"=>119,"loc1"=>120,"interval1"=>121,"interval2"=>122,"interval3"=>123,;
             "show"=>124, "or"=>125, "and"=>126, "xor"=>127, "nor"=>128, "nand"=>129, "not"=>130, "totalarg"=>131,;
             "type"=>132,"iserror"=>133, "pause"=>134,"microsecs"=>135, "return"=>136, "transform"=>137,;
             "getenv"=>138, "iskbhit"=>140, "iskbesc"=>141, "echo"=>142, "replace"=>143,"print"=>144,;
             "copy"=>145, "offset1"=>146, "true"=>147,"sectotime"=>148, "iskbctrlc"=>149,;
             "isnumeric"=>150,"isstring"=>151,"isarray"=>152,"length"=>153,;
             "kill"=>154, "clearstack"=>155, "countat"=>156,;
             "findat"=>157, "find"=>158, "mask"=>159, "money"=>160, "multipasson"=>161,;
             "multipassoff"=>162, "toksep"=>163, "seconds"=>164, ;
             "false"=>165, "matmul"=>166,;
             "padcenter"=>167, "padright"=>168, "padleft"=>169, "cat"=>170, "repl"=>171, "replicate"=>171,;
             "setenv"=>172, "unsetenv"=>173,"onlychar"=>175, "compact"=>176, "offset2"=>177,;
             "ins"=>179,"insert"=>179, "del"=>180,"delete"=>180, "statsfile"=>181, "strtoutf8"=>182,;
             "utf8tostr"=>183, "deletechar"=>184, "fileerror"=>185, "load"=>186, "save"=>187, "exec"=>188,"sleep"=>189,;
             "onechar"=>191, "poschar"=>192 ,"printusingtoken"=>193,"keep"=>194,"puts"=>195,"goxy"=>196,;
             "clockpersec"=>197, "execv"=>198,"cli"=>199,;
             "arcsin"=>322,"arccos"=>323,"arctan"=>324,"arcsinh"=>325,"arccosh"=>326,"arctanh"=>327,;
             "seed"=>332,"sqrdiff"=>334,"sqradd"=>335,"hypot"=>336,"mulall"=>337,"sumall"=>338,;
             "iseqarr"=>339,"isneqarr"=>340,"print2d"=>342,;
             "gcd"=>343,"lcm"=>344,"typestring"=>346,"disttypestring"=>347,"chrutf8"=>348}*/
   
   funcion :={"isneg"=>29, "ispos"=>30,"eoccurs"=>31,"occurs"=>32,"iszero"=>33,;
             "isvoid"=>34, "isbetween"=>35, "isemptystack?"=>36, "isenvvar"=>37, "exist"=>38, "getstrerror"=>39,;
             "round"=>47,"max"=>48, "min"=>49,"bool"=>51, "kbfree"=>52, "keyput"=>53,;
             "rleft"=>54,"rright"=>55,"rall"=>56,"isinf"=>57,"isnan"=>58, "cut"=>59, ;
             "len"=>60, "upper"=>61, "lower"=>62, "trim"=>63, "asc"=>64, "rtrim"=>65, "ltrim"=>66, "number"=>67,;
             "isall"=>68, "isany"=>69, "elaptime"=>72,"daysdiff"=>73,"dateadd"=>74,;
             "gettk"=>75, "modtk"=>76, "rcut"=>77, "regvalid"=>78, "regmatch"=>79, ;
             "exp"=>80, "int"=>81, "sign"=>82, "log"=>83, "log10"=>84, "sqrt"=>85, "sin"=>86, "cos"=>87, "tan"=>88,;
             "sinh"=>89, "cosh"=>90, "tanh"=>91, "string"=>92, "floor"=>93, "abs"=>94, "chr"=>95, "ceil"=>96, ;
             "exp2"=>97, "log2"=>98, "exp10"=>99, "hex"=>100, "bin"=>101, "oct"=>102, "lennum"=>103, "fact"=>104,;
             "notation"=>105, "radian"=>106, "degree"=>107,;
             "cbrt"=>108, "rand"=>109, "trunc"=>110, "iseven"=>111, "neg"=>112,/* "nop"=>113,*/ "dup"=>114,;
             "typechar"=>115,"sizstk"=>116,;
             "clrrng"=>117,"cartesian"=>118,;/*"loc2"=>119,"loc1"=>120,"interval1"=>121,"interval2"=>122,"interval3"=>123,;*/
             "show"=>124, "xor"=>127, "nor"=>128, "nand"=>129, "not"=>130 /*, "totalarg"=>131*/,;
             "type"=>132,"iserror"=>133,"pause"=>134,"microsecs"=>135, "return"=>136, "strtran"=>137,;
             "getenv"=>138, /* "back"=>139, */ "iskbhit"=>140,  "iskbesc"=>141, ;
             "echo"=>142,"replace"=>143,"print"=>144,;
             "mid"=>145, /*"offset1"=>146,*/ "true"=>147,"sec2time"=>148, "iskbctrlc"=>149,;
             "isnumeric"=>150,"isstring"=>151,"isarray"=>152,"length"=>153,;
             /*"kill"=>154,*/ "clrstk"=>155, "countat"=>156,;
             "findat"=>157, "find"=>158, "mask"=>159, "money"=>160,"multipasson"=>161,;
             "multipassoff"=>162, "toksep"=>163, "seconds"=>164, ;
             "false"=>165, "matmul"=>166,;
             "cpad"=>167, "rpad"=>168, "lpad"=>169, "cat"=>170, "replicate"=>171,;
             "setenv"=>172, "unsetenv"=>173, "dayname"=>174, "onlychar"=>175, "compact"=>176,/* "offset2"=>177,*/;
             /*"ptr"=>178,*/ "insert"=>179, "delete"=>180, "statsfile"=>181, "utf8"=>182,;
             "ansi"=>183, "deletechar"=>184, "fileerror"=>185, "load"=>186, "save"=>187, "exec"=>188,"sleep"=>189,;
             "drwtbl"=>190, "onechar"=>191, "poschar"=>192 ,"printusingtk"=>193,/*"keep"=>194,*/"puts"=>195,"goxy"=>196,;
             "clockpersec"=>197, "execv"=>198,"clrinterv"=>199,;
             "arcsin"=>322,"arccos"=>323,"arctan"=>324,"arcsinh"=>325,"arccosh"=>326,"arctanh"=>327,;
             "isempty"=>328,"gox"=>329,"goy"=>330,"monthname"=>331,"seed"=>332,"gettoksep"=>333,"sqrdiff"=>334,"sqradd"=>335,;
             "hypot"=>336,"mulall"=>337,"sumall"=>338,"iseqarr"=>339,"isnoteqarr"=>340,"swap"=>341,"prntbl"=>342,;
             "gcd"=>343,"lcm"=>344,"getsizscr"=>345,"typestring"=>346,"disttypestring"=>347,"chrutf8"=>348,/*"getnotation"=>349,*/;
             "sjoin"=>350,"updrow"=>351,"updcol"=>352,"fillbox"=>353,"dumparray"=>354,"existdir"=>355,"getenvnum"=>356,;
             "isoutbetween" => 357, "line"=>358, "circle"=>359, "poligon"=>360,"isnotneg"=>361, "isnotpos"=>362,;
             "list"=>363,;
             "if"=>500, "endif"=>501,"while"=>501,"until"=>503,"do"=>504, "wend"=>505, "else"=>506, "elseif"=>507, ;
             "break"=>508,"breakif"=>509,"continue"=>510,"continueif"=>511,"exitall"=>512,"exitallif"=>513}
   
   simbolos:={"+"=>"add","-"=>"sub","*"=>"mul","/"=>"div","\"=>"idiv","!"=>"not",;
              "%"=>"mod","^"=>"pow","=="=>"eq?","<"=>"lt?",">"=>"gt?","<="=>"le?",">="=>"ge?","<>"=>"neq?","!="=>"neq?",;
              AND=>"and",OR=>"or"}
   pila:={}
   p:={}
   aadd(pila,"(")
   k:=1
   lc:=len(cola)
   set exact on
   while k<=lc

      sw:=.F.
      l:=cola[k++]

      if ISTNUMBER(l)==1
        // if(l=="-")
        //    ? "ENCONTRE = ",l
        // end
         aadd(p,l)
//      elseif ISNOTATION

      else 
         
         if is_noall(l,"+","-","*","/","\","%",")","(","^","==","<",">","<=",">=","<>","!=",AND,OR,XOR)
            orden := hb_HGetDef( funcion, l, -1 )
            if orden>0
               aadd(pila,l)     // es funcion
            else
               if getopdefine(DEF,l)
                  aadd(pila,l)
               else
                  //_Error ("Error(1): Símbolo no definido ["+l+"]",linErr)
                  if ":=" $ l
                     aadd(pila,l)  // será tratado como función, pero es asignación CPY
               /*   elseif ascan(DEF, l)>0   // es macro-funcion
                     aadd(pila,l) */
                  else
                     aadd(p,l)
                  end
               end
            end
         elseif l=="NOP0" .or. l=="NOP1" .or. l=="END0"
            aadd(p,l)
         else
            if l=="("
               aadd(pila,l)
            elseif is_any(l,"+","-","*","/","\","%","^") .or. is_any(l,/*"=",*/"<",">" ) .or. getopdefine(DEF,l);
                   .or.hb_HGetDef( funcion, l, -1 )!=-1 .or. is_any(l,"==","<>","!=","<=",">=",AND,OR,XOR)/* .or. ;
                   ascan(DEF, l)>0 */  // es macro-funcion

               while !sw
                  m:=stackpop(pila)
                  if m=="("
                     aadd(pila,m)  //mete m en pila
                     aadd(pila,l)  //mete l en pila
                     sw:=.T.; loop
                  end
                  if is_any(l,OR,AND,XOR)
                     __swlogic:=.F.
                     while is_any(m,/*"=",*/"<",">" ) .or. is_any(m,"==","<>","!=","<=",">=",OR,AND) .or. l==XOR .or.;
                           is_any(m,"+","-","*","/","\","%","^") .and. m!="("
                       // ? "L= ",l," ; M= ",m
                        if l==OR .and. is_any(m,AND,XOR)
                           aadd(p,m)
                           aadd(pila,l)
                           __swlogic:=.T.
                           exit
                        elseif l==AND .and. m==OR
                           aadd(pila,m)
                           aadd(pila,l)
                           __swlogic:=.T.
                           exit
                        elseif l==OR.and.m==OR
                           aadd(pila,m)
                           aadd(pila,l)
                           __swlogic:=.T.
                           exit                           
                        else
                           aadd (p,m)
                           m:=stackpop(pila)
                        end
                     end
                     if !__swlogic
                        aadd(pila,m)  // pongo el utimo simbolo leido porque no es lsim ni operador
                        aadd (pila,l)
                     end
                     sw:=.T.; loop
                  elseif is_any(l,/*"=",*/"==","<=",">=","<>","!=","<",">")
                     if is_any(m,"+","-","*","/","\","%",")","(","^")
                        aadd(p,m)
                        aadd(pila,l)

                     else
                        aadd(pila,m)
                        aadd(pila,l)
                     end
                     sw:=.T.; loop
                  end
                  if l=="^"
                     if m=="^"
                        aadd(p,m)  //mete m en p
                        aadd(p,l)
                     else
                        aadd(pila,m) //mete m en pila
                        aadd(pila,l) //mete l en pila
                        sw:=.T.
                     end
               
                  elseif l=="*" 
                     if is_any(m,/*"=",*/"<",">" ) .or. is_any(m,"==","<>","!=","<=",">=")
                        aadd(pila,m)  
                        aadd(pila,l)
                        sw:=.t.
                     elseif is_any(m,"^","*","/","\","%") 
                        aadd(p,m)   //mete m en p
                     else
                        if (hb_HGetDef( funcion, m, -1 )!=-1 .or. getopdefine(DEF,m)) .and. is_noall(m,AND,OR,XOR)
                           aadd(p,m)
                        else
                           aadd(pila,m) //mete m en pila
                        end
                        aadd(pila,l) //mete l en pila
                        sw:=.T.
                     end
               
                  elseif is_any(l,"/","\","%") 
                     if is_any(m,/*"=",*/"<",">" ).or. is_any(m,"==","<>","!=","<=",">=") 
                        aadd(pila,m)   
                        aadd(pila,l)
                        sw:=.t.
                     elseif is_any(m,"*","^","/","\","%" ) 
                        aadd(p,m)     //mete l en p
                        aadd(pila,l) //mete m en pila

                        sw:=.T.
                     else
                        if (hb_HGetDef( funcion, m, -1 )!=-1 .or. getopdefine(DEF,m)).and. is_noall(m,AND,OR,XOR)
                           aadd(p,m)
                        else
                           aadd(pila,m) //mete m en pila
                        end
                        aadd(pila,l) //mete l en pila
                        sw:=.T.
                     end
                
                  elseif is_any(l,"-","+")
                     if is_any(m,/*"=",*/"<",">" ) .or. is_any(m,"==","<>","!=","<=",">=",OR,AND,XOR) 
                        aadd(pila,m)   
                        aadd(pila,l)
                     else  
                        aadd(p,m)       //mete m en p
                        aadd(pila,l)    //mete l en pila
                     end
                     sw:=.T.
           
               // -------  Y si es funcion?
                  elseif hb_HGetDef( funcion, l, -1 )!=-1 .or. getopdefine(DEF,l)
                     aadd(pila,m)
                     aadd(p,l)
                     sw:=.T.
               // -------------------------
                  end
               end   // while

               if len(pila)==0 
                  aadd(pila,"(")   //mete cen en pila
               end
            elseif l==")"          // es un parentesis derecho?
               m:=stackpop(pila)        // extrae de pila para m
               while m!="(" 
                  aadd(p,m)        //mete m en p
                  m:=stackpop(pila)     // extrae de pila para m
                  if m==nil
                     _Error ("Math expresion error",linErr)
                  end
               end
               if len(pila)>0
                  m:=stackpop(pila)
                  if hb_HGetDef( funcion, m, -1 )!=-1 .or. getopdefine(DEF,m)
                     aadd(p,m)
                  else
                     aadd(pila,m)   // regresa a pila
                  end
               end
            end
         end
      end
   end
   if len(pila)>0
      m:=stackpop(pila)
      while m!="("
         aadd(p,m)
         m:=stackpop(pila)
      end
   end
   
 //  String:="postfix,"
   String:=""
   
  //? "PILA="
   orden:=NULL
   dato:=NULL
   set exact on
   
   pilaIF:={}
   label:="END"+alltrim(str(int(hb_random()*1000000000)))
   pilaELSE:={label}
   //? "****VUELTA*****"
   for i:=1 to len(p)
     //? "SIMBOLO = ",p[i]
      orden:=hb_HGetDef( simbolos, p[i], "" )
      if len(orden)==0
         orden:=hb_HGetDef( funcion, p[i], -1 )
         if orden<0
            if getopdefine(DEF,p[i])
               if substr(p[i],1,1)=="_"
                  dato := ";jsub("+substr(p[i],2,len(p[i]))+");"
               else
                  // Aquí van todas las definiciones posibles.
                  dato := p[i]
               end
            else
               if substr(p[i],1,1)=='"'
                  dato:="{"+p[i]+"}"
            
               elseif !("[" $ p[i])
                  if ":=" $ p[i]
                     _var:=substr(p[i],1,at(":=",p[i])-1)
                     dato:=";cpy("+_var+")"   // MOD.20-03-2022
                     ///dato:=_var+"=0;cpy("+_var+")"
                     //dato:=",clear("+_var+"),cpy("+_var+")"  // MOD.30-11-2021
                  else
                     if p[i]=="NOP0"
                        label:="IF"+alltrim(str(int(hb_random()*1000000000)))
                        stackpush(pilaIF,label)
                        dato:="jnt("+label+")"
                     elseif p[i]=="NOP1"
                        dato:="jmp("+pilaELSE[1]+")"
                        if len(pilaIF)>0
                           dato+=";"+stackpop(pilaIF)+":"
                        else
                           _Error("Error: conditional "+GenMsg(chr(27)+"[1m"+"?:"+chr(27)+"[0m")+" bad formed",linErr)
                        end
                     elseif p[i]=="END0"
                        if len(pilaELSE)>0
                           dato:=stackpop(pilaELSE)+":"
                        else
                           _Error("Error: conditional "+GenMsg(chr(27)+"[1m"+"?:"+chr(27)+"[0m")+" bad formed",linErr)
                        end
                       // añadir nuevo END por si hay más bifurcaciones inline
                        label:="END"+alltrim(str(int(hb_random()*1000000000)))
                        pilaELSE:={label}
                     else
                        dato:="{"+p[i]+"}"
                     end
                  end
               else
                  dato:=p[i]
               end
            end // getopdefine
         else
            if p[i]=="if"
               label:="BLKIF"+alltrim(str(int(hb_random()*1000000000)))
               stackpush(blkIF,label)
               dato:="jnt("+label+")"
               
               label:="END"+alltrim(str(int(hb_random()*1000000000)))
               stackpush(blkEND,label)
               stackpush(lineStruct,{"if",linErr})
            elseif p[i]=="else"
               if len(blkEND)>0
                  dato:="jmp("+blkEND[len(blkEND)]+")"
               else
                  _Error("Error: macro conditional "+GenMsg(chr(27)+"[1m"+"if/else"+chr(27)+"[0m")+" bad formed",linErr)
               end
               if len(blkIF)>0
                  dato+=";"+stackpop(blkIF)+":"
// MOD 30-11-2021.  Añadir una etiqueta fantasma a blkIF, para evitar el error de los IFs anidados
                  label:="PHANTIF"+alltrim(str(int(hb_random()*1000000000)))
                  stackpush(blkIF,label)
//
               else
                  _Error("Error: macro conditional "+GenMsg(chr(27)+"[1m"+"else: "+dato+chr(27)+"[0m")+" bad formed",linErr)
               end            
            elseif p[i]=="elseif"
               if len(blkEND)>0 .and. len(blkIF)>0
                  String:="jmp("+blkEND[len(blkEND)]+");"+stackpop(blkIF)+":;"+String
               else
                  _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+"elseif"+chr(27)+"[0m")+" bad formed",linErr)
               end
               label:="BLKIF"+alltrim(str(int(hb_random()*1000000000)))
               stackpush(blkIF,label)
               dato:="jnt("+label+")"
               
            elseif p[i]=="endif"
               if len(blkEND)>0
                  dato:=stackpop(blkEND)+":;"+iif(len(blkIF)>0,stackpop(blkIF)+":","")
               else
                  _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+"endif"+chr(27)+"[0m")+" bad formed",linErr)
               end
               if len(lineStruct)>0
                  if lineStruct[len(lineStruct)][1]!="if"
                     _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+lineStruct[len(lineStruct)][1]+chr(27)+"[0m")+" not closed",lineStruct[len(lineStruct)][2])
                  end
               else
                  _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+"*if"+chr(27)+"[0m")+" bad formed",linErr)
               end
               stackpop(lineStruct)
               
            elseif p[i]=="while"
               label:="BLKIWHILE"+alltrim(str(int(hb_random()*1000000000)))
               stackpush(blkWHILE,label)
               String:=label+":,"+String
               label:="BLKWHILE"+alltrim(str(int(hb_random()*1000000000)))
               stackpush(blkEWHILE,label)
               dato:="jnt("+label+")"
               stackpush(lineStruct,{"while",linErr})
            elseif p[i]=="wend"
               if len(blkEWHILE)>0 .and. len(blkWHILE)>0
                  dato:="jmp("+stackpop(blkWHILE)+");"+stackpop(blkEWHILE)+":"
               else
                  _Error("Error: macro-loop "+GenMsg(chr(27)+"[1m"+"while/wend"+chr(27)+"[0m")+" bad formed",linErr)
               end
               if len(lineStruct)>0
                  if lineStruct[len(lineStruct)][1]!="while"
                     _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+lineStruct[len(lineStruct)][1]+chr(27)+"[0m")+" not closed",lineStruct[len(lineStruct)][2]) 
                  end
               else
                  _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+"while"+chr(27)+"[0m")+" bad formed",linErr)
               end
               stackpop(lineStruct)
            elseif p[i]=="do" .or. p[i]=="repeat"
               label:="BLKIDO"+alltrim(str(int(hb_random()*1000000000)))
               stackpush(blkWHILE,label)
               dato:=label+":"
               
               label:="BLKENDUNTIL"+alltrim(str(int(hb_random()*1000000000)))
               stackpush(blkEWHILE,label)
               
               stackpush(lineStruct,{"do",linErr})
            elseif p[i]=="until"
               if len(blkWHILE)>0 .and. len(blkEWHILE)>0
                  dato:="jnt("+stackpop(blkWHILE)+");"+stackpop(blkEWHILE)+":"
               else
                  _Error("Error: macro-loop "+GenMsg(chr(27)+"[1m"+"do/until"+chr(27)+"[0m")+" bad formed",linErr)
               end
               if len(lineStruct)>0
                  if lineStruct[len(lineStruct)][1]!="do"
                     _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+"do/until"+chr(27)+"[0m")+" bad formed",linErr)
                  end
               else
                  _Error("Error: macro-conditional "+GenMsg(chr(27)+"[1m"+"do"+chr(27)+"[0m")+" bad formed",linErr)
               end
               stackpop(lineStruct)
            elseif p[i]=="break"
               if len(blkEWHILE)>0
                  dato:="jmp("+blkEWHILE[len(blkEWHILE)]+")"
               else 
                  _Error("Error: exit loop "+GenMsg(chr(27)+"[1m"+"break"+chr(27)+"[0m")+" without structure",linErr)
               end
            elseif p[i]=="exitall"
               if len(blkEWHILE)>0
                  dato:="jmp("+blkEWHILE[1]+")"
               else 
                  _Error("Error: exit all loops "+GenMsg(chr(27)+"[1m"+"exit all"+chr(27)+"[0m")+" without structure",linErr)
               end
            elseif p[i]=="exitallif"
               if len(blkEWHILE)>0
                  dato:="jt("+blkEWHILE[1]+")"
               else 
                  _Error("Error: exit all loops "+GenMsg(chr(27)+"[1m"+"exit all if"+chr(27)+"[0m")+" without structure",linErr)
               end

            elseif p[i]=="breakif"
               if len(blkEWHILE)>0
                  dato:="jt("+blkEWHILE[len(blkEWHILE)]+")"
               else 
                  _Error("Error: exit loop "+GenMsg(chr(27)+"[1m"+"break if"+chr(27)+"[0m")+" without structure",linErr)
               end
            elseif p[i]=="continue"
               if len(blkWHILE)>0
                  dato:="jmp("+blkWHILE[len(blkWHILE)]+")"
               else 
                  _Error("Error: exit loop "+GenMsg(chr(27)+"[1m"+"continue"+chr(27)+"[0m")+" without structure",linErr)
               end
            elseif p[i]=="continueif"
               if len(blkWHILE)>0
                  dato:="jt("+blkWHILE[len(blkWHILE)]+")"
               else 
                  _Error("Error: exit loop "+GenMsg(chr(27)+"[1m"+"continue if"+chr(27)+"[0m")+" without structure",linErr)
               end
            else
            dato:=p[i]
            end
         end
      else
         dato:=orden
      end
      
      String += dato + ";"  //iif(len(orden)>0, orden, "{"+p[i]+"}" )+","
   end
 //  ? " EV-POLACA = ",String
/*   if len(pilaIF)>0 .or. len(pilaELSE)>0
      _Error("Error: conditional "+GenMsg("?:")+" bad formed",linErr)
   end */
  // String += "postfix"
   hb_HClear(funcion)
   hb_HClear(simbolos)
//   hb_HClear(saltos)

return String

function replaceRange(pString,tipo,lineaFisica)
local nTok, nTok1,cStr,cLinea,cString,rangoF,rangoC,rangoP,i,j,c,posEnd,v,w
local Separator
     /* busco por "end" en rango */
     Separator:=","
    /* if ";" $ pString .and. !("," $ pString)
        Separator:=";"
     end */
     /*debo buscar "end" carcater a caracter, para no reemplaza en "calendario", ni nada parecido, solo "end"*/
     /*while (posEnd:=at("end",pString)) > 0
         //nPosEnd:=BUSCACOMPLETA(nPosEnd,pString,3)
         v:=substr(pString,posEnd-1,1)
         w:=substr(pString,posEnd+3,1)
         if !isalpha(v) .and. !isdigit(v) .and.;// v!="_" .and.;
            !isalpha(w) .and. !isdigit(w) //.and. w!="_"
            
     end*/
     
     pString:=strtran(pString,"_end_","999999999")
     
     nTok:=numtoken(pString,Separator)
     if nTok==1
        cLinea:=""
        nTok1:=numtoken(pString,":")
        //while i<=nTok1
        for i:=1 to nTok1
           cStr:=token(pString,":",i)
           if "(" $ cStr .or. "{" $ cStr .or. Separator $ cStr .or. "++"$cStr .or. "--"$cStr
              cLinea+=cStr
           else
              cLinea+="{"+cStr+"}"
           end
           if i==1
              cLinea+=";loc1;"
           elseif i==2
              if nTok1==3
                 cLinea+=";interval1;"
              else
                 cLinea+=";offset1;"
              end
           elseif i==3
              cLinea+=";offset1;"
           end
          // ++i
        end

     elseif nTok==2
        cLinea:=""
        rangoF:={"{0}","{0}","{0}"}
        rangoC:={"{0}","{0}","{0}"}
        for j:=1 to nTok
           cString:=token(pString,Separator,j)
           nTok1:=numtoken(cString,":")

           for i:=1 to nTok1
              cStr:=token(cString,":",i)
              
              if "(" $ cStr .or. "{" $ cStr .or. Separator $ cStr .or. "++"$cStr .or. "--"$cStr
                 if j==1
                    rangoF[i]:=cStr
                 else
                    rangoC[i]:=cStr
                 end
              else
                 if j==1
                    rangoF[i]:="{"+cStr+"}"
                 else
                    rangoC[i]:="{"+cStr+"}"
                 end
              end
           end
           if nTok1==2
              if j==1
                 rangoF[3]:=rangoF[2]; rangoF[2]:="{0}"
              else
                 rangoC[3]:=rangoC[2]; rangoC[2]:="{0}"
              end
           end
        end
        // armo linea definitiva:
        cLinea:=rangoF[1]+";"+rangoC[1]+";loc2;"
        if tipo  // si es .T.: no hace redundancia con {0}, esta dentro de HOPPER
                 // si es .F.: hace redundancia, porque esta en #HL
           if rangoF[2]+rangoC[2] != "{0}{0}"
              cLinea+=rangoF[2]+";"+rangoC[2]+";interval2;"
           end
           if rangoF[3]+rangoC[3] != "{0}{0}"
              cLinea+=rangoF[3]+";"+rangoC[3]+";offset2;"
           end
        else  // redundancia, porque no se puede hacer clrmarksall dentro de #HL
           cLinea+=rangoF[2]+";"+rangoC[2]+";interval2;"
           cLinea+=rangoF[3]+";"+rangoC[3]+";offset2;"
        end
        
     elseif nTok==3
        cLinea:=""
        rangoF:={"{0}","{0}","{0}"}
        rangoC:={"{0}","{0}","{0}"}
        rangoP:={"{0}","{0}","{0}"}
        for j:=1 to nTok
           cString:=token(pString,Separator,j)
           nTok1:=numtoken(cString,":")

           for i:=1 to nTok1
              cStr:=token(cString,":",i)
              
              if "(" $ cStr .or. "{" $ cStr .or. Separator $ cStr .or. "++"$cStr .or. "--"$cStr
                 if j==1
                    rangoF[i]:=cStr
                 elseif j==2
                    rangoC[i]:=cStr
                 else
                    rangoP[i]:=cStr
                 end
              else
                 if j==1
                    rangoF[i]:="{"+cStr+"}"
                 elseif j==2
                    rangoC[i]:="{"+cStr+"}"
                 else
                    rangoP[i]:="{"+cStr+"}"
                 end
              end
           end
           if nTok1==2
              if j==1
                 rangoF[3]:=rangoF[2]; rangoF[2]:="{0}"
              elseif j==2
                 rangoC[3]:=rangoC[2]; rangoC[2]:="{0}"
              else
                 rangoP[3]:=rangoP[2]; rangoP[2]:="{0}"
              end
           end
        end
        // armo linea definitiva:
        cLinea:=rangoF[1]+";"+rangoC[1]+";loc2;"+rangoP[1]+";loc1;"
        if tipo
           if rangoF[2]+rangoC[2]+rangoP[2] != "{0}{0}{0}"
              cLinea+=rangoF[2]+";"+rangoC[2]+";"+rangoP[2]+";interval3;"
           end
           if rangoF[3]+rangoC[3] != "{0}{0}"
              cLinea+=rangoF[3]+";"+rangoC[3]+";offset2;"
           end
           if rangoP[3]!="{0}"
              cLinea+=rangoP[3]+";offset1;"
           end
        else
           cLinea+=rangoF[2]+";"+rangoC[2]+";"+rangoP[2]+";interval3;"
           cLinea+=rangoF[3]+";"+rangoC[3]+";offset2;"
           cLinea+=rangoP[3]+";offset1;"
        end
     else
        _Error("range array access error: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
     end
     if ";,;" $ cLinea
         cLinea:=strtran(cLinea,";,;",";")
     end
 /// ?"LF =",lineaFisica," --> REPRANGE = ", cLinea
return cLinea

Procedure Procesa_inline(pLineaDef,c,pLinea,swMLinea,sw_macro,fp,h_ini,h_fin,lineaFisica,;
                         DEF,blkIF,blkELSE,blkEND,blkWHILE,blkEWHILE,lineStruct,;
                         DEFVAR,DEFBODY,DEFEXPRE,DEFLOOP, DEFENDLOOP,DEFENDIF,DEFENDIIF,;
                         DEFCATCH,DEFENDCATCH,DEFCODEIF,DEFRANDVAR,DEFCODESW,DEFCODEMARK)

local ctaPar,swOpEspecial,nSavePos,opc,pString
local n,arr,cDest,cDestTmp,swKeeper, swProcesoAsignar, countKeeper

        // obtengo todo hasta el final del parentesis primario:
        ctaPar:=1
        swOpEspecial:=.F.  // para añadir ")" al final con +=, -=, etc.
        while c!=chr(10)  .and. h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
           if c=="("
              ctaPar++
           elseif c==")"
              ctaPar--
           elseif c=='"'  // es un string...
              pLineaDef+=c
              while c!=chr(10) .and. h_ini<=h_fin
                fread(fp,@c,1); ++h_ini
                pLineaDef+=c
                if c=="\"
                   fread(fp,@c,1); ++h_ini
                   pLineaDef+=c

                elseif c==chr(34)
                   exit
                end
              end
              loop
        /* añado análisis de [:], dado que puede confundirse con "?:" */
           elseif c=="["   // es un corchete de subindice
              pLineaDef+=c
              while c!=chr(10) .and. h_ini<=h_fin
                fread(fp,@c,1); ++h_ini
                pLineaDef+=c
                if c=="]"
                   exit
                end
              end
              if h_ini>h_fin
                 _Error ("macro #(): premature end-of-file detected",lineaFisica)
              elseif c==chr(10)
                 _Error ("macro #(): premature end-of-line detected",lineaFisica)
              end
              loop
        /* hasta aquí */
           elseif c=="?"
              pLineaDef+="NOP0"
              loop
           elseif c==":"
              fread(fp,@c,1); ++h_ini
              nSavePos := fseek( fp, 0, 1 )
              if c=="="
                 pLineaDef+=":="
                 //fseek(fp,nSavePos-1,0); --h_ini
              else
                 pLineaDef+="NOP1"
                 fseek(fp,nSavePos-1,0); --h_ini
              end
              loop
           elseif c==";"
              pLineaDef+="END0"
              loop
           elseif c=="\"   // ojo: puede haber línea separada. Procesar
              _Error ("macro #(): premature end-of-file detected",lineaFisica)
           elseif c=="/"   // ojo: puede haber comentarios, de línea o de bloque. procesar.
                           // un comentario de linea debe terminar con ")". Esto ya está resuelto
             // while .T.   // posible comentario
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
                 if c=="/"  // comentario de linea
                    while c!=chr(10) .and. h_ini<=h_fin
                       fread(fp,@c,1); ++h_ini
                    end
                    
                 elseif c=="*"  // comentario de bloque
               //     BloqueComentario(@h_ini,@h_fin,@fp,@fw,@lineaFisica,@c)
                    while h_ini<=h_fin
                       fread(fp,@c,1); ++h_ini
                       if c=="*"
                          fread(fp,@c,1); ++h_ini
                          nSavePosI := fseek( fp, 0, 1 )
                          if c=="/"
                             fread(fp,@c,1); ++h_ini
                             exit
                          else
                             fseek(fp,nSavePosI-1,0); --h_ini
                          end
                       elseif c==chr(10)
                          //++newLine
                          _Error ("macro #(): premature end-of-file detected",lineaFisica)
                         // ++keepLine
                          //++lineaFisica
                       end
                    end
                 else
                    fseek(fp,nSavePos-1,0); --h_ini
                    c:="/"
                   // ? "LineaFisica=",lineaFisica
                 end
             // end   

           elseif c==" "
              loop
           end

           if is_any(c,"+","-","^","%","*","/","\","|","&")   // verificar +=, -=, *= /= \= ^= y %=
              opc:=c
              fread(fp,@c,1); ++h_ini
              nSavePos := fseek( fp, 0, 1 )
              if c=="="
                 swOpEspecial:=.T.
                 _var:=substr(pLineaDef,2,len(pLineaDef))
                 pLineaDef += "=" + _var + opc + "("
              else
                 pLineaDef+=opc
                 fseek(fp,nSavePos-1,0); --h_ini
              end
              loop
           end

           if c=="}"
              if sw_macro
                 pLineaDef+=")"
                 ////fwrite(fw,",postfix")
                 sw_macro:=.F.
                 swMLinea:=.T.
                 exit
              end
           end
           //if c!=","
           if c!=chr(10)
              pLineaDef+=c
           else
              if sw_macro
                 pLineaDef+=")"
                 //fseek(fp,nSavePos-1,0); --h_ini
                 exit
              end              
           end
           if ctaPar==0
              exit
           end
        end   // while

        if swOpEspecial
           swOpEspecial:=.F.
           pLineaDef += ")"
        end
      //  ? "ANTES=",pLineaDef
        pLineaDef:=strtran(pLineaDef,"(-",",neg(")
       
        //? "ANTES-LLENA =",pLineaDef
        arr:=LLENAPILA(pLineaDef)
        if valtype(arr)=="N"
            _Error ("macro #(): unbalanced parentheses (or not needed here) or macro bad former",lineaFisica) 
        end
        /*? "DESPUES LLENA ="
        for poto:=1 to len(arr)
           ?? arr[poto]," @ "
        end*/
        
        if valtype(arr)=="A"
          // ?" LLENAPILA = "

           for i:=1 to len(arr)
              if "NOP0" $ arr[i]
                 asize(arr,len(arr)+1)
                 ains(arr,i)
                 arr[i]:="NOP0"
                 arr[i+1]:=substr(arr[i+1],5,len(arr[i+1]))
              end
              if "NOP1" $ arr[i]
                 arr[i]:=substr(arr[i],1,len(arr[i])-4)
                 asize(arr,len(arr)+1)
                 ++i
                 ains(arr,i)
                 arr[i]:="NOP1"
              end
           end 
        end
        
        if valtype(arr)=="N"
           if arr==1
              _Error ("macro #(): Unrecognized symbol set as logical operator",lineaFisica)

           elseif arr==2
              _Error ("macro #(): Syntax error",lineaFisica)

           elseif arr==3
              _Error ("macro #(): Unbalanced parentheses",lineaFisica)

           end
        end
        // verificar si no hay una asignación: si la hay, quitar de la evaluación:
        n:=ascan(arr,"=")
        cDest:=NULL
        cDestTmp:=NULL
        swKeeper:=.T.; swProcesoAsignar:=.F.; countKeeper:=0
       // ?" MULTI ASIG (N)= ", alltrim(str(n))
        while n>0
           swProcesoAsignar:=.T.
           ++countKeeper
           cDestTmp:=arr[n-1]
           if "[" $ arr[n-1]
               if len(cDest)==0
                  cDest:=strtran(cDestTmp,"get","!put")+";"
               else
                  cDest:=strtran(cDestTmp,"get","!put")+";"+cDest
               end
               //swKeeper:=.T.
           else
               if len(cDest)==0
                  cDest:=";mov("+cDestTmp+")" // MOD.20-03-2022
                  //cDest:=cDestTmp+"=0;mov("+cDestTmp+")" // MOD.30-11-2021
                  //cDest:=",clear("+cDestTmp+"),mov("+cDestTmp+")" // MOD.30-11-2021
                  swKeeper:=.F.
               else
                  cDest:=";cpy("+cDestTmp+");"+cDest  // MOD.20-03-2022
                  ///cDest:=cDestTmp+"=0;cpy("+cDestTmp+");"+cDest  // MOD.30-11-2021
                  //cDest:=",clear("+cDestTmp+"),cpy("+cDestTmp+"),"+cDest  // MOD.30-11-2021
                  //swKeeper:=.F.
               end
           end
           adel(arr,n-1)
           adel(arr,n-1)
           asize(arr,len(arr)-2)
           n:=ascan(arr,"=")
           
        end
       // ? "<< ",cDest
        if swProcesoAsignar
           if swKeeper   // porque no sé hasta dónde habrá un put en la asignación múltiple
              if countKeeper>1
                 cDest:=cDest+"kill"
              else //if countKeeper==1
               // ? "ENTRA AQUI"
                 cDest:=strtran(cDest,";!put",";put")
              end
           end
        end
       // ? "ARR = "
       // for hhh=1 to len(arr); ?? arr[hhh],","; end
        
        pString:=EvPolaca(arr, lineaFisica, @DEF,@blkIF, @blkELSE, @blkEND, @blkWHILE, @blkEWHILE, @lineStruct)
       // ? "pSTRING << ", pString
        if len(cDest)>0
           pString += ";"+cDest
        end
        pString:=strtran(pString,";{}","")
        if !sw_macro
           if swMLinea
              swMLinea:=.F.
              ////pString += ";clrmarksall;postfix"
              //pString += ";clrmarksall;"
           //   pString += ";clearinterval;"
           //else   
              ////pString := "postfix;clrmarksall;"+pString+";clrmarksall;postfix"
           //   pString := /*";clrmarksall;"+*/pString+";clearinterval;"
           end
        end
               
        pString:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                              @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,pString,@lineaFisica)

        // analizar cada aparición de [] y convertirlo a hop-code:
        cLinea:=""
       // ? "REPL-RNG << ",pString
        while "[" $ pString
           nPosRA:=at("[",pString)
           t1Str:=substr(pString,1,nPosRA-1)  // incluyo todo antes de: "["
           tStr:=substr(pString,nPosRA+1,len(pString))  // porcion desde "["+1
           cStr:=substr(tStr,1,at("]",tStr)-1)  // tomo porcion entre "[" y "]"
           t2Str:=substr(tStr,at("]",tStr)+1,len(tStr))  // porcion sobrante, proxima a analizar en este ciclo
           // evaluar cada porcion con llenapila y evPolaca:
           // análisis separador
           
           Separator:=","
           /*if ";" $ cStr
              Separator:=";"
           end*/
           
          // ? "cSTR >>",cStr
           nTok:=numtoken(cStr,Separator)
          // ? "Ntok =", nTok
           c2Linea:=""
           for j:=1 to nTok
              ct1Str:=token(cStr,Separator,j)
              //? "TOK ct1Str = ", ct1Str
              nTok2:=numtoken(ct1Str,":")
              
              for i:=1 to nTok2
                 ct2Str:=token(ct1Str,":",i)
                // ? "ct2Str [",alltrim(str(i)),"] << ", ct2Str
                 arr:=LLENAPILA(ct2Str)
                 if valtype(arr)=="N"
                     _Error ("macro #(): unbalanced parentheses (or not needed here) or macro bad former",lineaFisica) 
                 end
                 //? "Len arr = ", len(arr)                
                 ct2Str:=EvPolaca(arr, lineaFisica, @DEF,@blkIF, @blkELSE, @blkEND, @blkWHILE, @blkEWHILE, @lineStruct)
                 ct2Str:=strtran(ct2Str,Separator,"")
                 if i<nTok2
                     ct2Str+=":"
                 end
                 //? "ct2Str [",alltrim(str(i)),"] >> ", ct2Str
                 c2Linea+=ct2Str
              end
              c2Linea+=Separator
           end
          // ?" c2LINEA << ", c2Linea
           c2Linea:=replaceRange(c2Linea,.F.,lineaFisica)
          // ?" c2LINEA >> ", c2Linea
           // OJO: había un error de análisis cuando quedaba "{algo};,;loc1: al volver a analizar (cuando habían 2 o más
           //      "#"), desaparecía ";,;" por el análisis del separador. FIX
          // ? "() LF = ",lineaFisica," -> LINEA = ", c2Linea
           
           cLinea:=t1Str + c2Linea + t2Str
           pString:=cLinea

        end
       // ? "REPL-RNG >> ",pString
        ctaPar:=0
        pLinea+=pString
       // ? "#PLINEA= ",pLinea

return pLinea

procedure Preproceso(file, tmpFile)
LOCAL DEF:={},DEFVAR:={},DEFBODY:={},DEFEXPRE:={},DEFRANDVAR:={},DEFCODESW:={},DEFCODEMARK:={} 
LOCAL DEFLOOP:={}, DEFENDLOOP:={}, DEFENDIF:={}, DEFENDIIF:={}, DEFCATCH:={},DEFENDCATCH:={},DEFCODEIF:={}
LOCAL fp,fw,h_ini,h_fin,c,lineaFisica,pLinea,pLineaDef
LOCAL pFileInclude, fpi,nSavePos, i_ini,i_fin,ctmp
LOCAL msgError  //, tLinea
LOCAL keepLine:=0,mkline:=0  // líneas vacías a agregar luego de encontrar "\"
LOCAL sw_macro:=.F.,ant_c:="",swMLinea:=.F.
LOCAL pLineaImport,swSHELL
//LOCAL pilaIF:={},pilaWHILE:={},pilaUNTIL:={}
LOCAL blkIF:={},blkELSE:={},blkEND:={},blkWHILE:={},blkEWHILE:={},lineStruct:={},label
LOCAL i,j
//label:="END"+alltrim(str(int(hb_random()*1000000000)))
//blkELSE:={label}

fp:=fopen(file,2) // para la modificacion #deffun y context, debo abrir modo APPEND e insertar código.
if ferror()!=0
  msgError:="Source file open error: "+GenMsg(chr(27)+"[1m"+file+chr(27)+"[0m")
  _error(msgError,0)
end
fw:=fcreate(tmpFile,0)
if ferror()!=0
  msgError:="Temporal file create error: "+GenMsg(chr(27)+"[1m"+tmpFile+chr(27)+"[0m")
  _error(msgError,0)
end

h_fin:=fseek(fp,0,2)
h_ini:=fseek(fp,0,0)
c:=" "
lineaFisica:=1
pLinea:=NULL
pLineaImport:=NULL
swSHELL:=.F.
while h_ini<=h_fin
  
  fread(fp,@c,1); ++h_ini
//  nSavePos := fseek( fp, 0, 1 )
/***** DEFINE INCLUDE ******/
  // que tal si quito espacios en blanco aqui?
  if c==" "
     loop
  end
  if c=="#" .and. !swSHELL
     // ver si no es un script #!/usr/bin/hopper. hacer lo mismo con bhopper
     fread(fp,@c,1); ++h_ini
     nSavePos := fseek( fp, 0, 1 )
     if c=="!"  // es un script!
        swSHELL:=.T.
        while c!=chr(10)   // lee hasta que llegue a chr(10)
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
        end
        fwrite(fw,chr(10))
        ++lineaFisica
        loop
     else
        fseek(fp,nSavePos-1,0); --h_ini
        c:="#"
     end
  end
  
  if sw_macro
     if c=="}"
////        fwrite(fw,";clrmarksall;postfix")
        ///fwrite(fw,";clrmarksall;")
        //fwrite(fw,";clearinterval;")
        sw_macro:=.F.
        loop
     elseif c!=chr(10)
        ant_c:=""

        if c!=" "
           if c!="/"  // porque inicia un comentario
              ant_c:=c  // guardo, para recuperar en #FX
              c:="#"
           end
        end
        //c:="#"
     end
  end
  
  if c=="/"    // comentario
     //fwrite(fw," ",1)
     fread(fp,@c,1); ++h_ini
     nSavePos := fseek( fp, 0, 1 )
     if c=="/"   // comentario de linea
      // ESTE CAMBIO NO ESTA BIEN
    //    pLinea:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP,@DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
    //                          @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,pLinea,@lineaFisica)
    //    fwrite(fw,pLinea,len(pLinea))
    //    pLinea:=NULL
        //fwrite(fw," ",1)
        fread(fp,@c,1); ++h_ini
        nSavePos := fseek( fp, 0, 1 )
        while c!=chr(10) .and. h_ini<=h_fin
           //fwrite(fw," ",1)
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
        end
        if c==chr(10)
           fseek(fp,nSavePos-1,0); --h_ini
           //fwrite(fw,chr(10),1)
        end
        
     elseif c=="*"   // comentario de bloque
      // ESTE CAMBIO NO ESTA BIEN
//        pLinea:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
//                              @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,pLinea,@lineaFisica)
     //   fwrite(fw,pLinea,len(pLinea))
     //   pLinea:=NULL
        BloqueComentario(@h_ini,@h_fin,@fp,@fw,@lineaFisica,@c)
     elseif c=="="   // es una asignación V*=n
        pLinea+="/="
     else
        _Error("unknow character: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m"),lineaFisica)
     end
  elseif c=="\"  // es una continuación de linea ?
     fread(fp,@c,1); ++h_ini
     nSavePos := fseek( fp, 0, 1 )
     if c!="="
        //fseek(fp,nSavePos-1,0); --h_ini
        while c!=chr(10) .and. h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
        end
        c:=" "
        ++keepLine
        ++lineaFisica
     else   // asignacion V\=n
        pLinea+="\="
     end
  
  elseif is_any(c,"^","%",">","<","|","&")  // asignaciones VX=n? No debo preguntar por "*", porque puede ser repetición de instr.
     pLinea+=c; ctmp:=c
     fread(fp,@c,1); ++h_ini
     nSavePos := fseek( fp, 0, 1 )
     if is_noall(c,"=","<",">") .and. (c=="-" .and. ctmp!="<")
         //? "PASA POR AQUI C=",c," ANTERIOR=",ctmp
        _Error("unknow character: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m"),lineaFisica)
     end
     pLinea+=c
     
  elseif c==chr(96)     // string especial de invocacion de orden de sistema
     pLinea+=c
     c:=" "
     while c!=chr(10) .and. h_ini<=h_fin
        fread(fp,@c,1); ++h_ini
        //fwrite(fw,c,1)
        pLinea+=c
        if c=="\"
           fread(fp,@c,1); ++h_ini
           //fwrite(fw,c,1)
           pLinea+=c

        elseif c==chr(96)
           //fwrite(fw,c,1)
           exit
        end
     end
     if c==chr(10) .or. h_ini>h_fin
        _Error("string-command unclosed ``: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
     end
     
  elseif c==chr(34)     // inicia string
     //fwrite(fw,c,1)
     pLinea+=c
     c:=" "
     while c!=chr(10) .and. h_ini<=h_fin
        fread(fp,@c,1); ++h_ini
        //fwrite(fw,c,1)
        pLinea+=c
        if c=="\"
           fread(fp,@c,1); ++h_ini
           //fwrite(fw,c,1)
           pLinea+=c
        elseif c==chr(34)
           //fwrite(fw,c,1)
           exit
        end
     end
     if c==chr(10) .or. h_ini>h_fin
        _Error("(1)string unclosed: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
     end
     
  elseif c == "["   // analizo y convierto rango de arrays: no soporta indizacion anidada
     //pLinea+="["
     pString := ""
     nSavePos := fseek( fp, 0, 1 )  //por si no es un array, sino, un 
     while c!=chr(10) .and. h_ini<=h_fin
        fread(fp,@c,1); ++h_ini
        //¿es un parametro?
        if c=="&"
           exit
        end
        if c=="]"
           exit
        end
        if c=='"'  // string!
           pString+=c
           c:=" "
           while c!=chr(10) .and. h_ini<=h_fin
              fread(fp,@c,1); ++h_ini
              //fwrite(fw,c,1)
              pString+=c
              if c=="\"
                 fread(fp,@c,1); ++h_ini
                 //fwrite(fw,c,1)
                 pString+=c
              elseif c==chr(34)
                 //fwrite(fw,c,1)
                 exit
              end
           end
           if c==chr(10) .or. h_ini>h_fin
              _Error("(1)string unclosed: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
           end
        elseif c=="#"
           p2String:=NULL
           fread(fp,@c,1); ++h_ini
           pLineaDef:=c // debe ser un paréntesis
           //? "(1)>>>>",pString
           p2String:=Procesa_inline(pLineaDef,@c,p2String,swMLinea,@sw_macro,@fp,@h_ini,@h_fin,@lineaFisica,;
                         @blkIF,@blkELSE,@blkEND,@blkWHILE,@blkEWHILE,@lineStruct,;
                         @DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                         @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK)
           ///p2String:=strtran(p2String,"clrmarksall;","")
           ///p2String:=strtran(p2String,"clearinterval;","") // parece que no es necesario
           //? ">>",p2String
           pString := pString + p2String
           //? "(2)>>>>",pString
        else
           if c!=" "
              pString+=c
           end
        end
     end
     if c==chr(10) .or. h_ini>h_fin
        _Error("range array unclosed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
     end
     if c=="&"
        cLinea:="["+pString
        while c!=chr(10) .and. h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
           cLinea+=c
           if c=="]"
              exit
           end
        end
     else
        //? ">>",pString
        
        pString:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                              @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,pString,@lineaFisica)
        //? "<<",pString


        cLinea:=replaceRange(pString,.T.,lineaFisica)
       // if ";;;" $ cLinea
       //    cLinea:=strtran(cLinea,";;;",";")
       // end
     //   ? "[] LF = ",alltrim(str(lineaFisica))," -> LINEA = ", cLinea
     end
     //? "cLinea = ",cLinea
     pLinea+=cLinea
     
  elseif c == "#"   // # define, #include, #defn, #proto, #fx/#compute, #synon/#synonymous, #autosub, #enum
       
     pLineaDef:=NULL
     
     if !sw_macro 
        fread(fp,@c,1); ++h_ini

        while (isalpha(c) .or. c=="-").and. c!=chr(10) .and. h_ini<=h_fin
           pLineaDef+=c
           fread(fp,@c,1); ++h_ini
           //fwrite(fw," ",1)
        end
        pLineaDef:=alltrim(pLineaDef)

        if c==" "
           QuitaEspacio(@h_ini,@h_fin,@fp,@c)
        end
        
        if c==chr(10)   // encontró una declaración vacia
           _Error ("macro "+GenMsg(chr(27)+"[1m#"+pLineaDef+chr(27)+"[0m")+" bad formed",lineaFisica)
        end

       // para #()
        if len(pLineaDef)==0 .and. c=="("
           pLineaDef:=c
        end

     else
        pLineaDef:="compute"
        
//        if len(ant_c)>0
//           c:=ant_c; ant_c:=""
//        else
           c:="("  // incrusta lógicamente un "(" para el analisis.
//        end
     end
     //?"pLineaDef = [",pLineaDef,"]"
     if pLineaDef=="("   // cambia dentro de una linea, y no escribe, sino que continúa
        pLinea:=Procesa_inline(pLineaDef,@c,pLinea,swMLinea,@sw_macro,@fp,@h_ini,@h_fin,@lineaFisica,;
                         @blkIF,@blkELSE,@blkEND,@blkWHILE,@blkEWHILE,@lineStruct,;
                         @DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                         @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK)

     
     elseif pLineaDef=="define"  .or. pLineaDef=="define-a" // define macros de usuario, o macros simples
        if len(pLinea)>0
           _Error ("macro #DEFINE must be unique in this line",lineaFisica)
        end
        mkline:=lineaFisica
        nSavePos:=GETDEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP,@DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                            @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,@h_ini,@h_fin,@fp,@fw,@c,@lineaFisica,0,file,0)
       // ? "mkline = ",mkline
       // ? "lineaFisica = ",lineaFisica
        if lineaFisica!=mkline
         //  pLinea:=NULL
           while mkline<=lineaFisica
              fwrite(fw,chr(10))
              ++mkline
           end
           ++lineaFisica
           c:=" "
        else
          // if c==chr(10)  // por si resulto ser una linea simple
          //    fseek(fp,nSavePos-1,0); --h_ini
          // end
          fwrite(fw,chr(10))
          ++lineaFisica
        end
        pLineaDef:=NULL
        
     elseif pLineaDef=="defn"    // define macros del lenguaje base
        if len(pLinea)>0
           _Error ("macro #DEFN must be unique in this line",lineaFisica)
        end
        mkline:=lineaFisica
        nSavePos:=GETDEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                            @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,@h_ini,@h_fin,@fp,@fw,@c, @lineaFisica,1,file,0)
       // ? "mkline = ",mkline
       // ? "lineaFisica = ",lineaFisica
        if lineaFisica!=mkline
         //  pLinea:=NULL
           while mkline<=lineaFisica
              fwrite(fw,chr(10))
              ++mkline
           end
           ++lineaFisica
           c:=" "
        else
          // if c==chr(10)  // por si resulto ser una linea simple
          //    fseek(fp,nSavePos-1,0); --h_ini
          // end
          fwrite(fw,chr(10))
          ++lineaFisica
        end
        pLineaDef:=NULL
     elseif pLineaDef=="synon" .or. pLineaDef=="synonymous"
        // recorro DEF y veo si ya existe la clave
        if len(pLinea)>0
           _Error ("macro #SYNONYMOUS must be unique in this line",lineaFisica)
        end
        mkline:=lineaFisica
        nSavePos:=GETDEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                            @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,@h_ini,@h_fin,@fp,@fw,@c, @lineaFisica,2,file,0)
       // ? "mkline = ",mkline
       // ? "lineaFisica = ",lineaFisica
        if lineaFisica!=mkline
         //  pLinea:=NULL
           while mkline<=lineaFisica
              fwrite(fw,chr(10))
              ++mkline
           end
           ++lineaFisica
           c:=" "
        else
          // if c==chr(10)  // por si resulto ser una linea simple
          //    fseek(fp,nSavePos-1,0); --h_ini
          // end
          fwrite(fw,chr(10))
          ++lineaFisica
        end
        pLineaDef:=NULL
     elseif pLineaDef=="proto" .or. pLineaDef=="prototype" .or. pLineaDef=="DefFn"
        if len(pLinea)>0
           _Error ("macro #PROTO must be unique in this line",lineaFisica)
        end
        swPrototipo:=.T.
        nSavePos:=GETPROTOTYPE(@DEF,@DEFVAR,@DEFBODY,@h_ini,@h_fin,@fp,@c,@lineaFisica,file,0)
        //nSavePos:=GETDEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
        //                    @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@h_ini,@h_fin,@fp,@fw,@c, @lineaFisica,2,file,0)
        if c==chr(10)  // por si resulto ser una linea simple
           fseek(fp,nSavePos-1,0); --h_ini
        end
        swPrototipo:=.F.
        pLineaDef:=NULL
     
     elseif pLineaDef=="enum" .or. pLineaDef=="enumerate"
        if len(pLinea)>0
           _Error ("macro #ENUM must be unique in this line",lineaFisica)
        end
        pString:=c; nARRANQUE:="0"; newLine:=1
        c=" "; swSepara:=.F.
        while c!=chr(10) .and. h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
           if c==" "; loop; end
           if c=="/"   // un comentario?
              fread(fp,@c,1); ++h_ini
              if c=="/"   // comentario de linea
                 while c!=chr(10) .and. h_ini<=h_fin
                    fread(fp,@c,1); ++h_ini
                 end
              elseif c=="*"  // comentario de bloque
                 BloqueComentario(@h_ini,@h_fin,@fp,@fw,@lineaFisica,@c)  // el ultimo sera el "/"
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
              else
                 _Error ("macro #ENUM: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m")+" not recognized",lineaFisica)
                 exit
              end
           elseif c=="\"   // ojo: debe haber línea separada. Procesar
              c:=" "
              while (c!=chr(10) .and. c==" ").and. h_ini<=h_fin
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
              end
              if c==chr(10)
                 ++newLine
                 swSepara:=.T.
                 //c:=" "
              else
                 _Error ("macro #ENUM: premature end-of-file detected",lineaFisica)
              end
           end
           if c=="," .or. c==chr(10)  // separa autosubs
              if ISTNUMBER(pString)==1   // es el valor de arranque
                 nARRANQUE:=val(alltrim(pString))
              else
                 aadd( DEFVAR, {} )  // no hay argumentos.
                 aadd( DEF,pString )
                 aadd( DEFBODY, hb_valtostr(nARRANQUE++) )
              end
              if swSepara
                 c:=" "; swSepara:=.F.
              end
              //? "(CONTEXT) pSTRING  = ",pString
              pString:=NULL  // reinicia, para otro contexto
           else
              if c!=chr(10)
                 pString+=c
              end
           end
        end
        if h_ini>h_fin
           _Error ("macro #ENUM: end-of-file detected",lineaFisica)
        end
        //fwrite(fw,chr(10),1)
        while newLine>0
           fwrite(fw,chr(10))
           --newLine
           ++lineaFisica
        end

        pLineaDef:=NULL; pString:=NULL
        //++lineaFisica

     elseif pLineaDef=="autosub" .or. pLineaDef=="context-free" .or. pLineaDef=="context"  
        // guarda etiquetas de contexto para ser reemplazadas por llamadas jsub o gosub
        // ejemplo:   #autosub elaboraestadística, imprime
        //            elabora estadística
        //            ==> jsub(elaboraestadística)
        if len(pLinea)>0
           _Error ("macro #CONTEXT|#AUTOSUB must be unique in this line",lineaFisica)
        end 
        //?"(CONTEXT) C=",c
        
        pString:=c
        c=" "
        nameContexto:=NULL
        // busco nombre de Context:
        ///? "pString inicial=",pString;?
        while c!=chr(10) .and. h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
          //?? c
           if c==" "; loop; end
           if c=="/"   // un comentario?
              fread(fp,@c,1); ++h_ini
              if c=="/"   // comentario de linea
                 while c!=chr(10) .and. h_ini<=h_fin
                    fread(fp,@c,1); ++h_ini
                 end
              elseif c=="*"  // comentario de bloque
                 BloqueComentario(@h_ini,@h_fin,@fp,@fw,@lineaFisica,@c)  // el ultimo sera el "/"
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
              else
                 _Error ("macro #CONTEXT: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m")+" not recognized",lineaFisica)
                 exit
              end
           end
           if c==chr(10)  // termina declaracion autosub
              aadd( DEFVAR, {} )  // no hay argumentos.
              aadd( DEF,pString )
              if pLineaDef=="context-free" .or. pLineaDef=="autosub"
                 aadd( DEFBODY, "jsub("+pString+")" )
              elseif pLineaDef=="context"
                 aadd( DEFBODY, "keep;gsub("+pString+")" )
              end
              //? "(CONTEXT) pSTRING  = ",pString
              nameContexto:=pString
              pString:=NULL  // reinicia, para otro contexto
              // define sinonimos "and", "then", "now"
              aadd( DEFVAR, {} )  // si no hay vars, len(aTempVar)=0
              aadd( DEF, "and"+nameContexto )
              aadd( DEFBODY, atail(DEFBODY) )
              aadd( DEFVAR, {} )  // si no hay vars, len(aTempVar)=0
              aadd( DEF, "now"+nameContexto )
              aadd( DEFBODY, atail(DEFBODY) )
              aadd( DEFVAR, {} )  // si no hay vars, len(aTempVar)=0
              aadd( DEF, "then"+nameContexto )
              aadd( DEFBODY, atail(DEFBODY) )

              exit
           else
              if c!=chr(10)
                 pString+=c
              end
           end
        end
        //? "nameContexto=",nameContexto
        if h_ini>h_fin
           _Error ("macro #CONTEXT-1: end-of-file detected",lineaFisica)
        end
        // Busca el código perteneciente a Context declarado:
        newLine:=1
        //QuitaEspacio(@h_ini,@h_fin,@fp,@c)
        //if c==chr(10)
        //   ++newLine
        //end
        while /*c!="." .and.*/ h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
           pString+=c
           if c=='"'
              while c!=chr(10) .and. h_ini<=h_fin
                fread(fp,@c,1); ++h_ini
                pString+=c
                if c=="\"
                   fread(fp,@c,1); ++h_ini
                   pString+=c
                elseif c==chr(34)
                   exit
                end
              end
              if h_ini>h_fin
                 _Error ("macro #CONTEXT: string not closed (end-of-file detected)",lineaFisica)
              end
           elseif c==chr(10)
              ++newLine
           elseif c=="\"   // fin de declaración?
              fread(fp,@c,1); ++h_ini
              if c=="\"   // es fin de declaracion
                 pString:=substr(pString,1,len(pString)-1)  // quito ultimo "\"
                 exit
              elseif c==chr(10)
                 pString+=c
                 ++newLine
              else
                 _Error ("macro #CONTEXT: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m")+" not recognized",lineaFisica)
//                 printmsg("Message from Hopper: "+GenMsg(chr(27)+"[1m"+"I don't accept line separator '\' in CONTEXT"+chr(27)+"[0m")+_CR)
              end
           end
        end
        if h_ini>h_fin
           _Error ("macro #CONTEXT: end-of-file detected",lineaFisica)
        end
        // guardo en archivo fuente, al final.
        nSavePos := fseek( fp, 0, 1 )  // guardo última posicion de lectura
        h_fin:=fseek(fp,0,2)   // me voy al final
        fwrite(fp,nameContexto+":"+_CR)  // guardo encabezado del contexto
        fwrite(fp,pString+_CR) // guardo porcion de codigo
        h_fin:=fseek(fp,0,2)   // actualizo fin de archivo
        fseek(fp,nSavePos,0)   // rescato posicion de lectura de archivo fuente
        nameContexto:=NULL
        pString:=NULL
        while newLine>0
           fwrite(fw,chr(10))
           --newLine
           ++lineaFisica
        end
        //fwrite(fw,chr(10),1)
        pLineaDef:=NULL
        //++lineaFisica
     elseif pLineaDef=="fx" .or. pLineaDef=="compute" .or. pLineaDef=="hl";
            .or. pLineaDef=="high-level"  // llama al analizador sintáctico de expresiones matemáticas infijas. Luego, a GETDEFINE
        // "c" tiene o un espacio, o un "("
        /* IMPORTANTE:
           El tag #MATH convierte una expresión en POSTFIJA, que HOPPER no evalúa ls expresiones de esta manera, sino, de
           adelante para atrás: 
           {a}{b}add ==> b+a 
           #MATH obtiene la expresión para ser evaluada de la siguiente manera:
           {a}{b}add ==> a+b
           es decir, en notacion polaca postfija.
           Para que pueda evaluarse el código en la notación posfija, es preciso hacer que la orden evalúe como primer
           operando "a", y "b" como segundo, y no como lo hace de manera natural. 
           Se crearán las funciones padd, ppow, pdiv, psin, pcos, etc, que harán este trabajo, o bien:
           crear una instruccion PFON, que gatillará este comportamiento, quitándolo con PFOFF. Esto solo podrá ser
           aplicable para instrucciones matemáticas definidas para #MATH.
           */
        //if len(pLinea)>0
        //   _Error ("macro #FX|#COMPUTE must be locate in BOL, and not be built-in another macro",lineaFisica)
        //end
       // ? "ENTRA LineaFisica=",lineaFisica
      /*  if len(pLinea)>0
           pLinea:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                              @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,pLinea,@lineaFisica)
           fwrite(fw,pLinea,len(pLinea))
           pLinea:=NULL
        end */
        if c==chr(10)  // es posible que "{", si hay, comience abajo
           c:=" "
           lineaFisica++
           fwrite(fw,chr(10))
           while c!=chr(10) .and. h_ini<=h_fin
              fread(fp,@c,1); ++h_ini
              nSavePos := fseek( fp, 0, 1 )
              if c=="{"
                 exit
              end
           end
           if c==chr(10)
              _Error ("multi-macro #FX|#COMPUTE "+GenMsg(chr(27)+"[1m"+"{"+chr(27)+"[0m")+" not found",lineaFisica)
           end
        end   
        if c=="{"  // es un conjunto de líneas de macros
           ///? "ENTRÓOOO"
           sw_macro:=.T.
           c:=" "
           ///fwrite(fw,"postfix;clrmarksall")
           ///fwrite(fw,";clrmarksall")
         //  fwrite(fw,";clearinterval;")

         /*  while c!=chr(10)  .and. h_ini<=h_fin
              fread(fp,@c,1); ++h_ini
              nSavePos := fseek( fp, 0, 1 )
           end
           if c!=chr(10)
              _Error ("multi-macro #FX|#COMPUTE end-of-line not found",lineaFisica)
           end
           fwrite(fw,chr(10))
           lineaFisica++
           pLinea:=NULL
           pLineaDef:=NULL*/
           loop
        end
        if c=="("
           ctaPar:=1
           pLineaDef:=c
           if sw_macro
              if len(ant_c)>0
                 pLineaDef+=ant_c
              end
           end
        else
           ctaPar:=0
           c:=" "
           pLineaDef:=NULL
        end
        
        //Q:={}
        newLine:=0
        swOpEspecial:=.F.  // para añadir ")" al final con +=, -=, etc.
        while c!=chr(10)  .and. h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
           if c=="("
              ctaPar++
           elseif c==")"
              ctaPar--
           elseif c=='"'  // es un string...
              pLineaDef+=c
              while c!=chr(10) .and. h_ini<=h_fin
                fread(fp,@c,1); ++h_ini
                pLineaDef+=c
                if c=="\"
                   fread(fp,@c,1); ++h_ini
                   pLineaDef+=c

                elseif c==chr(34)
                   exit
                end
              end
              loop
        /* añado análisis de [:], dado que puede confundirse con "?:" */
           elseif c=="["   // es un corchete de subindice
              pLineaDef+=c
              while c!=chr(10) .and. h_ini<=h_fin
                fread(fp,@c,1); ++h_ini
                pLineaDef+=c
                if c=="]"
                   exit
                end
              end
              if h_ini>h_fin
                 _Error ("macro #FX: premature end-of-file detected",lineaFisica)
              elseif c==chr(10)
                 _Error ("macro #FX: premature end-of-line detected",lineaFisica)
              end
              loop
        /* hasta aquí */
           elseif c=="?"
              pLineaDef+="NOP0"
              loop
           elseif c==":"
              fread(fp,@c,1); ++h_ini
              nSavePos := fseek( fp, 0, 1 )
              if c=="="
                 pLineaDef+=":="
                 //fseek(fp,nSavePos-1,0); --h_ini
              else
                 pLineaDef+="NOP1"
                 fseek(fp,nSavePos-1,0); --h_ini
              end
              loop
           elseif c==";"
              pLineaDef+="END0"
              loop
           elseif c=="\"   // ojo: puede haber línea separada. Procesar
              c:=" "
              while (c!=chr(10) .and. c==" ").and. h_ini<=h_fin
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
              end
              if c==chr(10)
                 ++newLine
                 //++keepLine
                 //++lineaFisica
                 c:=" "
              elseif c!=" "
                 fseek(fp,nSavePos-1,0); --h_ini
                 c:="\"
              else
                 _Error ("macro #FX: premature end-of-file detected",lineaFisica)
              end               
           elseif c=="/"   // ojo: puede haber comentarios, de línea o de bloque. procesar.
                           // un comentario de linea debe terminar con ")". Esto ya está resuelto
             // while .T.   // posible comentario
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
                 if c=="/"  // comentario de linea
                    while c!=chr(10) .and. h_ini<=h_fin
                       fread(fp,@c,1); ++h_ini
                    end
                    
                 elseif c=="*"  // comentario de bloque
               //     BloqueComentario(@h_ini,@h_fin,@fp,@fw,@lineaFisica,@c)
                    while h_ini<=h_fin
                       fread(fp,@c,1); ++h_ini
                       if c=="*"
                          fread(fp,@c,1); ++h_ini
                          nSavePosI := fseek( fp, 0, 1 )
                          if c=="/"
                             fread(fp,@c,1); ++h_ini
                             exit
                          else
                             fseek(fp,nSavePosI-1,0); --h_ini
                          end
                       elseif c==chr(10)
                          ++newLine
                         // ++keepLine
                          //++lineaFisica
                       end
                    end
                 else
                    fseek(fp,nSavePos-1,0); --h_ini
                    c:="/"
                   // ? "LineaFisica=",lineaFisica
                 end
             // end   

           elseif c==" "
              loop
           end

           if is_any(c,"+","-","^","%","*","/","\","|","&")   // verificar +=, -=, *= /= \= ^= y %=
              opc:=c
              fread(fp,@c,1); ++h_ini
              nSavePos := fseek( fp, 0, 1 )
              if c=="="
                 swOpEspecial:=.T.
                 _var:=substr(pLineaDef,2,len(pLineaDef))
                 pLineaDef += "=" + _var + opc + "("
              else
                 pLineaDef+=opc
                 fseek(fp,nSavePos-1,0); --h_ini
              end
              loop
           end

           if c=="}"
              if sw_macro
                 pLineaDef+=")"
                 ////fwrite(fw,",postfix")
                 sw_macro:=.F.
                 swMLinea:=.T.
                 exit
              end
           end
           //if c!=","
           if c!=chr(10)
              pLineaDef+=c
           else
              if sw_macro
                 pLineaDef+=")"
                 //fseek(fp,nSavePos-1,0); --h_ini
                 exit
              end              
           end
           if ctaPar==0
              exit
           end
        end
        //? "PLINEADEF = ",pLineaDef; inkey(0)
        /*if c==chr(10)
           _Error("macro #MATH malformed: "+pLineaDef,lineaFisica)
        end*/
        if swOpEspecial
           swOpEspecial:=.F.
           pLineaDef += ")"
        end
      //  ? "ANTES=",pLineaDef
        pLineaDef:=strtran(pLineaDef,"(-",",neg(")
       
       // ? alltrim(str(lineaFisica)),":ANTES = ",pLineaDef
        arr:=LLENAPILA(pLineaDef)
        if valtype(arr)=="N"
            _Error ("macro #FX: unbalanced parentheses (or not needed here) or macro bad former",lineaFisica) 
        end
       /* ? alltrim(str(lineaFisica)),":DESPS = "
        for poto:=1 to len(arr)
           ?? arr[poto],","
        end*/
       // ? "ANAL ARR"
        if valtype(arr)=="A"
          // ?" LLENAPILA = "

           for i:=1 to len(arr)
              if "NOP0" $ arr[i]
                 asize(arr,len(arr)+1)
                 ains(arr,i)
                 //label:="IF"+alltrim(str(int(hb_random()*1000000000)))
                 //stackpush( pilaIF, label )
                 //arr[i]:="jnt("+label+")"
                 arr[i]:="NOP0"
                 arr[i+1]:=substr(arr[i+1],5,len(arr[i+1]))
              end
              if "NOP1" $ arr[i]
                 arr[i]:=substr(arr[i],1,len(arr[i])-4)
              //   ?? arr[i],", "
                 asize(arr,len(arr)+1)
                 ++i
                 ains(arr,i)
                // label:="ELSIF"+alltrim(str(int(hb_random()*1000000000)))
                // stackpush( pilaELSE, label )
                // arr[i]:="jmp("+label+")"+pila
                 arr[i]:="NOP1"
              end
             // ?? arr[i],", "
           end 
        end
      /*  ? alltrim(str(lineaFisica)),":FIN = "
        for poto:=1 to len(arr)
           ?? arr[poto],","
        end*/
        
        if valtype(arr)=="N"
           if arr==1
              _Error ("macro #FX: Unrecognized symbol set as logical operator",lineaFisica)

           elseif arr==2
              _Error ("macro #FX: Syntax error",lineaFisica)

           elseif arr==3
              _Error ("macro #FX: Unbalanced parentheses",lineaFisica)

           end
        end
        // verificar si no hay una asignación: si la hay, quitar de la evaluación:
        n:=ascan(arr,"=")
        cDest:=NULL
        cDestTmp:=NULL
        swKeeper:=.T.; swProcesoAsignar:=.F.; countKeeper:=0
        while n>0
           swProcesoAsignar:=.T.
           ++countKeeper
           cDestTmp:=arr[n-1]
           if "[" $ arr[n-1]
               if len(cDest)==0
                  cDest:=strtran(cDestTmp,"get","!put")+";"//","
               else
                  cDest:=strtran(cDestTmp,"get","!put")+/*","*/";"+cDest
               end
               //swKeeper:=.T.
           else
               if len(cDest)==0
                  cDest:=";mov("+cDestTmp+")" // MOD.20-03-2022
                  //cDest:=cDestTmp+"=0;mov("+cDestTmp+")" // MOD.30-11-2021
                  //cDest:=",clear("+cDestTmp+"),mov("+cDestTmp+")" // MOD.30-11-2021
                  swKeeper:=.F.
               else
                  cDest:=";cpy("+cDestTmp+")"+cDest // MOD.20-03-2022
                  //cDest:=cDestTmp+"=0;cpy("+cDestTmp+");"+cDest  // MOD.30-11-2021
                  //cDest:=",clear("+cDestTmp+"),cpy("+cDestTmp+"),"+cDest  // MOD.30-11-2021
                  //swKeeper:=.F.
               end
           end
           adel(arr,n-1)
           adel(arr,n-1)
           asize(arr,len(arr)-2)
           n:=ascan(arr,"=")
           
        end
        if swProcesoAsignar
           if swKeeper   // porque no sé hasta dónde habrá un put en la asignación múltiple
              if countKeeper>1
                 cDest:=cDest+"kill"
              else //if countKeeper==1
               // ? "ENTRA AQUI"
                 cDest:=strtran(cDest,";!put",";put")
              end
           end
        end
/*
        n:=ascan(arr,"=")
        cDest:=NULL
        if n>0
           cDest:=arr[n-1]
           if "[" $ arr[n-1]
               cDest:=strtran(cDest,"get","put")
           else
               cDest:=cDest+"=0,mov("+cDest+")"
           end
           adel(arr,n-1)
           adel(arr,n-1)
           asize(arr,len(arr)-2)
        end
*/        //
/*?
        for hhh=1 to len(arr); ?? arr[hhh]; end*/
        pString:=EvPolaca(arr, lineaFisica, @DEF,@blkIF, @blkELSE, @blkEND, @blkWHILE, @blkEWHILE, @lineStruct)
        if len(cDest)>0
           pString += ";"+cDest
        end
        pString:=strtran(pString,";{}","")
        if !sw_macro
           if swMLinea
              swMLinea:=.F.
              //pString += ";clrmarksall;postfix"
             /// pString += ";clrmarksall;"
           //  pString += ";clearinterval;"
           //else   
              ///pString := "postfix;clrmarksall;"+pString+";clrmarksall;postfix"
           //   pString := /*";clrmarksall;"+*/ pString+";clearinterval;"
           end
        end
        // reemplazar {NOPx} por jnt y jmp
        //pilaIF:={}
        //pilaELSE:={}

      //  ? "pSTRING = ",pString
   /*    if len(pLinea)>0
          pString:=pLinea+pString
          pLinea:=NULL
       end */
               
        pString:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                              @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,pString,@lineaFisica)
       // fwrite(1, "PSTRING = "+ pString+" : LINEA = "+hb_ntos(lineaFisica)+_CR)
        //? pString 
        // analizar cada aparición de [] y convertirlo a hop-code:
        cLinea:=""
        while "[" $ pString
           nPosRA:=at("[",pString)
           t1Str:=substr(pString,1,nPosRA-1)  // incluyo todo antes de: "["
           tStr:=substr(pString,nPosRA+1,len(pString))  // porcion desde "["+1
           cStr:=substr(tStr,1,at("]",tStr)-1)  // tomo porcion entre "[" y "]"
           t2Str:=substr(tStr,at("]",tStr)+1,len(tStr))  // porcion sobrante, proxima a analizar en este ciclo
           // evaluar cada porcion con llenapila y evPolaca:
           Separator:=","
          // if ";" $ cStr
          //    Separator:=";"
          // end
          // ? "cSTR >>",cStr
           nTok:=numtoken(cStr,Separator)
          // ? "Ntok =", nTok
           c2Linea:=""
           for j:=1 to nTok
              ct1Str:=token(cStr,Separator,j)
              nTok2:=numtoken(ct1Str,":")
             // ? "TOK ct1Str = ", ct1Str
              for i:=1 to nTok2
                 ct2Str:=token(ct1Str,":",i)
                // ? "ct2Str [",alltrim(str(i)),"] << ", ct2Str
                 arr:=LLENAPILA(ct2Str)
                 if valtype(arr)=="N"
                     _Error ("macro #FX: unbalanced parentheses (or not needed here) or macro bad former",lineaFisica) 
                 end
                // ? "Len arr = ", len(arr)
                 ct2Str:=EvPolaca(arr, lineaFisica, @DEF,@blkIF, @blkELSE, @blkEND, @blkWHILE, @blkEWHILE, @lineStruct)
                 ct2Str:=strtran(ct2Str,Separator,"")
                 if i<nTok2
                     ct2Str+=":"
               //  else
               //      ct2Str+=","
                 end
                // ? "ct2Str [",alltrim(str(i)),"] >> ", ct2Str
                 c2Linea+=ct2Str
              end
              c2Linea+=Separator
           end
          // ? "REPL-RNG: >>",c2Linea
           c2Linea:=replaceRange(c2Linea,.F.,lineaFisica)
          // ? "REPL-RNG: <<",c2Linea
           cLinea:=t1Str + c2Linea + t2Str
           pString:=cLinea
          // ? "FINAL: ",pString
          // wait
           //? cStr
           //? t2Str
            
        end
        
        
        fwrite(fw,pString,len(pString))
        while newLine>0
           fwrite(fw,chr(10))
           --newLine
           ++lineaFisica
        end
        if sw_macro
           fwrite(fw,chr(10))
           ++lineaFisica
        end 
/*        pLinea+=pString
        ?"pLINEA=",pLinea*/
        pLineaDef:=NULL
        pString:=NULL
        
     elseif pLineaDef=="import"   // importa código HOPPER
        if len(pLinea)>0
           _Error ("macro #IMPORT must be unique in this line",lineaFisica)
        end
        QuitaEspacio(@h_ini,@h_fin,@fp,@c)
        pFileInclude:=NULL
        while is_noall(c,chr(10)," ") .and.h_ini<=h_fin
           pFileInclude+=c
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
        end
        if !file(pFileInclude)
              _Error(file+": import file error: "+GenMsg(chr(27)+"[1m"+pFileInclude+chr(27)+"[0m"),lineaFisica)
        end
        fpi:=fopen(pFileInclude)
        if ferror()!=0
              _Error(file+": open import file error: "+GenMsg(chr(27)+"[1m"+pFileInclude+chr(27)+"[0m"),lineaFisica)
        end
        i_fin:=fseek(fpi,0,2)
        i_ini:=fseek(fpi,0,0)
        c:=" "
        linTemp:=lineaFisica
        
        while i_ini<=i_fin
           fread(fpi,@c,1); ++i_ini
           pLineaImport+=c
        end
        fclose(fpi)

        fwrite(fw,chr(10),1)
        pLineaDef:=NULL
        ++lineaFisica

     elseif pLineaDef=="include"
      /*** Se aceptan: 
          #include <archivo.def>  para buscar en directorio "usr/include"
          #include ./archivo.def  para buscar en otro lado
          ***/
        if len(pLinea)>0
           _Error ("macro #INCLUDE must be unique in this line",lineaFisica)
        end
        QuitaEspacio(@h_ini,@h_fin,@fp,@c)
        pFileInclude:=NULL
        while is_noall(c,chr(10)," ") /*c!=chr(10) .and. c!=" "*/ .and.h_ini<=h_fin
           pFileInclude+=c
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
        end
        if substr(pFileInclude,1,1)=="<"
           pFileInclude:=substr(pFileInclude,2,len(pFileInclude))
           pFileInclude:=substr(pFileInclude,1,at(">",pFileInclude)-1)
           if !file("/usr/include/hopper/"+pFileInclude)
              _Error(file+": in folder "+GenMsg(chr(27)+"[1m"+"include"+chr(27)+"[0m")+" don't exist: "+GenMsg(chr(27)+"[1m"+pFileInclude+chr(27)+"[0m"),lineaFisica)
           end
           fpi:=fopen("/usr/include/hopper/"+pFileInclude)
           if ferror()!=0
              _Error(file+": file open error: "+GenMsg(chr(27)+"[1m"+pFileInclude+chr(27)+"[0m"),lineaFisica)
           end
        else
           if !file(pFileInclude)
              _Error(file+": include file error: "+GenMsg(chr(27)+"[1m"+pFileInclude+chr(27)+"[0m"),lineaFisica)
           end
           fpi:=fopen(pFileInclude)
           if ferror()!=0
              _Error(file+": open include file error: "+GenMsg(chr(27)+"[1m"+pFileInclude+chr(27)+"[0m"),lineaFisica)
           end
        end
        i_fin:=fseek(fpi,0,2)
        i_ini:=fseek(fpi,0,0)
        c:=" "
        linTemp:=0//lineaFisica
        swContext:=.F.
        while .T.
           while c!="#".and.i_ini<=i_fin
              fread(fpi,@c,1); ++i_ini
              if c=="/"   // posible comentario
                 fread(fpi,@c,1); ++i_ini
                 if c=="/"  // comentario de linea
                    while c!=chr(10) .and. i_ini<=i_fin
                       fread(fpi,@c,1); ++i_ini
                    end
                    if c==chr(10)
                       ++linTemp
                    end
                 elseif c=="*"  // comentario de bloque
                    while i_ini<=i_fin
                       fread(fpi,@c,1); ++i_ini
                       if c=="*"
                          fread(fpi,@c,1); ++i_ini
                          nSavePosI := fseek( fpi, 0, 1 )
                          if c=="/"
                             exit
                          else
                             fseek(fpi,nSavePosI-1,0); --i_ini
                          end
                       elseif c==chr(10)
                          ++linTemp
                       end
                    end
                 end
              elseif c==chr(10)
                 ++linTemp
              end   
           end
           if i_ini>i_fin
              fclose(fpi)
              exit
           end
          // busco palabra "define" 
           pLineaDef:=NULL
           fread(fpi,@c,1); ++i_ini
           while (isalpha(c) .or. c=="-") .and. i_ini<=i_fin
              pLineaDef+=c
              fread(fpi,@c,1); ++i_ini
           end
           pLineaDef:=alltrim(pLineaDef)
           if c==" "
              QuitaEspacio(@i_ini,@i_fin,@fpi,@c)
           end
           
           if c==chr(10)   // encontró una declaración vacia
              _Error (pFileInclude+": macro "+GenMsg(chr(27)+"[1m#"+pLineaDef+chr(27)+"[0m")+" bad formed",lineaFisica)
           end
           
           if pLineaDef=="define" .or. pLineaDef=="define-a"
              subTipoDef:=1
              if pLineaDef=="define-a"
                 subTipoDef:=3
              end
              nSavePos1:=GETDEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                                   @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,@i_ini,@i_fin,;
                                   @fpi,0,@c,@linTemp,0,pFileInclude,subTipoDef)
              if c==chr(10)  // por si resulto ser una linea simple
                 fseek(fpi,nSavePos1-1,0); --i_ini          
              end
              
           elseif pLineaDef=="defn"
              nSavePos1:=GETDEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                                   @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,@i_ini,@i_fin,@fpi,0,@c,@linTemp,1,pFileInclude,1)
              if c==chr(10)  // por si resulto ser una linea simple
                 fseek(fpi,nSavePos1-1,0); --i_ini          
              end
           elseif pLineaDef=="synon" .or. pLineaDef=="synonymous"
              nSavePos1:=GETDEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                                   @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,@i_ini,@i_fin,@fpi,0,@c,@linTemp,2,pFileInclude,1)
              if c==chr(10)  // por si resulto ser una linea simple
                 fseek(fpi,nSavePos1-1,0); --i_ini          
              end
           elseif pLineaDef=="proto" .or. pLineaDef=="prototype"
              swPrototipo:=.T.
              nSavePos1:=GETPROTOTYPE(@DEF,@DEFVAR,@DEFBODY,@i_ini,@i_fin,@fpi,@c,@linTemp,pFileInclude,1)
              if c==chr(10)  // por si resulto ser una linea simple
                 fseek(fpi,nSavePos1-1,0); --i_ini
              end
              swPrototipo:=.F.

           elseif pLineaDef=="enum" .or. pLineaDef=="enumerate"
              pString:=c; nARRANQUE:="0" //; newLine:=1
              c=" "; swSepara:=.F.
              while c!=chr(10) .and. i_ini<=i_fin
                 fread(fpi,@c,1); ++i_ini
                 if c==" "; loop; end
                 if c=="/"   // un comentario?
                    fread(fpi,@c,1); ++i_ini
                    if c=="/"   // comentario de linea
                       while c!=chr(10) .and. i_ini<=i_fin
                          fread(fpi,@c,1); ++i_ini
                       end
                       if c==chr(10)
                          ++linTemp
                       end
                    elseif c=="*"  // comentario de bloque
                       BloqueComentario(@i_ini,@i_fin,@fpi,@fw,@linTemp,@c)  // el ultimo sera el "/"
                       fread(fpi,@c,1); ++i_ini
                       nSavePos := fseek( fpi, 0, 1 )
                    else
                       _Error (pFileInclude+": macro #ENUM: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m")+" not recognized",linTemp)
                       exit
                    end
                 elseif c=="\"   // ojo: debe haber línea separada. Procesar
                    c:=" "
                    while (c!=chr(10) .and. c==" ").and. i_ini<=i_fin
                       fread(fpi,@c,1); ++i_ini
                       nSavePos := fseek( fpi, 0, 1 )
                    end
                    if c==chr(10)
                       //++newLine
                       ++linTemp
                       //c:=" "
                       swSepara:=.T.
                    else
                       _Error (pFileInclude+": macro #ENUM: premature end-of-file detected",linTemp)
                    end
                 end
                 if c=="," .or. c==chr(10)  // separa autosubs
                    if ISTNUMBER(pString)==1   // es el valor de arranque
                       nARRANQUE:=val(alltrim(pString))
                    else
                       aadd( DEFVAR, {} )  // no hay argumentos.
                       aadd( DEF,pString )
                       aadd( DEFBODY, hb_valtostr(nARRANQUE++) )
                    end
                    //? "(CONTEXT) pSTRING  = ",pString
                    if c==chr(10)
                       ++linTemp
                    end
                    if swSepara
                       swSepara:=.F.
                       c:=" "
                    end
                    pString:=NULL  // reinicia, para otro contexto
                 else
                    if c!=chr(10)
                       pString+=c
                    end
                 end
              end
              if i_ini>i_fin
                 _Error (pFileInclude+": macro #ENUM: end-of-file detected",linTemp)
              end
               //fwrite(fw,chr(10),1)
             /* while newLine>0
                 fwrite(fw,chr(10))
                 --newLine
                 ++lineaFisica
              end */

              pLineaDef:=NULL; pString:=NULL
              //++lineaFisica

           
           elseif pLineaDef=="autosub" .or. pLineaDef=="context-free" .or. pLineaDef=="context"         
              pString:=c
              c=" "
              nameContexto:=NULL
              swContext:=.T.
              while c!=chr(10) .and. i_ini<=i_fin
                 fread(fpi,@c,1); ++i_ini
                 nSavePos1 := fseek( fpi, 0, 1 )
                 if c==" "; loop; end
                 if c=="/"   // un comentario?
                    fread(fpi,@c,1); ++i_ini
                    nSavePos1 := fseek( fpi, 0, 1 )
                    if c=="/"   // comentario de linea
                       while c!=chr(10) .and. i_ini<=i_fin
                          fread(fpi,@c,1); ++i_ini
                       end
                       if c==chr(10)
                          ++linTemp
                       end
                    elseif c=="*"  // comentario de bloque
                       BloqueComentario(@i_ini,@i_fin,@fpi,@fw,@linTemp,@c)  // el ultimo sera el "/"
                       fread(fpi,@c,1); ++i_ini
                       nSavePos1 := fseek( fpi, 0, 1 )
                    else
                       _Error (pFileInclude+": macro #CONTEXT: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m")+" not recognized",linTemp)
                       exit
                    end
                 end

                 if c==chr(10)  // separa autosubs
                    aadd( DEFVAR, {} )  // no hay argumentos.
                    aadd( DEF,pString )
                    if pLineaDef=="context-free" .or. pLineaDef=="autosub"
                       aadd( DEFBODY, "jsub("+pString+")" )
                    elseif pLineaDef=="context"
                       aadd( DEFBODY, "keep;gsub("+pString+")" )
                    end
                    //? "pSTRING-include=[",pString,"]"
                    nameContexto:=pString
                    pString:=NULL  // reinicia, para otro contexto
                    ++linTemp
                    // define sinonimos "and", "then", "now"
                    aadd( DEFVAR, {} )  // si no hay vars, len(aTempVar)=0
                    aadd( DEF, "and"+nameContexto )
                    aadd( DEFBODY, atail(DEFBODY) )
                    aadd( DEFVAR, {} )  // si no hay vars, len(aTempVar)=0
                    aadd( DEF, "now"+nameContexto )
                    aadd( DEFBODY, atail(DEFBODY) )
                    aadd( DEFVAR, {} )  // si no hay vars, len(aTempVar)=0
                    aadd( DEF, "then"+nameContexto )
                    aadd( DEFBODY, atail(DEFBODY) )
                    exit
                 else
                    if c!=chr(10)
                       pString+=c
                    end
                 end
              end
              
             // if c==chr(10)  // por si resulto ser una linea simple
             //    fseek(fpi,nSavePos1-1,0); --i_ini
             // end
                     //? "nameContexto=",nameContexto
             if i_ini>i_fin
                _Error (pFileInclude+": macro #CONTEXT: end-of-file detected",linTemp)
             end
             // Busca el código perteneciente a Context declarado:
             newLine:=1
             //QuitaEspacio(@h_ini,@h_fin,@fp,@c)
             //if c==chr(10)
             //   ++newLine
             //end
             while /*c!="." .and.*/ i_ini<=i_fin
                fread(fpi,@c,1); ++i_ini
                pString+=c
                if c=='"'
                   while c!=chr(10) .and. i_ini<=i_fin
                     fread(fpi,@c,1); ++i_ini
                     pString+=c
                     if c=="\"
                        fread(fpi,@c,1); ++i_ini
                        pString+=c
                     elseif c==chr(34)
                        exit
                     end
                   end
                   if c==chr(10)
                      ++linTemp
                   end
                   if i_ini>i_fin
                      _Error (pFileInclude+": macro #CONTEXT: string not closed (end-of-file detected)",linTemp)
                   end
                elseif c==chr(10)
                   ++newLine; ++linTemp
                elseif c=="\"   // fin de declaración?
                   fread(fpi,@c,1); ++i_ini
                   if c=="\"   // es fin de declaracion
                      pString:=substr(pString,1,len(pString)-1)  // quito ultimo "\"
                      exit
                   elseif c==chr(10)
                      pString+=c
                      ++newLine
                   else
                      _Error (pFileInclude+": macro #CONTEXT: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m")+" not recognized",linTemp)
                   end
                end
             end
             if i_ini>i_fin
                _Error (pFileInclude+": macro #CONTEXT: end-of-file detected",linTemp)
             end
             // guardo en archivo fuente, al final.
             nSavePos := fseek( fp, 0, 1 )  // guardo última posicion de lectura
             h_fin:=fseek(fp,0,2)   // me voy al final
             fwrite(fp,nameContexto+":"+_CR)  // guardo encabezado del contexto
             fwrite(fp,pString+_CR) // guardo porcion de codigo
             h_fin:=fseek(fp,0,2)   // actualizo fin de archivo
             fseek(fp,nSavePos,0)   // rescato posicion de lectura de archivo fuente
             nameContexto:=NULL
             pString:=NULL
             /*while newLine>0
                fwrite(fw,chr(10))
                --newLine
                ++lineaFisica
             end
             //fwrite(fw,chr(10),1)
             pLineaDef:=NULL
             //++lineaFisica
            */
           else
              _Error(pFileInclude+": "+GenMsg(chr(27)+"[1m"+pLineaDef+chr(27)+"[0m")+" is not valid in include file",lineafisica)
           end
        end
        fwrite(fw,chr(10),1)
        pLineaDef:=NULL
        ++lineaFisica
     ///elseif upper(pLineaDef)=="OPL")
        
     else
        _Error(file+": preprocess directive error: "+_CR+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineafisica)
     end

/***************************/   
  else
     pLinea+=c

     if c==chr(10)
        /*if pLinea=="##"
           fwrite(fw,chr(10))
           sw_macro:=!sw_macro
        else   
          */ 
        // cambiar "." por línea de codigo de fin de párrafo
        //
        if substr(pLinea,len(pLinea)-1,1)=="."
          // ? "pLINEA>>=",pLinea
           pLinea:=substr(pLinea,1,len(pLinea)-2)+';emptystack?;not;do{ {"you did not close the idea "};throw(1100) }'+chr(10)
          // ? "pLINEA<<=",pLinea
        end
        pLinea:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                              @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,pLinea,@lineaFisica)
        fwrite(fw,pLinea,len(pLinea))
       // end
        pLinea:=NULL
        while keepLine>0
           fwrite(fw,chr(10))
           --keepLine
        end
        lineaFisica++
     end
  end
end

// verifica si hay codigo IMPORT que insertar al final:
if len(pLineaImport)>0
   fwrite(fw,pLineaImport)
end

if len(blkIF)>0
   eDato:=stackpop(lineStruct); linErr:=eDato[2]
   _Error(file+": preprocess directive error: "+GenMsg(chr(27)+"[1m"+"if"+chr(27)+"[0m"),iif(len(lineStruct)>0,linErr,lineafisica))
elseif len(blkELSE)>0 
   eDato:=stackpop(lineStruct); linErr:=eDato[2]
   _Error(file+": preprocess directive error: "+GenMsg(chr(27)+"[1mif->else"+chr(27)+"[0m"),iif(len(lineStruct)>0,linErr,lineafisica))
elseif len(blkEND)>0 .or. len(blkWHILE)>0 .or. len(blkEWHILE)>0
   eDato:=stackpop(lineStruct); linErr:=eDato[2]
   _Error(file+": preprocess directive error: struct not closed",iif(len(lineStruct)>0,linErr,lineafisica))
end

fclose(fp)
fclose(fw)

return


function Carga_archivo(file)
LOCAL h_ini, h_fin,nSavePos,nLineaTemp,nLineaAmp,nLineas,cnt:=0
LOCAL fp,c,linea,lineaFisica:=1,pFileInclude,pString,pCodeString,pLinea
LOCAL fpi,i_ini,i_fin,tmpFile
LOCAL swAmper,swEspacio,swCuerpo,swUse,sw,swRet, swMAINPRG
LOCAL reg,reg1,swNoEsSwap:=.F.
LOCAL registros,typeRegistro,pushes,lets,saltos,instrucc,funcs,labels,ctaIns,ctaReg,ctaLabels
///LOCAL DEF:={},DEFVAR:={},DEFBODY:={},
LOCAL STKSTR:={}
LOCAL coords, swTipo, ctaCoord, swOffset, offset,i, swHayStack,linePhantom
LOCAL stackPrg:={}
LOCAL swLock:=.F., lock_ini:=0, unlock_to:=0,localOpcode // declaración de variables locales.

fp:=fopen(file)
if ferror()!=0
  _Error("file source open error: "+GenMsg(chr(27)+"[1m"+file+chr(27)+"[0m"),0)   
end

h_fin:=fseek(fp,0,2)
h_ini:=fseek(fp,0,0)

SET EXACT ON

pString:=NULL
// a cargar lowlevel!

           
linea:=NULL
swCierre:=.F.
 // comienza carga de funciones de bajo nivel: NO.CARGO TODO HASTA "UP" Y LUEGO APLICO STRTRAN " "=>",", "PUSH"=>100 ETC.

 registros:={}      // guardo variables y constantes
 typeRegistro:={}     // guardo el tipo de objeto encontrado: R(registro), C(cte)
 // declaracion y uso de variables, con numero de linea donde se declaró:
 usedRegs:={}   // {num var, .F., num linea decl}

 pushes   :={"spush"=>0, "cpush"=>1, "dpush"=>2}
 lets     :={"slet"=>3,  "clet"=>4,  "dlet"=>5}
 saltos   :={"jmp"=>6, "jeq"=>7, "jneq"=>8, "jlt"=>9,;
             "jle"=>10, "jgt"=>11, "jge"=>12,;
             "jt"=>13, "jnt"=>14, "jv"=>15, ;
             "jnv"=>16, "jz"=>17, "jnz"=>18,;
             "jneg"=>19, "jpos"=>20,"gsub"=>21, "jsub"=>22}
 instrucc :={"eq?"=>23, "neq?"=>24, "noteq?"=>24,"iseq"=>23, "isneq"=>24, "isnoteq"=>24,;
             "lt?"=>25, "le?"=>26, "gt?"=>27,  "ge?"=>28, "islt"=>25, "isle"=>26, "isgt"=>27,  "isge"=>28, ;
             "neg?"=>29, "pos?"=>30,"isneg"=>29, "ispos"=>30,;
             "eoccurs"=>31,"occurs"=>32,;
             "cin?"=>32,"occursin?"=>32, "ecin?"=>31, "exactoccursin?"=>31, ;
             "iscin"=>32,"isoccursin"=>32, "isecin"=>31, "isexactoccursin"=>31, ;
             "zero?"=>33, ;
             "iszero"=>33, ;
             "void?"=>34,  "between?"=>35, "emptystack?"=>36, "env?"=>37, "exist?"=>38, "getstrerror"=>39,;
             "isvoid"=>34,  "isbetween"=>35, "isemptystack"=>36, "isenv"=>37, "isexist"=>38, ;
             "add"=>40,  "sub"=>41, "mul"=>42,  "div"=>43,  "idiv"=>44,  "pow"=>45, "power"=>45,"mod"=>46,"module"=>46,"round"=>47,;
             "max"=>48, "min"=>49, /*"jcase"=>50,*/ "xtobool"=>51, "kbfree"=>52, "keyput"=>53,;
             "rleft"=>54,"rright"=>55,"rall"=>56,"inf?"=>57,"nan?"=>58, "isinf"=>57,"isnan"=>58, "cut"=>59, ;
             "len"=>60, "upper"=>61, "lower"=>62, "trim"=>63, "asc"=>64, "trimright"=>65, "trimleft"=>66, "xtonum"=>67,;
             "all?"=>68, "any?"=>69, "isall"=>68, "isany"=>69, /*"clearmark"=>70,*/ "popcatch"=>71, "elaptime"=>72,;
             "elapsedtime"=>72,"daysdiff"=>73,;
             "dateadd"=>74,"$"=>75, "$$"=>76, "gettk"=>75, "modtk"=>76, "rcut"=>77, "regvalid"=>78, "regmatch"=>79, ;
             "exp"=>80, "int"=>81, "sign"=>82, "log"=>83, "log10"=>84, "sqrt"=>85, "sin"=>86, "cos"=>87, "tan"=>88,;
             "sinh"=>89, "cosh"=>90, "tanh"=>91, "xtostr"=>92, "floor"=>93, "abs"=>94, "chr"=>95, "ceil"=>96, ;
             "exp2"=>97, "log2"=>98, "exp10"=>99, "hex"=>100, "bin"=>101, "oct"=>102, "lennum"=>103, "fact"=>104,;
             "sci"=>105, "notation"=>105, "d2r"=>106, "r2d"=>107,;
             "cbrt"=>108, "rand"=>109, "trunc"=>110, "even?"=>111, "iseven"=>111, "neg"=>112, "nop"=>113, "dup"=>114,;
             "typechar?"=>115,"sizestack"=>116,"typechar"=>115,"sizstk"=>116,;
             "clearrange"=>117,"clrrng"=>117,"cartesian"=>118,"loc2"=>119,"loc1"=>120,"interval1"=>121,;
             "interval2"=>122,"interval3"=>123,;
             "show"=>124, "or"=>125, "and"=>126, "xor"=>127, "nor"=>128, "nand"=>129, "not"=>130, "totalarg"=>131,;
             "type"=>132,"error?"=>133, "iserror"=>133,"pause"=>134,"microsecs"=>135, "return"=>136, "transform"=>137,;
             "getenv"=>138,  "back"=>139,  "kbhit?"=>140,  "kbesc?"=>141, "iskbhit"=>140,  "iskbesc"=>141, ;
             "echo"=>142,"replace"=>143,"print"=>144,;
             "copy"=>145,"mid"=>145, "offset1"=>146, "true"=>147,"sectotime"=>148, "kbctrlc?"=>149,"iskbctrlc"=>149,;
             "numeric?"=>150,"string?"=>151,"array?"=>152,"isnumeric"=>150,"isstring"=>151,"isarray"=>152,"length"=>153,;
             "kill"=>154, "clearstack"=>155,"clrstk"=>155, "countat"=>156,;
             "findat"=>157, "find"=>158, "mask"=>159, "money"=>160,"multipasson"=>161,;
             "multipassoff"=>162, "toksep"=>163, "seconds"=>164, ;
             "false"=>165, "matmul"=>166,;
             "padcenter"=>167, "padright"=>168, "padleft"=>169, ;
             "cpad"=>167, "rpad"=>168, "lpad"=>169,"cat"=>170, "repl"=>171, "replicate"=>171,;
             "setenv"=>172, "unsetenv"=>173, "dayname"=>174, "onlychar"=>175, "compact"=>176, "offset2"=>177,;
             "ptr"=>178, "ins"=>179,"insert"=>179, "del"=>180,"delete"=>180, "statsfile"=>181, "strtoutf8"=>182,"utf8"=>182,;
             "utf8tostr"=>183,"ansi"=>183, "deletechar"=>184, "fileerror"=>185, "load"=>186, "save"=>187, "exec"=>188,"sleep"=>189,;
             "drwtbl"=>190, "onechar"=>191, "poschar"=>192 ,"printusingtoken"=>193,"printusingtk"=>193,"keep"=>194,"puts"=>195,;
             "goxy"=>196,;
             "clockpersec"=>197, "execv"=>198,"clearinterval"=>199,"clrinterv"=>199 }
 funcs    :={"sizebin"=>200, "mov"=>201,   "inc"=>202,  "dec"=>203,  "prec"=>204, "precision"=>204, "newarray"=>205,;
             "totaltoken"=>206, "pinc"=>207, "loc2"=>208, "pdec"=>209, "fillarray"=>210, "reverse"=>211, "loc1"=>212,;
             "readrow"=>213, "lastkey"=>214, "dprec"=>215, "addrow"=>216, "put"=>217, "get"=>218,"getrow"=>219,;
             "getcol"=>220, "getcolumn"=>220, "catrow"=>221, "catcol"=>222, "catcolumn"=>222, "getpage"=>223,;
             "putpage"=>224, "size"=>225, "type"=>226, "gettoken"=>227, "modtoken"=>228,"$"=>227, "$$"=>228,;
             "open"=>229, "empty"=>230, "randarray"=>231, "zerosarray"=>232, "onesarray"=>233,;
             "eyesarray"=>234, "close"=>235, "writeline"=>236, "readline"=>237, "seek"=>238, "eof"=>239, "create"=>240,;
             "dowith"=>241, "writerow"=>242, "sequencespaced"=>243, "seqsp"=>243, "sequence"=>244, "seq"=>244, "cpy"=>245,;
             "reshape"=>246, "true"=>247, "false"=>248, "datenow"=>249, "stats"=>250,"statistic"=>250, "sets"=>251,"array"=>252,;
             "date"=>253, "socket"=>254, "join"=>256, "divby"=>257, "idivby"=>258,"powby"=>259,"module"=>260,;
             "minus"=>261,"plus"=>262,"mulby"=>263,;
             "gettry"=>264, "swtrap"=>265, "throw"=>266,;
             "eqto"=>267, "neqto"=>268, ;
             "lthan"=>269, "lethan"=>270,"gthan"=>271, ;
             "gethan"=>272, "clear"=>273,"push"=>274,;
             "ecin"=>275, "exactoccursin"=>275, "cin"=>276,"occursin"=>276,  ;
             "roundby"=>277, "bit"=>278,"cal"=>279,;
             "calendar"=>279, "loadstring"=>280, "split"=>281, "packstring"=>282, "savestring"=>283,"getline"=>284,;
             "countlines"=>285, "search"=>286, "timer"=>287, "puts"=>288,"ipush"=>289, "ipop"=>290 ,;
             "pop"=>291,"qpop"=>292,"tail"=>293,"head"=>294, "replyby"=>295, "writestring"=>296, "readstring"=>297,;
             "saturate"=>298,"accept"=>299, "recv"=>300, "send"=>301, "connect"=>302,"recvfrom"=>303,"sendto"=>304,"opecod"=>305,;
             "qcreate"=>306,"qset"=>307,"qsend"=>308,"qrecv"=>309,"qremove"=>310,"assert"=>311, "parser"=>312,"unparser"=>313,;
             "regcompile"=>314,"regfree"=>315, "clamp"=>316, "keep"=>317,"timecpu"=>318,"range"=>319,"voidarray"=>320,;
             "nanarray"=>321,;
             "arcsin"=>322,"arccos"=>323,"arctan"=>324,"arcsinh"=>325,"arccosh"=>326,"arctanh"=>327,;
             "isempty"=>328,"gox"=>329,"goy"=>330,"monthname"=>331,"seed"=>332,"gettoksep"=>333,"sqrdiff"=>334,"sqradd"=>335,;
             "hypot"=>336,"mulall"=>337,"sumall"=>338,"eqarr?"=>339,"neqarr?"=>340,"swap"=>341,"print2d"=>342,;
             "gcd"=>343,"lcm"=>344,"getsizscr"=>345,"typestring?"=>346,"disttypestring?"=>347,"chrutf8"=>348,"getnotation?"=>349,;
             "sjoin"=>350,"updrow"=>351,"updcol"=>352,"fillbox"=>353,"dumparray"=>354,"existdir?"=>355,"getenvnum"=>356,;
             "outbetween?" => 357, "isoutbetween" => 357, "line"=>358, "circle"=>359, "poligon"=>360,;
             "nneg?"=>361, "npos?"=>362,"mklist"=>363,"isnotneg"=>361, "isnotpos"=>362,;
             "list"=>363,;
             "itop"=>370,"format"=>371,;
             "pushall"=>372,"ewget"=>373,"ewput"=>374,"eqarrto"=>375,"neqarrto"=>376,"jsnt"=>377,;
             "jst"=>378,"look"=>379,"dims"=>380,"rows"=>381,"cols"=>382,"pages"=>383,"minusone"=>384,"plusone"=>385,;
             "minustwo"=>386,"plustwo"=>387,"cposx"=>388,"cposy"=>389, "draw"=>390, "jnneg"=>391, "jnpos"=>392,"nbrc"=>393,;
             "getpositive"=>394,"getnegative"=>395,"getnonzero"=>396,"getnonvoid"=>397,"pushvar"=>398,"delcols"=>399,;
             "delrows"=>400,"delpags"=>401,"inscols"=>402,"insrows"=>403,"inspags"=>404 /*,"gencart"=>405*/ }
             
             /*ATENCION: JSNT = 357, SI SE DESEA AÑADIR INSTRUCCIONES SIMPLES MÁS ALLÁ DE 349, MODIFICAR 357 -> EN ANALISIS
                                DE SALTOS */
             
             //"getrange"=>319,"putrange"=>320}
             /*"read16"=>312,"read32"=>313,;
             "write16"=>314,"write32"=>315} */
             /*"areeqto"=>295, "areneqto"=>296, ;
             "arelthan"=>297, "arelethan"=>298,"aregthan"=>299, "aregethan"=>300, "replyby"=>301 }*/
             // NO TOCAR 255: ES ARRANQUE DE MAIN
             
 // recuperar labels de salto
 labels:={=>}
 
 ctaIns:=0
 ctaReg:=0
 ctaLabels:=0
 swRet:=.F.
 swMAINPRG:=.F.  // indica si se encontró un "main:"

 linea:={}
 /* siguientes lineas se agregan al final, junto con la declaración de constantes */
// linePhantom:=NULL
 /* guardo línea fantasma con longitud del stack de registros */
 header:={}
 aadd(header,"__LONG_REGISTER__")
 ++ctaIns
 /* guardo linea fantasma con longitud del stack de trabajo */
 aadd(header,"__LONG_STACK__")
 ++ctaIns
 aadd(header,"___LOCAL_VARS___")
  ++ctaIns
 aadd(header,"___CTRL_C___")
  ++ctaIns
 nLineaTemp:=lineaFisica
 
 c:=" "    // inicia carga desde cero.

 pLinea:=NULL
 pString:=NULL

 phantomLabels:={}
 nPhantom:=0
 numLine:={}

 swHayStack:=.T.
 //  ? "ENTRA Linea=",lineaFisica

 while h_ini<=h_fin
    fread(fp,@c,1); ++h_ini   // leo sig caracter
    nSavePos := fseek( fp, 0, 1 )
    
    if c=='"'
       //_Error("unknow element here: ("+pLinea+"):"+c,lineaFisica)
       swCopiaArray:=.F.
       //while c!=chr(10) .and. h_ini<=h_fin
       //      fread(fp,@c,1); ++h_ini
       //      nSavePos := fseek( fp, 0, 1 )

                if len(pLinea)==0
                   pLinea:=c
                else
                   pLinea += c
                end
                swString:=.T.
                c:=" "
                while c!=chr(10) .and. h_ini<=h_fin
                   fread(fp,@c,1); ++h_ini
                   pLinea+=c
                   if c=="\"
                      fread(fp,@c,1); ++h_ini
                      pLinea+=c
                   elseif c==chr(34)
                      exit
                   end
                end
                //? "string detectado: [",pLinea,"]"
                if c==chr(10)
                   _Error("function "+chr(27)+"[1m"+"{}"+chr(27)+"[0m"+" unclosed: "+_CR+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end

       //end
       Procesa_registro_o_constante(@pLinea,@lineaFisica,@linea,@registros,@typeRegistro,@usedRegs,@numLine,;
                                    @swLock,@lock_ini,@unlock_to,@ctaIns,@ctaReg,@swCopiaArray,@swString)
    elseif c==" "
       loop
    elseif c=="}" // ¿Y qué pasa si pLinea!=""?
       Procesa_una_huea_que_no_recuerdo(@pLinea,@ctaIns,@linea,@numLine,@swLock,@lock_ini,@registros,;
                                        @instrucc,@phantomLabels,@labels,@nPhantom,@ctaLabels,@swRet,lineaFisica)

    elseif c==chr(10)  // si quito espacios, deberá quedar esto aquí
       if !Procesa_instruccion_en_EOL(@pLinea,@swHayStack,@linea,@numline,@ctaIns,@registros,@header,@swLock,@unlock_to,;
                                      @lock_ini,@instrucc,@funcs,@lineaFisica,@swRet,@typeRegistro,@usedRegs,@ctaReg)
          loop
       end

    elseif c==":"   // es un label
       Procesa_etiqueta(@pLinea,@swMAINPRG,@linea,@numline,@ctaLabels,/*@ActualLabel,*/@labels,@ctaIns,lineaFisica)

    elseif c=="{"  // inicia push... analizar el tipo de push, según el mismo algoritmo de PUSH más abajo
                   // hasta que encuentre un "}".
                   // puede ser "do{"
//       ? "PLINEA=",pLinea
       if pLinea=="do"
          Procesa_DO(@pLinea,@linea,@numLine,@nPhantom,@phantomLabels,@ctaIns,lineaFisica)

       elseif pLinea=="case"  // esto debería estar deprecado, pero lo dejo por siaca
          Procesa_CASE(@pLinea,@linea,@numLine,@nPhantom,@phantomLabels,@ctaIns,lineaFisica)

       else
          // Busco registro o constante, y lo meto al programa
           Busca_registro_o_constante(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                      @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica)
       end   // do{

    elseif c=="<"  .and. !swNoEsSwap  // puede ser un swap:  v <-> w
       if !Procesa_swap_de_registros(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                     @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica,@swNoEsSwap)
          loop
       end

    elseif c=="*"           // si es una asignacion especial, debo procesar aparte.
       Procesa_mul_operador_especial(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                     @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica)
       
    elseif is_any(c,"/","^","%",">","<","|","&","\","!")   // asignacion especial
       Procesa_operador_especial(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                 @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica,@swNoEsSwap)
       
    elseif c=="+"   // puede ser REG++
       Procesa_incremento_de_variable(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                      @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica)

    elseif c=="-"   // debe ser REG--
       Procesa_decremento_de_variable(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                      @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica)

    elseif c=="["  //orden==208 // .and. orden<=211       // localizacion de elemento de un array.
       Procesa_rangos_array(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                            @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica)

    elseif c=="="  // emcontró una asignación. dejar pLinea en label, asignar un número, y ya.
       if !Procesa_asignacion(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                              @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica)
          loop
       end
       
    elseif c=="(" .or. c=="'"   // inicia inner-funcion. dejar igual
       if len(alltrim(pLinea))==0   // es un "push"
          // Busco registro o constante, y lo meto al programa
          //?"PLINEA=", pLinea
           Busca_registro_o_constante(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                      @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica)
       else
           Busca_funcion(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                      @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica,;
                                      @lets,@pushes,@saltos,@funcs)
       end // push con paréntesis.

   elseif c=="," .or. c==";" .or. c=="?"    // separador de funciones, obligadamente
      // buscar en instrucc
      Procesa_por_separador(@pLinea,@fp,@h_ini,@h_fin,@registros,@lock_ini,@unlock_to,@typeRegistro,;
                                      @usedRegs,@linea,@ctaIns,@ctaReg,@swLock,@numLine,@c,lineaFisica,;
                                      @lets,@instrucc,@funcs)      
   else         // proceso lo que sea
      pLinea+=c
   end

end
if !swMAINPRG
    _Error("Start of execution was not declared "+GenMsg(chr(27)+"[1m"+"main:"+chr(27)+"[0m"),lineaFisica-1)
end
if !swRet
   _Error("Every low-level function must return something "+GenMsg(chr(27)+"[1m"+"return"+chr(27)+"[0m"),lineaFisica-1)
end
if len(phantomLabels)>0
   _Error("I found a group 'DO' unclosed",lineaFisica-1)
end

header[1]:=ctaReg
if valtype(header[2]) == "C" ///at("__LONG_STACK__",linePhantom)>0
   header[2]:=10
end
if lock_ini>0
   header[3]:=lock_ini  // arreglar!!
else
   header[3]:=1      // no debe ser cero, por ahora.
end
if valtype(header[4])=="C"  // activa ctrl+c o no
   header[4]:=0
end

// recorre registros y typeRegistro, para añadir tabla de constantes, y
// obtener numero de constantes registradas, para recalcular aJump:
noffset:=0

for i:=1 to ctaReg
   if typeRegistro[i]!="R"
      aadd(header,0)
      aadd(header,i)
      if typeRegistro[i]=="N"
         aadd(header,val(registros[i]))
      else
         aadd(header,hb_utf8tostr(registros[i]))
      end
      noffset+=3
   else
      if !usedRegs[i,2]
         if swWarning
            //fwrite(1,"Line: "+alltrim(str(usedRegs[i,3]))+" => warning: variable "+GenMsg(registros[usedRegs[i,1]])+" set but not used"+_CR) 
            /*chr(27)+"[1m"+archivoExec+chr(27)+"[0m"*/
            printmsg("Line: "+alltrim(str(usedRegs[i,3]))+" => "+chr(27)+"[35mwarning"+chr(27)+"[0m"+": variable "+GenMsg(chr(27)+"[1m"+registros[usedRegs[i,1]]+chr(27)+"[0m")+" set but not used"+_CR)
         end
      end
   ///      ? usedRegs[i,1],",",usedRegs[i,2],",",usedRegs[i,3]
   end
end
// añado un 255 como final de constantes. Este valor jamas será una instrucción
aadd(header,255)
noffset++
            
// añadir encabezado a resto de programa
stackPrg:=array( len(header) + len(linea) )
for i:=1 to len(header)
   stackPrg[i]:=header[i]
   asize(numLine,len(numLine)+1)
   ains(numLine,1)
   numLine[1]:=0
end
j:=len(header)+1
for i:=1 to len(linea)
   stackPrg[j]:=linea[i]
   ++j
end
            
// recorrer cada una de las claves de labels, y reemplazar en todo el codigo por su key.
// eliminar la clave seleccionada de labels.
// si quedan "CODE JUMP" en el codigo, hay error: etiqueta de salto no reconocido.
// si quedan claves, no hay error: puede ser un codigo que, de igual forma, sea ejecutado.
for i:=1 to ctaLabels
    aJump:=hb_HPairAt(labels, i)
    linea:="____CODE__JUMP____"+aJump[1]
    hValue:= aJump[2] + noffset
    while .t.
       n:=ascan(stackPrg,linea)
       if n>0
          stackPrg[n]:=hValue
       else
          exit
       end
    end
end
// buscar algún code jump guacho:
for i:=1 to len(stackPrg)
   if valtype(stackPrg[i]) == "C"
      if at("____CODE__JUMP____", stackPrg[i])>0

         _Error("a jump tag has no declared destination",lineaFisica-1)
      else
         stackPrg[i]:=strtran(stackPrg[i],"\n",_CR)
         stackPrg[i]:=strtran(stackPrg[i],"\t",chr(9))
         stackPrg[i]:=strtran(stackPrg[i],"\b",chr(8))
         stackPrg[i]:=strtran(stackPrg[i],'\"','"')
         stackPrg[i]:=substr(stackPrg[i],2,len(stackPrg[i]))
         stackPrg[i]:=substr(stackPrg[i],1,len(stackPrg[i])-1)
         // colores de terminal en print
         stackPrg[i]:=strtran(stackPrg[i],'\BGLGR',chr(27)+"[47m")  // bg ligth grey
         stackPrg[i]:=strtran(stackPrg[i],'\BGDGR',chr(27)+"[100m")  // bg dark grey
         stackPrg[i]:=strtran(stackPrg[i],'\BGLR',chr(27)+"[101m")   // bg ligth red
         stackPrg[i]:=strtran(stackPrg[i],'\BGLG',chr(27)+"[102m")   // bg ligth green
         stackPrg[i]:=strtran(stackPrg[i],'\BGLY',chr(27)+"[103m")   // bg ligth yellow
         stackPrg[i]:=strtran(stackPrg[i],'\BGLB',chr(27)+"[104m")   // bg ligth blue
         stackPrg[i]:=strtran(stackPrg[i],'\BGLM',chr(27)+"[105m")   // bg ligth magenta
         stackPrg[i]:=strtran(stackPrg[i],'\BGLC',chr(27)+"[106m")   // bg ligth cyan
         stackPrg[i]:=strtran(stackPrg[i],'\BGW',chr(27)+"[107m")    // bg WHITE
         stackPrg[i]:=strtran(stackPrg[i],'\BGBK',chr(27)+"[40m")    // bg black
         stackPrg[i]:=strtran(stackPrg[i],'\BGR',chr(27)+"[41m")     // bg red
         stackPrg[i]:=strtran(stackPrg[i],'\BGG',chr(27)+"[42m")     // bg green
         stackPrg[i]:=strtran(stackPrg[i],'\BGY',chr(27)+"[43m")    // bg yellow
         stackPrg[i]:=strtran(stackPrg[i],'\BGB',chr(27)+"[44m")    // bg blue
         stackPrg[i]:=strtran(stackPrg[i],'\BGM',chr(27)+"[45m")    // bg magenta
         stackPrg[i]:=strtran(stackPrg[i],'\BGC',chr(27)+"[46m")    // bg cyan

         stackPrg[i]:=strtran(stackPrg[i],'\CUR',chr(27)+"[3m")  //  CURSIVA
         stackPrg[i]:=strtran(stackPrg[i],'\ENF',chr(27)+"[1m")  // ENFATIZADO
         stackPrg[i]:=strtran(stackPrg[i],'\UL',chr(27)+"[4m")  //  UNDERLINE
         stackPrg[i]:=strtran(stackPrg[i],'\BLK',chr(27)+"[5m")  // BLINK
         stackPrg[i]:=strtran(stackPrg[i],'\INV',chr(27)+"[7m")  //  INVERT
         
         

         stackPrg[i]:=strtran(stackPrg[i],'\DGR',chr(27)+"[90m")    //  dark grey
         stackPrg[i]:=strtran(stackPrg[i],'\LGR',chr(27)+"[37m")  //  ligth grey
         stackPrg[i]:=strtran(stackPrg[i],'\LR',chr(27)+"[91m")     // ligth red
         stackPrg[i]:=strtran(stackPrg[i],'\LG',chr(27)+"[92m")   // ligth green
         stackPrg[i]:=strtran(stackPrg[i],'\LY',chr(27)+"[93m")   // ligth yellow
         stackPrg[i]:=strtran(stackPrg[i],'\LB',chr(27)+"[94m")   // ligth blue
         stackPrg[i]:=strtran(stackPrg[i],'\LM',chr(27)+"[95m")   // ligth magenta
         stackPrg[i]:=strtran(stackPrg[i],'\LC',chr(27)+"[96m")   // ligth cyan
         stackPrg[i]:=strtran(stackPrg[i],'\W',chr(27)+"[97m")  //  white
         stackPrg[i]:=strtran(stackPrg[i],'\BK',chr(27)+"[30m")    //  black

         stackPrg[i]:=strtran(stackPrg[i],'\RGBF',chr(27)+"[38;2;")    // COlor RGB alta gama: fore
         stackPrg[i]:=strtran(stackPrg[i],'\RGBB',chr(27)+"[48;2;")    // COlor RGB alta gama: back
         
         stackPrg[i]:=strtran(stackPrg[i],'\R',chr(27)+"[31m")     //  red
         stackPrg[i]:=strtran(stackPrg[i],'\G',chr(27)+"[32m")     //  green
         stackPrg[i]:=strtran(stackPrg[i],'\Y',chr(27)+"[33m")    //  yellow
         stackPrg[i]:=strtran(stackPrg[i],'\B',chr(27)+"[34m")    //  blue
         stackPrg[i]:=strtran(stackPrg[i],'\M',chr(27)+"[35m")    //  magenta
         
         stackPrg[i]:=strtran(stackPrg[i],'\CF',chr(27)+"[38;5;")    // COlor 0:255 alta gama: foreground
         stackPrg[i]:=strtran(stackPrg[i],'\CB',chr(27)+"[48;5;")    // COlor 0:255 alta gama: background

         stackPrg[i]:=strtran(stackPrg[i],'\C',chr(27)+"[36m")    //  cyan

         stackPrg[i]:=strtran(stackPrg[i],'\OFF',chr(27)+"[0m")
         
         stackPrg[i]:=strtran(stackPrg[i],'\033',chr(27))
         stackPrg[i]:=strtran(stackPrg[i],'\e',chr(27))

      end
   end
end

if swOutDebug
   Genera_debug(@stackPrg,@numline,@registros,@typeRegistro,@ctaReg,@usedRegs)
end
// guarda pString en fd.

pString:=NULL
linea:=NULL
hValue:=NULL
hb_HClear(labels)
hb_HClear(pushes)
hb_HClear(lets)
hb_HClear(saltos)
hb_HClear(instrucc)
hb_HClear(funcs)
release registros
release typeRegistro

SET EXACT OFF

return stackPrg

Procedure Busca_funcion(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                        usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica,lets,pushes,saltos,funcs)
local orden

       orden := hb_HGetDef( lets, pLinea, -1 )
       if orden==-1
          orden := hb_HGetDef( pushes, pLinea, -1 )
          if orden==-1
             orden := hb_HGetDef( saltos, pLinea, -1 )
             if orden==-1
                orden := hb_HGetDef( funcs, pLinea, -1 )
                if orden==-1
                   // último recurso: pueden ser funciones trigonométricas
                   _Error("low-level instruction not recognized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             end
          end
       end
       pLinea:=NULL
       if orden>=6 .and. orden<=22 .or. orden==265  .or. orden==377 .or. orden==378 .or.;
          orden==391 .or. orden==392// es un salto, incluyendo jsnt=377 y jst=378
          while c!=chr(10) .and. h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             if c==" "
                loop
             elseif c==")" .or. c=="'"
                // determinar si es un jsub: si swLock, entonces, hay que añadir lista de vars a proteger en stack_obj:
                if orden==22   // 22=jsub
                   if swLock   // se invoca dentro de una subrutina local
                      //if lock_ini<=len(registros)
                         for i:=lock_ini to len(registros)
                            if typeRegistro[i] == "R"
                               aadd(linea,289)   // guarda de adelante para atrás: dspush
                               aadd(linea,i)
                               aadd(numLine,lineaFisica)
                               aadd(numLine,lineaFisica)
                               ctaIns+=2
                            end
                         end
                      //end
                   end
                end
                // chequear label y obtener numero de instruccion                
                hValue:="____CODE__JUMP____"+pLinea
                //torden:=getFamilia(orden)
                aadd(linea,orden)
                aadd(linea,hValue)
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                ctaIns+=2
                // si swLock, es evidente que se guardó previamente una lista de variables en stk_obj, y debo recuperarlas:
                if orden==22   // 22=jsub
                   if swLock   // se invoca dentro de una subrutina local
                      //if lock_ini<=len(registros)
                         for i:=len(registros) to lock_ini step -1
                            if typeRegistro[i] == "R"
                               aadd(linea,290)   // rescata de atrás para adelante: dspop
                               aadd(linea,i)
                               aadd(numLine,lineaFisica)
                               aadd(numLine,lineaFisica)
                               ctaIns+=2
                            end
                         end
                      //end
                   end
                end

                pLinea:=NULL
                exit
             else
                pLinea+=c
             end
          end
          if c==chr(10)
             fseek(fp,nSavePos-1,0); --h_ini
          end
       elseif (orden>=200 .and. orden<=206) .or. orden==210 .or.orden==211 .or. orden>=213 //.and. orden<=218)   // es una funcion
          while c!=chr(10) .and. h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             // debo identificar si es un string, para respetar los espacios en blanco, si orden es 288,227,228 y 206
             if c==chr(34)   // es una cte string. debo guardar sin comillas, luego se quitan
                pLinea:=c
                c:=" "
                swString:=.T.
                while c!=chr(10) .and. h_ini<=h_fin// .and. c!=chr(34)
                   fread(fp,@c,1); ++h_ini
                   pLinea+=c
                   if c=="\"
                      //
                      fread(fp,@c,1); ++h_ini
                      pLinea+=c
                   elseif c==chr(34)
                      exit
                   end
                end
                if h_ini>h_fin
                   _Error("(3)string unclosed"+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             elseif c==" "
                loop
             elseif c==")" .or. c=="'"
                // chequear registros. no debería dejar pasar ningún string, por default.
                pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
                if swLock
                   reg:=ascan(registros, pLinea,lock_ini) // busco en locales
                   if reg==0
                      reg:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                   end
                else
                   reg := ascan(registros, pLinea)
                end
                if reg>0
                   // chequear que sea registro; constante: solo para 204

                  if typeRegistro[reg] == "N"
                      if is_noallnum(orden,204,200,249,266,250,251,252,253,254,257,258,259,260,261,262,263,267,268,269,;
                                           270,271,272,273,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,;
                                           295,299,300,301,302,303,304,306,307,308,309,310,317,322)
//                      if orden!=204 .and. orden!=200 .and. orden!=249 .and. orden!=266 .and. orden!=251 .and. orden!=252 ;
//                         .and. orden!=253 .and. orden!=254
                        if (orden >= 231 .and. orden <= 234) .or. orden == 210 .or. orden == 321
                           if pLinea!="0"
                              _Error("I don't expect a number here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                           end
                        end
                     end
                  elseif typeRegistro[reg] != "R" .and. /*orden!=288,*/is_noallnum(orden,288,227,228,206,267,311)
                     _Error("register not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                  end
                  //torden:=getFamilia(orden)
                  if typeRegistro[reg] == "R" 
                     usedRegs[reg,2]:=.T.
                  end
                  aadd(linea,orden)
                  aadd(linea,reg)
                  aadd(numLine,lineaFisica)
                  aadd(numLine,lineaFisica)
                  ctaIns+=2
               else  // no existe el registro, ni como variable, ni como constante?
                  
                  if ISTNUMBER(pLinea)==1
                     if is_noallnum(orden,204,200,249,266,250,251,252,253,254,257,258,259,260,261,262,263,267,268,269,;
                                          270,271,272,273,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,;
                                          295,299,300,301,302,303,304,306,307,308,309,310,317,322)
//                     if orden!=204 .and. orden!=200 .and. orden!=249 .and. orden!=266 .and. orden!=251 .and. orden!=252 ;
//                         .and. orden!=253 .and. orden!=254
                        if (orden >= 231 .and. orden <= 234) .or. orden == 210 .or. orden == 321
                           if pLinea!="0"
                              _Error("I don't expect a number here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                           end
                        end
                     end
                     // agregar nueva constante a tabla registros:
                     aadd(registros,pLinea)     // agrego label de registro variable
                     aadd(typeRegistro, "N")    // agrego tipo registro
                     ++ctaReg
                     aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                     //torden:=getFamilia(orden)
                     aadd(linea,orden)
                     aadd(linea,ctaReg)
                     aadd(numLine,lineaFisica)
                     aadd(numLine,lineaFisica)
                     ctaIns+=2
                  elseif substr(pLinea,1,1)==chr(34) .and. ( orden==288.or.orden==227.or.orden==228.or.orden==206.or.orden==267;
                                                             .or.orden==311)
                     aadd(registros,pLinea)     // agrego label de registro variable
                     aadd(typeRegistro, "C")    // agrego tipo registro
                     ++ctaReg
                     aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                     //torden:=getFamilia(orden)
                     aadd(linea,orden)
                     aadd(linea,ctaReg)
                     aadd(numLine,lineaFisica)
                     aadd(numLine,lineaFisica)
                     ctaIns+=2
                  elseif substr(pLinea,1,1)=="["  // es un dataseg
                     if orden!=204
                        orden:=215
                     else
                        _Error("I don't expect a parameter here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                     end
                     pLinea:=strtran(pLinea,"[","")
                     pLinea:=strtran(pLinea,"]","")
                     pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
                     if swLock
                        reg:=ascan(registros, pLinea,lock_ini) // busco en locales
                        if reg==0
                           reg:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                        end
                     else
                        reg := ascan(registros, pLinea)
                     end
                     aadd(linea,orden)
                     aadd(numLine,lineaFisica)
                     // pLinea debe ser numero o registro
                     if reg==0   // no está registrado. hay que registrarlo, si es un numero.
                        if ISTNUMBER(pLinea)==1
                           aadd(registros,pLinea)     // agrego label de registro variable
                           aadd(typeRegistro, "N")    // agrego tipo registro
                           ++ctaReg
                           aadd(linea,ctaReg)
                           aadd(numLine,lineaFisica)
                           aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                        else
                           _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                        end
                     else   // existe: es un registro o un numero?
                        if typeRegistro[reg] == "C"  // es un numero?
                           _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                        end   
                        // es un registro o un numero valido y registrado
                        if typeRegistro[reg] == "R" 
                          usedRegs[reg,2]:=.T.
                        end
                        aadd(linea,reg)
                        aadd(numLine,lineaFisica)
                     end
                     ctaIns+=2
                     pLinea:=NULL
                  
                  else
                     // verificar si orden es 247 (true) o 248 (false), para inicializar. 
                     if orden==247 .or. orden==248
                        aadd(registros,pLinea)     // agrego label de registro variable
                        aadd(typeRegistro, "R")    // agrego tipo registro
                        ++ctaReg
                        reg:=ctaReg
                        aadd(usedRegs,{reg,.T.,lineaFisica})
                        aadd(linea,orden)
                        aadd(linea,ctaReg)
                        aadd(numLine,lineaFisica)
                        aadd(numLine,lineaFisica)
                        ctaIns+=2
                     else
                        _Error("invalid argument: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                     end
                  end
               end
               pLinea:=NULL
               exit
            else
               pLinea+=c
            end
         end
         if c==chr(10)
            fseek(fp,nSavePos-1,0); --h_ini
         end   
      else
         _Error("this instruction|function does not need parentheses",lineaFisica)
      end

return

Procedure Procesa_asignacion(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                             usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica)
local Ret:=.T., dato, reg, swString

       pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
       if swLock
          reg:=ascan(registros, pLinea,lock_ini) // busco en locales
         // if reg==0
         //    reg:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
         // end
       else
          reg:=ascan(registros, pLinea)
       end
       if reg==0    // si es nuevo el registro, agregarlo.
          // solo cuando no sea algun tipo de constante.
          if ISTNUMBER(pLinea)!=1   // no es un numero
                if substr(pLinea,1,1)!="["  // no es un dataseg
                   //? "Recipiente = ",pLinea, " ctaReg = ", ctaReg+1
                   aadd(registros,pLinea)     // agrego label de registro variable
                   aadd(typeRegistro, "R")    // agrego tipo registro
                   ++ctaReg
                   reg:=ctaReg
                   aadd(usedRegs,{reg,.F.,lineaFisica})
                else
                   _Error("i need a register instead of: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
          else
             _Error("i need a register instead of: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
          end
       else     // lo encontré: debe ser registro y no constante
          if typeRegistro[reg] != "R"
             _Error("i need a register instead of: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
          end
       end
       // verifico si es una asignación de puntero:
       //? "PLINEA RECIPIENTE = ",pLinea
       orden:=3    // establece orden=LET de registros por default.
       
       fread(fp,@c,1); ++h_ini
       nSavePos := fseek( fp, 0, 1 )
       swPuntero:=.F.
       if c=="="    // puntero!
          //torden:=getFamilia(178)
          aadd(linea,178)
          aadd(numLine,lineaFisica)
          swPuntero:=.T.
          ctaIns++
       elseif c==chr(96)  // es una orden de sistema
          pLinea:='"'
          while c!=chr(10) .and. h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             if c==chr(96)  // cierra
                pLinea+='"'
                exit
             else
                pLinea+=c
             end
          end
          if c==chr(10) .or. h_ini>h_fin
             _Error("macro-system unclosed",lineaFisica)
          end
          ///pLinea:=ISNUMSPECIAL(pLinea,lineafisica)

          if len(pLinea)>0
             if swLock
                dato:=ascan(registros, pLinea,lock_ini) // busco en locales
                if dato==0
                   dato:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                end
             else 
                dato:=ascan(registros, pLinea)
             end
          else
             _Error("macro-system error",lineaFisica)
          end

          aadd(linea,orden+1)
          aadd(linea,reg)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          if dato==0
             aadd(registros,pLinea)     // agrego label de registro variable
             aadd(typeRegistro, "C")    // agrego tipo registro
             ++ctaReg
             aadd(linea,ctaReg)
             aadd(numLine,lineaFisica)
             aadd(usedRegs,{ctaReg,.F.,lineaFisica})
          else
             aadd(linea,dato)
             aadd(numLine,lineaFisica)
             if typeRegistro[dato] == "R" 
                usedRegs[dato,2]:=.T.
             end
          end
          ctaIns+=3
          pLinea:=NULL
          if swPuntero
             if swWarning
                outstd(_CR+"l:"+alltrim(str(lineaFisica))+" - "+chr(27)+"[35mwarning"+chr(27)+"[0m"+": pointer asignment only can be used by array-register."+_CR)
             end
          end
          Ret:=.F.; return Ret ///loop
       else
          fseek(fp,nSavePos-1,0); --h_ini
       end
       
       // busca el dato asignado, y define el tipo de instrucción LET
//       varTmpLinea:=pLinea
//       ?"varTmpLinea=",varTmpLinea
//       swArrayStatic:=.F.
       pLinea:=NULL

       swString:=.F.
  //     ?"--- C=",c
       c:=" "
       while c!=chr(10) .and. c!="}" .and. h_ini<=h_fin
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
           if c==" "
              loop
           elseif c==chr(34)   // es una cte string. debo guardar sin comillas, luego se quitan
              pLinea:=c
              c:=" "
              swString:=.T.
              while c!=chr(10) .and. h_ini<=h_fin// .and. c!=chr(34)
                 fread(fp,@c,1); ++h_ini
                 pLinea+=c
                 if c=="\"
                    //
                    fread(fp,@c,1); ++h_ini
                    pLinea+=c
                 elseif c==chr(34)
                    exit
                 end
              end
              if h_ini>h_fin
                 _Error("(2)string unclosed"+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
              end
           elseif c=="," .or. c==";" ///.or. c=="}"   // debe saltar, para entrar otra vez desde el ciclo central
 //             if !swArrayStatic
                 exit
 //             end
/*
           elseif c=="{"   // puede ser un array nulo, o con datos.
              pLinea+=c
              swArrayStatic:=.T.
           elseif c=="}"
              if swArrayStatic
                 pLinea+=c
              end
*/
           else
              if c!=chr(10)
                 pLinea+=c
              end
           end
        //   ??"--",c
       end
       if c==chr(10) /* MOD 30-11-2021.or. c=="}" */
           fseek(fp,nSavePos-1,0); --h_ini  // debe contar chr(0) para santo de línea.
       end
   // MOD 30-11-2021.  para do { c=1 } falla: "1}". correccion:
   
       if substr(pLinea,len(pLinea),1)=="}"
          fseek(fp,nSavePos-1,0); --h_ini
          pLinea:=substr(pLinea,1,len(pLinea)-1)
          if pLinea=="{"   // es una asignacion de array vacio
             pLinea+="}"
             fseek(fp,nSavePos,0); ++h_ini
          end
       end
   // *********
      // ? "PLINEA ASIGNAO = ",pLinea
       pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
     /*  if ISNOTATION(pLinea) == 1
          ? "PLINEA = ",pLinea
          ? "RESUKTADO= ",FUNE2D(pLinea)
          pLinea := hb_ntos(FUNE2D(pLinea))
          ? "PLINEA = ",pLinea
       end */
       dato:=0
       if len(pLinea)>0

          if swLock
             dato:=ascan(registros, pLinea,lock_ini) // busco en locales
             if dato==0
                dato:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
             end
          else
             dato:=ascan(registros, pLinea)
          end

       end
       if dato==0   // no es un registro existente: puede ser constante o parametro, o inicializacion de algo, nuevo
          if substr(pLinea,1,1)!=chr(34)  // no es un string
             if ISTNUMBER(pLinea)!=1   // no es un numero
                if substr(pLinea,1,1)=="["  // es un dataseg
                   pLinea:=strtran(pLinea,"[","")
                   pLinea:=strtran(pLinea,"]","")
                   pLinea:=ISNUMSPECIAL(pLinea,lineafisica)

                   aadd(linea,orden+2)
                   aadd(linea,reg)
                   aadd(numLine,lineaFisica)
                   aadd(numLine,lineaFisica)
                   if swLock
                      reg:=ascan(registros, pLinea,lock_ini) // busco en locales
                      if reg==0
                         reg:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                      end
                   else
                      reg := ascan(registros, pLinea)
                   end
                   // pLinea debe ser numero o registro
                   if reg==0   // no está registrado. hay que registrarlo, si es un numero.
                      if ISTNUMBER(pLinea)==1
                         aadd(registros,pLinea)     // agrego label de registro variable
                         aadd(typeRegistro, "N")    // agrego tipo registro
                         ++ctaReg
                         aadd(linea,ctaReg)
                         aadd(numLine,lineaFisica)
                         aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                      else
                         _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                      end
                   else   // existe: es un registro o un numero?
                      if typeRegistro[reg] == "C" // no es un numero? no es un registro
                         _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                      end   
                      // es un registro o un numero valido y registrado
                      aadd(linea,reg)
                      aadd(numLine,lineaFisica)
                      if typeRegistro[reg] == "R" 
                         usedRegs[reg,2]:=.T.
                      end
                   end

                   ctaIns+=3
                   pLinea:=NULL
                   if swPuntero
                      if swWarning
                         outstd(_CR+"l:"+alltrim(str(lineaFisica))+" - "+chr(27)+"[35mwarning"+chr(27)+"[0m"+": pointer asignment only can be used by array-register"+_CR)
                      end
                   end
                elseif substr(pLinea,1,1)=="{"   // es un array inicializado
                 //  ?"pLINEA=",pLinea
                 //  if substr(pLinea,2,1)=="}"
                      pLinea:=strtran(pLinea,"{","")
                      pLinea:=strtran(pLinea,"}","")
                      //torden:=getFamilia(205)
                      //aadd(linea,205)
                      aadd(linea,320)
                      aadd(linea,reg)
                      aadd(numLine,lineaFisica)
                      aadd(numLine,lineaFisica)
                      ctaIns+=2
                      pLinea:=NULL
                      if swPuntero
                         if swWarning
                            outstd(_CR+"l:"+alltrim(str(lineaFisica))+" - "+chr(27)+"[35mwarning"+chr(27)+"[0m"+": pointer asignment only can be used by array-register"+_CR)
                         end
                      end
                /*   else   // deberá ser un array de addrow
                      pLinea:=strtran(pLinea,"{","")
                      pLinea:=strtran(pLinea,"}","")
                      aadd(linea,)
                      
                      // rescatar elementos para push
                      aadd(linea,)
                      aadd(linea,)
                      aadd(linea,)
                      aadd(linea,216)   // addrow
                      ///_Error("register not initialized: "+GenMsg(pLinea),lineaFisica)
                   end*/
                else
                   _Error("register not initialized!: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else   // es una constante numerica:
                // añadirlo a registros:
                aadd(registros,pLinea)     // agrego label de registro variable
                aadd(typeRegistro, "N")    // agrego tipo registro
                ++ctaReg
                aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                //torden:=getFamilia(orden)
                aadd(linea,orden)
                aadd(linea,reg)
                aadd(linea,ctaReg)
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                ctaIns+=3
                pLinea:=NULL
                if swPuntero
                   if swWarning
                      outstd(_CR+"l:"+alltrim(str(lineaFisica))+" - "+chr(27)+"[35mwarning"+chr(27)+"[0m"+": pointer asignment only can be used by array-register"+_CR)
                   end
                end
             end
          else  // es un string

             swString:=.F.
             aadd(registros,pLinea)     // agrego label de registro variable
             aadd(typeRegistro, "C")    // agrego tipo registro
             ++ctaReg
             aadd(usedRegs,{ctaReg,.F.,lineaFisica})
             //torden:=getFamilia(orden)
             aadd(linea,orden)
             aadd(linea,reg)
             aadd(linea,ctaReg)
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             
             ctaIns+=3
             pLinea:=NULL
             if swPuntero
                if swWarning
                   outstd(_CR+"l:"+alltrim(str(lineaFisica))+" - "+chr(27)+"[35mwarning"+chr(27)+"[0m"+": pointer asignment only can be used by array-register"+_CR)
                end
             end
          end
       else   // es un registro o constante. Es asignado, luego, no hay que hacer nada nuevo.
          swString:=.F.
          //torden:=getFamilia(orden)
          aadd(linea,orden)
          aadd(linea,reg)
          aadd(linea,dato)
          if typeRegistro[dato] == "R" 
             usedRegs[dato,2]:=.T.
          end
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)

          ctaIns+=3
          pLinea:=NULL
       end

return Ret

Procedure Procesa_swap_de_registros(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                                    usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica,swNoEsSwap)
local pString,nSavePos,orden,reg,reg1, Ret:=.T.

       // pLinea contiene una variable.
       pString:=c
       fread(fp,@c,1); ++h_ini       // "-"
       nSavePos := fseek( fp, 0, 1 )
       pString+=c
       fread(fp,@c,1); ++h_ini       // "<"
       nSavePos := fseek( fp, 0, 1 )
       pString+=c
       if pString!="<->"  // puede ser reg <<= n...
          fseek(fp,nSavePos-2,0); h_ini-=2  // debiera volver a "<" dentro del archivo.
          pString:=NULL
          swNoEsSwap:=.T.
          Ret:=.F.; return Ret ///loop
          //_Error("simbol not recognized: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
       else
          if len(pLinea)>0
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] != "R"
                   _Error("(<->)I need an initialized register here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(<->)I need an initialized register here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg0 <-> reg1"+chr(27)+"[0m"),lineaFisica) 
          end
       end
       pLinea:=NULL
       usedRegs[reg,2]:=.T.  // habilito primer registro usado
       pString:=NULL  // busco segundo registro
       while h_ini<=h_fin .and. c!=chr(10)
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             if c==" "; loop; end
             if c!=chr(10)
                pString+=c
             end
       end
       if c==chr(10)
          fseek(fp,nSavePos-1,0); --h_ini
       end
       if len(pString)>0
             if swLock
                reg1:=ascan(registros, pString,lock_ini)
                if reg1==0
                   reg1:=ascan(registros, pString, 1, unlock_to)
                end
             else
                reg1:=ascan(registros, pString)
             end
             if reg1>0
                if typeRegistro[reg1] != "R"
                   _Error("(<->)I need an initialized register here: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(<->)I need an initialized register here: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica) 
             end
       else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg0 <-> reg1"+chr(27)+"[0m"),lineaFisica) 
       end
       // armo la cadena a ejecutar:
       usedRegs[reg1,2]:=.T.   // habilito segundo registro usado

       aadd(linea,341)   // swap
       aadd(linea,reg)       
       aadd(linea,reg1)
       aadd(numLine,lineaFisica)
       aadd(numLine,lineaFisica)
       aadd(numLine,lineaFisica)
       ctaIns+=3

return Ret

Procedure Procesa_mul_operador_especial(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                                        usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica)
local dato, reg, nSavePos,pString,orden

       fread(fp,@c,1); ++h_ini
       nSavePos := fseek( fp, 0, 1 )
       if c=="="   // una asignación  V*=n
          pString:=NULL
          while h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             if c==" "; loop; end
             if is_noall(c,chr(10),",","[","{","(","'")
                pString+=c
             else
                exit
             end
          end
          fseek(fp,nSavePos-1,0); --h_ini
          // analizar pLinea y operando 2:
          orden:=305   // un código unico para todos los opcode de operación.
          if len(pLinea)>0
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] $ "CN"
                   _Error("register not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(*=)register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg-=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end

          usedRegs[reg,2]:=.T.

          aadd(linea,orden)
          aadd(linea,1)       // 1="*"
          aadd(linea,reg)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          ctaIns+=3
          if len(pString)>0
             pString:=ISNUMSPECIAL(pString,lineafisica)
            /* if ISNOTATION(pString) == 1
                pString := alltrim(str(FUNE2D(pString)))
             end */
             if swLock
                reg:=ascan(registros, pString,lock_ini)
                if reg==0
                   reg:=ascan(registros, pString, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pString)
             end
             if reg>0
                if typeRegistro[reg] == "C"
                   _Error("argument error: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                end
                dato:=reg
             else
                if ISTNUMBER(pString)!=1   // no es un número?
                   _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                else
                   // añade el numero a registros
                   aadd(registros,pString)     // agrego label de registro variable
                   aadd(typeRegistro, "N")    // agrego tipo registro
                   ++ctaReg
                   dato:=ctaReg
                   aadd(usedRegs,{dato,.F.,lineaFisica})
                end
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg*=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end
          if typeRegistro[dato] == "R" 
             usedRegs[dato,2]:=.T.
          end
          aadd(linea,dato)
          aadd(numLine,lineaFisica)
          ctaIns++
          pLinea:=NULL
          pString:=NULL
       else
          pLinea+="*"+c
       end       

return

Procedure Procesa_operador_especial(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                                    usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica,swNoEsSwap)
local pString, localOpcode, nSavePos, orden
       if c=="<"
          swNoEsSwap:=.F.  // ya sé que viene de arriba, porque no entraría aquí si no fuese así.
       end
       localOpcode:=c
       fread(fp,@c,1); ++h_ini
       nSavePos := fseek( fp, 0, 1 )
       if c=="<" .or. c==">"
          fread(fp,@c,1); ++h_ini         // siguiente debe ser "="
          nSavePos := fseek( fp, 0, 1 )
       end   
       if c=="="   // una asignación  VX=n
          pString:=NULL
          while h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             if c==" "; loop; end
             if is_noall(c,chr(10),",","[","{","(","'")
                pString+=c
             else
                exit
             end
          end
          fseek(fp,nSavePos-1,0); --h_ini
          // analizar pLinea y operando 2:
          orden:=305   // un código unico para todos los opcode de operación.
          if len(pLinea)>0
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] $ "CN"
                   _Error("register not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(<ope>=)register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg-=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end

          usedRegs[reg,2]:=.T.

          aadd(linea,orden)
          switch(asc(localOpcode))
             case 47/*"/"*/ ; aadd(linea,2) ; exit      // 1="OPE"
             case 92/*"\"*/ ; aadd(linea,3) ; exit
             case 94/*"^"*/ ; aadd(linea,4) ; exit
             case 37/*"%"*/ ; aadd(linea,5) ; exit
             case 62/*">"*/ ; aadd(linea,6) ; exit
             case 60/*"<"*/ ; aadd(linea,7) ; exit
             case 124/*"|"*/ ; aadd(linea,8) ; exit
             case 38/*"&"*/ ; aadd(linea,9) ; exit
             case 33/*"!"*/ ; aadd(linea,10) ; exit
             otherwise
                 _Error("unknowed symbol: "+GenMsg(chr(27)+"[1m"+localOpcode+chr(27)+"[0m"),lineaFisica)
          end
          aadd(linea,reg)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          ctaIns+=3
          if len(pString)>0
             pString:=ISNUMSPECIAL(pString,lineafisica)
            /* if ISNOTATION(pString) == 1
                pString := alltrim(str(FUNE2D(pString)))
             end */
             if swLock
                reg:=ascan(registros, pString,lock_ini)
                if reg==0
                   reg:=ascan(registros, pString, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pString)
             end
             if reg>0
                if typeRegistro[reg] == "C"
                   _Error("argument error: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                end
                dato:=reg
             else
                if ISTNUMBER(pString)!=1   // no es un número?
                   _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                else
                   // añade el numero a registros
                   aadd(registros,pString)     // agrego label de registro variable
                   aadd(typeRegistro, "N")    // agrego tipo registro
                   ++ctaReg
                   dato:=ctaReg
                   aadd(usedRegs,{dato,.F.,lineaFisica})
                end
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg*=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end
          if typeRegistro[dato] == "R" 
             usedRegs[dato,2]:=.T.
          end
          aadd(linea,dato)
          aadd(numLine,lineaFisica)
          ctaIns++
          pLinea:=NULL
          pString:=NULL

       else
          pLinea+="*"+c
       end       

return

Procedure Procesa_incremento_de_variable(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                                         usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica)

local reg, dato, pString,orden

       fread(fp,@c,1); ++h_ini
       nSavePos := fseek( fp, 0, 1 )
       if c=="+"   // es INC
          orden:=202
          if len(pLinea)>0  // VAR++
             // pLinea:=ISNUMSPECIAL(pLinea,lineafisica)   es un registro!!!
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else   
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] $ "CN"
                   _Error("i need a register here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
               /* ? "UNLOCK_TO = ",unlock_to
                ? "LOCK_INI  = ",lock_ini
                for jjj:=1 to len(registros)
                   ? "REG = ",registros[jjj]," POS = ",jjj, iif(jjj==lock_ini," --- LOCAL"," --- GLOBAL")
                end */
                _Error("("+pLinea+"++)register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
             usedRegs[reg,2]:=.T.
             pLinea:=NULL
             aadd(linea,1)        // push de registro. mete el registro al stack antes de ser usado
             aadd(linea,reg)      // registro
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             aadd(linea,orden)    // incremento
             aadd(linea,reg)      //  registro
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             ctaIns+=4
          else  // ++VAR: buscar la variable, añadirla al stack y luego incrementar
             //_Error("command must be: "+GenMsg("reg++"),lineaFisica) 
             pLinea:=""
             while h_ini<=h_fin
                fread(fp,@c,1); ++h_ini
                nSavePos := fseek( fp, 0, 1 )
                
                if c==" "; loop; end
                if is_noall(c,chr(10),",","[","{","(",";","}","]",")")
                   pLinea+=c
                else
                   exit
                end
             end
             fseek(fp,nSavePos-1,0); --h_ini
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else   
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] $ "CN"
                   _Error("i need a register here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(++"+pLinea+")register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
             usedRegs[reg,2]:=.T.
             pLinea:=NULL
             aadd(linea,orden)    // incremento
             aadd(linea,reg)      //  registro
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             ctaIns+=2

          end
//          usedRegs[reg,2]:=.T.
//          pLinea:=NULL

//          aadd(linea,orden)
//          aadd(linea,reg)
//          aadd(numLine,lineaFisica)
//          aadd(numLine,lineaFisica)
//          ctaIns+=2
       elseif c=="="   // puede ser REG+=n
          pString:=NULL
          while /*is_noall(c,chr(10)," ",",","[","{").and.*/h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             if c==" "; loop; end
             if is_noall(c,chr(10),",","[","{","(",";","}","]",")")
                pString+=c
             else
                exit
             end
          end
        //  if c==chr(10)
             fseek(fp,nSavePos-1,0); --h_ini
        //  end
          // analizar pLinea e incrementador:
          orden:=207
          if len(pLinea)>0
             // pLinea:=ISNUMSPECIAL(pLinea,lineafisica)   es un registro!!!
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] $ "CN"
                   _Error("register not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(+=)register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
          else
             _Error("command must be: "+ GenMsg(chr(27)+"[1m"+"reg+=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end
          usedRegs[reg,2]:=.T.
          aadd(linea,orden)
          aadd(linea,reg)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          ctaIns+=2
          if len(pString)>0
             pString:=ISNUMSPECIAL(pString,lineafisica)
            /* if ISNOTATION(pString) == 1
                pString := alltrim(str(FUNE2D(pString)))
             end */
             if swLock
                reg:=ascan(registros, pString,lock_ini)
                if reg==0
                   reg:=ascan(registros, pString, 1, unlock_to)
                end
             else  
                reg:=ascan(registros, pString)
             end
             if reg>0
                if typeRegistro[reg] == "C"
                   _Error("argument error: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                end
                dato:=reg
             else
                if ISTNUMBER(pString)!=1   // no es un número?
                   _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                else
                   // añade el numero a registros
                   aadd(registros,pString)     // agrego label de registro variable
                   aadd(typeRegistro, "N")    // agrego tipo registro
                   ++ctaReg
                   dato:=ctaReg
                   aadd(usedRegs,{dato,.F.,lineaFisica})
                end
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg+=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end
          if typeRegistro[dato] == "R" 
             usedRegs[dato,2]:=.T.
          end
          aadd(linea,dato)
          aadd(numLine,lineaFisica)
          ctaIns++
          pLinea:=NULL
          pString:=NULL
       else
          _Error("unknowed symbol: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m"),lineaFisica)
       end

return

Procedure Procesa_decremento_de_variable(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                                         usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica)
local dato, pString, reg, orden

       fread(fp,@c,1); ++h_ini
       nSavePos := fseek( fp, 0, 1 )
       if c=="-"   // es DEC
          orden:=203
          if len(pLinea)>0
            // pLinea:=ISNUMSPECIAL(pLinea,lineafisica)  es un registro!!!
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pLinea)
             end
             if reg>0   // existe. ver si es un registro o una constante
                if typeRegistro[reg] $ "CN"
                   _Error("i need a register here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("("+pLinea+"--)register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
             end
             usedRegs[reg,2]:=.T.
             pLinea:=NULL
             aadd(linea,1)        // push de registro. mete el registro al stack antes de ser usado
             aadd(linea,reg)      // registro
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             aadd(linea,orden)    // decremento
             aadd(linea,reg)      //  registro
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             ctaIns+=4
          else
             //_Error("command must be: "+GenMsg("reg--"),lineaFisica) 
             pLinea:=""
             while h_ini<=h_fin
                fread(fp,@c,1); ++h_ini
                nSavePos := fseek( fp, 0, 1 )
                
                if c==" "; loop; end
                if is_noall(c,chr(10),",","[","{","(",";","}","]",")")
                   pLinea+=c
                else
                   exit
                end
             end
             fseek(fp,nSavePos-1,0); --h_ini
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else   
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] $ "CN"
                   _Error("i need a register here: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(--"+pLinea+")register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
             usedRegs[reg,2]:=.T.
             pLinea:=NULL
             aadd(linea,orden)    // incremento
             aadd(linea,reg)      //  registro
             aadd(numLine,lineaFisica)
             aadd(numLine,lineaFisica)
             ctaIns+=2
          end
//          pLinea:=NULL          
//          usedRegs[reg,2]:=.T.        
//          aadd(linea,orden)
//          aadd(linea,reg)
//          aadd(numLine,lineaFisica)
//          aadd(numLine,lineaFisica)
//          ctaIns+=2
       elseif c=="="   // puede ser REG+=n
          pString:=NULL
          while /*is_noall(c,chr(10)," ",",","[","{").and.*/h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )
             if c==" "; loop; end
             if is_noall(c,chr(10),",","[","{","(",";","}","]",")")
                pString+=c
             else
                exit
             end
          end
         // if c==chr(10)
             fseek(fp,nSavePos-1,0); --h_ini
         // end
          // analizar pLinea y decrementador:
          orden:=209
          if len(pLinea)>0
             if swLock
                reg:=ascan(registros, pLinea,lock_ini)
                if reg==0
                   reg:=ascan(registros, pLinea, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pLinea)
             end
             if reg>0
                if typeRegistro[reg] $ "CN"
                   _Error("register not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             else
                _Error("(-=)register not initialized "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica) 
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg-=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end

             usedRegs[reg,2]:=.T.

          aadd(linea,orden)
          aadd(linea,reg)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)
          ctaIns+=2
          if len(pString)>0
             pString:=ISNUMSPECIAL(pString,lineafisica)
            /* if ISNOTATION(pString) == 1
                pString := alltrim(str(FUNE2D(pString)))
             end */
             if swLock
                reg:=ascan(registros, pString,lock_ini)
                if reg==0
                   reg:=ascan(registros, pString, 1, unlock_to)
                end
             else
                reg:=ascan(registros, pString)
             end
             if reg>0
                if typeRegistro[reg] == "C"
                   _Error("argument error: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                end
                dato:=reg
             else
                if ISTNUMBER(pString)!=1   // no es un número?
                   _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                else
                   // añade el numero a registros
                   aadd(registros,pString)     // agrego label de registro variable
                   aadd(typeRegistro, "N")    // agrego tipo registro
                   ++ctaReg
                   dato:=ctaReg
                   aadd(usedRegs,{dato,.F.,lineaFisica})
                end
             end
          else
             _Error("command must be: "+GenMsg(chr(27)+"[1m"+"reg+=reg|const-num"+chr(27)+"[0m"),lineaFisica) 
          end
          if typeRegistro[dato] == "R" 
             usedRegs[dato,2]:=.T.
          end
          aadd(linea,dato)
          aadd(numLine,lineaFisica)
          ctaIns++
          pLinea:=NULL
          pString:=NULL

       else
          _Error("unknowed symbol: "+GenMsg(chr(27)+"[1m"+c+chr(27)+"[0m"),lineaFisica)
       end

return

Procedure Procesa_rangos_array(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                               usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica)
local coords, ctaCoord,swFinalBrag,nSavePos,dato,dInfinito,offset

       // semejante a 206
       //? "ENTRA AQUI"
       coords:={-1,-1,-1}
       //swTipo:={.F.,.F.,.F.}
       ctaCoord:=0
       //swoffset:={.F.,.F.,.F.}
       offset:={0,0,0}
//       swInterval:=.F.
//       interval:={0,0,0}
       
       swFinalBrag:=.F.

       while c!=chr(10) .and. h_ini<=h_fin
          fread(fp,@c,1); ++h_ini
          nSavePos := fseek( fp, 0, 1 )
          
          if c==" "
             loop
          elseif c=="," .or. c==";" .or. (c=="]" .and. !swFinalBrag) // buscar registro.
             ++ctaCoord
             if ctaCoord>3
                _Error("dimension error",lineaFisica)
             end 
             if pLinea=="_end_"
                dInfinito:=ascan(registros, "999999999")  // busco en todo: una cte es unica
                if dInfinito>0
                   coords[ctaCoord]:=dInfinito
                else
                   aadd(registros,"999999999")     // agrego label de registro variable
                   aadd(typeRegistro, "N")    // agrego tipo registro
                   ++ctaReg
                   coords[ctaCoord]:=ctaReg   // infinito imaginario de "end"
                   aadd(usedRegs,{ctaReg,.F.,lineaFisica}) 
                end
                //swTipo[ctaCoord]:=.T.
             else
                pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
                if swLock
                   dato:=ascan(registros, pLinea,lock_ini) // busco en locales
                   if dato==0
                      dato:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                   end
                else  
                   dato:=ascan(registros, pLinea)
                end
                if dato==0      // no está registrado ni como cte ni como registro
                   
                   if ISTNUMBER(pLinea)!=1   // no es un número?
                      _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   else
                      // añade el numero a registros
                      aadd(registros,pLinea)     // agrego label de registro variable
                      aadd(typeRegistro, "N")    // agrego tipo registro
                      ++ctaReg
                      //swTipo[ctaCoord]:=.T.  // es una cte.
                      dato:=ctaReg
                      aadd(usedRegs,{dato,.F.,lineaFisica})
                   end
                else   // ver si no se trata de un string
                   
                   if typeRegistro[dato] == "C"
                      _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   end
                end
                coords[ctaCoord]:=dato
                reg:=dato
                if typeRegistro[dato] == "R" 
                   usedRegs[dato,2]:=.T.
                end
             end
             pLinea:=NULL
             if c=="]"
                fseek(fp,nSavePos-1,0); --h_ini
                swFinalBrag:=.T.
             end
          elseif c==":"  // es un offset
             
             // cuento primero el registro inicial, y luego obtengo el desplazamiento.
             // se repite el código para c==","
                ++ctaCoord
                if ctaCoord>3
                   _Error("dimension error",lineaFisica)
                end 

             if pLinea=="_end_"
                dInfinito:=ascan(registros, "999999999")
                if dInfinito>0
                   coords[ctaCoord]:=dInfinito
                else
                   aadd(registros,"999999999")     // agrego label de registro variable
                   aadd(typeRegistro, "N")    // agrego tipo registro
                   ++ctaReg
                   coords[ctaCoord]:=ctaReg   // infinito imaginario de "end"
                   aadd(usedRegs,{ctaReg,.F.,lineaFisica}) 
                end
                //swTipo[ctaCoord]:=.T.
             else
                pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
                if swLock
                   dato:=ascan(registros, pLinea,lock_ini) // busco en locales
                   if dato==0
                      dato:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                   end
                else
                   dato:=ascan(registros, pLinea)
                end
                if dato==0
                   //? "DENTRO = ",pLinea
                   if ISTNUMBER(pLinea)!=1   // busca lo asignado
                      _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   else
                      aadd(registros,pLinea)     // agrego label de registro variable
                      aadd(typeRegistro, "N")    // agrego tipo registro
                      ++ctaReg
                      //swTipo[ctaCoord]:=.T.  // es una cte.
                      dato:=ctaReg
                      aadd(usedRegs,{dato,.F.,lineaFisica})
                   end
                else   // debo verificar que sea registro o numero
                   if typeRegistro[dato] == "C"
                      _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   end
                end
                coords[ctaCoord]:=dato
              //  ? "DATO=",coords[ctaCoord]
                reg:=dato
                if typeRegistro[dato] == "R" 
                   usedRegs[dato,2]:=.T.
                end
             end
             
             pLinea:=NULL
             // busco offset. Debo dejar asignacion en bruto, porque asigno después
             c:=" "
             swBasta:=.F.
             while c!=chr(10) .and. h_ini<=h_fin// .and. c!=chr(34)
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )

                 if c==" "; loop; end
                 if c=="," .or. c=="]"  // lo suelto
                     swBasta:=.T.
                     exit
                 end
                 pLinea+=c
             end
             if !swBasta
                 _Error("offset error: range array not closed",lineaFisica)
             end

             if pLinea=="_end_"
                dInfinito:=ascan(registros, "999999999")
                if dInfinito>0
                   offset[ctaCoord]:=dInfinito
                else
                   aadd(registros,"999999999")     // agrego label de registro variable
                   aadd(typeRegistro, "N")    // agrego tipo registro
                   ++ctaReg
                   offset[ctaCoord]:=ctaReg   // infinito imaginario de "end"
                   aadd(usedRegs,{ctaReg,.F.,lineaFisica})  
                end

             else
                pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
                if swLock
                   dato:=ascan(registros, pLinea,lock_ini) // busco en locales
                   if dato==0
                      dato:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                   end
                else
                   dato:=ascan(registros, pLinea)
                end
                if dato==0
                   if ISTNUMBER(pLinea)!=1   // busca lo asignado
                      _Error("register or constant not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   else
                      aadd(registros,pLinea)     // agrego label de registro variable
                      aadd(typeRegistro, "N")    // agrego tipo registro
                      ++ctaReg
                         offset[ctaCoord]:=ctaReg
                      aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                   end
                else  // verificar que sea registro o numero
                   if typeRegistro[dato] == "C"
                      _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   end
                      offset[ctaCoord]:=dato
                   //swoffset[ctaCoord]:=.T.  // es un reg.
                   if typeRegistro[dato] == "R" 
                      usedRegs[dato,2]:=.T.
                   end
                end
             end
          //   ? "OFFSET=",offset[ctaCoord], " C=",c
             pLinea:=NULL
             if c=="]"
                fseek(fp,nSavePos-1,0); --h_ini
                swFinalBrag:=.T.
             end
          elseif c=="]"   //
             // busco ceros para añadirlos a registros:
             
             // analizo marcas para offset
             switch(ctaCoord)
             case 1
               /// torden:=getFamilia(212)
                aadd(linea,212)
                aadd(linea,coords[ctaCoord])
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                ctaIns+=2
                // veo offset
                if offset[ctaCoord]>0
                   //torden:=getFamilia(0)
                   aadd(linea,0)
                   aadd(linea,offset[ctaCoord])
                   aadd(linea,146)
                   aadd(numLine,lineaFisica)
                   aadd(numLine,lineaFisica)
                   aadd(numLine,lineaFisica)
                   ctaIns+=3
                end
                pLinea:=NULL 
                exit

             case 2
                ///torden:=getFamilia(208)
                aadd(linea,208)
                //aadd(linea,coords[1])
                //aadd(linea,coords[2])
                aadd(linea,coords[2]) // cambia con el cambio de orientación de las coordenadas
                aadd(linea,coords[1])
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                ctaIns+=3
                // veo offset
                if offset[1]>0 .or. offset[2]>0
                   //torden:=getFamilia(0)
                   aadd(linea,0)
                   aadd(numLine,lineaFisica)
                   //if offset[2]>0   // offset ya está registrado.
                   if offset[1]>0
                      //aadd(linea,offset[2])
                      aadd(linea,offset[1])
                      aadd(numLine,lineaFisica)
                   else  // es cero, registrarlo si no está registrado:
                      //pLinea:=alltrim(str(offset[2]))
                      pLinea:=alltrim(str(offset[1]))
                      if swLock
                         dOffset:=ascan(registros, pLinea,lock_ini) // busco en locales
                         if dOffset==0
                            dOffset:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                         end
                      else
                         dOffset:=ascan(registros, pLinea)
                      end
                      if dOffset==0
                         aadd(registros,pLinea)     // agrego label de registro variable
                         aadd(typeRegistro, "N")         // agrego tipo registro
                         ++ctaReg
                         aadd(linea,ctaReg)
                         aadd(numLine,lineaFisica)
                         aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                      else
                         aadd(linea,dOffset)
                         aadd(numLine,lineaFisica)
                         if typeRegistro[dOffset] == "R" 
                            usedRegs[dOffset,2]:=.T.
                         end
                      end                           
                   end
                   ///torden:=getFamilia(0)
                   aadd(linea,0)
                   aadd(numLine,lineaFisica)
                   //if offset[1]>0
                   if offset[2]>0
                      //aadd(linea,offset[1])
                      aadd(linea,offset[2])
                      aadd(numLine,lineaFisica)
                   else
                      //pLinea:=alltrim(str(offset[1]))
                      pLinea:=alltrim(str(offset[2]))
                      if swLock
                         dOffset:=ascan(registros, pLinea,lock_ini) // busco en locales
                         if dOffset==0
                            dOffset:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                         end
                      else
                         dOffset:=ascan(registros, pLinea)
                      end
                      if dOffset==0
                         aadd(registros,pLinea)     // agrego label de registro variable
                         aadd(typeRegistro, "N")         // agrego tipo registro
                         ++ctaReg
                         aadd(linea,ctaReg)
                         aadd(numLine,lineaFisica)
                         aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                      else
                         aadd(linea,dOffset)
                         aadd(numLine,lineaFisica)
                         if typeRegistro[dOffset] == "R" 
                            usedRegs[dOffset,2]:=.T.
                         end
                      end
                   end
                   //torden:=getFamilia(177)
                   aadd(linea,177)
                   aadd(numLine,lineaFisica)
                   ctaIns+=5
                end
                pLinea:=NULL 
                exit

             case 3
                //torden:=getFamilia(212)
                aadd(linea,212)
                aadd(linea,coords[3])
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                ctaIns+=2
                // veo offset
                if offset[3]>0
                   //torden:=getFamilia(0)
                   aadd(linea,0)
                   aadd(linea,offset[3])
                   ///torden:=getFamilia(146)
                   aadd(linea,146)
                   aadd(numLine,lineaFisica)
                   aadd(numLine,lineaFisica)
                   aadd(numLine,lineaFisica)
                   ctaIns+=3
                end
                //torden:=getFamilia(208)
                aadd(linea,208)
                //aadd(linea,coords[1])
                //aadd(linea,coords[2])
                aadd(linea,coords[2])
                aadd(linea,coords[1])
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                aadd(numLine,lineaFisica)
                ctaIns+=3
                // veo offset
                if offset[1]>0 .or. offset[2]>0
                   //torden:=getFamilia(0)
                   aadd(linea,0)
                   aadd(numLine,lineaFisica)
                  // if offset[2]>0   // offset ya está registrado.
                  //    aadd(linea,offset[2])
                   if offset[1]>0   // offset ya está registrado.
                      aadd(linea,offset[1])
                      aadd(numLine,lineaFisica)
                   else  // es cero, registrarlo si no está registrado:
                      //pLinea:=alltrim(str(offset[2]))
                      pLinea:=alltrim(str(offset[1]))
                      if swLock
                         dOffset:=ascan(registros, pLinea,lock_ini) // busco en locales
                         if dOffset==0
                            dOffset:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                         end
                      else
                         dOffset:=ascan(registros, pLinea)
                      end
                      if dOffset==0
                         aadd(registros,pLinea)     // agrego label de registro variable
                         aadd(typeRegistro, "N")         // agrego tipo registro
                         ++ctaReg
                         aadd(linea,ctaReg)
                         aadd(numLine,lineaFisica)
                         aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                      else
                         aadd(linea,dOffset)
                         aadd(numLine,lineaFisica)
                         if typeRegistro[dOffset] == "R" 
                            usedRegs[dOffset,2]:=.T.
                         end
                      end                           
                   end

                   //torden:=getFamilia(0)
                   aadd(linea,0)
                   aadd(numLine,lineaFisica)
                   //if offset[1]>0
                   //   aadd(linea,offset[1])
                   if offset[2]>0
                      aadd(linea,offset[2])
                      aadd(numLine,lineaFisica)
                   else
                      //pLinea:=alltrim(str(offset[1]))
                      pLinea:=alltrim(str(offset[2]))
                      if swLock
                         dOffset:=ascan(registros, pLinea,lock_ini) // busco en locales
                         if dOffset==0
                            dOffset:=ascan(registros, pLinea, 1, unlock_to) // busco en globales
                         end
                      else
                         dOffset:=ascan(registros, pLinea)
                      end
                      if dOffset==0
                         aadd(registros,pLinea)     // agrego label de registro variable
                         aadd(typeRegistro, "N")         // agrego tipo registro
                         ++ctaReg
                         aadd(linea,ctaReg)
                         aadd(numLine,lineaFisica)
                         aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                      else
                         aadd(linea,dOffset)
                         aadd(numLine,lineaFisica)
                         if typeRegistro[dOffset] == "R" 
                            usedRegs[dOffset,2]:=.T.
                         end
                      end
                   end
                   //torden:=getFamilia(177)
                   aadd(linea,177)
                   aadd(numLine,lineaFisica)
                   ctaIns+=5
                end
                pLinea:=NULL 
                exit
             otherwise
                _Error("dimension error",lineaFisica)
             end                          
             exit

          else
             pLinea+=c
          end 
          
       end
       if c==chr(10)
          fseek(fp,nSavePos-1,0); --h_ini
       end

Return

Procedure Procesa_DO(pLinea,linea,numLine,nPhantom,phantomLabels,ctaIns,lineaFisica)
local labelPhantom
          // genera etiqueta fantasma:
          nPhantom++
          labelPhantom := alltrim(str(int(hb_random()*1000000000))) 
          stackpush(phantomLabels, labelPhantom)
          labelPhantom := "____CODE__JUMP____"+labelPhantom
          /////torden:=getFamilia(14)
          aadd(linea,14)
          aadd(linea,labelPhantom)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)

          ctaIns+=2
          pLinea:=NULL
return

Procedure Procesa_CASE(pLinea,linea,numLine,nPhantom,phantomLabels,ctaIns,lineaFisica)
local labelPhantom
          labelPhantom := alltrim(str(int(hb_random()*1000000000))) 
          stackpush(phantomLabels, labelPhantom)
          labelPhantom := "____CODE__JUMP____"+labelPhantom
          ////torden:=getFamilia(50)
          aadd(linea,50)
          aadd(linea,labelPhantom)
          aadd(numLine,lineaFisica)
          aadd(numLine,lineaFisica)

          ctaIns+=2
          pLinea:=NULL
return
Procedure Procesa_una_huea_que_no_recuerdo(pLinea,ctaIns,linea,numLine,swLock,lock_ini,registros,;
                                           instrucc,phantomLabels,labels,nPhantom,ctaLabels,swRet,lineaFisica)
local i,orden,ctaRep,rep
       
       if len(pLinea)>0
                ctaRep:=1
                rep:=substr(pLinea,1,1)
                while rep=="*" //isdigit(rep)
                   ++ctaRep
                   pLinea:=substr(pLinea,2,len(pLinea))
                   rep:=substr(pLinea,1,1)
                end

                // buscar en instrucc
                if swLock  // dentro de locals
                   if pLinea=="back" .or. pLinea=="aback"
                      if ctaRep>1
                         _Error("low-level instruction BACK|ABACK must be unique",lineaFisica)
                      else
                        // ? "(10)lock_ini original = ",lock_ini
                         if pLinea=="back"
                            lock_ini:=len(registros)+1  // desde donde busca variables dentro de un bloque
                         else
                            pLinea:="back"
                         end
                      end
                  /* elseif pLinea=="nop"  // evita warning
                      */
                   end
                else
                   if pLinea=="back" .or. pLinea=="aback"
                      if swWarning
                         /*fwrite(1,"Line: "+alltrim(str(lineaFisica))+" => warning: "+GenMsg("back")+" detected but not set "+GenMsg(".locals")+_CR)
                         fwrite(1," ---> (if this warning occurs before "+GenMsg(".locals")+", skip this warning)"+_CR)*/
                         printmsg("Line: "+alltrim(str(lineaFisica))+" => "+chr(27)+"[35mwarning"+chr(27)+"[0m: " +GenMsg(chr(27)+"[1mback"+chr(27)+"[0m")+" detected but not set "+GenMsg(chr(27)+"[1m .locals"+chr(27)+"[0m")+_CR)
                         printmsg(" ---> (if this warning occurs before "+GenMsg(chr(27)+"[1m .locals"+chr(27)+"[0m")+", skip this warning)"+_CR)
                      end
                   end
                   if pLinea=="aback"
                      pLinea:="back"
                   end
                end
                orden := hb_HGetDef( instrucc, pLinea, -1 )
                if orden==-1
                   _Error("low-level instruction not recognized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
                for i:=1 to ctaRep
                   aadd(linea,orden)
                   aadd(numLine,lineaFisica)
                   ++ctaIns
                end
                if orden==136
                   if ctaRep==1
                      swRet:=.T.
                   else
                      _Error("duplicated instruction: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   end
                end       
       end
       pLinea:=NULL

       // continua revisando el labelPhanthom:
       labelPhantom:=stackpop(phantomLabels)
       if labelPhantom==NIL
          _Error(GenMsg(chr(27)+"[1m"+"{}"+chr(27)+"[0m")+" OR INSTRUCTION BAD FORMED",lineaFisica)
       end
       --nPhantom
       hb_hset(labels,labelPhantom,ctaIns+1)  // no debe dejar constancia, dado que no volverá a usarse

       ++ctaLabels

return

Procedure Procesa_instruccion_en_EOL(pLinea,swHayStack,linea,numline,ctaIns,registros,header,swLock,unlock_to,;
                                      lock_ini,instrucc,funcs,lineaFisica,swRet,typeRegistro,usedRegs,ctaReg)
local Ret:=.T., i, orden,rep, ctaRep
       
       if ".stack" $ pLinea
          if swHayStack
             swHayStack:=.F.
             pLinea:=substr(pLinea,7,len(pLinea))
             pLinea:=ISNUMSPECIAL(pLinea,lineaFisica)  // por si está en otra base

             if ISTNUMBER(pLinea)==1
                header[2]:=val(pLinea)
                pLinea:=NULL
             else
                _Error("Directive .STACK: argument error: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
             end
          end
       elseif ".ctrlc" $ pLinea
          header[4]:=1
          pLinea:=NULL
      /* elseif "algo" $ pLinea
          pLinea:=substr(pLinea,9,len(pLinea))
             pLinea:=ISNUMSPECIAL(pLinea,lineafisica)  // por si está en otra base

             if ISTNUMBER(pLinea)==1
                header[4]:=val(pLinea)
                pLinea:=NULL
             else
                _Error("Directive .STACK: argument error: "+pLinea,lineaFisica)
             end */
       elseif ".buffer" $ pLinea
             pLinea:=substr(pLinea,8,len(pLinea))
             pLinea:=ISNUMSPECIAL(pLinea,lineaFisica)  // por si está en otra base

             if ISTNUMBER(pLinea)==1
                SETTYPEAHEAD(val(pLinea))
                pLinea:=NULL
             else
                _Error("Directive .BUFFER: argument error: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
             end
          
       elseif ".local" == pLinea .or. ".locals" == pLinea  // setea variables locales.
          if !swLock
             swLock:=.T.
             unlock_to:=len(registros)
             lock_ini:=len(registros)+1  // desde donde busca variables dentro de un bloque
          else
             _Error("Directive .LOCAL redefined",lineaFisica)
          end
       
       else   
          if len(pLinea)>0
                ctaRep:=1
                rep:=substr(pLinea,1,1)
                while rep=="*" //isdigit(rep)
                   ++ctaRep
                   pLinea:=substr(pLinea,2,len(pLinea))
                   rep:=substr(pLinea,1,1)
                end

                // buscar en instrucc
                if swLock
                   if pLinea=="back" .or. pLinea=="aback"
                      if ctaRep>1
                         _Error("low-level instruction BACK|ABACK must be unique",lineaFisica)
                      else
                        // ? "(10)lock_ini original = ",lock_ini
                         if pLinea=="back"
                            lock_ini:=len(registros)+1  // desde donde busca variables dentro de un bloque
                         else
                            pLinea:="back"
                         end
                        // ? "(10)nuevo lock_ini = ",lock_ini
                      end
                   end
                else
                   if pLinea=="back" .or. pLinea=="aback"
                      if swWarning
                         /*fwrite(1,"Line: "+alltrim(str(lineaFisica))+" => warning: "+GenMsg("back")+" detected but not set "+GenMsg(".locals")+_CR)
                         fwrite(1," ---> (if this warning occurs before "+GenMsg(".locals")+", skip this warning)"+_CR)*/
                         printmsg("Line: "+alltrim(str(lineaFisica))+" => "+chr(27)+"[35mwarning"+chr(27)+"[0m: " +GenMsg(chr(27)+"[1mback"+chr(27)+"[0m")+" detected but not set "+GenMsg(chr(27)+"[1m .locals"+chr(27)+"[0m")+_CR)
                         printmsg(" ---> (if this warning occurs before "+GenMsg(chr(27)+"[1m .locals"+chr(27)+"[0m")+", skip this warning)"+_CR)
                      end
                   end
                   if pLinea=="aback"
                      pLinea:="back"
                   end
                end
                orden := hb_HGetDef( instrucc, pLinea, -1 )
                if orden==-1
                   // ¿Y si es una instruccion incrustada aqui por falta de espacio?
                   orden := hb_HGetDef( funcs, pLinea, -1 )
                   if orden==-1
                      _Error("proc-EOL(1): low-level instruction not recognized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                      /*swCopiaArray:=.F.; swString:=.F.
                      Procesa_registro_o_constante(@pLinea,@lineaFisica,@linea,@registros,@typeRegistro,@usedRegs,@numLine,;
                                    @swLock,@lock_ini,@unlock_to,@ctaIns,@ctaReg,@swCopiaArray,@swString)*/
                  /* end  07-NOV-2022 */
                   else
                   if orden >=322 .and. orden <=363  // es una funcion trig inversa
                      ; // todo bien!
                   else
                      _Error("proc-EOL(2): low-level instruction not recognized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                      /*swCopiaArray:=.F.; swString:=.F.
                      Procesa_registro_o_constante(@pLinea,@lineaFisica,@linea,@registros,@typeRegistro,@usedRegs,@numLine,;
                                    @swLock,@lock_ini,@unlock_to,@ctaIns,@ctaReg,@swCopiaArray,@swString)*/
                   end
                   end
                end
                for i:=1 to ctaRep
                   aadd(linea,orden)
                   aadd(numLine,lineaFisica)
                   ++ctaIns
                end
                if orden==136
                   if ctaRep==1
                      swRet:=.T.
                   else
                      _Error("duplicated instrution: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                   end
                end

/*             orden := hb_HGetDef( instrucc, pLinea, -1 )
             if orden==-1
                _Error("(1) unknowed low-level instruction: ["+pLinea+"]",lineaFisica)
             end
             if orden==136  // ret
                swRet:=.T.
             end
          
             ///torden:=getFamilia(orden)
             aadd(linea,orden)
             aadd(numLine,lineaFisica)
*/
//             ++ctaIns

             pLinea:=NULL
             ++lineaFisica
             Ret:=.F.; return Ret ///loop
          end
       end  // if swHayStack
       pLinea:=NULL
       ++lineaFisica

return Ret

Procedure Procesa_registro_o_constante(pLinea,lineaFisica,linea,registros,typeRegistro,usedRegs,numLine,;
                                       swLock,lock_ini,unlock_to,ctaIns,ctaReg,swCopiaArray,swString)
local ctaRep, rep,dato,reg,i,orden:=0
                ctaRep:=1
                rep:=substr(pLinea,1,1)
                while rep=="*" //isdigit(rep)
                  ++ctaRep
                  pLinea:=substr(pLinea,2,len(pLinea))
                  rep:=substr(pLinea,1,1)
                end

               // ? "pLINEA=[",pLinea,"]"," ISNOTATION=",ISNOTATION(pLinea)
                if ISNOTATION(pLinea) == 1
                   pLinea := alltrim(str(FUNE2D(pLinea)))
                else
                   pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
                end
               // ?">>> pLinea=",pLinea
                
                if swLock
                   dato:=ascan(registros, pLinea,lock_ini)
                   if dato==0
                      dato:=ascan(registros, pLinea, 1, unlock_to)
                   end
                else
                   dato:=ascan(registros, pLinea)
                end
               // ? "DATO encontrado : ",dato, iif(dato>0, " = "+registros[dato],"")

                if dato==0   // no es un registro
                   //if !swString   //
                   if substr(pLinea,1,1)!=chr(34)  // no es un string
                      if ISTNUMBER(pLinea)!=1   // no es un numero
                         if substr(pLinea,1,1)=="["  // es un dataseg
                            pLinea:=strtran(pLinea,"[","")
                            pLinea:=strtran(pLinea,"]","")
                            pLinea:=ISNUMSPECIAL(pLinea,lineaFisica)
                            if swLock
                               reg:=ascan(registros, pLinea,lock_ini)
                               if reg==0
                                  reg:=ascan(registros, pLinea, 1, unlock_to)
                               end
                            else
                               reg := ascan(registros, pLinea)
                            end
                            if reg==0   // no existe. ver si es un cte o registro
                               if ISTNUMBER(pLinea)==1
                                  aadd(registros,pLinea)     // agrego label de registro variable
                                  aadd(typeRegistro, "N")    // agrego tipo registro
                                  ++ctaReg
                                  reg:=ctaReg
                                  aadd(usedRegs,{reg,.F.,lineaFisica})
                               else
                                  _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                               end
                            else         // ver si es un registro o constante.
                               if typeRegistro[reg] == "C"
                                  _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                               end
                            end
                            for i:=1 to ctaRep

                               aadd(linea,orden+2)
                               aadd(linea,reg)
                               aadd(numLine,lineaFisica)
                               aadd(numLine,lineaFisica)
                               ctaIns+=2
                            end
                            pLinea:=NULL
                         else
                            _Error("register not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                         end
                      else   // es un numero no registrado
                         aadd(registros,pLinea)     // agrego label de registro variable
                         aadd(typeRegistro, "N")    // agrego tipo registro
                         ++ctaReg
                         aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                         if swCopiaArray
                            orden:=1
                            swCopiaArray:=.F.  // desactiva opción para otros push
                         end
                         for i:=1 to ctaRep
                            ///torden:=getFamilia(orden)
                            aadd(linea,orden)
                            aadd(linea,ctaReg)
                            aadd(numLine,lineaFisica)
                            aadd(numLine,lineaFisica)
                            ctaIns+=2
                         end
                         pLinea:=NULL
                      end
                   else    // es un string
                      swString:=.F.
                      aadd(registros,pLinea)     // agrego label de registro variable
                      aadd(typeRegistro, "C")    // agrego tipo registro
                      ++ctaReg
                      aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                      if swCopiaArray
                         orden:=1
                         swCopiaArray:=.F.  // desactiva opción para otros push
                      end

                      for i:=1 to ctaRep
                        //// torden:=getFamilia(orden)
                         aadd(linea,orden)
                         aadd(linea,ctaReg)
                         aadd(numLine,lineaFisica)
                         aadd(numLine,lineaFisica)
                         ctaIns+=2
                      end
                      pLinea:=NULL
                   end
                else
                   swString:=.F.
                   if swCopiaArray
                      orden:=1
                      swCopiaArray:=.F.  // desactiva opción para otros push
                   end
                   usedRegs[dato,2]:=.T.

                   for i:=1 to ctaRep
                      ///torden:=getFamilia(orden)
                      aadd(linea,orden)
                      aadd(linea,dato)
                      aadd(numLine,lineaFisica)
                      aadd(numLine,lineaFisica)
                      ctaIns+=2
                   end
                   //?"PLINEA=",pLinea
                   pLinea:=NULL
                end
return

Procedure Procesa_por_separador(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                                usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica,;
                                lets,instrucc,funcs)
local ctaRep,rep,i,orden,swCopiaArray:=.F.,swString:=.F.
      if c=="?"  // añade. Con esto no necesito la "," => error? do{...
         pLinea+=c
      end
      if len(pLinea)>0
         if pLinea==".local" .or. pLinea==".locals"
            if !swLock
               swLock:=.T.
               unlock_to:=len(registros)
               lock_ini:=len(registros)+1  // desde donde busca variables dentro de un bloque
            else
               _Error("Directive "+GenMsg(chr(27)+"[1m"+" .locals"+chr(27)+"[0m")+" redefined",lineaFisica)
            end
         else 
            ctaRep:=1
            rep:=substr(pLinea,1,1)
            while rep=="*" //isdigit(rep)
               ++ctaRep
               pLinea:=substr(pLinea,2,len(pLinea))
               rep:=substr(pLinea,1,1)
            end
            if pLinea=="back" .or. pLinea=="aback"
               if ctaRep>1
                  _Error("(a)low-level instruction BACK|ABACK must be unique",lineaFisica)
               end
               if swLock   // solo si está en zona de locales, registra nueva frontera de variables locales.
                  // ? "(;)lock_ini original = ",lock_ini
                  if pLinea=="back"
                     lock_ini:=len(registros)+1  // desde donde busca variables dentro de un bloque
                  end
                  // ? "(;)nuevo lock_ini = ",lock_ini
               else
                  if swWarning
                     /*fwrite(1,"Line: "+alltrim(str(lineaFisica))+" => warning: "+GenMsg("back")+" detected but not set "+GenMsg(".locals")+_CR)
                     fwrite(," ---> (if this warning ocurrs before "+GenMsg(".locals")+", skip this warning)"+_CR)*/
                     printmsg("Line: "+alltrim(str(lineaFisica))+" => "+chr(27)+"[35mwarning"+chr(27)+"[0m: " +GenMsg(chr(27)+"[1mback"+chr(27)+"[0m")+" detected but not set "+GenMsg(chr(27)+"[1m .locals"+chr(27)+"[0m")+_CR)
                     printmsg(" ---> (if this warning occurs before "+GenMsg(chr(27)+"[1m .locals"+chr(27)+"[0m")+", skip this warning)"+_CR)
                  end
               end
               if pLinea=="aback"
                  pLinea:="back"
               end
            end
            orden := hb_HGetDef( instrucc, pLinea, -1 )
            if orden==-1
               // ¿Y si es una instruccion incrustada aqui por falta de espacio?
               orden := hb_HGetDef( funcs, pLinea, -1 )
               if orden==-1
                  //_Error("(b)low-level instruction not recognized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                  /*  07-NOV-2022 
                      Añade detección de registro o constante, para añadir como SPUSH. FIX de error de uso de 
                      definiciones simples en #HL() */
                  Procesa_registro_o_constante(@pLinea,@lineaFisica,@linea,@registros,@typeRegistro,@usedRegs,@numLine,;
                                               @swLock,@lock_ini,@unlock_to,@ctaIns,@ctaReg,@swCopiaArray,@swString)
                  
               /*end   07-NOV-2022 */
               else
               if orden >=322 .and. orden <=363  // es una funcion trig inversa o function=>instruction
                  for i:=1 to ctaRep
                  //torden:=getFamilia(orden)
                     aadd(linea,orden)
                     aadd(numLine,lineaFisica)
                     ++ctaIns
                  end
                  if orden==136
                     if ctaRep==1
                        swRet:=.T.
                     else
                        _Error("duplicated instrution: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                     end
                   end
               else 
                  _Error("(c)low-level instruction not recognized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
               end
               end /* 07-NOV-2022 */
            else
               for i:=1 to ctaRep
               //torden:=getFamilia(orden)
                  aadd(linea,orden)
                  aadd(numLine,lineaFisica)
                  ++ctaIns
               end
               if orden==136
                  if ctaRep==1
                     swRet:=.T.
                  else
                     _Error("duplicated instrution: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                  end
               end
            end
         end
      end

      pLinea:=NULL

return

Procedure Procesa_etiqueta(pLinea,swMAINPRG,linea,numline,ctaLabels,/*ActualLabel,*/labels,ctaIns,lineaFisica)
local dato
       // extraer e identificar label
       // Identificar MAIN: definir el punto de inicio del programa, si quiero que el sistema
       // de saltos bottom-up funcione.

       if pLinea == "main" //.or. pLinea == "begin:"
          if swMAINPRG
             _Error("directive MAIN duplicated",lineaFisica)
          else
             swMAINPRG:=.T.
          end
          aadd(linea,255)
          aadd(numLine,lineaFisica)

          //pString+=linea
          ++ctaIns
       end
       dato:=hb_HGetDef( labels, pLinea, -1 )
       if dato==-1
          hb_hset(labels,pLinea,ctaIns+1)
          ++ctaLabels
       else
          _Error("label duplicated",lineaFisica)
       end
       //ActualLabel:=pLinea
       pLinea:=NULL
       //linea:=NULL

return

Procedure Busca_registro_o_constante(pLinea,fp,h_ini,h_fin,registros,lock_ini,unlock_to,typeRegistro,;
                                     usedRegs,linea,ctaIns,ctaReg,swLock,numLine,c,lineaFisica)
local orden:=0,i
local swString:=.F.
local swCopiaArray:=.F.
          //orden:=0    // por default=push de registros.
          while c!=chr(10) .and. h_ini<=h_fin
             fread(fp,@c,1); ++h_ini
             nSavePos := fseek( fp, 0, 1 )

             if c==" "
                loop
             
             elseif c=="@"   // fuerza copia de array en stack
                swCopiaArray:=.T.
                loop
             elseif c==chr(34)   // es una cte string.
                if len(pLinea)==0
                   pLinea:=c
                else
                   pLinea += c
                end
                swString:=.T.
                c:=" "
                while c!=chr(10) .and. h_ini<=h_fin
                   fread(fp,@c,1); ++h_ini
                   pLinea+=c
                   if c=="\"
                      fread(fp,@c,1); ++h_ini
                      pLinea+=c
                   elseif c==chr(34)
                      exit
                   end
                end
                //? "string detectado: [",pLinea,"]"
                if c==chr(10)
                   _Error("function "+chr(27)+"[1m"+"{}"+chr(27)+"[0m"+" unclosed: "+_CR+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                end
             elseif is_any(c,",",";","}",")","'")  //c=="," .or. c==";" .or. c=="}" .or. c==")" .or. c=="'"
                //? "??? ",pLinea
                Procesa_registro_o_constante(@pLinea,@lineaFisica,@linea,@registros,@typeRegistro,@usedRegs,@numLine,;
                                               @swLock,@lock_ini,@unlock_to,@ctaIns,@ctaReg,@swCopiaArray,@swString)
                                               
               /* ctaRep:=1
                rep:=substr(pLinea,1,1)
                while rep=="*" //isdigit(rep)
                  ++ctaRep
                  pLinea:=substr(pLinea,2,len(pLinea))
                  rep:=substr(pLinea,1,1)
                end

               // ? "pLINEA=[",pLinea,"]"," ISNOTATION=",ISNOTATION(pLinea)
                if ISNOTATION(pLinea) == 1
                   pLinea := alltrim(str(FUNE2D(pLinea)))
                else
                   pLinea:=ISNUMSPECIAL(pLinea,lineafisica)
                end
               // ?">>> pLinea=",pLinea
                
                if swLock
                   dato:=ascan(registros, pLinea,lock_ini)
                   if dato==0
                      dato:=ascan(registros, pLinea, 1, unlock_to)
                   end
                else
                   dato:=ascan(registros, pLinea)
                end
               // ? "DATO encontrado : ",dato, iif(dato>0, " = "+registros[dato],"")

                if dato==0   // no es un registro
                   //if !swString   //
                   if substr(pLinea,1,1)!=chr(34)  // no es un string
                      if ISTNUMBER(pLinea)!=1   // no es un numero
                         if substr(pLinea,1,1)=="["  // es un dataseg
                            pLinea:=strtran(pLinea,"[","")
                            pLinea:=strtran(pLinea,"]","")
                            pLinea:=ISNUMSPECIAL(pLinea,lineaFisica)
                            if swLock
                               reg:=ascan(registros, pLinea,lock_ini)
                               if reg==0
                                  reg:=ascan(registros, pLinea, 1, unlock_to)
                               end
                            else
                               reg := ascan(registros, pLinea)
                            end
                            if reg==0   // no existe. ver si es un cte o registro
                               if ISTNUMBER(pLinea)==1
                                  aadd(registros,pLinea)     // agrego label de registro variable
                                  aadd(typeRegistro, "N")    // agrego tipo registro
                                  ++ctaReg
                                  reg:=ctaReg
                                  aadd(usedRegs,{reg,.F.,lineaFisica})
                               else
                                  _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                               end
                            else         // ver si es un registro o constante.
                               if typeRegistro[reg] == "C"
                                  _Error("register not initialized or not a number: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                               end
                            end
                            for i:=1 to ctaRep

                               aadd(linea,orden+2)
                               aadd(linea,reg)
                               aadd(numLine,lineaFisica)
                               aadd(numLine,lineaFisica)
                               ctaIns+=2
                            end
                            pLinea:=NULL
                         else
                            _Error("register not initialized: "+GenMsg(chr(27)+"[1m"+pLinea+chr(27)+"[0m"),lineaFisica)
                         end
                      else   // es un numero no registrado
                         aadd(registros,pLinea)     // agrego label de registro variable
                         aadd(typeRegistro, "N")    // agrego tipo registro
                         ++ctaReg
                         aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                         if swCopiaArray
                            orden:=1
                            swCopiaArray:=.F.  // desactiva opción para otros push
                         end
                         for i:=1 to ctaRep
                            ///torden:=getFamilia(orden)
                            aadd(linea,orden)
                            aadd(linea,ctaReg)
                            aadd(numLine,lineaFisica)
                            aadd(numLine,lineaFisica)
                            ctaIns+=2
                         end
                         pLinea:=NULL
                      end
                   else    // es un string
                      swString:=.F.
                      aadd(registros,pLinea)     // agrego label de registro variable
                      aadd(typeRegistro, "C")    // agrego tipo registro
                      ++ctaReg
                      aadd(usedRegs,{ctaReg,.F.,lineaFisica})
                      if swCopiaArray
                         orden:=1
                         swCopiaArray:=.F.  // desactiva opción para otros push
                      end

                      for i:=1 to ctaRep
                        //// torden:=getFamilia(orden)
                         aadd(linea,orden)
                         aadd(linea,ctaReg)
                         aadd(numLine,lineaFisica)
                         aadd(numLine,lineaFisica)
                         ctaIns+=2
                      end
                      pLinea:=NULL
                   end
                else
                   swString:=.F.
                   if swCopiaArray
                      orden:=1
                      swCopiaArray:=.F.  // desactiva opción para otros push
                   end
                   usedRegs[dato,2]:=.T.

                   for i:=1 to ctaRep
                      ///torden:=getFamilia(orden)
                      aadd(linea,orden)
                      aadd(linea,dato)
                      aadd(numLine,lineaFisica)
                      aadd(numLine,lineaFisica)
                      ctaIns+=2
                   end
                   //?"PLINEA=",pLinea
                   pLinea:=NULL
                end*/
                if c=="}" .or. c==")" .or. c=="'"  // llegó al final
                   exit
                end
                orden:=0   // reset de orden principal
             else
                pLinea+=c
             end 
          end
          if c==chr(10)
             fseek(fp,nSavePos-1,0); --h_ini
          end

return

procedure LineaComentario(h_ini,h_fin,fp,c)
while h_ini<=h_fin
   fread(fp,@c,1); ++h_ini   // lee hasta el fin de linea
   nSavePos := fseek( fp, 0, 1 )
   if c==chr(10)
      fseek(fp,nSavePos-1,0); --h_ini
      exit
   end
end
return nSavePos

procedure GETPROTOTYPE(DEF,DEFVAR,DEFBODY,h_ini,h_fin,fp,c,lineaFisica,pFile,tipo)
LOCAL pDefine,pBodyDef,pVarDef,lineDef,nSavePos,nTok,iTok,aTempVar:={},swError:=.F.
pDefine:=NULL
pBodyDef:=NULL
pVarDef:=NULL
lineDef:=""

        QuitaEspacio(@h_ini,@h_fin,@fp,@c)
        
        while is_noall(c," ",chr(10)) .and.h_ini<=h_fin
           pDefine+=c
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
        end

        pDefine:=alltrim(pDefine)
       // ? "PROTO pdefine = ",pDefine
       nVarDef:=NULL
        if "(" $ pDefine
           pVarDef:=alltrim( substr(pDefine,at("(",pDefine)+1,len(pDefine)) )
           pVarDef:=alltrim( substr(pVarDef,1,at(")",pVarDef)-1) )
           pDefine:=alltrim( substr(pDefine,1,at("(",pDefine)-1) )

           nTok:=numtoken(pVarDef,",")
           iTok:=1
           tokenVar:=NULL
           while iTok<=nTok
              tokenVar:=TOKEN(pVarDef,",",iTok)
              aadd( aTempVar, tokenVar )
             // if tokenVar!="VARGIN"
                  nVarDef+="#ATOM#CMPLX;"
                  ++iTok
             // else
                  //nVarDef+="*,"  // debe ser el último
             //     exit
             // end
              //++iTok
           end
        else
           _Error(pFile+": prototype needs params definition",lineaFisica)
           //swError:=.T.
           quit
        end
        //? "----- nVARDEF = ",nVarDef
        if !swError
           // genera la línea de definición de macro-funcion prototipo: pBodyDef
           // funcname:, y=0,mov(y), x=0,mov(x),...
           pBodyDef:=pDefine+":"
           while nTok>0
              // esto debe ir así, porque es la primera declaración dentro de una pseudo-funcion:
              pBodyDef += ","+aTempVar[nTok]+"=0,mov("+aTempVar[nTok]+")"
              nTok--
           end
           //arma definición de contexto
           aadd( DEFVAR, aTempVar )
           aadd( DEF,pDefine )
           aadd( DEFBODY, pBodyDef )
           // arma llamador
           aadd( DEFVAR, aTempVar )
           aadd( DEF,"_"+pDefine )   // "_" es para no repetir la declaracion.
           aadd( DEFBODY, nVarDef+"jsub("+pDefine+")" )
           
           // guarda el sinónimo para trabajar tranquilos con el nombre natural
           ///SET EXACT ON
           ///? "(GETDEFINE) pDEFINE  = ",pDefine
           //n:=ascan(DEF,pDefine)
           //if n==0
           //   _Error(File+": synonymous not exist: "+GenMsg(chr(27)+"[1m"+pDefine+chr(27)+"[0m"),lineaFisica)
           //   quit
           //end
          // ? "DEF found = ",DEF[n]
         /*  n:=len(DEFVAR)  // la definición original de proto
           ?"DEF[",n,"]=",DEF[n]
           //nTok:=numtoken(pBodyDef,",")
           //iTok:=1
           //while iTok<=nTok
              //hb_hset(SINONIMOS,TOKEN(pBodyDef,",",iTok),pVarDef)
              aadd( DEFVAR, DEFVAR[n] )  // si no hay vars, len(aTempVar)=0
              //aadd( DEF,alltrim(TOKEN(pBodyDef,",",iTok)) )
              aadd( DEF,alltrim(pDefine) )
              aadd( DEFBODY, DEFBODY[n] )
           //   ++iTok
           //end
           */
        end
return nSavePos

procedure GETDEFINE(DEF,DEFVAR,DEFBODY,DEFEXPRE,DEFLOOP,DEFENDLOOP,DEFENDIF,DEFENDIIF,DEFCATCH,DEFENDCATCH,DEFCODEIF,;
                    DEFRANDVAR,DEFCODESW,DEFCODEMARK,h_ini,h_fin,fp,fw,c,lineaFisica,tipo,File,subtipo)
LOCAL pDefine,pBodyDef,pVarDef,nTok,iTok,nSavePos,aTempVar:={},cta_c:=0
pDefine:=NULL
pBodyDef:=NULL
pVarDef:=NULL
/************** DEBO ACEPTAR COSAS COMO ESTA:
  #define PUSH(X,Y)        ... use(X); push Y 
  #define VECTOR(X,Y)      ...   [X Y]
  #define PRNVECTOR(X,Y,Z) ... {  Y<-0; do \
                                     write [X Y]\
                                     until (++Y)=Z } 
  #define IMPRIMELAHUEA(X,Y)...  write X,Y,"\n"
  #define PRINT         ... write
***************/

/*** obtengo el avatar del define. LEO HASTA el " " ***/
        
        QuitaEspacio(@h_ini,@h_fin,@fp,@c)
        
        while is_noall(c," ",chr(10)) /*c!=" ".and.c!=chr(10)*/ .and.h_ini<=h_fin
           pDefine+=c //iif(c==":",",",c)
           fread(fp,@c,1); ++h_ini
           nSavePos := fseek( fp, 0, 1 )
        end
        if c==chr(10)
           _Error(File+": The line break does not go here",lineaFisica)
        end
        pDefine:=alltrim(pDefine)
       // ?">>>pDEFINE= ",pDefine
/*** obtengo el cuerpo del define ***/
        c:=" "
        QuitaEspacio(@h_ini,@h_fin,@fp,@c)

           if c==chr(10)
              _Error(File+": You must start defining here, not on the next line",lineaFisica)
           end
           if c==chr(34)   // define una constante string?
              pBodyDef+=c
              while c!=chr(10) .and. h_ini<=h_fin
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
                 pBodyDef+=c
                 if c=="\"
                    fread(fp,@c,1); ++h_ini
                    nSavePos := fseek( fp, 0, 1 )
                    pBodyDef+=c
                 elseif c==chr(34)
                    pBodyDef:=substr(pBodyDef,1,len(pBodyDef)-1)
                    exit
                 end
              end
           end
           sw_otra_linea:=.F.
           sw_next:=.T.
           //while c!="}" .and. h_ini<=h_fin
           while sw_next .and. h_ini<=h_fin
//              if subtipo==1
                 if c!=chr(10) .and. c!=" "
                    pBodyDef+=c
                 end
//              elseif c!=" " 
//                 pBodyDef+=c
//              end
              
              fread(fp,@c,1); ++h_ini
              nSavePos := fseek( fp, 0, 1 )
              
              if c==" "
                 loop
              end
              if c=="/"    // quito comentarios
                 fread(fp,@c,1); ++h_ini
                 nSavePos := fseek( fp, 0, 1 )
                 if c=="*"
                    while h_ini<=h_fin
                       fread(fp,@c,1); ++h_ini
                       nSavePos := fseek( fp, 0, 1 )
                       if c=="*"
                          fread(fp,@c,1); ++h_ini
                          nSavePos := fseek( fp, 0, 1 )
                          if c=="/"
                             c:=" "
                             exit
                          end
                       end
                       if c==chr(10)
                          ++lineaFisica
                       end
                    end
                    //BloqueComentario(@h_ini,@h_fin,@fp,@fw,@lineaFisica,@c)
                    //fread(fp,@c,1); ++h_ini
                    //nSavePos := fseek( fp, 0, 1 )
                 elseif c=="/"
                    nSavePos := LineaComentario(@h_ini,@h_fin,@fp,@c)
                    fread(fp,@c,1); ++h_ini
                    nSavePos := fseek( fp, 0, 1 )
                 else
                    pBodyDef+="/"
                 end
              end
              
              if c=="\"
                 sw_otra_linea:=.T.
                 c:=" "
              elseif c==chr(34)
                 pBodyDef+=c
                 while c!=chr(10) .and. h_ini<=h_fin
                    fread(fp,@c,1); ++h_ini
                    nSavePos := fseek( fp, 0, 1 )
                    pBodyDef+=c
                    if c=="\"
                       fread(fp,@c,1); ++h_ini
                       nSavePos := fseek( fp, 0, 1 )
                       pBodyDef+=c
                    elseif c==chr(34)
                       pBodyDef:=substr(pBodyDef,1,len(pBodyDef)-1)
                       exit
                    end
                 end
                 if c==chr(10) .or. h_ini>h_fin
                    _Error(File+": string has not been closed (#define-1): "+GenMsg(chr(27)+"[1m"+pBodyDef+chr(27)+"[0m"),lineaFisica)
                 end
                // ? "BODYDEF=",pBodyDef
              elseif c==chr(10)
                 if sw_otra_linea
                    sw_otra_linea:=.F.
                    sw_next:=.T.
                    //if subtipo==0
                    ++lineaFisica

                    //end
                 else
                    sw_next:=.F.
                 end
                 
              end
           end

          // if cta_c!=0
          //    _Error("Instrucción compuesta '{}' como el pico",lineafisica)
          // end

        pBodyDef:=BUSCALINEASBLANCAS(pBodyDef)

        if len(pBodyDef)==0
           _Error(File+": Why do you define things that you are not going to complete? "+GenMsg(chr(27)+"[1m"+pDefine+chr(27)+"[0m"),lineaFisica)
        end
        if tipo==0   // es un define simple o de usuario

           pBodyDef:=_CAMBIODEFINE(@DEF,@DEFVAR,@DEFBODY,@DEFEXPRE,@DEFLOOP, @DEFENDLOOP,@DEFENDIF,@DEFENDIIF,;
                                   @DEFCATCH,@DEFENDCATCH,@DEFCODEIF,@DEFRANDVAR,@DEFCODESW,@DEFCODEMARK,pBodyDef,lineaFisica)
        end
                // GUARDAR def EN TABLA DE SINONIMOS {"DEF"=>"DEF"}
        if tipo==2   // es un sinónimo
           // pvardef debe ser único, sin ()
           SET EXACT ON
           ///? "(GETDEFINE) pDEFINE  = ",pDefine
           n:=ascan(DEF,pDefine)
           if n==0
              _Error(File+": synonymous not exist: "+GenMsg(chr(27)+"[1m"+pDefine+chr(27)+"[0m"),lineaFisica)
              quit
           end
           //? "Synon of = ",pDefine,"DEF found = ",DEF[n]
           //? "DEFBODY = ",DEFBODY[n], "  sinonimo: ","["+pBodyDef+"]"
           nTok:=numtoken(pBodyDef,",")
           iTok:=1
           while iTok<=nTok
              //hb_hset(SINONIMOS,TOKEN(pBodyDef,",",iTok),pVarDef)
              aadd( DEFVAR, DEFVAR[n] )  // si no hay vars, len(aTempVar)=0
              // supongamos que antepongo "*" y esto significa "and","then","now"
              tokenSub:=alltrim(TOKEN(pBodyDef,",",iTok))
              swSinonimos:=.F.
              if substr(tokenSub,1,1)=="*"
                 swSinonimos:=.T.
                 tokenSub:=substr(tokenSub,2,len(tokenSub))
              end
              //aadd( DEF,alltrim(TOKEN(pBodyDef,",",iTok)) )
              aadd( DEF, tokenSub )
              aadd( DEFBODY, DEFBODY[n] )
              if swSinonimos
                 aadd( DEFVAR, DEFVAR[n] )
                 aadd( DEF, "and"+tokenSub )
                 aadd( DEFBODY, DEFBODY[n] )
                 aadd( DEFVAR, DEFVAR[n] )
                 aadd( DEF, "now"+tokenSub )
                 aadd( DEFBODY, DEFBODY[n] )
                 aadd( DEFVAR, DEFVAR[n] )
                 aadd( DEF, "then"+tokenSub )
                 aadd( DEFBODY, DEFBODY[n] )
              end

              ++iTok
           end
        else

    /*** Tiene variables? ***/
           nTok:=0; iTok:=1
           if "(" $ pDefine
              pVarDef:=alltrim( substr(pDefine,at("(",pDefine)+1,len(pDefine)) )
              pVarDef:=alltrim( substr(pVarDef,1,at(")",pVarDef)-1) )
              pDefine:=alltrim( substr(pDefine,1,at("(",pDefine)-1) )

              nTok:=numtoken(pVarDef,",")
              //iTok:=1
              while iTok<=nTok
                 aadd( aTempVar,TOKEN(pVarDef,",",iTok) )
                 ++iTok
              end
           end
         //  if subtipo==1
         //     pBodyDef:=strtran(pBodyDef,chr(10),",")
         //  end
         /* BUSCAR SI YA ESTA DEFINIDA UNA MACRO CON EL MISMO NOMBRE */
           SET EXACT ON
           //? "(GETDEFINE) pDEFINE  = ",pDefine
           n:=ascan(DEF,pDefine)
           if n>0
              if iTok>1 // tiene argumentos la nueva macro?
                 //if len(DEFVAR[n][1])>0  // tiene argumentos la macro ya definida?
                 if len(DEFVAR[n])>0  // tiene argumentos la macro ya definida?
/*                    ? DEF[n]
                    ? DEFVAR[n], " Len=",len(DEFVAR[n][1])
                    ? DEFBODY[n]*/
                    _Error(File+": macro() already exist: "+GenMsg(chr(27)+"[1m"+pDefine+chr(27)+"[0m"),lineaFisica)
                 end
              else   // no tiene argumentos
                 
               //  ? "---> N=",n
                 //if len(DEFVAR[n][1])==0  // no tiene argumentos la macro ya definida?
                 if len(DEFVAR[n])==0  // no tiene argumentos la macro ya definida?
                    _Error(File+": macro already exist: "+GenMsg(chr(27)+"[1m"+pDefine+chr(27)+"[0m"),lineaFisica)
                 end
              end
           end
           // para #define-a
           if subtipo==3
              aadd(aTempVar,.T.)
           end
           aadd( DEFVAR, aTempVar )  // si no hay vars, len(aTempVar)=0
           aadd( DEF,pDefine )
           aadd( DEFBODY, pBodyDef )
        end
return nSavePos

function _CAMBIODEFINE(DEF,DEFVAR,DEFBODY,DEFEXPRE,DEFLOOP,DEFENDLOOP,DEFENDIF,DEFENDIIF,DEFCATCH,DEFENDCATCH,;
                       DEFCODEIF,DEFRANDVAR,DEFCODESW,DEFCODEMARK,linea,lineaFisica)
LOCAL nLen,i,j,nPos,pLinea:="",pLineafin:="",ctaPar ,pString:=NULL,strComplex:=NULL
LOCAL c:="",pPos,pBody:="",tBody,nTok:=0,cTok:="",sw, newLabel,tPos
LOCAL swComplex:=.F.,w,cTmp, ignore //, tmpStr, tmpCode, tmpString, w
LOCAL tLinea:={},nPosible:=0,swDefinea:=.F.
nLen:=len(DEF)

/* salvar cadenas para evitar reemplazos en strings (falsos positivos) */
tLinea:=rescueStrings(linea)
if len(tLinea)>2
   linea:=tLinea[len(tLinea)]
   //? "linea = ",linea
end

/* revision de linea */
for i:=1 to nLen

   // buscar DEF[i] en linea leida.
   if DEF[i] $ linea  //at(DEF[i],linea)>0
/*      nPosible:=at(DEF[i],linea)
      // debe ser, por ejemplo: ,Inv; y no Inversion, o TotalInvitiados 
      if ( isalpha(substr(linea,nPosible-1,1)) .or. isalpha(substr(linea,nPosible+len(DEF[i]),1)) ) .and. DEF[i]!=linea
         ? "DEF[i]=",DEF[i]," linea=",linea
         loop
      end*/
      //?"DEF[i]=",DEF[i]
      //??"  VALTYPE=",valtype(DEFVAR[i][1])
      swDefinea:=.F.
      if len(DEFVAR[i])==1
         if valtype(DEFVAR[i][1])=="L"
            swDefinea:=.T.
         end
      end
      if len(DEFVAR[i])==0 .or. swDefinea  // no tiene variable. solo reemplazo
      
         // buscar para no hacer reemplazo en un string
         ignore:=0
         contador_loop:=0
         //? "DEF = ",DEF[i]
         while .T.
            nPos:=atnum(DEF[i],linea,1,ignore)
           /// nPos:=BUSCACOMPLETA(nPos,linea,len(DEF[i]))

           // ? "ANTES=",isalpha(substr(linea,nPos-1,1))," DESP=", isalpha(substr(linea,nPos+len(DEF[i]),1)) 
            //? "QUE LEO? = ", "("+substr(linea,nPos-1,1)+DEF[i]+substr(linea,nPos+len(DEF[i]),1)+")"
            //? "BUSCA = ",nPos:=BUSCACOMPLETA(nPos,linea,len(DEF[i]))
            if nPos>0
               if substr(linea,nPos+len(DEF[i]),1)==":" //.or. ;
                  //isalpha(substr(linea,nPos-1,1)) .or. isalpha(substr(linea,nPos+len(DEF[i]),1)) 
                  ignore:=nPos+len(DEF[i])
                  loop
               end

                  ++contador_loop
                  //? contador_loop
                  if contador_loop>100
                     _Error("synonymous bad indexed, or #proto & #context combined: "+GenMsg(chr(27)+"[1m"+DEF[i]+chr(27)+"[0m"),lineaFisica)
                     quit
                  end

               /*? "DEF    = ",DEF[i]
               ? "ANTES  = ",linea
               ? "POS    = ",nPos
               ? "IGNORE = ",ignore*/
               w:=1
               while w<=nPos
                  c:=substr(linea,w,1)
                  if c==chr(34)
                     cTmp:=c
                     while ++w<=nPos
                        c:=substr(linea,w,1)
                        if c==chr(34)
                           cTmp:=NULL
                           exit
                        elseif c=="\"
                           ++w
                        end
                     end
                  end
                  ++w
               end
               
               if cTmp!=chr(34)
                  // PROBLEMA CON ESO: reemplaza correctamente, pero no cosas cmo a:=b. Con la modificacion #define-a, pretendo
                  // solucionar esto.
                  if swDefinea // reemplace donde esté
                    //? "PASA!"
                     linea:=STUFF(linea, nPos, len(DEF[i]), DEFBODY[i])  //strtran(linea,DEF[i],DEFBODY[i],1,1)
                  else   // cuide de reemplazar solo donde sea necesario:
                     if (!isalpha(substr(linea,nPos-1,1)) .and. !isalpha(substr(linea,nPos+len(DEF[i]),1))) .or. DEF[i]==left(linea,len(DEF[i]))
                        //? "ANTES  = ",linea
                        linea:=STUFF(linea, nPos, len(DEF[i]), DEFBODY[i])  //strtran(linea,DEF[i],DEFBODY[i],1,1)
                        //? "DESPU=",linea
                     end
                  end
               end
              // ? "DESPU=",linea
               if len(DEF[i]) <= len(DEFBODY[i])
                  ignore:=nPos+len(DEF[i])
               else
                  ignore:=nPos+len(DEFBODY[i])
               end
            else
               exit
            end
         end
      else   // aqui empieza el webeo por la puta
         //nPos:=at(DEF[i],linea)
         ignore:=0
         nPos:=atnum(DEF[i],linea,1,ignore)
         tPos:=nPos
         
         Temp_linea:=linea
         //? "PROCESO: ",Temp_linea
         //cnt_tlinea:=0
//         while nPos>0 .and. (substr(linea,nPos+len(DEF[i]),1)=="(" .or.substr(linea,nPos+len(DEF[i]),1)=="'" )
         while nPos>0 //.and. BUSCACOMPLETA(nPos,linea,len(DEF[i]))!=0
          //  ? "LINEA= ",linea
          //  ? "Tramo= ",substr(linea,1,nPos-1)+">>"+substr(linea,nPos,len(DEF[i]))+"<<"+substr(linea,nPos+len(DEF[i])+1,len(linea))

            if BUSCACOMPLETA(nPos,linea,len(DEF[i]))==0
               ignore:=nPos+1  // comentar: revisar desde el mismo punto por una macro anidada
               nPos:=atnum(DEF[i],linea,1,ignore)
               /*if tPos==nPos
                  ? "-------- SALIO: tPos=",tPos," nPos=",nPos
                  exit
               end*/
               tPos:=nPos
               loop
            end

           /** identifico la macro del usuario en cuestión **/
            ctaPar := 0     // para saber si hay cosas cmo MACRO( a*(b-c), n ) que hueá!!
            pPos:=nPos+len(DEF[i])
            swPar:=.F.
            while .T. //.and. inkey()==0
               c:=substr(linea,pPos,1)
               if c=="'"
                  if !swPar
                     ++ctaPar
                     if ctaPar>1
                        pBody+="("
                     end
                     swPar:=.T.
                  else
                     --ctaPar
                     if ctaPar>0
                        pBody+=")"
                     end
                     swPar:=.F.
                  end
            //   
            // 
               elseif c =="(" .or. c=="'"
                  ++ctaPar
                  if ctaPar>1
                     pBody+="("
                  end
                 // c:="("
               elseif c==")" .or. c=="'"
                  --ctaPar
                  if ctaPar>0
                     pBody+=")"
                  end
                  //c:=")"
               elseif c==chr(34)
                 pBody+=c
                 while c!=chr(10) 
                    c:=substr(linea,++pPos,1)
                    pBody+=c
                    if c=="\"
                       c:=substr(linea,++pPos,1)
                       pBody+=c
                    elseif c==chr(34)
                       ///pBody:=substr(pBody,1,len(pBody)-1)
                       exit
                    end
                    
                 end
                // ?"pBody=",pBody
                 if c==chr(10) 
                    _Error("string has not been closed (#define-2): "+_CR+"--> "+linea,lineafisica)
                 end
               elseif pPos>=len(linea)
                 // ? linea
                  _Error("You are missusing your macro:"+_CR+"--> "+linea,lineaFisica)
               else
                  pBody+=c
               end
               
               
               if ctaPar==0
                  exit
               end
               ++pPos
               
            end
             //  ? "SALIO"
           /*** aislo la porcion de codigo a procesar ***/
            pLinea:=substr(linea,1,nPos-1)
            pLineaFin:=substr(linea,pPos+1,len(linea))
           /*** procedo con la macro sustitucion ***/
            tBody:=DEFBODY[i]  // definición de cuerpo de macro
            //? ">tBODY : ",tBody
            for j:=1 to len(DEFVAR[i])
               //cTok:=TOKEN(pBody,",",j)
               //?">>>DEFVAR : ",valtype(DEFVAR[i][j])
               c:=""
               pString:=NULL
               swComplex:=.F.
              // ? "pBODY(1)=",pBody
              // ? "SWCOMPLEX(1) = ",swComplex
               if valtype(DEFVAR[i][j]) != "C"
                    _Error(GenMsg(chr(27)+"[1m"+"#define-a for "+DEF[i]+"? "+chr(27)+"[0m")+" not need arguments or not use "+;
                       GenMsg(chr(27)+"[1m"+"#define-a"+chr(27)+"[0m"),lineaFisica)
               end
               k:=1
               if DEFVAR[i][j]=="*"
                  tBody:=strtran(tBody,DEFVAR[i][j],pBody)
               else
                  ctaPar:=0
                 /// swComplex:=.F.

                  while c!="," /*.and. c!=";"*/ .and. k<=len(pBody)
                     c:=substr(pBody,k,1)
                     if c=="{"
                        swComplex:=.T.
                        pString+=c
                        while c!="}" .and. k<=len(pBody)
                           c:=substr(pBody,++k,1)
                           pString+=c
                        end
                     elseif c=="["
                        swComplex:=.T.
                        pString+=c
                        while c!="]" .and. k<=len(pBody)
                           c:=substr(pBody,++k,1)
                           pString+=c
                        end
                     elseif c==chr(34)  // se topó con un string de entrada.
                        pString+=c
                        while c!=chr(10) 
                           c:=substr(pBody,++k,1)
                           pString+=c
                           if c=="\"
                              c:=substr(pBody,++k,1)
                              pString+=c
                           elseif c==chr(34)
                              c=""
                              exit
                           end
                        end
                        if c==chr(10) 
                           _Error("string has not been closed (#define-3): "+_CR+GenMsg(chr(27)+"[1m"+pBody+chr(27)+"[0m"),lineafisica)
                        end
                     elseif c=="(" .or. c=="'"
                        pString+=c
                        ++ctaPar
                        swComplex:=.T.
                       // ? " ENTRA a ( = ",pString," pBody = ",pBody
                        while ctaPar > 0 .and. c!=chr(10)
                           c:=substr(pBody,++k,1)
                           if c=="(" .or. c=="'"
                              ++ctaPar
                              //swComplex:=.T.
                           elseif c==")" .or. c=="'"
                              --ctaPar
                              //if ctaPar==0   // cerró el único parentesis, el principal. No es complejo.
                              //   swComplex:=.T.
                           elseif c==chr(34)
                              pString+=c
                              while c!=chr(10) 
                                 //c:=substr(linea,++k,1)
                                 c:=substr(pBody,++k,1)
                                 pString+=c
                                 if c=="\"
                                    //c:=substr(linea,++k,1)
                                    c:=substr(pBody,++k,1)
                                    pString+=c
                                 elseif c==chr(34)
                                   // pString:=substr(pString,1,len(pString)-1)
                                    exit
                                 end
                              end
                              if c==chr(10) 
                                 _Error("string has not been closed (#define-4): "+_CR+GenMsg(chr(27)+"[1m"+pBody+chr(27)+"[0m"),lineafisica)
                              end
                              loop
                           end
                           // else
                              pString+=c
                           //end
                        end
                        if c==chr(10)
                           _Error("Unbalanced parentheses: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m"),lineaFisica)
                        end
                     elseif c=="," //.or. c==";"
                        if len(DEFVAR[i])>1
                           ++k
                           exit
                        else
                           pString+=c
                           c:=""
                        end
                     else
                        pString+=c
                     end
                     ++k
                  end
                  pString:=alltrim(pString)
                  pBody:=substr(pBody,k,len(pBody))
                 // ? "pBODY(2)=",pBody
                 // ? "---> pSTRING =",pString
                 // ? "SWCOMPLEX(2) = ",swComplex

                 // if !swComplex
                 //    pString:="{ "+pString+" }"
                 // end
                 // ?">>>pSTRING : ", pString, " swComplex : ", iif(swComplex,".T.",".F.")
                 // ?">>>DEFVAR   : ", DEFVAR[i][j]
                 
                 // Busca por elementos del argumento en la línea procesada.
                 /* EVAUACION #ATOM#CMPLX:
                    Esta evaluación antes se hacía afuera, porque consideraba que solo debia hacerse
                    con funciones que tuviesen un solo argumento.
                    Para añadir más argumentos, se debe asegurarse de que los primeros argumentos son
                    #ATOM#CMPLX, y los últimos, normales. Si se intercalan argumentos normales, o se
                    ponen al principio, la evaluación fallará, porque no hay manera de saber dónde se
                    ubica el #ATOM#CMPLX dentro de la línea.
                    */
                  if len(alltrim(pString))>0
                   // ? "ANTES   tBODY= ",tBody
                    //? "----> pString= ",pString

                    //tBody:=strtran(tBody,DEFVAR[i][j],pString) //,tPos,1)
                    // decisión: cambio todos los #ATOMF, o solo uno?
                    posAtom:=at("#ATOM",tBody)
                    posFatom:=at("#FATOM",tBody)
                    pillAtom:=NULL
                    if posAtom>0 .and. posFatom>0 //.or. "#CMPLX" $ tBody
                       if posAtom < posFatom
                          pillAtom:="#ATOM"
                       else
                          pillAtom:="#FATOM"
                       end
                      // ?" PILL = ",pillAtom
                       //?" pSTRING = ",pString
                       if "(" $ pString .or. ")" $ pString .or. "["$pString .or. "]"$pString.or.";"$pString;
                          .or."{"$pString.or."}"$pString.or."++"$pString.or."--"$pString.or."?"$pString
                          tBody:=strtran(tBody,pillAtom,"",1,1)
                          tBody:=strtran(tBody,"#CMPLX",pString,1,1)
                          if substr(pString,1,1)=="~"
                             pString:=substr(pString,2,len(pString))
                          end
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#IF",tBody),(at("#ELSE",tBody)+5)-at("#IF",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#EIF","",1,1)
                          end
                       else
                          tBody:=strtran(tBody,"#CMPLX","",1,1)
                          if substr(pString,1,1)=="~"
                             pString:=substr(pString,2,len(pString))
                             tBody:=strtran(tBody,pillAtom,pString,1,1)
                          else
                             
                             if pillAtom=="#FATOM"
                                tBody:=strtran(tBody,pillAtom,pString,1,1)
                             else
                                tBody:=strtran(tBody,pillAtom,"{"+pString+"}",1,1)
                             end
                          end
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#ELSE",tBody),(at("#EIF",tBody)+4)-at("#ELSE",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#IF","",1,1)
                          end
                       end
                    elseif "#FATOM" $ tBody
                       if "(" $ pString .or. ")" $ pString .or. "["$pString .or. "]"$pString.or.";"$pString;
                          .or."{"$pString.or."}"$pString.or."++"$pString.or."--"$pString.or."?"$pString
                          if substr(pString,1,1)=="~"
                             pString:=substr(pString,2,len(pString))
                          end
                          tBody:=strtran(tBody,"#FATOM","",1,1)
                          tBody:=strtran(tBody,"#CMPLX",pString,1,1)
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#IF",tBody),(at("#ELSE",tBody)+5)-at("#IF",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#EIF","",1,1)
                          end
                       else
                          tBody:=strtran(tBody,"#CMPLX","",1,1)
                          if substr(pString,1,1)=="~"
                             pString:=substr(pString,2,len(pString))
                             tBody:=strtran(tBody,"#FATOM",pString,1,1)
                          else
                             //tBody:=strtran(tBody,"#ATOMF","{"+pString+"}",1,1)
                             tBody:=strtran(tBody,"#FATOM",pString,1,1)
                          end
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#ELSE",tBody),(at("#EIF",tBody)+4)-at("#ELSE",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#IF","",1,1)
                          end
                       end
                     /*  if swComplex                             
                          tBody:=strtran(tBody,"#ATOMF","",1,1)
                          tBody:=strtran(tBody,"#CMPLX",pString,1,1)
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#IF",tBody),(at("#ELSE",tBody)+5)-at("#IF",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#EIF","",1,1)
                          end
                       else
                          tBody:=strtran(tBody,"#CMPLX","",1,1)
                          if substr(pString,1,1)=="~"
                             pString:=substr(pString,2,len(pString))
                             tBody:=strtran(tBody,"#ATOMF",pString,1,1)
                          else
                             //tBody:=strtran(tBody,"#ATOMF","{"+pString+"}",1,1)
                             tBody:=strtran(tBody,"#ATOMF",pString,1,1)
                          end
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#ELSE",tBody),(at("#EIF",tBody)+4)-at("#ELSE",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#IF","",1,1)
                          end
                       end */
                    elseif "#ATOM" $ tBody
                       if "(" $ pString .or. ")" $ pString .or. "["$pString .or. "]"$pString.or.";"$pString;
                          .or."{"$pString.or."}"$pString.or."++"$pString.or."--"$pString.or."?"$pString
                          if substr(pString,1,1)=="~"
                             pString:=substr(pString,2,len(pString))
                          end
                          tBody:=strtran(tBody,"#ATOM","",1,1)
                          tBody:=strtran(tBody,"#CMPLX",pString,1,1)
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#IF",tBody),(at("#ELSE",tBody)+5)-at("#IF",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#EIF","",1,1)
                          end
                       else
                          tBody:=strtran(tBody,"#CMPLX","",1,1)
                          
                          if substr(pString,1,1)=="~" // esto estaba comentado
                             pString:=substr(pString,2,len(pString))
                             tBody:=strtran(tBody,"#ATOM",pString,1,1)
                          else // hasta aqui
                             tBody:=strtran(tBody,"#ATOM","{"+pString+"}",1,1)
                          end
                          
                          //tBody:=strtran(tBody,"#ATOM","{"+pString+"}",1,1)
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#ELSE",tBody),(at("#EIF",tBody)+4)-at("#ELSE",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#IF","",1,1)
                          end
                       end

                   /*    if swComplex
                          tBody:=strtran(tBody,"#ATOM","",1,1)
                          tBody:=strtran(tBody,"#CMPLX",pString,1,1)
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#IF",tBody),(at("#ELSE",tBody)+5)-at("#IF",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#EIF","",1,1)
                          end
                       else
                          tBody:=strtran(tBody,"#CMPLX","",1,1)
                          
                          if substr(pString,1,1)=="~" // esto estaba comentado
                             pString:=substr(pString,2,len(pString))
                             tBody:=strtran(tBody,"#ATOM",pString,1,1)
                          else // hasta aqui
                             tBody:=strtran(tBody,"#ATOM","{"+pString+"}",1,1)
                          end
                          
                          //tBody:=strtran(tBody,"#ATOM","{"+pString+"}",1,1)
                          if "#IF" $ tBody
                             porc:=substr(tBody,at("#ELSE",tBody),(at("#EIF",tBody)+4)-at("#ELSE",tBody))
                             tBody:=strtran(tBody,porc,"",1,1)
                             tBody:=strtran(tBody,"#IF","",1,1)
                          end
                       end
                      */
                   /* elseif "#CMPLX" $ tBody
                       tBody:=strtran(tBody,"#CMPLX",pString,1,1)
                    */
                    else
                       tBody:=strtran(tBody,DEFVAR[i][j],pString) //,tPos,1)
                    end
                    // ? "DESPUES tBODY=",tBody
                     //? ">>>>>>>>>>>>>>",tBody
                  else
                     
                     /* que tal si en vez de error, reemplazo argumento faltante por espacio? */
                     /* MOD_23022021 */
                     //_Error("macro arguments incomplete: "+GenMsg(chr(27)+"[1m"+DEF[i]+chr(27)+"[0m"),lineaFisica)
                     tBody:=strtran(tBody,DEFVAR[i][j],NULL) //,tPos,1)
                     if swWarning
                        printmsg("Line: "+alltrim(str(lineaFisica))+" => "+chr(27)+"[35mwarning"+chr(27)+;
                                 "[0m"+": macro "+GenMsg(chr(27)+"[1m"+DEF[i]+chr(27)+"[0m")+;
                                 " arg "+GenMsg(chr(27)+"[1m"+DEFVAR[i][j]+chr(27)+"[0m")+" set but not used"+_CR)
                        //? "Tbody=",tBody
                     end
                  end
               end
            end
            /* SEGUN MODIFICACION MOD_23022021: eliminar "{}" de tbody. Las comas son despreciables */
            
            tbody:=strtran(tbody,"{}","")
            if "()" $ tbody .and. !("#LOOP" $ tbody)
                //? tbody;?
               _Error("macro arguments incomplete: "+GenMsg(chr(27)+"[1m"+DEF[i]+chr(27)+"[0m"),lineaFisica)
            end
            
            linea:=pLinea+tBody+pLineaFin
         //   ? "linea >>> ",linea
         // ?" >>>pSTRING = ",pString
         // ?"    OLD     = ",linea
          /*  if "#VOID" $ pString
               pString:=strtran(pString,"#VOID","")
            end */
          /*  if "#ATOM" $ linea
              if swComplex
                linea:=strtran(linea,"#ATOM","",1)
                linea:=strtran(linea,"#CMPLX",pString,1)
              else
                linea:=strtran(linea,"#CMPLX","",1)
                linea:=strtran(linea,"#ATOM","{"+pString+"}",1)
              end

            end */
         // ?"    NEW     = ",linea
            pBody:=NULL
            
            // nPos:=at(DEF[i],linea)
            nPos:=atnum(DEF[i],linea,1,ignore)
            if nPos==tPos
               
               //ignore:=nPos+1
               if linea==Temp_linea
                  ignore:=nPos+1
                  Temp_linea:=linea
               end

               nPos:=atnum(DEF[i],linea,1,ignore)
            end
            tPos:=nPos
           // ? "OUT LINEA= ",linea
         end
      end
   end  // if DEF[i] $ xxxx
end  // FOR i

// aqui iba rescate de "piturro"

/*if swComplex
   strComplex:=pString
   ?"strComplex= ",strComplex; ?
else
   strComplex:="{"+pString+"}"
//   ?"strAtom= ",strComplex
end*/
/*?"#LINEA = ",linea
if len(pString)>0
   ?"pSTRING= ",pString
end*/


/* veifica si hay que crear variables aleatorias */
/* esto implica que no deben ponerse 2 ciclos en una misma linea */
/* MOD (17-12-2021): debo meterlo al WHILE, y debo crear una pila, así tomará cada #RAND, y reemplazará cada #RNDV en su 
   contexto correcto.
   Esto me obliga a definir #RAND y %RAND. 
    */
/*if "#RAND" $ linea
   newLabel:=alltrim(str(int(hb_random()*1000000)))
   linea:=strtran(linea,"#RNDV",newLabel,1,100)
   linea:=strtran(linea,"#RAND","")
end */

if "#GENCODE" $ linea
  // ?"LINEA >> ", linea
   linea := Reemplaza_Gencode(linea,lineafisica)
  // ?"LINEA << ", linea 
end

/*cntError:=0
while "#GENCODE" $ linea   // es una iteración de codigo!
   pLateralIzq:=substr(linea,1,at("#GENCODE",linea)-1)
   pLateralDer:=substr(linea,at("#ENDGEN",linea)+7,len(linea))
   cPorcion:=strtran(linea,pLateralIzq,"")
   cPorcion:=strtran(cPorcion,pLateralDer,"")
   cPorcion:=strtran(cPorcion,"#GENCODE","")
   cPorcion:=alltrim(strtran(cPorcion,"#ENDGEN",""))
   cLista:=substr(cPorcion,4,len(cPorcion))
   cPorcion:=substr(cPorcion,rat("$$$",cPorcion)+3,len(cPorcion))
   cLista:=substr(cLista,1,at("$$$",cLista)-1)
  // ? "ITERA = ", cPorcion
  // ? "CLISTA= ",cLista
   nLista:=numtoken( cLista, "," )
   ntok:=1
   nBase:=1
   nBakBase:=nLista
   pString:=NULL
   cTLinea:=NULL
   cLastHere:=""
   swConteo:=.T.
   if "#REVITV" $ cPorcion
      swConteo:=.F.
   end
   if "#HERE" $ cPorcion
      newLabel:="__HERE__"+alltrim(str(int(hb_random()*1000000000)))
      cPorcion:=strtran(cPorcion,"#HERE",newLabel)
      cLastHere:=","+newLabel+":,"
   end
   if "#REVLIST" $ cPorcion     // toma la lista al reves, o sea, sirve para cosas sacadas del stack
      while( nLista>0 )
         cValor:=token(cLista,",",nLista--)
         ///?" cVALOR=", cValor
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         cTLinea += strtran(pString,"#REVLIST",cValor)
      end
   elseif "#LIST" $ cPorcion
      while( ntok <= nLista )
         cValor:=token(cLista,",",ntok++)
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         cTLinea += strtran(pString,"#LIST",cValor)
      end
   elseif "#ATCMLIST" $ cPorcion
      while( ntok <= nLista )
         cValor:=token(cLista,",",ntok++)
         ///?" cVALOR=", cValor
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         if "(" $ cValor .or. ")" $ cValor .or. "["$cValor .or. "]"$cValor.or.";"$cValor.or."~"$cValor;
            .or."{"$cValor.or."}"$cValor.or."++"$cValor.or."--"$cValor.or."?"$cValor
            if "~" $ cValor
               cValor:=substr(cValor,2,len(cValor))
            end
            cTLinea += strtran(pString,"#ATCMLIST",cValor)
         else
            cTLinea += strtran(pString,"#ATCMLIST","{"+cValor+"}")
         end
      end
      ///pString := strtran(cPorcion,"#ITVCNT",alltrim(str(nBase-1)))
   elseif "#REVATCMLIST" $ cPorcion
      while( nLista>0 )
         cValor:=token(cLista,",",nLista--)
         ///?" cVALOR=", cValor
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         if "(" $ cValor .or. ")" $ cValor .or. "["$cValor .or. "]"$cValor.or.";"$cValor.or."~"$cValor;
            .or."{"$cValor.or."}"$cValor.or."++"$cValor.or."--"$cValor.or."?"$cValor
            if "~" $ cValor
               cValor:=substr(cValor,2,len(cValor))
            end
            cTLinea += strtran(pString,"#REVATCMLIST",cValor)
         else
            cTLinea += strtran(pString,"#REVATCMLIST","{"+cValor+"}")
         end
      end   
   end
   linea:=pLateralIzq + cTLinea + cLastHere + pLateralDer 
   
   if ++cntError == 50
      _Error("user-macro #GENCODE expanded error: recursive declaration",lineafisica)
   end
end*/
//?"LINEA=",linea
/* rescate de strings desde los code */

if len(tLinea)>2
   if len(tLinea)==3  // solo hay un rescate: podría estar distribuido por el cambio de macros complejas.
      linea:=strtran(linea,"p1i2t3u4r5r6o",tLinea[2])
   else
      for _i:=2 to len(tLinea)-1
         //? "         proceso: ",tLinea[_i]
         linea:=strtran(linea,"p1i2t3u4r5r6o",tLinea[_i],1,1)
      next
   end
   //? "linea rescatada: ",linea
end

linea:=strtran(linea,"#APTFE",chr(34))

if "p1i2t3u4r5r6o" $ linea
   _Error("user-macro expanded error: let the strings into #RAND-vars, and use this #RAND-vars in your macro-body",lineafisica)
end
/* analiza si hay &( para rescatar contenido y dejar en stack especial, para break, brkif, etc */
/* mismo para # y $ */
nLen:=len(linea)
i:=0

newLabel:=NULL
/* GO! */
//? ">>> LINEA= ",linea
while i<=nLen
   c:=substr(linea,++i,1)
   // debo saltarme los strings
  // ?" porcion = ", substr(linea,i,len(linea))
   if c==chr(34)
      while c!=chr(10) 
         c:=substr(linea,++i,1)
         if c=="\"
            c:=substr(linea,++i,1)
         elseif c==chr(34)
            exit
         end
      end
      //? "LINEA:"+substr(linea,1,i)
      if c==chr(10) 
         _Error("string has not been closed (#define-5): "+_CR+GenMsg(chr(27)+"[1m"+linea+chr(27)+"[0m"),lineafisica)
      end
   //
   elseif c=="&"   // gotcha!
      if substr(linea,i+1,1)!="="  // es un operador. no pesca.
      sw:=.T.
      pString:=NULL
      while i<=nLen .and. sw
         c:=substr(linea,++i,1)
         ctaPar:=0
         if c=="("
            //pString+=c  // no incluye "("
            ++ctaPar
            while ctaPar > 0 .and. sw
               c:=substr(linea,++i,1)
               if c=="("
                  ++ctaPar
               elseif c==")"
                  --ctaPar
                  if ctaPar==0  // legó al final de la expresion
                     sw:=.F.
                     exit
                  end
               end
               pString+=c
            end
         end
      end
      ++i
      linea:=substr(linea,i,len(linea))  // aislo la porcion de la expresion
      nLen:=len(linea)
      i:=0
      /* verifico #RNDV en pString */
      if "#RNDV" $ pString
         if len(DEFRANDVAR)>0
            newLabel:=atail(DEFRANDVAR)
         else
            _Error("don't find #RAND declaration?: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
         end
         
        // ? "LINEA PORCION=",pString
         pString:=strtran(pString,"#RNDV",newLabel)
        // ? "LINEA PORCION=",pString
      end
      //? "CAPTURA &()=", pSTRING
      /* guardo! */
      stackpush(DEFEXPRE,pString)
      end
     // ?"LINEA = ",linea
   elseif c=="%"   // ver donde hace pop, o si solo leer.
      if substr(linea,i+1,1)!="="  // es un operador. no pesca.
      c:=substr(linea,++i,1)
      if c=="&"   // expresion de FOR
         if len(DEFEXPRE)>0
            expresion := stackpop(DEFEXPRE)
         else
            _Error("(macro)flow-struct bad formed: "+_CR+GenMsg(chr(27)+"[1m"+linea+chr(27)+"[0m"),lineafisica)
         end
         
         linea:=strtran(linea,"%&",expresion,1,1)
         nLen:=len(linea)
      elseif c=="%"   // es lectura de stack especial
         c:=substr(linea,++i,1)
         if c=="&"   // expresion
            if len(DEFEXPRE)>0
               expresion := atail(DEFEXPRE)
            else
               _Error("(macro)flow-struct bad formed: "+_CR+GenMsg(chr(27)+"[1m"+linea+chr(27)+"[0m"),lineafisica)
            end

            linea:=strtran(linea,"%%&",expresion,1,1)
            nLen:=len(linea)
         else
            pString:="%%"+c
            while i<=nLen
               c:=substr(linea,++i,1)
               if !isalpha(c)
                  exit
               end
               pString+=c
            end
            if pString=="%%LOOP"
               if len(DEFLOOP)>0
                  newLabel:=atail(DEFLOOP)
               else
                  _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
               end
               linea:=strtran(linea,pString,newLabel,1,1)
               nLen:=len(linea)
            elseif pString=="%%ENDLOOP"
               if len(DEFENDLOOP)>0
                  newLabel:=atail(DEFENDLOOP)
               else
                  _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
               end
               linea:=strtran(linea,pString,newLabel,1,1)
               nLen:=len(linea)
            elseif pString=="%%ENDIF"
               if len(DEFENDIF)>0
                  newLabel:=atail(DEFENDIF)
               else
                  _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
               end
               linea:=strtran(linea,pString,newLabel,1,1)
               nLen:=len(linea)
            elseif pString=="%%CODESW"
               if len(DEFCODESW)>0
                  newLabel:=atail(DEFCODESW)
               else
                  _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
               end
               linea:=strtran(linea,pString,newLabel,1,1)
               nLen:=len(linea)
            elseif pString=="%%CODEIF"
               if len(DEFCODEIF)>0
                  newLabel:=atail(DEFCODEIF)
               else
                  _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
               end
               linea:=strtran(linea,pString,newLabel,1,1)
               nLen:=len(linea)
            elseif pString=="%%MARK"
               if len(DEFCODEMARK)>0
                  newLabel:=atail(DEFCODEMARK)
               else
                  _Error("(macro-mark) don't find #CODEMARK declaration?: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
               end
               linea:=strtran(linea,pString,newLabel,1,1)
               nLen:=len(linea)
            else
               _Error("unrecognized internal macro code: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineaFisica)
            end
         end
      else  // es un label.
         pString:="%"+c
         while i<=nLen
            c:=substr(linea,++i,1)
            if !isalpha(c)
               exit
            end
            pString+=c
         end
         if pString=="%LOOP"
            if len(DEFLOOP)>0
               newLabel:=stackpop(DEFLOOP)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%MARK"
            if len(DEFCODEMARK)>0
               newLabel:=stackpop(DEFCODEMARK)
            else
               _Error("(macro-mark) don't find #CODEMARK declaration?: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%RAND"
            if len(DEFRANDVAR)>0
               newLabel:=stackpop(DEFRANDVAR)
            else
               _Error("don't find #RAND declaration?: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            newLabel:=NULL
            linea:=strtran(linea,pString,"",1,1)
            nLen:=len(linea)
            i-=6

         elseif pString=="%ENDLOOP"
            if len(DEFENDLOOP)>0
               newLabel:=stackpop(DEFENDLOOP)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%ENDIIF"
            if len(DEFENDIIF)>0
               newLabel:=stackpop(DEFENDIIF)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%ENDIF"
            if len(DEFENDIF)>0
               newLabel:=stackpop(DEFENDIF)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%CATCH"
            if len(DEFCATCH)>0
               newLabel:=stackpop(DEFCATCH)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%ENDCATCH"
            if len(DEFENDCATCH)>0
               newLabel:=stackpop(DEFENDCATCH)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%CODESW"
            if len(DEFCODESW)>0
               newLabel:=stackpop(DEFCODESW)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         elseif pString=="%CODEIF"
            if len(DEFCODEIF)>0
               newLabel:=stackpop(DEFCODEIF)
            else
               _Error("(macro)flow-struct bad formed: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
         else
            _Error("unrecognized internal macro code: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+linea,lineafisica)
         end
      end
      end
     // ?"LINEA = ",linea
   elseif c=="#"   // label! LOOP=push, ENDLOOP=pop
      c:=substr(linea,i+1,1)
      if c!="#"
         pString:="#"
         while i<=nLen
            c:=substr(linea,++i,1)
            if !isalpha(c)
               exit
            end
            pString+=c
         end
        // ? "CODIGO # = ",pString
         if pString=="#RAND"   // creo un set de variables fantasmas
            newLabel:=alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFRANDVAR, newLabel)
            linea:=strtran(linea,pString,"",1,1)
            nLen:=len(linea)
            i-=5
/*            
            ? "LINEA=",linea
            ? "I=",i */

         elseif pString=="#RNDV"
            if len(DEFRANDVAR)>0
               newLabel:=atail(DEFRANDVAR)
            else
               _Error("don't find #RAND declaration?: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
            end
            //? ">>>LINEA=",linea
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
            i-=5
            i+=len(newLabel)
            //? "<<<LINEA=",substr(linea,1,i-1)," [ ",substr(linea,i,1)," ] ", substr(linea,i+1,len(linea))
            //? "I= ",i
         elseif pString=="#LOOP"   // inicia lbel de ciclo:
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFLOOP, newLabel)
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
            i+=17  // tamaño de ____CODE...
         elseif pString=="#ENDLOOP"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFENDLOOP,newLabel)
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
            i+=17
         elseif pString=="#ENDIIF"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFENDIIF,newLabel)
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
            i+=17
         elseif pString=="#ENDIF"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFENDIF,newLabel)
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
            i+=17
         elseif pString=="#CATCH"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFCATCH,newLabel)
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
            i+=17
         elseif pString=="#ENDCATCH"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFENDCATCH,newLabel)
            linea:=strtran(linea,pString,newLabel,1,1)
            nLen:=len(linea)
            i+=17

/*         elseif pString=="#OPTIMLOG" //.or. upper(pString)==".OPL.".or. upper(pString)==".OPI."
            ; */
/*         elseif pString=="#ATOM"
            if swComplex
               linea:=strtran(linea,pString,"",1)
//               i-=6
            else
               linea:=strtran(linea,pString,strComplex,1)
//               i-=6//+=len(strComplex)
            end
            nLen:=len(linea)
            i-=6
//            ? "#ATOM LINEA= ",linea, " I=",i
         elseif pString=="#CMPLX"
            if swComplex
               linea:=strtran(linea,pString,strComplex,1)
//               i-=7
            else
               linea:=strtran(linea,pString,"",1)
//               i-=7 //+=len(strComplex)
            end
            nLen:=len(linea)
            i-=7
//            ? "#CMPLX LINEA= ",linea
*/
/*         elseif pString=="#RAND"
            newRandLabel:=alltrim(str(int(hb_random()*1000000)))
            linea:=strtran(linea,"#RAND","",1,1)
            i-=5
         elseif pString=="#RNDV"
            linea:=strtran(linea,"#RNDV",newRandLabel,1,1)
            i+=len(newRandLabel)-5*/
         elseif pString=="#VOID"
            linea:=strtran(linea,pString,"",1)
            i-=5 
         else
            _Error("unrecognized internal macro code: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
         end
      else
         ++i
         pString:="##"
         while i<=nLen
            c:=substr(linea,++i,1)
            if !isalpha(c)
               exit
            end
            pString+=c
         end
         if pString=="##ENDLOOP"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFENDLOOP,newLabel)
            linea:=strtran(linea,pString,"",1,1)
            nLen:=len(linea)
           // ?" LINEA SIN ##ENDLOOP = ", linea
           // ?" NEWLABEL=", newLabel
            i-=10
         elseif pString=="##CODEMRK"   // codigo ue será usado en una estructura cualquiera
            newLabel:="__MARK__"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFCODEMARK,newLabel)
            linea:=strtran(linea,pString,"",1,1)
            nLen:=len(linea)
            i-=10
         elseif pString=="##CODESW"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFCODESW,newLabel)
            linea:=strtran(linea,pString,"",1,1)
            nLen:=len(linea)
            i-=9
         elseif pString=="##CODEIF"
            newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
            stackpush(DEFCODEIF,newLabel)
            linea:=strtran(linea,pString,"",1,1)
            nLen:=len(linea)
            i-=9
         else
            _Error("unrecognized internal macro code: "+GenMsg(chr(27)+"[1m"+pString+chr(27)+"[0m")+" : "+_CR+linea,lineafisica)
         end
      end
     // ?"LINEA = ",linea
   end
   
end
if len(DEFRANDVAR)>0
   _Error("macro "+GenMsg(chr(27)+"[1m"+"#RAND"+chr(27)+"[0m")+" not closed in line:"+_CR+linea,lineafisica)
end
/*if "#OPTIMLOG" $ linea
  // ?">>> LINEA = ",linea
   if (".apl." $ linea)
      pString1:=substr(linea,1,at("#OPTIMLOG",linea)-1)
      porcionTmp:=substr(linea,at("#OPTIMLOG",linea)+9,len(linea))
      porcion:=substr(porcionTmp,1,at("#OPTIMLOG",porcionTmp)-1)
      pString2:=substr(porcionTmp,at("#OPTIMLOG",porcionTmp)+9,len(porcionTmp))
      
      newLabelLoop:=atail(DEFENDLOOP)
      porcion:=strtran(porcion,".apl.",";jsnt("+newLabelLoop+");")
      linea:=pString1 + porcion + pString2
   end
   if (".opl." $ linea)
     // ? " ENTRA AQUI "; ? ">>>",linea
      pString1:=substr(linea,1,at("#OPTIMLOG",linea)-1)
      porcionTmp:=substr(linea,at("#OPTIMLOG",linea)+9,len(linea))
      porcion:=substr(porcionTmp,1,at("#OPTIMLOG",porcionTmp)-1)
      pString2:=substr(porcionTmp,at("#OPTIMLOG",porcionTmp)+9,len(porcionTmp))
      
      newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
      porcion:=strtran(porcion,".opl.",";jst("+newLabel+");")
      linea:=pString1 + porcion + pString2 + ";" + newLabel + ":"
   end
   if (".api." $ linea)
      pString1:=substr(linea,1,at("#OPTIMLOG",linea)-1)
      porcionTmp:=substr(linea,at("#OPTIMLOG",linea)+9,len(linea))
      porcion:=substr(porcionTmp,1,at("#OPTIMLOG",porcionTmp)-1)
      pString2:=substr(porcionTmp,at("#OPTIMLOG",porcionTmp)+9,len(porcionTmp))

      newLabelIF:=atail(DEFENDIF)
      porcion:=strtran(porcion,".api.",";jsnt("+newLabelIF+");")
      linea:=pString1 + porcion + pString2
   end
   if (".opi." $ linea)
      pString1:=substr(linea,1,at("#OPTIMLOG",linea)-1)
      porcionTmp:=substr(linea,at("#OPTIMLOG",linea)+9,len(linea))
      porcion:=substr(porcionTmp,1,at("#OPTIMLOG",porcionTmp)-1)
      pString2:=substr(porcionTmp,at("#OPTIMLOG",porcionTmp)+9,len(porcionTmp))

      newLabel:="____CODE_JUMP____"+alltrim(str(int(hb_random()*1000000000)))
      porcion:=strtran(porcion,".opi.",";jst("+newLabel+");")
      linea:=pString1 + porcion + pString2 + ";" + newLabel + ":"
   end
   if "#OPTIMLOG" $ linea  // no se usaron macros: eliminar tag
      linea:=strtran(linea,"#OPTIMLOG","")
   end
end*/
if ";;;" $ linea
    linea:=strtran(linea,";;;",";")
end
if ";;" $ linea
    linea:=strtran(linea,";;",";")
end
if ";," $ linea
    linea:=strtran(linea,";,",",")
end
if ",;" $ linea
    linea:=strtran(linea,",;",",")
end
//?"<<< LINEA FINAL = ",linea
return linea

function Reemplaza_Gencode(linea,lineafisica)
local cntError:=0, ntop:=0, nbottom:=0,i:=0,c:=""

while "#GENCODE" $ linea   // es una iteración de codigo!

   /* busca desde atrás para adelante cada #GENCODE */
   
   ntop:=rat("#GENCODE",linea)
   /* encontrar el primer #ENDGEN desde ntop */
   //nbottom:=rat("#ENDGEN",linea)+7
   for i:=ntop+1 to len(linea)
       //? "-----SUB: ",substr(linea,i,7)
       if substr(linea,i,7)=="#ENDGEN"
           nbottom:=i+7
           exit
       end
   end
 //  ? "----- nTOP= ",ntop," nBOTTOM= ",nbottom
   pLateralIzq:=substr(linea,1,ntop-1)  // rescato todo a la izquierda
   pLateralDer:=substr(linea,nbottom,len(linea))  // rescato todo desde #ENDGEN a la derecha.
   cPorcion:=substr(linea,ntop, nbottom-ntop)  // rescato porcion a analizar.
 //  ? "----- CPORCION= ",cPorcion
   /* elimino #GENCODE y #ENDGEN de la porcion */
   cPorcion:=strtran(cPorcion,"#GENCODE","")
   cPorcion:=alltrim(strtran(cPorcion,"#ENDGEN",""))
//   ? "----- CPORCION= ",cPorcion
   /*busco lista de argumentos de este #GENCODE */
   cLista:=substr(cPorcion,4,len(cPorcion))
   // actualizo porcion como lo que sigue de la lista de argumentos:
   cPorcion:=substr(cPorcion,rat("$$$",cPorcion)+3,len(cPorcion))
   // acoto el string de argumentos:
   cLista:=substr(cLista,1,at("$$$",cLista)-1)
 //  ?"----- CLISTA= ",cLista
   
/*   pLateralIzq:=substr(linea,1,at("#GENCODE",linea)-1)
   pLateralDer:=substr(linea,at("#ENDGEN",linea)+7,len(linea))
   cPorcion:=strtran(linea,pLateralIzq,"")
   cPorcion:=strtran(cPorcion,pLateralDer,"")
   cPorcion:=strtran(cPorcion,"#GENCODE","")
   cPorcion:=alltrim(strtran(cPorcion,"#ENDGEN",""))
   
   cLista:=substr(cPorcion,4,len(cPorcion))
   cPorcion:=substr(cPorcion,rat("$$$",cPorcion)+3,len(cPorcion))
   cLista:=substr(cLista,1,at("$$$",cLista)-1) */
  // ? "ITERA = ", cPorcion
  // ? "CLISTA= ",cLista


   nLista:=numtoken( cLista, "," )
   ntok:=1
   nBase:=1
   nBakBase:=nLista
   pString:=NULL
   cTLinea:=NULL
   cLastHere:=""
   swConteo:=.T.
   if "#REVITV" $ cPorcion
      swConteo:=.F.
   end
   if "#HERE" $ cPorcion
      newLabel:="__HERE__"+alltrim(str(int(hb_random()*1000000000)))
      cPorcion:=strtran(cPorcion,"#HERE",newLabel)
      cLastHere:=","+newLabel+":,"
   end
   if "#REVLIST" $ cPorcion     // toma la lista al reves, o sea, sirve para cosas sacadas del stack
      while( nLista>0 )
         cValor:=token(cLista,",",nLista--)
         ///?" cVALOR=", cValor
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         cTLinea += strtran(pString,"#REVLIST",cValor)
      end
   elseif "#LIST" $ cPorcion
      while( ntok <= nLista )
         cValor:=token(cLista,",",ntok++)
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         cTLinea += strtran(pString,"#LIST",cValor)
      end
   elseif "#ATCMLIST" $ cPorcion
      while( ntok <= nLista )
         cValor:=token(cLista,",",ntok++)
         ///?" cVALOR=", cValor
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         if "(" $ cValor .or. ")" $ cValor .or. "["$cValor .or. "]"$cValor.or.";"$cValor.or."~"$cValor;
            .or."{"$cValor.or."}"$cValor.or."++"$cValor.or."--"$cValor.or."?"$cValor
            if "~" $ cValor
               cValor:=substr(cValor,2,len(cValor))
            end
            cTLinea += strtran(pString,"#ATCMLIST",cValor)
         else
            cTLinea += strtran(pString,"#ATCMLIST","{"+cValor+"}")
         end
      end
      ///pString := strtran(cPorcion,"#ITVCNT",alltrim(str(nBase-1)))
   elseif "#REVATCMLIST" $ cPorcion
      while( nLista>0 )
         cValor:=token(cLista,",",nLista--)
         ///?" cVALOR=", cValor
         if swConteo
            pString := strtran(cPorcion,"#ITV",alltrim(str(nBase++)))
         else
            pString := strtran(cPorcion,"#REVITV",alltrim(str(nBakBase--)))
         end
         if "(" $ cValor .or. ")" $ cValor .or. "["$cValor .or. "]"$cValor.or.";"$cValor.or."~"$cValor;
            .or."{"$cValor.or."}"$cValor.or."++"$cValor.or."--"$cValor.or."?"$cValor
            if "~" $ cValor
               cValor:=substr(cValor,2,len(cValor))
            end
            cTLinea += strtran(pString,"#REVATCMLIST",cValor)
         else
            cTLinea += strtran(pString,"#REVATCMLIST","{"+cValor+"}")
         end
      end   
   end
   linea:=pLateralIzq + cTLinea + cLastHere + pLateralDer 
   
   if ++cntError == 50
      _Error("user-macro #GENCODE expanded error: recursive declaration",lineafisica)
   end
end
return linea

procedure BloqueComentario(h_ini,h_fin,fp,fw,lineaFisica,c)
LOCAL cAnt:=""
while h_ini<=h_fin
  fread(fp,@c,1); ++h_ini
  if c=="*"
     fread(fp,@c,1); ++h_ini
     if c=="/"
        exit
     elseif c==chr(10)
        if fw!=0
           fwrite(fw,chr(10),1)
        end
        ++lineaFisica
     end
  elseif c=="/" .and. cAnt=="*"
     exit
  elseif c==chr(10)
     if fw!=0
        fwrite(fw,chr(10),1)
     end
     ++lineaFisica
  end
  cAnt:=c
end
return

procedure QuitaEspacio(h_ini,h_fin,fp,c)
while c==" " .and. h_ini<=h_fin  // quito espacios de mas
  fread(fp,@c,1); ++h_ini
end
return

function BUSCALINEASBLANCAS(pBodyDef)
LOCAL i,s,nLineas,pLinea:=""
nLineas:=mlcount(pBodyDef,4096)
for i:=1 to nLineas-1
   s:=alltrim(Memoline(pBodyDef,4096,i))
   if len(s)>0
      pLinea+=s+_CR
   end
end
s:=alltrim(Memoline(pBodyDef,4096,i))
if len(s)==0
   pLinea:=substr(pLinea,1,len(pLinea)-1)
else
   pLinea+=s
end

return pLinea

Procedure _Error(bajada,linea)

//  fwrite(1,file+" : line ‘"+alltrim(str(linea))+"’ : "+bajada+_CR)
//  fwrite(1,file+" : line "+GenMsg(alltrim(str(linea)))+" : "+bajada+_CR)
  printmsg(_CR+file+":line "+GenMsg(alltrim(str(linea)))+" => "+chr(27)+"[38;5;202merror"+chr(27)+"[0m: "+bajada+_CR)
  
  _vnum:= linea //val(_numbusca) 
  if valtype(_vnum)!="N"
     _vnum:=val(_vnum)
     linea:=_vnum
  end
  ActualLogDir:=dirname()+"/log" //+substr(file,rat("/",file)+1,len(file))+"err"
  if makedir( ActualLogDir ) ==0
     printmsg("Directory [ ",ActualLogDir," ] successfully created"+_CR)
  end
  // copiando archivo del error
  ActualLogDir+="/"+substr(file,rat("/",file)+1,len(file))+".err"
  if linea>0  
     printmsg("Place of error-->[ "+fileTemp+" ]:")
     if file(fileTemp)
         // cargo programa fuente, si existe
       //  if file(_fuente) 
            _v:=Memoread(fileTemp)
            printmsg(_CR+"          :")
            for _j:=_vnum-4 to _vnum+4
               _linea:=rtrim(Memoline(_v,2048,_j))
               /*if "//" $ _linea  //AT("//",_linea)>0 
                  _linea:=substr(_linea,1,at("//",_linea)-1)
               end
               if "/*" $ _linea //AT("/*",_linea)>0 
                  _linea:=substr(_linea,1,at("/*",_linea)-1)
               end*/
               if _j==_vnum
                  //setcolor("15/2")
                  if len(_linea)>MAXCOL()-15
                     _linea:=substr(_linea,1,MAXCOL()-15)+"..."
                  end
                  printmsg(_CR+hb_UTF8tostr(strzero(linea,5)+" >> "+chr(27)+"[38;5;202m"+_linea+chr(27)+"[0m"))
                  //setcolor("")
               else
                  printmsg(_CR+hb_UTF8tostr("         "+_linea ))
               end
            end
            printmsg(_CR+"          :"+_CR)
            //break
            printmsg("Copying to [ ../log/"+substr(ActualLogDir,rat("/",ActualLogDir)+1,len(ActualLogDir))+" ] for your visualization"+_CR)
        // end
     end 
//  end
     if file(filePhantom)
        ferase(filePhantom)
     end
  
     FileCopy(fileTemp,ActualLogDir)
     if file(fileTemp)
        ferase(fileTemp)
     end
  end // if linea>0: si es -1, no existe el archivo
  
  RELEASE ALL
 /// run(" rm /tmp/tmpFilePreproMurray_* ")
 //  SW_ERROR:=.T.
  QUIT

return

function ISNUMSPECIAL(pString,lineafisica)
local i,c,cS:="",t,l,pLinea,swS:=0
     pLinea:=pString
     l:=len(pString)
     cS:=substr(pString,1,1)
     if cS=='+' .or. cS=='-'
        c:=substr(pString,2,2)
        swS:=1
     else
        c:=substr(pString,1,2)
        cS:=""
     end
     t:=substr(pString,l,1)
     
     if c=="0x" .and. is_any(t,"b","o","h") // podria ser un numero especial...
        if swS==1
           pString:=substr(pString,4,l)
        else
           pString:=substr(pString,3,l)
        end
        l:=len(pString)-1
        pString:=substr(pString,1,l)

        if t=="b"     // es binario
           for i:=1 to l
              c:=substr(pString,i,1)
              if is_noall(c,"0","1")
                 _Error("Malformed binary number",lineafisica)
              end
           end
           pString:=hb_ntos(BINTODEC(pString))
        elseif t=="o"   // es octal
           for i:=1 to l
              c:=substr(pString,i,1)
              if !(c $ "01234567")
                 _Error("Malformed octal number",lineafisica)
              end
           end
           pString:=hb_ntos(OCTALTODEC(pString))
        elseif t=="h"    // es hexa
           for i:=1 to l
              c:=substr(pString,i,1)
              if !(c $ "0123456789ABCDEFabcdef")
                 _Error("Malformed hexadecimal number",lineafisica)
              end
           end
           pString:=hb_ntos(HEXATODEC(pString))
        end 
        pLinea:=cS+pString
     elseif ISNOTATION(pString)==1
       // ? "pString = ",pString
        //pLinea:=alltrim(str(FUNE2D(pString)))
        pLinea:=alltrim(hb_valtostr(FUNE2D(pString)))
       // ? "FINAL = ",pLinea
       // ?
     end

return pLinea

function BinToDec( cString )

   LOCAL nNumber := 0, nX
   LOCAL cNewString := AllTrim( cString )
   LOCAL nLen := Len( cNewString )

// si uso FOR nX:=1 TO nLen, harbour toma: FOR nX:=1 000237 nLen, por el #define!!

   for nX := 1 to nLen
      nNumber += ( At( SubStr( cNewString, nX, 1 ), "01" ) - 1 ) * ( 2 ^ ( nLen - nX ) )
      
   end

return nNumber

function OctalToDec( cString )

   LOCAL nNumber := 0, nX
   LOCAL cNewString := AllTrim( cString )
   LOCAL nLen := Len( cNewString )

   for nX := 1 to nLen
      nNumber += ( At( SubStr( cNewString, nX, 1 ), "01234567" ) - 1 ) * ( 8 ^ ( nLen - nX ) )
      
   end

return nNumber

function HexaToDec( cString )

   LOCAL nNumber := 0, nX
   LOCAL cNewString := AllTrim( upper( cString ) )
   LOCAL nLen := Len( cNewString )

   for nX := 1 to nLen
      nNumber += ( At( SubStr( cNewString, nX, 1 ), "0123456789ABCDEF" ) - 1 ) * ( 16 ^ ( nLen - nX ) )
      
   end

return nNumber

Procedure Genera_debug(stackPrg,numline,registros,typeRegistro,ctaReg,usedRegs)
local t,i,linea
     printmsg( "PROGRAMA ******************" + _CR+_CR)
     printmsg( "# REGS/DATOS   : "+strzero(stackPrg[1],4)+_CR)
     printmsg( "STACK SIZE     : "+strzero(stackPrg[2],4)+_CR)
     printmsg( "NO USADO       : "+strzero(stackPrg[3],4)+_CR)
     printmsg( "QUIEBRE (1=SI) : "+strzero(stackPrg[4],4)+_CR+_CR)
     // busca programa:

     for t:=5 to len(stackPrg)
        if numline[t]>0
            ++t
            exit
        end
     end
     
     for i:=t to len(stackPrg)
       linea:= "LF: "+strzero(i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
       printmsg( linea )
       switch ( stackPrg[i] )
          case 0 
              printmsg( "("+strzero(stackPrg[i],5)+") SPUSH"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
               exit
          case 1
              printmsg( "("+strzero(stackPrg[i],5)+") CPUSH"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
               exit
          case 2
              printmsg( "("+strzero(stackPrg[i],5)+") DPUSH"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
               exit
          case 3
              printmsg( "("+strzero(stackPrg[i],5)+") SLET"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
               exit
          case 4
              printmsg( "("+strzero(stackPrg[i],5)+") CLET"+_CR)
               linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
               exit
          case 5
              printmsg( "("+strzero(stackPrg[i],5)+") DLET"+_CR)
               linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
               exit
          case 6
              printmsg( "("+strzero(stackPrg[i],5)+") JMP"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 7
              printmsg( "("+strzero(stackPrg[i],5)+") JEQ"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 8
              printmsg( "("+strzero(stackPrg[i],5)+") JNEQ"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 9
              printmsg( "("+strzero(stackPrg[i],5)+") JLT"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 10
              printmsg( "("+strzero(stackPrg[i],5)+") JLE"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 11
              printmsg( "("+strzero(stackPrg[i],5)+") JGT"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 12
              printmsg( "("+strzero(stackPrg[i],5)+") JGE"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 13
              printmsg( "("+strzero(stackPrg[i],5)+") JT"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 14
              printmsg( "("+strzero(stackPrg[i],5)+") JNT"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 15
              printmsg( "("+strzero(stackPrg[i],5)+") JV"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 16
              printmsg( "("+strzero(stackPrg[i],5)+") JNV"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 17
              printmsg( "("+strzero(stackPrg[i],5)+") JZ"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 18
              printmsg( "("+strzero(stackPrg[i],5)+") JNZ"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 19
              printmsg( "("+strzero(stackPrg[i],5)+") JNEG"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 20
              printmsg( "("+strzero(stackPrg[i],5)+") JPOS"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 21
              printmsg( "("+strzero(stackPrg[i],5)+") GSUB"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 22
              printmsg( "("+strzero(stackPrg[i],5)+") JSUB"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 23
              printmsg( "("+strzero(stackPrg[i],5)+") EQ?"+_CR)
              exit
          case 24
              printmsg( "("+strzero(stackPrg[i],5)+") NEQ?"+_CR)
              exit
          case 25
              printmsg( "("+strzero(stackPrg[i],5)+") LT?"+_CR)
              exit
          case 26
              printmsg( "("+strzero(stackPrg[i],5)+") LE?"+_CR)
              exit
          case 27
              printmsg( "("+strzero(stackPrg[i],5)+") GT?"+_CR)
              exit
          case 28
              printmsg( "("+strzero(stackPrg[i],5)+") GE?"+_CR)
              exit
          case 29
              printmsg( "("+strzero(stackPrg[i],5)+") NEG?"+_CR)
              exit
          case 30
              printmsg( "("+strzero(stackPrg[i],5)+") POS?"+_CR)
              exit
          case 31
              printmsg( "("+strzero(stackPrg[i],5)+") ECIN? (EXACT-OCCURS-IN)"+_CR)
              exit
          case 32
              printmsg( "("+strzero(stackPrg[i],5)+") CIN? (OCCURS-IN)"+_CR)
              exit
          case 33
              printmsg( "("+strzero(stackPrg[i],5)+") ZERO?"+_CR)
              exit
          case 34
              printmsg( "("+strzero(stackPrg[i],5)+") VOID?"+_CR)
              exit
          case 35
              printmsg( "("+strzero(stackPrg[i],5)+") BETWEEN?"+_CR)
              exit
          case 36
              printmsg( "("+strzero(stackPrg[i],5)+") EMPTYSTACK?"+_CR)
              exit
          case 37
              printmsg( "("+strzero(stackPrg[i],5)+") ENV?"+_CR)
              exit
          case 38
              printmsg( "("+strzero(stackPrg[i],5)+") EXIST?"+_CR)
              exit
          case 39
              printmsg( "("+strzero(stackPrg[i],5)+") GETSTRERROR"+_CR)
              exit
          case 40
              printmsg( "("+strzero(stackPrg[i],5)+") ADD"+_CR)
              exit
          case 41
              printmsg( "("+strzero(stackPrg[i],5)+") SUB"+_CR)
              exit
          case 42
              printmsg( "("+strzero(stackPrg[i],5)+") MUL"+_CR)
              exit
          case 43
              printmsg( "("+strzero(stackPrg[i],5)+") DIV"+_CR)
              exit
          case 44
              printmsg( "("+strzero(stackPrg[i],5)+") IDIV"+_CR)
              exit
          case 45
              printmsg( "("+strzero(stackPrg[i],5)+") POW"+_CR)
              exit
          case 46
              printmsg( "("+strzero(stackPrg[i],5)+") MOD"+_CR)
              exit
          case 47
              printmsg( "("+strzero(stackPrg[i],5)+") ROUND"+_CR)
              exit
          case 48
              printmsg( "("+strzero(stackPrg[i],5)+") MAX"+_CR)
              exit
          case 49
              printmsg( "("+strzero(stackPrg[i],5)+") MIN"+_CR)
              exit
          case 50
              printmsg( "("+strzero(stackPrg[i],5)+") (UNUSED)"+_CR)
              exit
          case 51
              printmsg( "("+strzero(stackPrg[i],5)+") XTOBOOL"+_CR)
              exit
          case 52
              printmsg( "("+strzero(stackPrg[i],5)+") KBFREE"+_CR)
              exit
          case 53
              printmsg( "("+strzero(stackPrg[i],5)+") KEYPUT"+_CR)
              exit
          case 54
              printmsg( "("+strzero(stackPrg[i],5)+") RLEFT"+_CR)
              exit
          case 55
              printmsg( "("+strzero(stackPrg[i],5)+") RRIGHT"+_CR)
              exit
          case 56
              printmsg( "("+strzero(stackPrg[i],5)+") RALL"+_CR)
              exit
          case 57
              printmsg( "("+strzero(stackPrg[i],5)+") INF?"+_CR)
              exit
          case 58
              printmsg( "("+strzero(stackPrg[i],5)+") NAN?"+_CR)
              exit
          case 59
              printmsg( "("+strzero(stackPrg[i],5)+") CUT"+_CR)
              exit
          case 60
              printmsg( "("+strzero(stackPrg[i],5)+") LEN (STRING)"+_CR)
              exit
          case 61
              printmsg( "("+strzero(stackPrg[i],5)+") UPPER"+_CR)
              exit
          case 62
              printmsg( "("+strzero(stackPrg[i],5)+") LOWER"+_CR)
              exit
          case 63
              printmsg( "("+strzero(stackPrg[i],5)+") TRIM"+_CR)
              exit
          case 64
              printmsg( "("+strzero(stackPrg[i],5)+") ASC"+_CR)
              exit
          case 65
              printmsg( "("+strzero(stackPrg[i],5)+") TRIMRIGHT"+_CR)
              exit
          case 66
              printmsg( "("+strzero(stackPrg[i],5)+") TRIMLEFT"+_CR)
              exit
          case 67
              printmsg( "("+strzero(stackPrg[i],5)+") XTONUM"+_CR)
              exit
          case 68
              printmsg( "("+strzero(stackPrg[i],5)+") ALL?"+_CR)
              exit
          case 69
              printmsg( "("+strzero(stackPrg[i],5)+") ANY?"+_CR)
              exit
         /* case 70
              printmsg( "("+strzero(stackPrg[i],5)+") CLEARMARK"+_CR)
              exit*/
          case 71
              printmsg( "("+strzero(stackPrg[i],5)+") POPCATCH"+_CR)
              exit
          case 72
              printmsg( "("+strzero(stackPrg[i],5)+") ELAPTIME"+_CR)
              exit
          case 73
              printmsg( "("+strzero(stackPrg[i],5)+") DAYSDIFF"+_CR)
              exit
          case 74
              printmsg( "("+strzero(stackPrg[i],5)+") DATEADD"+_CR)
              exit
          case 75
              printmsg( "("+strzero(stackPrg[i],5)+") $ (GET-TOKEN)"+_CR)
              exit
          case 76
              printmsg( "("+strzero(stackPrg[i],5)+") $ (MOD-TOKEN)"+_CR)
              exit
          case 77
              printmsg( "("+strzero(stackPrg[i],5)+") RCUT"+_CR)
              exit
          case 78
              printmsg( "("+strzero(stackPrg[i],5)+") REGVALID"+_CR)
              exit
          case 79
              printmsg( "("+strzero(stackPrg[i],5)+") REGMATCH"+_CR)
              exit
          case 80
              printmsg( "("+strzero(stackPrg[i],5)+") EXP"+_CR)
              exit
          case 81
              printmsg( "("+strzero(stackPrg[i],5)+") INT"+_CR)
              exit
          case 82
              printmsg( "("+strzero(stackPrg[i],5)+") SIGN"+_CR)
              exit
          case 83
              printmsg( "("+strzero(stackPrg[i],5)+") LOG"+_CR)
              exit
          case 84
              printmsg( "("+strzero(stackPrg[i],5)+") LOG10"+_CR)
              exit
          case 85
              printmsg( "("+strzero(stackPrg[i],5)+") SQRT"+_CR)
              exit
          case 86
              printmsg( "("+strzero(stackPrg[i],5)+") SIN"+_CR)
              exit
          case 87
              printmsg( "("+strzero(stackPrg[i],5)+") COS"+_CR)
              exit
          case 88
              printmsg( "("+strzero(stackPrg[i],5)+") TAN"+_CR)
              exit
          case 89
              printmsg( "("+strzero(stackPrg[i],5)+") SINH"+_CR)
              exit
          case 90
              printmsg( "("+strzero(stackPrg[i],5)+") COSH"+_CR)
              exit
          case 91
              printmsg( "("+strzero(stackPrg[i],5)+") TANH"+_CR)
              exit
          case 92
              printmsg( "("+strzero(stackPrg[i],5)+") XTOSTR"+_CR)
              exit
          case 93
              printmsg( "("+strzero(stackPrg[i],5)+") FLOOR"+_CR)
              exit
          case 94
              printmsg( "("+strzero(stackPrg[i],5)+") ABS"+_CR)
              exit
          case 95
              printmsg( "("+strzero(stackPrg[i],5)+") CHR"+_CR)
              exit
          case 96
              printmsg( "("+strzero(stackPrg[i],5)+") CEIL"+_CR)
              exit
          case 97
              printmsg( "("+strzero(stackPrg[i],5)+") EXP2"+_CR)
              exit
          case 98
              printmsg( "("+strzero(stackPrg[i],5)+") LOG2"+_CR)
              exit
          case 99
              printmsg( "("+strzero(stackPrg[i],5)+") EXP10"+_CR)
              exit
          case 100
              printmsg( "("+strzero(stackPrg[i],5)+") HEX (CONVERTIR A)"+_CR)
              exit
          case 101
              printmsg( "("+strzero(stackPrg[i],5)+") BIN (CONVERTIR A)"+_CR)
              exit
          case 102
              printmsg( "("+strzero(stackPrg[i],5)+") OCT (CONVERTIR A)"+_CR)
              exit
          case 103
              printmsg( "("+strzero(stackPrg[i],5)+") LENNUM (PARTE ENTERA)"+_CR)
              exit
          case 104
              printmsg( "("+strzero(stackPrg[i],5)+") FACT"+_CR)
              exit
          case 105
              printmsg( "("+strzero(stackPrg[i],5)+") SCI (NOTACION CIENTIFICA)"+_CR)
              exit
          case 106
              printmsg( "("+strzero(stackPrg[i],5)+") D2R (GRADOS A RADIANES)"+_CR)
              exit
          case 107
              printmsg( "("+strzero(stackPrg[i],5)+") R2D (RADIANES A GRADOS)"+_CR)
              exit
          case 108
              printmsg( "("+strzero(stackPrg[i],5)+") CBRT"+_CR)
              exit
          case 109
              printmsg( "("+strzero(stackPrg[i],5)+") RAND"+_CR)
              exit
          case 110
              printmsg( "("+strzero(stackPrg[i],5)+") TRUNC"+_CR)
              exit
          case 111
              printmsg( "("+strzero(stackPrg[i],5)+") EVEN?"+_CR)
              exit
          case 112
              printmsg( "("+strzero(stackPrg[i],5)+") NEG (CAMBIA SIGNO A NEGATIVO)"+_CR)
              exit
          case 113
              printmsg( "("+strzero(stackPrg[i],5)+") NOP (SIN OPERACION)"+_CR)
              exit
          case 114
              printmsg( "("+strzero(stackPrg[i],5)+") DUP (DUPLICA ULTIMO VALOR DEL STACK)"+_CR)
              exit
          case 115
              printmsg( "("+strzero(stackPrg[i],5)+") TYPECHAR?"+_CR)
              exit
          case 116
              printmsg( "("+strzero(stackPrg[i],5)+") SIZESTACK"+_CR)
              exit
          case 117
              printmsg( "("+strzero(stackPrg[i],5)+") CLEARRANGE"+_CR)
              exit
          case 118
              printmsg( "("+strzero(stackPrg[i],5)+") CARTESIAN"+_CR)
              exit
          case 119
              printmsg( "("+strzero(stackPrg[i],5)+") LOC2"+_CR)
              exit
          case 120
              printmsg( "("+strzero(stackPrg[i],5)+") LOC1"+_CR)
              exit
          case 121
              printmsg( "("+strzero(stackPrg[i],5)+") INTERVAL1"+_CR)
              exit
          case 122
              printmsg( "("+strzero(stackPrg[i],5)+") INTERVAL2"+_CR)
              exit
          case 123
              printmsg( "("+strzero(stackPrg[i],5)+") INTERVAL3"+_CR)
              exit
          case 124
              printmsg( "("+strzero(stackPrg[i],5)+") SHOW"+_CR)
              exit
          case 125
              printmsg( "("+strzero(stackPrg[i],5)+") OR"+_CR)
              exit
          case 126
              printmsg( "("+strzero(stackPrg[i],5)+") AND"+_CR)
              exit
          case 127
              printmsg( "("+strzero(stackPrg[i],5)+") XOR"+_CR)
              exit
          case 128
              printmsg( "("+strzero(stackPrg[i],5)+") NOR"+_CR)
              exit
          case 129
              printmsg( "("+strzero(stackPrg[i],5)+") NAND"+_CR)
              exit
          case 130
              printmsg( "("+strzero(stackPrg[i],5)+") NOT"+_CR)
              exit
          case 131
              printmsg( "("+strzero(stackPrg[i],5)+") TOTALARG"+_CR)
              exit
          case 132
              printmsg( "("+strzero(stackPrg[i],5)+") TYPE"+_CR)
              exit
          case 133
              printmsg( "("+strzero(stackPrg[i],5)+") ERROR? (FILE-ERROR)"+_CR)
              exit
          case 134
              printmsg( "("+strzero(stackPrg[i],5)+") PAUSE"+_CR)
              exit
          case 135
              printmsg( "("+strzero(stackPrg[i],5)+") MICROSECS"+_CR)
              exit
          case 136
              printmsg( "("+strzero(stackPrg[i],5)+") RETURN (END-PRG)"+_CR)
              exit
          case 137
              printmsg( "("+strzero(stackPrg[i],5)+") TRANSFORM"+_CR)
              exit
          case 138
              printmsg( "("+strzero(stackPrg[i],5)+") GETENV"+_CR)
              exit
          case 139
              printmsg( "("+strzero(stackPrg[i],5)+") BACK"+_CR)
              exit
          case 140
              printmsg( "("+strzero(stackPrg[i],5)+") KBHIT?"+_CR)
              exit
          case 141
              printmsg( "("+strzero(stackPrg[i],5)+") KBESC?"+_CR)
              exit
          case 142
              printmsg( "("+strzero(stackPrg[i],5)+") ECHO"+_CR)
              exit
          case 143
              printmsg( "("+strzero(stackPrg[i],5)+") REPLACE"+_CR)
              exit
          case 144
              printmsg( "("+strzero(stackPrg[i],5)+") PRINT"+_CR)
              exit
          case 145
              printmsg( "("+strzero(stackPrg[i],5)+") COPY"+_CR)
              exit
          case 146
              printmsg( "("+strzero(stackPrg[i],5)+") OFFSET1"+_CR)
              exit
          case 147
              printmsg( "("+strzero(stackPrg[i],5)+") TRUE"+_CR)
              exit
          case 148
              printmsg( "("+strzero(stackPrg[i],5)+") SECTOTIME"+_CR)
              exit
          case 149
              printmsg( "("+strzero(stackPrg[i],5)+") KBCTRLC?"+_CR)
              exit
          case 150
              printmsg( "("+strzero(stackPrg[i],5)+") NUMERIC?"+_CR)
              exit
          case 151
              printmsg( "("+strzero(stackPrg[i],5)+") STRING?"+_CR)
              exit
          case 152
              printmsg( "("+strzero(stackPrg[i],5)+") ARRAY?"+_CR)
              exit
          case 153
              printmsg( "("+strzero(stackPrg[i],5)+") LENGTH (ARRAY)"+_CR)
              exit
          case 154
              printmsg( "("+strzero(stackPrg[i],5)+") KILL"+_CR)
              exit
          case 155
              printmsg( "("+strzero(stackPrg[i],5)+") CLEARSTACK"+_CR)
              exit
          case 156
              printmsg( "("+strzero(stackPrg[i],5)+") COUNTAT"+_CR)
              exit
          case 157
              printmsg( "("+strzero(stackPrg[i],5)+") FINDAT"+_CR)
              exit
          case 158
              printmsg( "("+strzero(stackPrg[i],5)+") FIND"+_CR)
              exit
          case 159
              printmsg( "("+strzero(stackPrg[i],5)+") MASK"+_CR)
              exit
          case 160
              printmsg( "("+strzero(stackPrg[i],5)+") MONEY"+_CR)
              exit
          case 161
              printmsg( "("+strzero(stackPrg[i],5)+") MULTIPASSON"+_CR)
              exit
          case 162
              printmsg( "("+strzero(stackPrg[i],5)+") MULTIPASSOFF"+_CR)
              exit
          case 163
              printmsg( "("+strzero(stackPrg[i],5)+") TOKSEP"+_CR)
              exit
          case 164
              printmsg( "("+strzero(stackPrg[i],5)+") SECONDS"+_CR)
              exit
          case 165
              printmsg( "("+strzero(stackPrg[i],5)+") FALSE"+_CR)
              exit
          case 166
              printmsg( "("+strzero(stackPrg[i],5)+") MATMUL (MULT MATRICIAL)"+_CR)
              exit
          case 167
              printmsg( "("+strzero(stackPrg[i],5)+") PADCENTER"+_CR)
              exit
          case 168
              printmsg( "("+strzero(stackPrg[i],5)+") PADRIGHT"+_CR)
              exit
          case 169
              printmsg( "("+strzero(stackPrg[i],5)+") PADLEFT"+_CR)
              exit
          case 170
              printmsg( "("+strzero(stackPrg[i],5)+") CAT"+_CR)
              exit
          case 171
              printmsg( "("+strzero(stackPrg[i],5)+") REPLICATE"+_CR)
              exit
          case 172
              printmsg( "("+strzero(stackPrg[i],5)+") SETENV"+_CR)
              exit
          case 173
              printmsg( "("+strzero(stackPrg[i],5)+") UNSETENV"+_CR)
              exit
          case 174
              printmsg( "("+strzero(stackPrg[i],5)+") UNUSED"+_CR)
              exit
          case 175
              printmsg( "("+strzero(stackPrg[i],5)+") ONLYCHAR"+_CR)
              exit
          case 176
              printmsg( "("+strzero(stackPrg[i],5)+") COMPACT"+_CR)
              exit
          case 177
              printmsg( "("+strzero(stackPrg[i],5)+") OFFSET2"+_CR)
              exit
          case 178
              printmsg( "("+strzero(stackPrg[i],5)+") PTR"+_CR)
              exit
          case 179
              printmsg( "("+strzero(stackPrg[i],5)+") INSERT"+_CR)
              exit
          case 180
              printmsg( "("+strzero(stackPrg[i],5)+") DELETE"+_CR)
              exit
          case 181
              printmsg( "("+strzero(stackPrg[i],5)+") STATSFILE"+_CR)
              exit
          case 182
              printmsg( "("+strzero(stackPrg[i],5)+") STRTOUTF8"+_CR)
              exit
          case 183
              printmsg( "("+strzero(stackPrg[i],5)+") UTF8TOSTR"+_CR)
              exit
          case 184
              printmsg( "("+strzero(stackPrg[i],5)+") DELETECHAR"+_CR)
              exit
          case 185
              printmsg( "("+strzero(stackPrg[i],5)+") FILEERROR (GET-STRING-FILE-ERROR)"+_CR)
              exit
          case 186
              printmsg( "("+strzero(stackPrg[i],5)+") LOAD"+_CR)
              exit
          case 187
              printmsg( "("+strzero(stackPrg[i],5)+") SAVE"+_CR)
              exit
          case 188
              printmsg( "("+strzero(stackPrg[i],5)+") EXEC"+_CR)
              exit
          case 189
              printmsg( "("+strzero(stackPrg[i],5)+") SLEEP"+_CR)
              exit
          case 190
              printmsg( "("+strzero(stackPrg[i],5)+") DRWTBL"+_CR)
              exit
          case 191
              printmsg( "("+strzero(stackPrg[i],5)+") ONECHAR"+_CR)
              exit
          case 192
              printmsg( "("+strzero(stackPrg[i],5)+") POSCHAR"+_CR)
              exit
          case 193
              printmsg( "("+strzero(stackPrg[i],5)+") PRINTUSINGTOKEN"+_CR)
              exit
          case 194
              printmsg( "("+strzero(stackPrg[i],5)+") KEEP"+_CR)
              exit
          case 195
              printmsg( "("+strzero(stackPrg[i],5)+") PUTS"+_CR)
              exit
          case 196
              printmsg( "("+strzero(stackPrg[i],5)+") GOXY"+_CR)
              exit
          case 197
              printmsg( "("+strzero(stackPrg[i],5)+") CLOCKPERSEC"+_CR)
              exit
          case 198
              printmsg( "("+strzero(stackPrg[i],5)+") EXECV"+_CR)
              exit
          case 199
              printmsg( "("+strzero(stackPrg[i],5)+") CLEARINTERVAL"+_CR)
              exit
/* FUNCIONES */
          case 200
              printmsg( "("+strzero(stackPrg[i],5)+") SIZEBIN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 201
              printmsg( "("+strzero(stackPrg[i],5)+") MOV (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 202
              printmsg( "("+strzero(stackPrg[i],5)+") INC (X)  ++X"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 203
              printmsg( "("+strzero(stackPrg[i],5)+") DEC (X)  --X"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 204
              printmsg( "("+strzero(stackPrg[i],5)+") PREC (PRECISION-DECIMAL)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 205
              printmsg( "("+strzero(stackPrg[i],5)+") NEWARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 206
              printmsg( "("+strzero(stackPrg[i],5)+") TOTALTOKEN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 207
              printmsg( "("+strzero(stackPrg[i],5)+") PINC (X)  X+="+_CR)
               linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 208
              printmsg( "("+strzero(stackPrg[i],5)+") LOC2 (X)"+_CR)
              printmsg( linea+"("+strzero(stackPrg[++i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 209
              printmsg( "("+strzero(stackPrg[i],5)+") PDEC (X)  X-="+_CR)
               linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 210
              printmsg( "("+strzero(stackPrg[i],5)+") FILLARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 211
              printmsg( "("+strzero(stackPrg[i],5)+") REVERSE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 212
              printmsg( "("+strzero(stackPrg[i],5)+") LOC1 (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 213
              printmsg( "("+strzero(stackPrg[i],5)+") READROW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 214
              printmsg( "("+strzero(stackPrg[i],5)+") LASTKEY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 215
              printmsg( "("+strzero(stackPrg[i],5)+") DPREC ([ARG])")
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 216
              printmsg( "("+strzero(stackPrg[i],5)+") ADDROW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 217
              printmsg( "("+strzero(stackPrg[i],5)+") PUT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 218
              printmsg( "("+strzero(stackPrg[i],5)+") GET (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 219
              printmsg( "("+strzero(stackPrg[i],5)+") GETROW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 220
              printmsg( "("+strzero(stackPrg[i],5)+") GETCOL (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 221
              printmsg( "("+strzero(stackPrg[i],5)+") CATROW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 222
              printmsg( "("+strzero(stackPrg[i],5)+") CATCOL (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 223
              printmsg( "("+strzero(stackPrg[i],5)+") GETPAGE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 224
              printmsg( "("+strzero(stackPrg[i],5)+") PUTPAGE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 225
              printmsg( "("+strzero(stackPrg[i],5)+") SIZE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 226
              printmsg( "("+strzero(stackPrg[i],5)+") TYPE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 227
              printmsg( "("+strzero(stackPrg[i],5)+") GETTOKEN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 228
              printmsg( "("+strzero(stackPrg[i],5)+") MODTOKEN (X) | $$ (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 229
              printmsg( "("+strzero(stackPrg[i],5)+") OPEN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 230
              printmsg( "("+strzero(stackPrg[i],5)+") EMPTY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 231
              printmsg( "("+strzero(stackPrg[i],5)+") RANDARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 232
              printmsg( "("+strzero(stackPrg[i],5)+") ZEROSARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 233
              printmsg( "("+strzero(stackPrg[i],5)+") ONESARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 234
              printmsg( "("+strzero(stackPrg[i],5)+") EYESARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 235
              printmsg( "("+strzero(stackPrg[i],5)+") CLOSE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 236
              printmsg( "("+strzero(stackPrg[i],5)+") WRITELINE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 237
              printmsg( "("+strzero(stackPrg[i],5)+") READLINE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 238
              printmsg( "("+strzero(stackPrg[i],5)+") SEEK (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 239
              printmsg( "("+strzero(stackPrg[i],5)+") EOF (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 240
              printmsg( "("+strzero(stackPrg[i],5)+") CREATE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 241
              printmsg( "("+strzero(stackPrg[i],5)+") DOWITH (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 242
              printmsg( "("+strzero(stackPrg[i],5)+") WRITEROW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 243
              printmsg( "("+strzero(stackPrg[i],5)+") SEQUENCESPACED (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 244
              printmsg( "("+strzero(stackPrg[i],5)+") SEQUENCE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 245
              printmsg( "("+strzero(stackPrg[i],5)+") CPY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 246
              printmsg( "("+strzero(stackPrg[i],5)+") RESHAPE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 247
              printmsg( "("+strzero(stackPrg[i],5)+") TRUE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 248
              printmsg( "("+strzero(stackPrg[i],5)+") FALSE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 249
              printmsg( "("+strzero(stackPrg[i],5)+") DATENOW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
/*          case 250
              printmsg( "("+strzero(stackPrg[i],5)+") (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit*/
          case 250
              printmsg( "("+strzero(stackPrg[i],5)+") STATS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 251
              printmsg( "("+strzero(stackPrg[i],5)+") SETS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 252
              printmsg( "("+strzero(stackPrg[i],5)+") ARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 253
              printmsg( "("+strzero(stackPrg[i],5)+") DATE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 254
              printmsg( "("+strzero(stackPrg[i],5)+") SOCKET (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 255
              printmsg( "("+strzero(stackPrg[i],5)+") (UNUSED)")
              exit
          case 256
              printmsg( "("+strzero(stackPrg[i],5)+") JOIN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 257
              printmsg( "("+strzero(stackPrg[i],5)+") DIVBY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 258
              printmsg( "("+strzero(stackPrg[i],5)+") IDIVBY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 259
              printmsg( "("+strzero(stackPrg[i],5)+") POWBY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 260
              printmsg( "("+strzero(stackPrg[i],5)+") MODULE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 261
              printmsg( "("+strzero(stackPrg[i],5)+") MINUS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 262
              printmsg( "("+strzero(stackPrg[i],5)+") PLUS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 263
              printmsg( "("+strzero(stackPrg[i],5)+") MULBY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 264
              printmsg( "("+strzero(stackPrg[i],5)+") GETTRY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 265
              printmsg( "("+strzero(stackPrg[i],5)+") SWTRAP (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 266
              printmsg( "("+strzero(stackPrg[i],5)+") THROW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 267
              printmsg( "("+strzero(stackPrg[i],5)+") EQTO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 268
              printmsg( "("+strzero(stackPrg[i],5)+") NEQTO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 269
              printmsg( "("+strzero(stackPrg[i],5)+") LTHAN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 270
              printmsg( "("+strzero(stackPrg[i],5)+") LETHAN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 271
              printmsg( "("+strzero(stackPrg[i],5)+") GTHAN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 272
              printmsg( "("+strzero(stackPrg[i],5)+") GETHAN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 273
              printmsg( "("+strzero(stackPrg[i],5)+") CLEAR (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 274
              printmsg( "("+strzero(stackPrg[i],5)+") PUSH (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 275
              printmsg( "("+strzero(stackPrg[i],5)+") ECIN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 276
              printmsg( "("+strzero(stackPrg[i],5)+") CIN (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 277
              printmsg( "("+strzero(stackPrg[i],5)+") ROUNDBY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 278
              printmsg( "("+strzero(stackPrg[i],5)+") BIT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 279
              printmsg( "("+strzero(stackPrg[i],5)+") CALENDAR (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 280
              printmsg( "("+strzero(stackPrg[i],5)+") LOADSTRING (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 281
              printmsg( "("+strzero(stackPrg[i],5)+") SPLIT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 282
              printmsg( "("+strzero(stackPrg[i],5)+") PACKSTRING (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 283
              printmsg( "("+strzero(stackPrg[i],5)+") SAVESTRING (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 284
              printmsg( "("+strzero(stackPrg[i],5)+") GETLINE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 285
              printmsg( "("+strzero(stackPrg[i],5)+") COUNTLINES (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 286
              printmsg( "("+strzero(stackPrg[i],5)+") SEARCH (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 287
              printmsg( "("+strzero(stackPrg[i],5)+") TIMER (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 288
              printmsg( "("+strzero(stackPrg[i],5)+") PUTS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 289
              printmsg( "("+strzero(stackPrg[i],5)+") IPUSH (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 290
              printmsg( "("+strzero(stackPrg[i],5)+") IPOP (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 291
              printmsg( "("+strzero(stackPrg[i],5)+") POP (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 292
              printmsg( "("+strzero(stackPrg[i],5)+") QPOP (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 293
              printmsg( "("+strzero(stackPrg[i],5)+") TAIL (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 294
              printmsg( "("+strzero(stackPrg[i],5)+") HEAD (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 295
              printmsg( "("+strzero(stackPrg[i],5)+") REPLYBY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 296
              printmsg( "("+strzero(stackPrg[i],5)+") WRITESTRING (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 297
              printmsg( "("+strzero(stackPrg[i],5)+") READSTRING (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 298
              printmsg( "("+strzero(stackPrg[i],5)+") SATURATE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 299
              printmsg( "("+strzero(stackPrg[i],5)+") ACCEPT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 300
              printmsg( "("+strzero(stackPrg[i],5)+") RECV (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 301
              printmsg( "("+strzero(stackPrg[i],5)+") SEND (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 302
              printmsg( "("+strzero(stackPrg[i],5)+") CONNECT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 303
              printmsg( "("+strzero(stackPrg[i],5)+") RECVFROM (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 304
              printmsg( "("+strzero(stackPrg[i],5)+") SENDTO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 305
              printmsg( "("+strzero(stackPrg[i],5)+") OPECOD (X) --- V <*>= INT-VALUE"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 306
              printmsg( "("+strzero(stackPrg[i],5)+") QCREATE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 307
              printmsg( "("+strzero(stackPrg[i],5)+") QSET (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 308
              printmsg( "("+strzero(stackPrg[i],5)+") QSEND (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 309
              printmsg( "("+strzero(stackPrg[i],5)+") QRECV (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 310
              printmsg( "("+strzero(stackPrg[i],5)+") QREMOVE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 311
              printmsg( "("+strzero(stackPrg[i],5)+") ASSERT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 312
              printmsg( "("+strzero(stackPrg[i],5)+") PARSER (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 313
              printmsg( "("+strzero(stackPrg[i],5)+") UNPARSER (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 314
              printmsg( "("+strzero(stackPrg[i],5)+") REGCOMPILE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 315
              printmsg( "("+strzero(stackPrg[i],5)+") REGFREE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 316
              printmsg( "("+strzero(stackPrg[i],5)+") CLAMP (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 317
              printmsg( "("+strzero(stackPrg[i],5)+") KEEP (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 318
              printmsg( "("+strzero(stackPrg[i],5)+") TIMECPU (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 319
              printmsg( "("+strzero(stackPrg[i],5)+") RANGE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 320
              printmsg( "("+strzero(stackPrg[i],5)+") VOIDARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 321
              printmsg( "("+strzero(stackPrg[i],5)+") NANARRAY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
/* INSTRUCCIONES */
          case 322
              printmsg( "("+strzero(stackPrg[i],5)+") ARCSIN"+_CR)
              exit
          case 323
              printmsg( "("+strzero(stackPrg[i],5)+") ARCCOS"+_CR)
              exit
          case 324
              printmsg( "("+strzero(stackPrg[i],5)+") ARCTAN"+_CR)
              exit
          case 325
              printmsg( "("+strzero(stackPrg[i],5)+") ARCSINH"+_CR)
              exit
          case 326
              printmsg( "("+strzero(stackPrg[i],5)+") ARCCOSH"+_CR)
              exit
          case 327
              printmsg( "("+strzero(stackPrg[i],5)+") ARCTANH"+_CR)
              exit
          case 328
              printmsg( "("+strzero(stackPrg[i],5)+") ISEMPTY"+_CR)
              exit
          case 329
              printmsg( "("+strzero(stackPrg[i],5)+") GOX"+_CR)
              exit
          case 330
              printmsg( "("+strzero(stackPrg[i],5)+") GOY"+_CR)
              exit
         /* case 331
              printmsg( "("+strzero(stackPrg[i],5)+") CLRMARKSALL"+_CR)
              exit*/
          case 332
              printmsg( "("+strzero(stackPrg[i],5)+") SEED"+_CR)
              exit
          case 333
              printmsg( "("+strzero(stackPrg[i],5)+") GETTOKSEP"+_CR)
              exit
          case 334
              printmsg( "("+strzero(stackPrg[i],5)+") SQRDIFF"+_CR)
              exit
          case 335
              printmsg( "("+strzero(stackPrg[i],5)+") SQRADD"+_CR)
              exit
          case 336
              printmsg( "("+strzero(stackPrg[i],5)+") HYPOT"+_CR)
              exit
          case 337
              printmsg( "("+strzero(stackPrg[i],5)+") MULALL"+_CR)
              exit
          case 338
              printmsg( "("+strzero(stackPrg[i],5)+") SUMALL"+_CR)
              exit
          case 339
              printmsg( "("+strzero(stackPrg[i],5)+") EQARR?"+_CR)
              exit
          case 340
              printmsg( "("+strzero(stackPrg[i],5)+") NEQARR?"+_CR)
              exit
          case 341
              printmsg( "("+strzero(stackPrg[i],5)+") SWAP"+_CR)
              exit
          case 342
              printmsg( "("+strzero(stackPrg[i],5)+") PRINT2D"+_CR)
              exit
          case 343
              printmsg( "("+strzero(stackPrg[i],5)+") GCD"+_CR)
              exit
          case 344
              printmsg( "("+strzero(stackPrg[i],5)+") LCM"+_CR)
              exit
          case 345
              printmsg( "("+strzero(stackPrg[i],5)+") GETSIZSRC"+_CR)
              exit
          case 346
              printmsg( "("+strzero(stackPrg[i],5)+") TYPESTRING?"+_CR)
              exit
          case 347
              printmsg( "("+strzero(stackPrg[i],5)+") DISTTYPESTRING?"+_CR)
              exit
          case 348
              printmsg( "("+strzero(stackPrg[i],5)+") CHRUTF8"+_CR)
              exit
          case 349
              printmsg( "("+strzero(stackPrg[i],5)+") GETNOTATION?"+_CR)
              exit
          case 350
              printmsg( "("+strzero(stackPrg[i],5)+") SJOIN"+_CR)
              exit
          case 351
              printmsg( "("+strzero(stackPrg[i],5)+") UPDROW"+_CR)
              exit
          case 352
              printmsg( "("+strzero(stackPrg[i],5)+") UPDCOL"+_CR)
              exit
          case 353
              printmsg( "("+strzero(stackPrg[i],5)+") FILLBOX"+_CR)
              exit
          case 354
              printmsg( "("+strzero(stackPrg[i],5)+") DUMPARRAY"+_CR)
              exit
          case 355
              printmsg( "("+strzero(stackPrg[i],5)+") EXISTDIR?"+_CR)
              exit
          case 356
              printmsg( "("+strzero(stackPrg[i],5)+") GETENVNUM"+_CR)
              exit
          case 357
              printmsg( "("+strzero(stackPrg[i],5)+") OUTBETWEEN?"+_CR)
              exit
          case 358
              printmsg( "("+strzero(stackPrg[i],5)+") LINE"+_CR)
              exit
          case 359
              printmsg( "("+strzero(stackPrg[i],5)+") CIRCLE"+_CR)
              exit
          case 360
              printmsg( "("+strzero(stackPrg[i],5)+") POLIGON"+_CR)
              exit
// "nneg?"=>361, "npos?"=>362,"mklist"=>363,;
          case 361
              printmsg( "("+strzero(stackPrg[i],5)+") NNEG?"+_CR)
              exit
          case 362
              printmsg( "("+strzero(stackPrg[i],5)+") NPOS?"+_CR)
              exit
          case 363
              printmsg( "("+strzero(stackPrg[i],5)+") MKLIST"+_CR)
              exit
/*FUNCIONES */
          case 370
              printmsg( "("+strzero(stackPrg[i],5)+") ITOP (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 371
              printmsg( "("+strzero(stackPrg[i],5)+") FORMAT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 372
              printmsg( "("+strzero(stackPrg[i],5)+") PUSHALL (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 373
              printmsg( "("+strzero(stackPrg[i],5)+") EWGET (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 374
              printmsg( "("+strzero(stackPrg[i],5)+") EWPUT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 375
              printmsg( "("+strzero(stackPrg[i],5)+") EQARRTO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 376
              printmsg( "("+strzero(stackPrg[i],5)+") NEQARRTO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 377
              printmsg( "("+strzero(stackPrg[i],5)+") JSNT (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 378
              printmsg( "("+strzero(stackPrg[i],5)+") JST (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 379
              printmsg( "("+strzero(stackPrg[i],5)+") LOOK (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 380
              printmsg( "("+strzero(stackPrg[i],5)+") DIMS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 381
              printmsg( "("+strzero(stackPrg[i],5)+") ROWS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 382
              printmsg( "("+strzero(stackPrg[i],5)+") COLS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 383
              printmsg( "("+strzero(stackPrg[i],5)+") PAGES (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 384
              printmsg( "("+strzero(stackPrg[i],5)+") MINUSONE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 385
              printmsg( "("+strzero(stackPrg[i],5)+") PLUSONE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 386
              printmsg( "("+strzero(stackPrg[i],5)+") MINUSTWO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 387
              printmsg( "("+strzero(stackPrg[i],5)+") PLUSTWO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 388
              printmsg( "("+strzero(stackPrg[i],5)+") CPOSX (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 389
              printmsg( "("+strzero(stackPrg[i],5)+") CPOSY (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 390
              printmsg( "("+strzero(stackPrg[i],5)+") DRAW (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
//"jnneg"=>391, "jnpos"=>392,"nbrc"=>393
          case 391
              printmsg( "("+strzero(stackPrg[i],5)+") JNNEG"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 392
              printmsg( "("+strzero(stackPrg[i],5)+") JNPOS"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") [PRG-DIR]"+_CR)
              exit
          case 393
              printmsg( "("+strzero(stackPrg[i],5)+") NBRC (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
//"getpositive"=>394,"getnegative"=>395,"getnonzero"=>396,"getnonvoid"=>397
          case 394
              printmsg( "("+strzero(stackPrg[i],5)+") GETPOSITIVE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 395
              printmsg( "("+strzero(stackPrg[i],5)+") GETNEGATIVE (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 396
              printmsg( "("+strzero(stackPrg[i],5)+") GETNONZERO (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 397
              printmsg( "("+strzero(stackPrg[i],5)+") GETNONVOID (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 398
              printmsg( "("+strzero(stackPrg[i],5)+") PUSHVAR (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 399
              printmsg( "("+strzero(stackPrg[i],5)+") DELCOLS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 400
              printmsg( "("+strzero(stackPrg[i],5)+") DELROWS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 401
              printmsg( "("+strzero(stackPrg[i],5)+") DELPAGS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 402
              printmsg( "("+strzero(stackPrg[i],5)+") INSCOLS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 403
              printmsg( "("+strzero(stackPrg[i],5)+") INSROWS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
          case 404
              printmsg( "("+strzero(stackPrg[i],5)+") INSPAGS (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit
/*          case 405
              printmsg( "("+strzero(stackPrg[i],5)+") GENCART (X)"+_CR)
              linea:= "LF: "+strzero(++i,4)+" -- LV: "+strzero(numline[i],4)+" -- "
              printmsg( linea+"("+strzero(stackPrg[i],5)+ ") "+iif(typeRegistro[stackPrg[i]]=="R","[var]","[cte]")+"    ["+hb_UTF8tostr(registros[stackPrg[i]])+"]"+_CR)
              exit*/
          otherwise
              printmsg( iif(valtype(stackPrg[i])=="N", alltrim(str(stackPrg[i])), stackPrg[i]) +_CR)

       end

//       ? "LF: ",strzero(i,4)," -- LV: ",strzero(numline[i],4)," -- ", iif(valtype(stackPrg[i])=="N", alltrim(str(stackPrg[i])), stackPrg[i])
     end
     printmsg(_CR+"REGISTROS ****************"+_CR+_CR)
     for i:=1 to ctaReg
         printmsg( "NUM: "+strzero(i,4)+" :: TIPO = "+ typeRegistro[i]+ " ST: "+iif(usedRegs[i,2],"US","NU")+" -- VAR/DATO = "+hb_UTF8tostr(registros[i])+_CR)
     end 

return 

procedure _header()
LOCAL msgError
   msgError:="  "+GenMsg(chr(27)+"[1m"+"AMAZING HOPPER!"+chr(27)+"[0m")+" COMPILER & VM v0.1+.2020"+_CR+ ;
             "  Inspirado en las ideas de Grace Murray Hopper."+_CR+ ;
             "  Compiladores: Harbour 3.0.0 (Rev. 16951) bajo gcc (Ubuntu 9.3.0-17ubuntu1~20.04)"+_CR+;
             "  Mr.Dalien, 2020."+_CR+_CR
   //fwrite(1,msgError)
   printmsg(msgerror)

return

procedure _modo_de_uso()
LOCAL msgError
    msgError:="  Modo de Uso:"+_CR+_CR+ ;
              "  hopper <archivo> [parametros] [parametros de usuario]"+_CR+_CR+ ;
              "  si el archivo cuenta con bang line "+GenMsg(chr(27)+"[1m"+"#!/usr/bin/hopper"+chr(27)+"[0m")+", puede ejecutar:"+_CR+_CR+;
              "  ./<archivo> [parametros] [parametros de usuario]"+_CR+_CR+;
              "  Importante! Si no piensa usar bang line, no lo comente: quitelo!"+_CR+;
              "---------------------------------------------------------------------------------------"+_CR+;
              "  donde:"+_CR+ ;
              "     <archivo>     Es el archivo a 'analizar', con extension 'com'."+_CR+ ;
              "     [parametros]  Parametros, si se requieren:"+_CR+ ;
              "                   -p          genera archivo preprocesado (.ppo)"+_CR+;
              "                   -l          genera archivo librería (.lib), usado por la cláusula"+_CR+;
              "                               '#import'. Si en el archivo librería existen prototipos,"+_CR+;
              "                               es necesario declararlos en el archivo principal."+_CR+;
              "                   -ne         no ejecuta."+_CR+;
              "                   -o <name>   especifica un nombre de archivo para salida binaria."+_CR+;
              "                   -x          genera un archivo binario, ejecutado por BHOPPER. Si no"+_CR+;
              "                               usa '-o <name>', el archivo se genera con el mismo"+_CR+;
              "                               nombre del archivo fuente, pero sin extensión."+_CR+;
              "                   -lb         ejecuta un archivo binario con HOPPER."+_CR+;
              "                   -w          desactiva todos los mensajes de warning."+_CR+;
              "                   -d          imprime el argumento de 'return' en el 'stdout'."+_CR+_CR+;
              "  Para mayor información, consulte: "+GenMsg(chr(27)+"[1m"+"man hbasic"+chr(27)+"[0m")+_CR+_CR+;
              "  Bugs, dudas y aportes: daniel.stuardo@gmail.com"+_CR+_CR
    //fwrite(1,msgError)
    printmsg(msgerror)
return



/** codigo C **/
#pragma BEGINDUMP
#include "hbapi.h"
#include "hbstack.h"
#include "hbapiitm.h"
#include "hbapierr.h"
#include "hbapigt.h"
#include "hbset.h"
#include "hbdate.h"
#include <sys/ioctl.h>

#define _GNU_SOURCE

//  #define _MAC64_
//  #define _LINUX32_
#define _LINUX64_


#ifdef _LINUX32_
  #include "/home/dalien/harbour-3.0.0/contrib/hbct/ct.h"
  #include "/home/dalien/harbour-3.0.0/contrib/hbct/ctmath.h"
#endif

#ifdef _MAC64_ 
  #include "ct.h"
  #include "ctmath.h"
#endif

#ifdef _LINUX64_ 
 /* #include "/home/xu/Lang/ct.h"
  #include "/home/xu/Lang/ctmath.h" */
  #include "/home/dalien/Lang/harbour-3.0.0/contrib/hbct/ct.h"
  #include "/home/dalien/Lang/harbour-3.0.0/contrib/hbct/ctmath.h" 

/*  #include "ct.h"
  #include "ctmath.h" */
#endif

#ifdef _MAC64_
   #include <sys/time.h>
#endif
#ifdef _LINUX64_
   #include <time.h>
#endif
#ifdef _LINUX32_
   #include <time.h>
#endif

#include "hbmather.h"
//#include "hbdate.h"
//#include "hbset.h"
#include "hbmath.h"
#include <ctype.h>
#include <extend.h>
#include <math.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <float.h>
#include <limits.h>

/*HB_FUNC( GETFAMILIA ){
   int codfun  = hb_parni( 1 );
   long newOrden = 0;
   long familia=0;
   if( codfun >= 0 && codfun <=5 )       familia=1;
   else if( codfun >= 6 && codfun <=22 ) familia=2;
   else if( codfun >= 23 && codfun <=59 )  familia=3;
   else if( codfun >= 60 && codfun <=89 )  familia=4;
   else if( codfun >= 90 && codfun <=119 ) familia=5;
   else if( codfun >= 120 && codfun <=159 ) familia=6;
   else if( codfun >= 160 && codfun <=189 ) familia=7;
   else if( codfun >= 190 && codfun <=219 ) familia=8;
   else if( codfun >= 220 && codfun <=259 ) familia=9;
   else familia=10;
 //  printf(">>> ORDEN = %d",codfun);
   newOrden |= codfun;
   newOrden = newOrden << 4;
   newOrden |= familia;
 //  printf(">>> NEW ORDEN = %ld\n",newOrden);
   //hb_retni( newOrden );
   
   hb_retnl( codfun );
}*/

HB_FUNC( CMDSYSTEM )  // solo está aquí en hopper_mod_garbage
{
   PHB_ITEM pSTRING = hb_param( 1, HB_IT_STRING );
   const char * t = hb_itemGetCPtr( pSTRING );
   //system(t);
   int ret = system(t);
   if (WIFSIGNALED(ret) &&
      (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
      printf("\n****warning: System Child Break! ****\n");
   }
}

HB_FUNC( BUSCACOMPLETA )
{
   unsigned int pKey  = hb_parni( 1 );
   PHB_ITEM pSTRING = hb_param( 2, HB_IT_STRING );
   unsigned int pLen = hb_parni( 3 );  //len busca
   
   const char * t = hb_itemGetCPtr( pSTRING );
//   printf("\n.....  %s : %d : %d .......\n",t,pKey,pLen);
   if(pKey>1){
      if ( !isalpha(*(t+pKey-2)) && !isdigit(*(t+pKey-2)) && *(t+pKey-2)!='_' &&
           (*(t+pKey+pLen-1)==40 || *(t+pKey+pLen-1)==39) ) 
         hb_retni( pKey );
      else
         hb_retni( 0 );
   }else{
      if ( *(t+pKey+pLen-1)==40 || *(t+pKey+pLen-1)==39)  
         hb_retni( pKey );
      else
         hb_retni( 0 );
   }
   hb_itemClear( pSTRING );
}
/*HB_FUNC( BUSCACOMPLETA )
{
   unsigned int pKey  = hb_parni( 1 );
   PHB_ITEM pSTRING = hb_param( 2, HB_IT_STRING );
   unsigned int pLen = hb_parni( 3 );  //len busca
   
   const char * t = hb_itemGetCPtr( pSTRING );

   if ( isalpha(*(t+pKey-2)) || isdigit(*(t+pKey-2)) || *(t+pKey-2)=='_' ||
        isalpha(*(t+pKey+pLen-1)) || isdigit(*(t+pKey+pLen-1)) || *(t+pKey+pLen-1)=='_') 
      hb_retni( 0 );
   else
      hb_retni( pKey );
   hb_itemClear( pSTRING );
}*/

HB_FUNC( PRINTMSG )
{
   PHB_ITEM pSTRING  = hb_param( 1, HB_IT_STRING );
   const char * expr = hb_itemGetCPtr( pSTRING );
   printf("%s",expr);
}

/*HB_FUNC( DELETE_TEMPORAL )
{
   int t;
   t=system("rm /tmp/tmpFilePreproMurray_*");
   hb_retni(t);
}*/

HB_FUNC( RESCUESTRINGS )
{
   PHB_ITEM pSTRING  = hb_param( 1, HB_IT_STRING );
   const char * expr = hb_itemGetCPtr( pSTRING );
   
   PHB_ITEM pCWM = hb_itemArrayNew( 1 );
   unsigned char c;
   int i=0, j=0, sw=0, nSize=1;
   
   //hb_arrayAdd(pCWM, pSTRING);  // guardo la linea original
   hb_arraySetC(pCWM,1,(const char *) expr) ;
   //hb_arraySize(pCWM, 1);
   
   //const char *code="p*i*t*u*r*r*i*n";   // guardara el codigo de referencia a la porcion
   
   char *linea=calloc(1500,1);  // guarda linea procesada

   if (linea!=NULL){
      while( *expr ){
         c = *expr;
         if (c==34){
            i=0;
            char *porcion=calloc(1500,1);  // guardara porcion original

            porcion[i] = c;
            ++i;
            ++expr;
            while( *expr ){
               c = *expr;
               if(c=='\\') {
                  sw=sw?0:1;  // una barra dentro de la cadena
               }
               if(c==34){
                  if(!sw) {
                     porcion[i] = c; ++i;
                     break;
                  }else{
                     sw=0;  // porque llegó con una barra previa.
                  }
               }else{
                  sw=0;
               }
               porcion[i] = c; 
               ++i;
               ++expr;
            }
            porcion[i]='\0';
            
            const char* pPorcion = porcion;
            hb_arraySize(pCWM, ++nSize);
            hb_arraySetC(pCWM,nSize,(const char *) pPorcion) ;
            memcpy(linea + j, "p1i2t3u4r5r6o", 13);
            j += 13; 
            free(porcion);
            
         }else if (c==96){  // para linea de comando shell v = `comando`
            i=0;
            char *porcion=calloc(1500,1);  // guardara porcion original
            porcion[i] = c;
            ++i;
            ++expr;
            while( *expr ){
               c = *expr;
               if(c==96){
                  porcion[i] = c; ++i;
                  break;
               }
               porcion[i] = c; 
               ++i;
               ++expr;
            }
            porcion[i]='\0';
            
            const char* pPorcion = porcion;
            hb_arraySize(pCWM, ++nSize);
            hb_arraySetC(pCWM,nSize,(const char *) pPorcion) ;
            memcpy(linea + j, "p1i2t3u4r5r6o", 13);
            j += 13; 
            free(porcion);
            
         }else{  // guardo resto de linea que no es un string.
            linea[j] = c;
            ++j;
         }
         if( *expr ) ++expr; // por si se topó con una cadena sin cerrar.
      }
      linea[j]='\0';
      const char *buffer = linea;
      hb_arraySize(pCWM, ++nSize);
      hb_arraySetC(pCWM,nSize,(const char *) buffer) ;
   }
   hb_itemReturnRelease( pCWM );
   free(linea);
   ///free(code);
}

HB_FUNC( GETOPDEFINE )
{
   PHB_ITEM pDEF = hb_param( 1, HB_IT_ARRAY );
   PHB_ITEM pSTRING  = hb_param( 2, HB_IT_STRING );
   const char * candidato = hb_itemGetCPtr( pSTRING );

   long i=0,ulLen = hb_arrayLen( pDEF );
   HB_BOOL bGood=HB_FALSE;
   
   for(i=1;i<=ulLen;++i){
      PHB_ITEM pdefine = hb_itemArrayGet( pDEF, i);
      //long cLen = hb_itemGetCLen(pdefine);
      const char * s = hb_itemGetCPtr(pdefine);
      hb_itemRelease(pdefine);
      if (strcmp(candidato,s)==0){
         bGood = HB_TRUE;
         break;
      }
   }

   hb_itemClear(pDEF);
   hb_itemClear(pSTRING);
   hb_retl( bGood );
}

HB_FUNC( LLENAPILA )
{
   PHB_ITEM pSTRING  = hb_param( 1, HB_IT_STRING );
   const char * expr = hb_itemGetCPtr( pSTRING );
   
   PHB_ITEM pCWM = hb_itemArrayNew( 100 );
   unsigned int cta_par=0,cont=0;
   unsigned char c,cc;
   int swError=0;
   
   while(*expr){
      c = *expr;
   ///   printf("%c",c);
      ++expr;
      if (c=='('){
         ++cta_par;
      }else if(c==')'){
         --cta_par;
      }
  //    if(c=='?') continue;
      if(c=='&' || c=='|' || c=='!'){
         const char * r = expr;
         cc = *r;
         ++r;
         if(cc=='&' || cc=='|' || cc=='='){
            char * s = (char *)calloc(3,1);
            s[0] = c; s[1] = cc; s[2]='\0';
            const char * t = s;
           // printf("\nSIMBOLO = %s\n",t);
            hb_arraySetC(pCWM,++cont,(const char *) t) ;
            free(s);
            expr = r;  // actualizo expr
         }else if(c=='!' && (cc==' '||cc=='(')){
            hb_arraySetC(pCWM,++cont,(const char *) "not") ;

         }else{
            hb_retni( 1 );
            swError=1;
            break;
         }
//      }else if(c=='$'){
      }else if(c=='$'){   // puede ser $$
         char * s = (char *)calloc(3,1);
         if( *expr == '$' ){  // es $$
            s[0] = c; s[1]='$'; s[2]='\0';
            ++expr;
         }else{
            s[0] = c; s[2]='\0';
         }
         const char * t = s;
         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);            

      }else if(c=='+'||c=='-'||c=='*'||c=='/'||c=='\\'||c=='%'||
               c==')'||c=='('||c=='^'||c=='$'){
         char * s = (char *)calloc(2,1);
         s[0] = c; s[1]='\0';
         const char * t = s;
         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);
      }else if(c=='='||c=='<'||c=='>'||c=='!'){
         const char * r = expr;
         cc = *r;
         ++r;
         if(cc=='='||cc=='<'||cc=='>'||cc=='!'){
            if(c=='<'){
               if (cc=='>'||cc=='='){
                  char * s = (char *)calloc(3,1);
                  s[0] = c; s[1] = cc; s[2]='\0';
                  const char * t = s;
                  hb_arraySetC(pCWM,++cont,(const char *) t) ;
                  free(s);
                  expr = r;  // actualizo expr
               }else{
                  hb_retni( 1 );
                  swError=1;
                  break;
               }
            }else if(c=='='){
               if(cc=='='){
                  char * s = (char *)calloc(3,1);
                  s[0] = c; s[1] = cc; s[2]='\0';
                  const char * t = s;
                  hb_arraySetC(pCWM,++cont,(const char *) t) ;
                  free(s);
                  expr = r;  // actualizo expr
               }else{
                  hb_retni( 1 );
                  swError=1;
                  break;
               }               
            }else if(c=='>'){
               if(cc=='='){
                  char * s = (char *)calloc(3,1);
                  s[0] = c; s[1] = cc; s[2]='\0';
                  const char * t = s;
                  hb_arraySetC(pCWM,++cont,(const char *) t) ;
                  free(s);
                  expr = r;  // actualizo expr
               }else{
                  hb_retni( 1 );
                  swError=1;
                  break;
               }
            }else{
               hb_retni( 1 );
               swError=1;
               break;
            }
         }else{
            char * s = (char *)calloc(2,1);
            s[0] = c; s[1]='\0';
            const char * t = s;
            hb_arraySetC(pCWM,++cont,(const char *) t) ;
            free(s);
         }
      }else if (c=='['){   // brakets de rangos para array
         // rescatar anterior y convertirlo:
         PHB_ITEM pVar = hb_itemArrayGet( pCWM, cont);
         long cLen = hb_itemGetCLen(pVar);
         const char * varget = hb_itemGetCPtr(pVar);
         hb_itemRelease(pVar);
         char * cGet = (char *)calloc(200,1);
         //char * fget="get(", * fpar=")";
         memcpy((char *)cGet, "get(" ,4);
         memcpy((char *)cGet+4, varget, cLen);
         //memset((char *)cGet+4+cLen,')', 1);
         memcpy((char *)cGet+4+cLen,");clearinterval;", 16);
       //  hb_arraySetC(pCWM,++cont,(const char *) cGet) ;
       //  free(cGet);
       //  cont-=2;
         int swCont=0;
         if(cont>1){
            --cont;
            swCont=1;
         }
            
         char * s = (char *)calloc(200,1);
         int i=1;
         s[0]=c;
         while (*expr && *expr!=']'){
            s[i++] = *expr;
            ++expr;
         }
         s[i++]=']'; s[i]=';'; //',';

         memcpy(s + strlen(s), cGet, cLen + 20/*5 solo si usa get sin clear...*/ ); //4+11=15 );
         const char * t=s;
         if(!swCont){
            hb_arraySetC(pCWM,cont,(const char *) t) ;
         }else{
            hb_arraySetC(pCWM,++cont,(const char *) t) ;
         }
         free(s);
         free(cGet);
         ++expr;
         //++cont;
         // el anterior debio ser la variable del array: swap y convertir v=>get(v):
      }else if(c==34){   // es un string
         char * s = (char *)calloc(2048,1);
         int i=1;
         s[0]=c;
         while (*expr!='\0'){
            s[i++] = *expr;
            if (*expr==34) {++expr;break;}
            ++expr;
         }
         s[i]='\0';
         const char * t=s;

         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);
      }else if (isdigit(c) || isalpha(c) || c=='-' || c=='@' || c=='_' || c>=128){
         char * s = (char *)calloc(1024,1);
         unsigned char ctmp;
         int i=1;
         s[0]=c;
         while (*expr && (isdigit(*expr) || isalpha(*expr) || *expr=='.' || *expr=='@' || *expr=='_' ||
                *expr=='?' || *expr==':' || (ctmp=*expr)>=128)){

            if(*expr==':'){
               if(*(expr+1)=='='){
                 s[i++] = *expr;
                 s[i++] = *(++expr);
               }else{
                 break;
               }
            }else s[i++] = *expr;
            ++expr;

//            if(strncmp(s,"NOP0",4)==0) break;
//            else if(strncmp(s,"NOP1",4)==0) s[i++] = ',';
            
         }
         s[i]='\0';
         const char * t=s;
         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);
      }else{
         if(c!=' '&&c!=','){
            ////printf("-  %c  -\n",c);
            hb_retni( 2 );
            swError=2;
            break;
         }
      }
   } 
 //  printf("\nCTAPAR = %d",cta_par);
   if(swError)
       hb_itemRelease(pCWM);
       
   else if(cta_par!=0 && !swError){
      hb_retni( 3 );
      hb_itemRelease(pCWM);
   }else{
     /* char * s = (char *)calloc(2,1);
      s[0] = ')'; s[1]='\0';
      const char * t = s;
      hb_arraySetC(pCWM,++cont,(const char *) t) ;
      free(s);
      */
      hb_arraySize( pCWM, cont );
      hb_itemReturnRelease( pCWM );
   }
}

double Factor_Precision[16] = {1,10,100,1000,10000,100000,1e+06,1e+07,1e+08,1e+09,1e+10,
                             1e+11,1e+12,1e+13,1e+14,1e+15}; //,1e+16};

double xu_funprecision(double dNum, int Dec){

/*  char *buf;
  double m;
  
  buf=(char *)calloc(1024,1);
  sprintf(buf,"%.*lf",Dec, dNum);
//
  sscanf(buf, "%lf", &m);

  free(buf);
  return(m); */
  //double fac[];  // population of this is left as an exercise for the reader

  //double my_round(double x, unsigned int digits) {
    //return round(x*fac[digits])/fac[digits];
    return round(dNum * Factor_Precision[Dec])/Factor_Precision[Dec];
}

HB_FUNC( IS_NOALLNUM )
{
   int iPCount = hb_pcount();

   HB_BOOL bGood = HB_TRUE;
   if( iPCount > 0 )
   {
      PHB_ITEM pVAR = hb_param( 1, HB_IT_NUMERIC );
      int nVAR = hb_itemGetNI( pVAR );
      int iParam;
      for( iParam = 2; iParam <= iPCount; iParam++ )
      {
         PHB_ITEM pCom = hb_param( iParam, HB_IT_NUMERIC );
         //int nNum = hb_itemGetNI( pCom );
         if( nVAR == hb_itemGetNI( pCom ) )
         {
            bGood = HB_FALSE;
            break;
         }
      }
   }
   hb_retl( bGood );
}


HB_FUNC( IS_NOALL )
{
   int iPCount = hb_pcount();

   HB_BOOL bGood = HB_TRUE;
   if( iPCount > 0 )
   {
      PHB_ITEM pVAR = hb_param( 1, HB_IT_STRING );
      const char * cVAR = hb_itemGetCPtr( pVAR );
      int iParam;
      for( iParam = 2; iParam <= iPCount; iParam++ )
      {
         PHB_ITEM pCom = hb_param( iParam, HB_IT_STRING );
         const char * cCom = hb_itemGetCPtr( pCom );
         if( strcmp( cVAR, cCom ) == 0 )
         {
            bGood = HB_FALSE;
            break;
         }
      }
   }
   hb_retl( bGood );
}

//isany(vtip,"NN","CC")
HB_FUNC( IS_ANY )
{
   int iPCount = hb_pcount();

   HB_BOOL bGood = HB_FALSE;
   if( iPCount > 0 )
   {
      PHB_ITEM pVAR = hb_param( 1, HB_IT_STRING );
      const char * cVAR = hb_itemGetCPtr( pVAR );
      int iParam;
      for( iParam = 2; iParam <= iPCount; iParam++ )
      {
         PHB_ITEM pCom = hb_param( iParam, HB_IT_STRING );
         const char * cCom = hb_itemGetCPtr( pCom );
         if( strcmp( cVAR, cCom ) == 0 )
         {
            bGood = HB_TRUE;
            break;
         }
      }
   }
   hb_retl( bGood );
}

int xu_funIsnotation(const char * AX){
  //int DX;
  //short int SW_E=0,SW_P=0,SW_S=0;
  int retorne=1;
  int swE=0;
  int swP=0;
  int swS=0;
  int swD=0;
  
  const char *t=AX;
  if(isdigit(*t) || *t=='-' || *t=='+'){
     ++t;
     while(*t!='\0'){
        if(isdigit(*t)) {
           ++t;
        }else if(*t=='.'){
           if(swP){
              //printf("hay mas de un punto = %c\n",*t);
              retorne=0; break;
           } else {
              swP=1;
           }
           ++t;
        }else if(isalpha(*t)){
           if(*t!='e' && *t!='E'){ 
               //printf("debo encontrar un E aqui = %c\n",*t);
               retorne=0;
               break;
           }else{
               if(swE) {
                  //printf("se repite E = %c\n",*t);
                  retorne=0; break;
               } else { 
                  swE=1; 
               }
               ++t;
               if(*t!='\0'){
                   if(!isdigit(*t) && (*t!='-' && *t!='+')) {
                      //printf("despues de E debe ser un digito o + o - = %c\n",*t);
                      retorne=0;
                      break;
                   }else if(*t=='-' || *t=='+'){
                      if(swS){ 
                         //printf("encontre mas de un signo luego de E = %c\n",*t);
                         retorne=0;break;
                      } else {
                         swS=1;
                         ++t;
                         if(isdigit(*t)){
                            //printf("Activa swD\n");
                            swD=1;
                         }else{
                            //printf("no encontre un digito luego de E+- = %c\n",*t);
                            retorne=0;break;
                         }
                      }
                   }else if(isdigit(*t)){
                      //printf("Activa swD\n");
                      swD=1;
                   }else{
                      //printf("Algo raro detecta = %c\n",*t);
                      retorne=0;break;
                   }
                   ++t;
               }else{
                   //printf("encontre fin de cadena antes de completar E\n");
                   retorne=0;break;
               }
           }
        }else{
           //printf("encontre algo distinto a digito, E y . = %c\n",*t);
           retorne=0;
           break;
        }
     }
  }else{
     //printf("no encontre signo ni digito al empezar = %c\n",*t);
     retorne=0;
  }
  if( retorne && !swD){
//     if(!swE)
     //printf("retorne = 1 pero !swD\n");
     retorne=0;
  }
/*  DX=*AX;
  if (DX=='-') ++AX; 
  
  while( (DX=*AX)!='\0'){
    if(toupper(DX)=='E'){
       if (!SW_E) SW_E=1;
       else {retorne=0;break;}
    }else if (DX=='.'){
       if (!SW_P) SW_P=1;
       else {retorne=0;break;}
    }else if (DX=='+' || DX=='-') {
       if (!SW_S) SW_S=1;
       else {retorne=0;break;}
    }else if (!isdigit(DX)) {retorne=0;break;}
    ++AX;
  }
  if (!SW_E ) retorne=0;*/
  return retorne;
}

HB_FUNC( ISNOTATION )
{
   hb_retni( xu_funIsnotation( hb_parc( 1 ) ) );
}

double xu_funE2D( const char * linea ){
   
   const char *buf;
   char *sMant;
   double nMant;
   int nExp,mant=0,signo;
   buf=linea;
   while(*buf!='E' && *buf!='e') {
      mant++;
      ++buf;
   }
   nExp = atoi(++buf);
   sMant = (char *)calloc(mant+10,1);
   strncpy(sMant,linea,mant);
   sMant[mant]='\0';
   if (sMant[0]=='-') {
      signo=(-1); 
      //sMant++;
      sMant[0]='0';
   } else signo=1;
   nMant = atof(sMant);
   free ( sMant );
//   printf("\n--> %f, %d, %d\n%f\n",nMant,nExp,signo, nMant * pow( (double)10, (double)nExp)*signo);
   //return ((double) nMant * (double)pow( (double)10, (double)nExp)*(double)signo );
   return (nMant * pow( 10.0, (double)nExp)*signo );
}

HB_FUNC( FUNE2D )
{
   const char* linea = hb_parc(1);
   double retorno = (double)xu_funE2D( linea );
//   printf("\n RES = %f\n",retorno);
   hb_retnd ( retorno );
}

short int fun_istnumber(const char * AX){
  int DX;
  short int SW_M=0,SW_N=0,SW_P=0;
  short int retorne;
  
  retorne = AX[0]!='\0' ? 1 : 0;
  
  while( (DX=*AX)!='\0'){
    if(DX=='-'){
       if (SW_N || SW_P || SW_M) {retorne=0;break;}
       SW_M=1;
    }else if (DX=='.'){
       if (!SW_N || SW_P) {retorne=0;break;}
       SW_P=1;
    }else if (isdigit(DX)) {SW_N=1;
    }else {retorne=0;break;}
    ++AX;
  }
  if( !SW_N ) return 0;
  return retorne;
}

HB_SIZE hb_striAt( const char * szSub, HB_SIZE nSubLen, const char * szText, HB_SIZE nLen )
{

   if( nSubLen > 0 && nLen >= nSubLen )
   {
      HB_SIZE nPos = 0;
      nLen -= nSubLen;
      do
      {
         if( HB_TOUPPER(szText[ nPos ]) == HB_TOUPPER(*szSub) )
         {
            HB_SIZE nSubPos = nSubLen;
            do
            {
               if( --nSubPos == 0 )
                  return nPos + 1;
            }
            while( HB_TOUPPER(szText[ nPos + nSubPos ]) == HB_TOUPPER(szSub[ nSubPos ]) );
         }
      }
      while( nPos++ < nLen );
   }

   return 0;
}

char *fun_rtrim(const char *linea, HB_SIZE size) {    

   if(size>0) size--;   // me salto el '\0'
   char * r, *buffer;
   const char * pLinea = linea;
   const char * t;
   HB_SIZE tsize;

   t = pLinea;
   t += size;
   while( /*size>=0 &&*/ HB_ISSPACE( *t ) )
   {
      t--;
      size--;
      if (size==0 && *t==' ') {--t;break;}
   }
   tsize = t - pLinea + 1;//2;

   buffer = (char *) calloc(tsize+1,1);
   if (buffer==NULL) return NULL;
   r = buffer;
   memcpy(r,pLinea,tsize);
   r[tsize]='\0';
   return buffer;
}
char * fun_ltrim(const char *linea, HB_SIZE nLen) {
   const char *t;
   t = linea;
   
   while( nLen && HB_ISSPACE( *t ) )
   {
      t++;
      nLen--;
   }
   char *r, *buffer;
   buffer = (char *) calloc(nLen+1,1);
   if (buffer==NULL) return NULL;
   r = buffer;
   memcpy(r,t,nLen); 
   r[nLen]='\0';
   return buffer;
} 

char * fun_alltrim( const char *linea, HB_SIZE size) {
   const char *t=linea;
   char *l = fun_ltrim(t,size);
   char *r = fun_rtrim(l,strlen(l));
   
   HB_SIZE nLen = strlen(r);
   char *u, *buffer;
   buffer = (char *) calloc(nLen+1,1);
   if (buffer==NULL) return NULL;
   u = buffer;
   memcpy(u,r,nLen); 
   free(r);free(l);
   u[nLen]='\0';

   return buffer;
}


double FFACTORIAL(double param){
  double f=1;
  int i,x;
  double tablaf[21]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,
                     87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,
                     121645100408832000,2432902008176640000};
  x = (long)param;

    if (x<=20){
       f=tablaf[x];
    }else{
       f=tablaf[20];
       i=21;
       do{
         f=f*i;
       }while(++i<=x);
    }
  return f;
}

HB_FUNC( ISTNUMBER )  // esto debe ir!! llevar otros codigos semejante a "C"
{
  PHB_ITEM pText = hb_param(1,HB_IT_STRING);
  const char *AX = hb_itemGetCPtr( pText );
  
  hb_retnint(fun_istnumber(AX));
}


/*
 * Harbour Project source code:
 * Stack structure
 *
 * Copyright 2000 Jose Lalin <dezac@corevia.com>
 * www - http://www.harbour-project.org
*/
/* StackNew() --> <aStack>
*/
HB_FUNC( STACKNEW )
{
   hb_itemReturnRelease( hb_itemArrayNew( 0 ) ); /* Create array */
}

/*  StackPush( <aStack>, <xValue> ) --> <aStack>
*/
HB_FUNC( STACKPUSH )
{
   hb_arrayAdd( hb_param( 1, HB_IT_ARRAY ), 
                hb_param( 2, HB_IT_ANY ) );
}

/* StackPop( <aStack> ) --> <xValue>
   Returns NIL if the stack is empty
*/
HB_FUNC( STACKPOP )
{
   PHB_ITEM pArray = hb_param( 1, HB_IT_ARRAY );
   long ulLen = hb_arrayLen( pArray );
   PHB_ITEM pLast = hb_itemNew( NULL );

   if( ulLen )
   {
      hb_arrayLast( pArray, pLast );
      hb_arrayDel( pArray, ulLen );
      --ulLen;
      hb_arraySize( pArray, HB_MAX( ulLen, 0 ) );
   }

   hb_itemReturnRelease( pLast );
}


// XFUNCALL(DATASEG,PROGRAM)
// TEMPORAL es un array: { var, tipo("C","N","L","AN","AC","AL"), DIM,DIMR,DIMC,DIMP,DIMB }
//      ejemplo: TEMPORAL:={ V, "AC", 2, 10, 30, 0 , 0 }
//               TEMPORAL:={ V, "N", 0,0,0,0,0}


/* Declaraciones básicas de variables globales */
/*#ifdef _LINUX32_
   unsigned int CLOCKS_PER_SEC=1000000;
#endif*/
int swErr=0;   // Error!  
int CP=0;      // contador de programa pSTK_PRG. Inicia en 1
int CADDR=0;   // contador de pSTK_ADDR
int SWKEEP=0;
int iLOCAL_INI=0;  // donde inician locales
int nINDEXOBJ=0;
// SET intervalos, y sw de rangos.
unsigned int SET_INTERVAL_ROW=1,SET_INTERVAL_COL=1,SET_INTERVAL_PAG=1;
unsigned int SW_USERANGE=0;  // indice del registro que tiene el rango
unsigned int RANGEROW=0,RANGECOL=0,RANGEDIM=0;
int SW_ORIGIN_RANGE=1;  // 1=REG, 0=ADDR
//
unsigned int MARK_ROW=0, MARK_COL=0, MARK_POS=0, OFFSET_POS=0;
//unsigned int MARK_INTERfVALO_ROW=0, MARK_INTERVALO_COL=0;
unsigned int MARK_PAGE=0;
unsigned int MULTIPASS=1;
unsigned int SW_PUNTERO=0;
int nSizeStack=0;   // tamaño del stack de trabajo.
int FILE_ERROR=0;
int SIZE_BINARY=0;   // tamaño del binario a convertir con BIN
// POSICION EN PANTALLA:
int SCREEN_ROW = 1, SCREEN_COL = 1;

//unsigned int MARK_OFFSETROW=0, MARK_OFFSETCOL=0;   // coordenadas fila, columna de arrays
unsigned int OFFSET_ROW=0, OFFSET_COL=0;  // desplazamiento en elementos detro de un array.
short int SW_PRECISION=0;  // no se hace ajuste de decimales por defecto.

//short int SW_POSTFIX=0;   // calculo en notacion polaca inversa para #MATH. inactivo por default.
int PUSH_VAR=-1; // variable de copiado directo de operaciones.

unsigned PRECISION = 0;   // precision. default: no hay precision
//double SWITCH_VAR=0;    // dato de switch.
unsigned int LENDS=0;     // total de argumentos pasados al programa
double CTE_NAN = 0;
////int SW_CLRMARKSALL = 0;  // habilita/inhabilita borrar marcas luego de GET/PUT.
static volatile int s_fInit = 0;

/* variables de ejecución, publicas.
   Con esto, es posible que no necesite pasar argumentos
   y, ademas, crear punteros a funcion */
PHB_ITEM pSTK_DS;   // dataseg
PHB_ITEM pSTK_PRG;  // program
PHB_ITEM pSTK_DBG;  // lineas del programa
PHB_ITEM pSTK_ADDR; // stack de trabajo.
PHB_ITEM pSTK_REG;  // stack de registros variables
PHB_ITEM SWITCH_VAR;  // stack para switch/case
PHB_ITEM pRET;      // stack de retorno fin de ejecucion
int *STK_PRG = NULL;  // stack de instrucciones enteras.
int nPCP=0; //,nPCPNext=0;   // codigo de funcion.
PHB_ITEM pSTK_OBJ[1024];  // 8182 bytes reservados. para guardar datos de llamadas recursivas, o desde un local a otro.

char *TOKENIZER;
    
static char * XU_SEMANA[8]={"","Domingo","Lunes","Martes","Miercoles","Jueves","Viernes","Sabado"};
static char * XU_ANO[13]={"","Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio",
                          "Agosto","Septiembre","Octubre","Noviembre","Diciembre"};

//unsigned long INFINITO=93786976294838206460L;
//static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};


void get_size( PHB_ITEM pSource, HB_MAXINT *nDim, HB_MAXINT *d1, HB_MAXINT *d2, HB_MAXINT *d3, HB_MAXINT *type){
   PHB_ITEM pType=NULL;
   //long uiArrayLen1d = ( long ) hb_arrayLen( pSource );
   
   if( ( *d1 = ( long ) hb_arrayLen( pSource ) ) ){
       ++*nDim;
       //*d1 = uiArrayLen1d;
       pType = hb_itemArrayGet( pSource, 1);
       PHB_ITEM pSource2D = hb_itemArrayGet( pSource, 1);
       
       if( HB_IS_ARRAY( pSource2D ) ){   // es un ARRAY 2D
           //long uiArrayLen2d = ( long ) hb_arrayLen( pSource2D );
           
           if( (*d2 = ( long ) hb_arrayLen( pSource2D )) ){
               ++*nDim;
               ///*d2 = uiArrayLen2d;
               hb_itemRelease(pType);
               pType = hb_itemArrayGet( pSource2D, 1);
                                    //pTemp = pSource2D;
               PHB_ITEM pSource3D = hb_itemArrayGet( pSource2D, 1);
               if( HB_IS_ARRAY( pSource3D ) ){   // es un ARRAY 3D
                  //long uiArrayLen3d = ( long ) hb_arrayLen( pSource3D );
                  
                  if( ( *d3 = ( long ) hb_arrayLen( pSource3D ) ) ){
                     ++*nDim;
                     //*d3 = uiArrayLen3d;
                     hb_itemRelease(pType);
                     pType = hb_itemArrayGet( pSource3D, 1);
                  }
               }
               
               hb_itemRelease(pSource3D);
           }
           
       }
       
       hb_itemRelease(pSource2D);
   }
   if( pType ){
      if( HB_IS_STRING( pType ) ){
       //hb_arraySetC( pRET, 2, (const char *)  "AC"  );
       *type = 10;
      }else if ( HB_IS_INTEGER ( pType ) ){
       //hb_arraySetC( pRET, 2, (const char *)  "AN"  );
       *type = 11;
      }else if( HB_IS_NUMERIC( pType ) ) {
       //hb_arraySetC( pRET, 2, (const char *)  "AN"  );
       *type = 11;
      }else if( HB_IS_LONG( pType )  ){
       //hb_arraySetC( pRET, 2, (const char *)  "AN"  );
       *type = 11;
  /*    }else if( HB_IS_LOGICAL( pType ) ){
       //hb_arraySetC( pRET, 2, (const char *)  "AL"  );
       *type = 12;*/
      }
      hb_itemRelease(pType);
   }else *nDim=0;
}

void get_item_type(PHB_ITEM pSource, HB_MAXINT *type){
   if( HB_IS_STRING( pSource ) ){
      *type = 10;
   }else if ( HB_IS_INTEGER ( pSource ) ){
      *type = 11;
   }else if( HB_IS_NUMERIC( pSource ) ) {
      *type = 12;
   }else if( HB_IS_LONG( pSource )  ){
      *type = 13;
 /*  }else if( HB_IS_LOGICAL( pSource ) ){
      *type = 14; */
   }
}

/*void put_inc_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){


    if ( HB_IS_INTEGER ( pSource ) ){
        int pNum = hb_itemGetNI( pSource );
        hb_arraySetNI( pWSTACK, ndx, (int)  (pNum + xcremento)  );
    }else if( HB_IS_DOUBLE( pSource ) ) {
        double pDbl = hb_itemGetND( pSource );
        hb_arraySetND( pWSTACK, ndx, (double) (pDbl + xcremento) );
    }else if( HB_IS_LONG( pSource )  ){
        long pLong = hb_itemGetNL( pSource );
        hb_arraySetNL( pWSTACK, ndx, (long) ( pLong+xcremento ) );
    }else{
        const char * s = hb_itemGetCPtr(pSource);
        long nLen = hb_itemGetCLen(pSource);
        char *st = (char *)calloc(nLen+1,1);
        sprintf(st,"%s",s);
        const char *t=st;
        if(xcremento>nLen) xcremento=nLen;
        t+=xcremento;
        hb_arraySetC(pWSTACK, ndx, (const char*) t);
        free(st);
    }
}*/
void put_inc_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){


    if ( HB_IS_INTEGER ( pSource ) ){
        hb_arraySetNI( pWSTACK, ndx, (int)  (hb_itemGetNI( pSource ) + xcremento)  );

    }else if( HB_IS_LONG( pSource )  ){
        hb_arraySetNL( pWSTACK, ndx, (long) ( hb_itemGetNL( pSource )+xcremento ) );

    }else if( HB_IS_DOUBLE( pSource ) ) { //ASUME DOUBLE
        hb_arraySetND( pWSTACK, ndx, (double) (hb_itemGetND( pSource ) + xcremento) );
    }else{
        const char * s = hb_itemGetCPtr(pSource);
        long nLen = hb_itemGetCLen(pSource);
        char *st = (char *)calloc(nLen+1,1);
        sprintf(st,"%s",s);
        const char *t=st;
        if(xcremento>nLen) xcremento=nLen;
        t+=xcremento;
        hb_arraySetC(pWSTACK, ndx, (const char*) t);
        free(st);
    }
}

/*void put_inc_INT_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    int pNum = hb_itemGetNI( pSource );
    hb_arraySetNI( pWSTACK, ndx, (int)  (pNum + xcremento)  );
}

void put_inc_LONG_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    long pLong = hb_itemGetNL( pSource );
    hb_arraySetNL( pWSTACK, ndx, (long) ( pLong+xcremento ) );
}
void put_inc_DOUBLE_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){
    double pDbl = hb_itemGetND( pSource );
    hb_arraySetND( pWSTACK, ndx, (double) (pDbl + xcremento) );
}*/

void put_inc_str_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    const char * s = hb_itemGetCPtr(pSource);
    long nLen = hb_itemGetCLen(pSource);
    char *st = (char *)calloc(nLen+1,1);
    sprintf(st,"%s",s);
    const char *t=st;
    if(xcremento>nLen) xcremento=nLen;
    t+=xcremento;
    hb_arraySetC(pWSTACK, ndx, (const char*) t);
    free(st);

}

void put_dec_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    if ( HB_IS_INTEGER ( pSource ) ){
        hb_arraySetNI( pWSTACK, ndx, (int)  (hb_itemGetNI( pSource ) - xcremento)  );

    }else if( HB_IS_LONG( pSource )  ){
        hb_arraySetNL( pWSTACK, ndx, (long) ( hb_itemGetNL( pSource )-xcremento ) );

    }else if( HB_IS_DOUBLE( pSource ) ) { //ASUME DOUBLE
        hb_arraySetND( pWSTACK, ndx, (double) (hb_itemGetND( pSource ) - xcremento) );
    }else{
        const char * s = hb_itemGetCPtr(pSource);
        long nLen = hb_itemGetCLen(pSource);
        char *st = (char *)calloc(nLen+1,1);
        sprintf(st,"%s",s);
        if(nLen-xcremento<=0) st[0]='\0';
        else st[nLen-xcremento]='\0';
        hb_arraySetC(pWSTACK, ndx, (const char*) st);
        free(st);
    }
}

void put_dec_str_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    const char * s = hb_itemGetCPtr(pSource);
    long nLen = hb_itemGetCLen(pSource);
    char *st = (char *)calloc(nLen+1,1);
    sprintf(st,"%s",s);
    if(nLen-xcremento<=0) st[0]='\0';
    else st[nLen-xcremento]='\0';
    hb_arraySetC(pWSTACK, ndx, (const char*) st);
    free(st);
}

void put_value(PHB_ITEM pWSTACK, PHB_ITEM pSource, int ndx, int PRECISION){

// chequea tipo de valor obtenido y guarda en STK_ADDR:
        
    if ( HB_IS_INTEGER ( pSource ) ){
        int pNum = hb_itemGetNInt( pSource );
        hb_arraySetNI( pWSTACK, ndx, (int)  pNum  );
    }else if( HB_IS_DOUBLE( pSource ) ) {
        double pDbl = hb_itemGetND( pSource );
        hb_arraySetND( pWSTACK, ndx, (double) SW_PRECISION ? xu_funprecision(pDbl,PRECISION) : pDbl );
    }else if( HB_IS_LONG( pSource )  ){
        long pLong = hb_itemGetNL( pSource );
        hb_arraySetNL( pWSTACK, ndx, (long) pLong ); 
    }else if( HB_IS_STRING( pSource ) ){
        const char * pString = hb_itemGetCPtr( pSource );
        hb_arraySetC( pWSTACK, ndx, (const char *)  pString  );

   /* }else if( HB_IS_LOGICAL( pSource ) ){
        HB_BOOL pBool = hb_itemGetL( pSource );
        hb_arraySetL( pWSTACK, ndx, (HB_BOOL) pBool ) ;*/
    }else if( HB_IS_ARRAY( pSource )){
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 ); // creo array ajustado a los rangos.
               int i;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                  put_value(pRows, pARGS, i, PRECISION);
                  hb_itemRelease(pARGS);
               }
               hb_arraySet(pWSTACK, ndx, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pCols, pARGC, j, PRECISION);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARGF);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pWSTACK, ndx, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               int i;
               for(i=1; i<=d1; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  int j;
                  for(j=1; j<=d2; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k;
                     for(k=d1; k<=d3; k++){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAYP, pARGP, k, PRECISION);
                        hb_itemRelease(pARGP);
                     }
                     hb_arraySet(pARRAYC, j, pARRAYP);
                     hb_itemRelease(pARRAYP);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet(pARRAY, i, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pWSTACK, ndx, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }
         }
    }
}

int put_error(PHB_ITEM pRET, const char *ErrString, int ErrCode){//, int *swErr){
   swErr=1;
   hb_arraySetC( pRET, 2, (const char *) ErrString );
   hb_arraySetNI(pRET, 7, (int) ErrCode );
   return 0;
}

int normaliza_indices_1d(unsigned int * nIni, unsigned int *nFin, HB_MAXINT d1,
                          unsigned int * MARK_POS ){

   if( *MARK_POS == 999999999 ) *MARK_POS = (unsigned int)d1;
   if( *MARK_POS ) { 
       *nIni = *MARK_POS; 
       *nFin = *MARK_POS;
   }
return 1;
}

int normaliza_indices_2d( unsigned int *nIniR, unsigned int *nFinR, unsigned int *nIniC, unsigned int *nFinC, 
                          long int d1, long int d2, int *swOffset,
                          unsigned int *MARK_ROW, unsigned int *OFFSET_ROW, 
                          unsigned int *MARK_COL, unsigned int *OFFSET_COL ){

int sw=1;

//            printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL); 
  if( *MARK_ROW ) {
      if( *MARK_ROW == 999999999 ) *MARK_ROW=(unsigned int)d1;
      if( *MARK_ROW>(unsigned int)d1 ){
          sw=put_error((PHB_ITEM) pRET, "GET|PUT ROW'MARK OVERFLOW",101);
          //hb_itemRelease(pSource);
          return sw;               
      }
      *nIniR=*MARK_ROW;*nFinR=*MARK_ROW;
      if( *OFFSET_ROW ){
          if( *OFFSET_ROW == 999999999 ) *OFFSET_ROW=(unsigned int)d1;
          if( *OFFSET_ROW<=(unsigned int)d1 ){
              *nFinR=*OFFSET_ROW;
          }else{   // es mayor! ERROR
              sw=put_error((PHB_ITEM) pRET, "GET|PUT ROW'OFFSET OVERFLOW",101);
              //hb_itemRelease(pSource);
              return sw;
          }
      }
  }else{  // asume todas las filas
      *swOffset=1;
      *OFFSET_ROW=*nFinR;
  }
  if( *MARK_COL ) {
      if( *MARK_COL == 999999999 ) *MARK_COL=(unsigned int)d2;
      if( *MARK_COL>(unsigned int)d2 ){
          sw=put_error((PHB_ITEM) pRET, "GET|PUT COL'MARK OVERFLOW",101);
          //        hb_itemRelease(pSource);
          return sw;               
      }
      *nIniC=*MARK_COL;*nFinC=*MARK_COL;
      if( *OFFSET_COL ){
          if( *OFFSET_COL == 999999999 ) *OFFSET_COL=(unsigned int)d2;
          if( *OFFSET_COL<=(unsigned int)d2 ){
              *nFinC=*OFFSET_COL;
          }else{   // es mayor! ERROR
              sw=put_error((PHB_ITEM) pRET, "GET|PUT COL'OFFSET OVERFLOW",101);
              //       hb_itemRelease(pSource);
              return sw;
          }
      }
  }else{  // asume todas las columnas
      *swOffset=1;
      *OFFSET_COL=*nFinC;
  }
  return sw;
}

int normaliza_indices_3d(unsigned int *nIniR, unsigned int *nFinR, unsigned int *nIniC, unsigned int *nFinC, 
                         unsigned int *nPagIni, unsigned int * nPagFin,
                         long int d1, long int d2, long int d3, int *swOffset,
                         unsigned int *MARK_PAGE, unsigned int *OFFSET_POS,
                         unsigned int *MARK_ROW, unsigned int *OFFSET_ROW, 
                         unsigned int *MARK_COL, unsigned int *OFFSET_COL){
int sw=1;
  if( *MARK_PAGE ){
      if( *MARK_PAGE == 999999999 ) *MARK_PAGE=(unsigned int)d3;
      if( *MARK_PAGE>(unsigned int)d3 ){
          sw=put_error((PHB_ITEM) pRET, "GET|PUT PAGE'MARK OVERFLOW",101);
          //hb_itemRelease(pSource);
          return sw;               
      }
      *nPagIni=*MARK_PAGE; *nPagFin=*MARK_PAGE;
      if( *OFFSET_POS ){
          if( *OFFSET_POS == 999999999 ) *OFFSET_POS=(unsigned int)d3;
          if( *OFFSET_POS<=(unsigned int)d3 ){
              *nPagFin=*OFFSET_POS;
          }else{   // es mayor! ERROR
              // printf("\n\nOFFSET_PAGE = %ld\n\n",OFFSET_POS);
              sw=put_error((PHB_ITEM) pRET, "GET|PUT PAGE'OFFSET OVERFLOW",101);
              //hb_itemRelease(pSource);
              return sw;
          }
      } 
  }else{  // si no existe marca de página, se asume todo; luego:
      *swOffset=1;
      *OFFSET_POS=*nPagFin; 
  }
  sw=normaliza_indices_2d(nIniR, nFinR, nIniC, nFinC, d1, d2, swOffset,
                          MARK_ROW, OFFSET_ROW, MARK_COL, OFFSET_COL );

return sw;
}


int fun_clear_interval(){
              SET_INTERVAL_ROW=1;SET_INTERVAL_COL=1;SET_INTERVAL_PAG=1;
              MARK_ROW=0; MARK_COL=0; MARK_POS=0; MARK_PAGE=0;
              OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0;
return 1;
}

int fun_clear_range(){
              SW_USERANGE=0;SW_ORIGIN_RANGE=1;
              RANGEROW=0;RANGECOL=0;RANGEDIM=0;
return 1;
}
/*int fun_clear_marks(){
              MARK_ROW=0; MARK_COL=0; MARK_POS=0; MARK_PAGE=0;
              OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0;
return 1;
}*/
/*int fun_clearall(){
int sw=1; 
  sw = fun_clear_marks();
  sw = fun_clear_range();
  sw = fun_clear_interval();
return sw;
}*/
/*int fun_clrmarksall(){
   //fun_clear_marks();
   //fun_clear_interval();
   SW_CLRMARKSALL = (SW_CLRMARKSALL)? 0 : 1;
return 1;
}*/

/******************************************************
     ESTRUCTURAS LISTAS PARA SALTOS Y OTROS
     PROCESOS INTERNOS
 *******************************************************/
 
/*struct stack_inner{
   PHB_ITEM pDATA; 
   struct stack_inner *siguiente;
}; 

typedef struct stack_inner saveData;
saveData *cabezaData = NULL;
saveData *actualData = NULL;

int push_data( PHB_ITEM pDato ){
int sw=1;
    
    saveData *nodo = (struct stack_inner*)malloc(sizeof(struct stack_inner));

    if(nodo == NULL){
       sw=0; //put_error((PHB_ITEM) pRET, "INNER-DATA STACK POINTER NOT ENOUGHT MEMORY",100);
    }else{
       //PHB_ITEM pdatotmp = hb_itemGet//hb_itemNew( NULL );
       PHB_ITEM pSEC = hb_itemPutND( NULL, (double) 3.14159265358979323846 );
       
       nodo->pDATA = pDato;
       nodo->siguiente = cabezaData;
       cabezaData = nodo;
    }

return sw;
}
//= hb_itemNew( NULL );
int pop_data( PHB_ITEM * pDato ){
int sw=1;

    if(cabezaData == NULL){
        sw=0; //put_error((PHB_ITEM) pRET, "INNER-DATA STACK POINTER OVERFLOW", 101);
    }else{
        saveData *nodo = cabezaData;
        // *dirJump = nodo->id;
        *pDato = nodo->pDATA;   // -1 por ++CP del final del ciclo.

        cabezaData=nodo->siguiente;
        free(nodo);
    }
return sw;
}
*/
struct label_to_jump{
    int id;
//    char *dataText;   // por si lo necesite después
    struct label_to_jump *siguiente;
};

typedef struct label_to_jump jumpLabel;
jumpLabel *cabeza = NULL;
jumpLabel *actual = NULL;

struct label_to_try{
    int id;
//    char *dataText;   // por si lo necesite después
    struct label_to_try *siguiente;
};

typedef struct label_to_try tryLabel;
tryLabel *cabezaTry = NULL;
tryLabel *actualTry = NULL;


int push_label( int etiqueta ){
int sw=1;
    
    jumpLabel *nodo = (struct label_to_jump*)malloc(sizeof(struct label_to_jump));

    if(nodo == NULL){
       sw=put_error((PHB_ITEM) pRET, "JSUB|GOSUB STACK POINTER NOT ENOUGHT MEMORY",100);
    }else{
       nodo->id = etiqueta;
       nodo->siguiente = cabeza;
       cabeza = nodo;
    }

return sw;
}

int pop_label(){
int sw=1;
    if(cabeza == NULL){
        sw=put_error((PHB_ITEM) pRET, "BACK STACK POINTER OVERFLOW", 101);
    }else{
        jumpLabel *nodo = cabeza;
        //*dirJump = nodo->id;
        CP = nodo->id - 1;   // -1 por ++CP del final del ciclo.

        cabeza=nodo->siguiente;
        free(nodo);
    }
return sw;
}

int push_try( int etiqueta ){
int sw=1;
    
    tryLabel *nodo = (struct label_to_try*)malloc(sizeof(struct label_to_try));

    if(nodo == NULL){
       sw=put_error((PHB_ITEM) pRET, "TRY STACK POINTER NOT ENOUGHT MEMORY",100);
    }else{
       nodo->id = etiqueta;
       nodo->siguiente = cabezaTry;
       cabezaTry = nodo;
    }

return sw;
}

int read_try(){
int sw=1;
    if(cabezaTry == NULL){
       sw=put_error((PHB_ITEM) pRET, "TRY STACK POINTER OVERFLOW", 101);
    }else{
       tryLabel *nodo = cabezaTry;
       CP = nodo->id - 1;   // -1 por ++CP del final del ciclo.
    }
return sw;
}

int pop_try(){
int sw=1;
    if(cabezaTry == NULL){
        sw=put_error((PHB_ITEM) pRET, "TRY STACK POINTER OVERFLOW", 101);
    }else{
        tryLabel *nodo = cabezaTry;
        //*dirJump = nodo->id;
        CP = nodo->id - 1;   // -1 por ++CP del final del ciclo.

        cabezaTry=nodo->siguiente;
        free(nodo);
    }
return sw;
}

/*
char * fun_notation( double x ){//, double nPrecision ){
char Times[] = "e ";
  char buffer[3 + DBL_DIG + sizeof(Times) + 20 + 1];
  char * dest = (char *)calloc(1024,1);
  if(fabs(x)!=0)
     sprintf(buffer, "%.*e", DBL_DIG, x);
  else{
     x=fabs(x);
     sprintf(buffer, "%.*e", DBL_DIG, x);
  }
///  printf("\ntemporal = %s\n",buffer);
  char *e = strchr(buffer, 'e');  // find exponent position
  if (e) {
    char *zero = e;
    
    while (zero[-1] == '0') zero--;
    if(zero[-1]=='.') zero--;
    *zero = '\0'; // OP wants excess zeros trimmed.
    int power = atoi(&e[1]);  // trim excess zeros by converting to int
    Times[1] = power>0? '+':power<0?'-':'\0';

    sprintf(dest, "%s%s%d", buffer, Times, abs(power));
    }
  else {
    strcpy(dest, buffer);
  }
  //printf("\ntemporal = %s\n",dest);
  ///const char * cBuffer = dest;
  return dest;
}
*/ 
/*  char *buf;
  double nExp;
  int signo;
  signo=nDec<0?-1:1;
  if (signo<0) nDec *= -1;
  if( nDec == 0) nExp = 0;
  else if (fabs( nDec ) < 1)  nExp = (double)(int)( log10( nDec ) ) - 1;
  else
      nExp = (double)(int)( log10( fabs( nDec ) + 0.00001 ) );   // 0.00001 == kludge 
             //for imprecise logs 
  nDec /= pow(10, nExp );  //pow(10, nExp);
  if (hb_numRound( fabs( nDec ), nPrecision ) >= 10){
      nDec /= 10;
      nExp++;
  }
  //buf = (char *) calloc(sizeof(char)*19+1,1);
  buf = (char *) calloc(32,1);
  switch((int)nPrecision){
     case 1:case 2:case 3: 
         sprintf(buf,"%1.3fe%d",nDec*signo,(int)nExp); break;
     case 4: sprintf(buf,"%1.4fe%d",nDec*signo,(int)nExp); break;
     case 5: sprintf(buf,"%1.5fe%d",nDec*signo,(int)nExp); break;
     case 6: sprintf(buf,"%1.6fe%d",nDec*signo,(int)nExp); break;
     case 7: sprintf(buf,"%1.7fe%d",nDec*signo,(int)nExp); break; 
     case 8: sprintf(buf,"%1.8fe%d",nDec*signo,(int)nExp); break;
     case 9: sprintf(buf,"%1.9fe%d",nDec*signo,(int)nExp); break; 
     default: sprintf(buf,"%1.10fe%d",nDec*signo,(int)nExp); 
  }  
  return buf; 
}*/


/*void put_vector(PHB_ITEM pARRAY, PHB_ITEM pSource, long uiArrayLen){
long i;
   // VER las marcas de MARK_ROW, etc.
   long nIni=1, nFin=uiArrayLen;
   
   if( HB_IS_STRING( pSource ) ){
       const char * pString = hb_itemGetCPtr( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetC( pARRAY, i, (const char *)  pString  );
       }
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNInt( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetNI( pARRAY, i, (int)  pNum  );
       }
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetND( pARRAY, i, (double) pDbl );
       }
   }else if( HB_IS_LONG( pSource )  ){
       long pLong = hb_itemGetNL( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetNL( pARRAY, i, (long) pLong );
       } 
   }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetL( pARRAY, i, (HB_BOOL) pBool ) ;
       }
   }
}
*/
/*void echo_single( PHB_ITEM pSource, unsigned PRECISION, FILE * fhnd ){
   if( HB_IS_STRING( pSource ) ){
       const char * pString = hb_itemGetCPtr( pSource );
       long nText = hb_itemGetCLen( pSource );
       fwrite( pString, nText, 1, fhnd );
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNI( pSource );
       char * buf = (char *)calloc(32,1);
       int size = sprintf(buf,"%d", pNum);
       const char * pString = buf;
       fwrite( pString, size, 1, fhnd );
       free(buf);
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%'.*lf", PRECISION, pDbl);
       //int size = sprintf(buf,"%f", pDbl);
       const char * pString = buf;
       fwrite( pString, size, 1, fhnd );
       free(buf);
   }else if( HB_IS_LONG( pSource ) ) {
       long pLong = hb_itemGetNL( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%ld", pLong);
       const char * pString = buf;
       fwrite( pString, size, 1, fhnd );
       free(buf);
   }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) fwrite( "1", 1,1,fhnd );
       else fwrite( "0", 1,1, fhnd );
   }
}*/

void echo_single( PHB_ITEM pSource, unsigned PRECISION, FILE * fhnd ){

   if( HB_IS_STRING( pSource ) ){
       fprintf(fhnd,"%s",hb_itemGetCPtr( pSource ));
   }else if( HB_IS_DOUBLE( pSource ) ) {
       if( SW_PRECISION )
          //fprintf(fhnd,"%lf",hb_itemGetND( pSource ));
          fprintf(fhnd,"%.*lf",PRECISION,hb_itemGetND( pSource ));
       else
          fprintf(fhnd,"%lf",hb_itemGetND( pSource ));  // "%g"
   }else if( HB_IS_LONG( pSource ) ) {
        
       fprintf(fhnd,"%ld",hb_itemGetNL( pSource ));
       
   }else if ( HB_IS_INTEGER ( pSource ) ){
       fprintf(fhnd,"%d",hb_itemGetNI( pSource ));
/*   }else if( HB_IS_LONG( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) fprintf(fhnd,"1");
       else fprintf(fhnd, "0");*/
   }
   
}

/*void hout_single( PHB_ITEM pSource, unsigned PRECISION ){
            
   if( HB_IS_STRING( pSource ) ){
       hb_conOutStd( hb_itemGetCPtr( pSource ), hb_itemGetCLen( pSource ) );
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNI( pSource );
       char * buf = (char *)calloc(32,1);
       int size = sprintf(buf,"%d", pNum);
       const char * pString = buf;
       hb_conOutStd( pString, size );
       free(buf);
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%.*lf", PRECISION, pDbl);
       const char * pString = buf;
       hb_conOutStd( pString, size );
       free(buf);
   }else if( HB_IS_LONG( pSource ) ) {
       long pLong = hb_itemGetNL( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%ld", pLong);
       const char * pString = buf;
       hb_conOutStd( pString, size );
       free(buf); 
   }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) hb_conOutStd( "1", 1 );
       else hb_conOutStd( "0", 1 );
   }
}*/


void print_single( PHB_ITEM pSource, unsigned PRECISION ){
   if( HB_IS_STRING( pSource ) ){
       printf("%s", hb_itemGetCPtr( pSource ));

   }else if( HB_IS_DOUBLE( pSource ) ) {
       if( SW_PRECISION )
          printf("%.*lf",PRECISION,hb_itemGetND( pSource ));
       else
          printf("%lf",hb_itemGetND( pSource )); //"%g"
   }else if( HB_IS_LONG( pSource ) ) {
       printf("%ld", hb_itemGetNL( pSource ));
   }else if ( HB_IS_INTEGER ( pSource ) ){
       printf("%d", hb_itemGetNI( pSource ));
   }
}

void echo_matrix( PHB_ITEM pSource, unsigned PRECISION, char *TOKENIZER, FILE *fhnd ){
            HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
            const char * tokenizer=TOKENIZER;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pDato = hb_itemArrayGet( pSource, i);
            echo_single( (PHB_ITEM) pDato, PRECISION, fhnd );
            if( d1-i ) fprintf( fhnd,"%s",tokenizer );
            hb_itemRelease(pDato);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               echo_single( (PHB_ITEM) pPrint, PRECISION, fhnd );
               hb_itemRelease(pPrint);
               if( d2-j ) fprintf( fhnd,"%s",tokenizer );
            }
            fprintf( fhnd,"\n" );
            hb_itemRelease(pDato2D);
         }
         break;
      }case 3:{
         int i;
         int k;
         for( k=1; k<=d3; k++){
            for( i=1; i<=d1; i++){
               PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
                  PHB_ITEM pPrint2 = hb_itemArrayGet( pPrint, k);
                  echo_single( (PHB_ITEM) pPrint2, PRECISION, fhnd );
                  hb_itemRelease(pPrint2);
                  if( d2-j ) fprintf( fhnd,"%s", tokenizer );
                  hb_itemRelease(pPrint);
               }
               hb_itemRelease(pDato2D);
               fprintf( fhnd,"\n" );
            }
           // fprintf( fhnd,"\n" );
         }
         break;     
      }
   }
}

HB_FUNC( PRINT_MATRIX ){
   PHB_ITEM pSource = hb_param( 1, HB_IT_ARRAY );
   
   echo_matrix( pSource, 13, ",", stdout);
}


void print_matrix( PHB_ITEM pSource, unsigned PRECISION , char *TOKENIZER  ){
            HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
            const char * tokenizer=TOKENIZER;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pDato = hb_itemArrayGet( pSource, i);
            print_single( (PHB_ITEM) pDato, PRECISION );
            if( d1-i ) putchar(tokenizer[0]);  //printf( "%s",tokenizer );
            hb_itemRelease(pDato);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               print_single( (PHB_ITEM) pPrint, PRECISION );

               hb_itemRelease(pPrint);
               if( d2-j ) putchar(tokenizer[0]);  //printf( "%s",tokenizer );
            }
            //printf( "\n" );
            putchar('\n');
            hb_itemRelease(pDato2D);
         }
         break;
      }case 3:{
         int i;
         int k;
         for( k=1; k<=d3; k++){
            printf( "PAGE: %d\n",k );
            for( i=1; i<=d1; i++){
               PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
                  PHB_ITEM pPrint2 = hb_itemArrayGet( pPrint, k);
                  print_single( (PHB_ITEM) pPrint2, PRECISION );                  
                  
                  hb_itemRelease(pPrint2);
                  if( d2-j ) putchar(tokenizer[0]);  //printf( "%s",tokenizer );
                  hb_itemRelease(pPrint);
               }
               hb_itemRelease(pDato2D);
               //printf( "\n" );
               putchar('\n');
            }
            putchar('\n');
         }
         break;
      }
   }
}

/* DEPRECADO */
/*int escapeDump(){
int sw=1;
if(CADDR){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1; //1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_STRING(pSource) ){
            printf("\033%s", hb_itemGetCPtr( pSource ) );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
      CADDR += SWKEEP; SWKEEP = 0;
}
return sw;
}*/
int fun_show(){
int cntDIR=CADDR;
int nPrecision = SW_PRECISION ? PRECISION : 13;
   if ( CADDR ){
      int ndxCADDR = 1;
      while (cntDIR){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){
            print_matrix( pSource, nPrecision, (char *)TOKENIZER );
         }else{
            print_single( pSource, nPrecision );
         }
         hb_itemRelease(pSource);
         --cntDIR;
  //       --CADDR;
         ++ndxCADDR;
      }
       fflush(stdout);
   }
return 1;
}
int fun_printusingtoken(){
int nPrecision = SW_PRECISION ? PRECISION : 13;
   if ( CADDR ){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1; //1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){

            print_matrix( pSource, nPrecision, (char *)TOKENIZER );
         }else{
            print_single( pSource, nPrecision );
            if( CADDR-1 ) putchar(TOKENIZER[0]); //printf( "%s",(char *)TOKENIZER );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
     // CADDR += SWKEEP; SWKEEP = 0;
     SWKEEP = 0; fflush(stdout);
/*      hb_arraySize(pSTK_ADDR,0);
      hb_arraySize(pSTK_ADDR,nSizeStack);
      hb_ret();
      hb_gcCollect(); */
   }
return 1;
}

int fun_print(){
int nPrecision = SW_PRECISION ? PRECISION : 13;
   
   if ( CADDR ){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1;//1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){

            print_matrix( pSource, nPrecision, (char *)TOKENIZER );
         }else{
            print_single( pSource, nPrecision );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
      //CADDR += SWKEEP; SWKEEP = 0;
      SWKEEP = 0; fflush(stdout);
/*      hb_arraySize(pSTK_ADDR,0);
      hb_arraySize(pSTK_ADDR,nSizeStack);
      hb_ret();
      hb_gcCollect(); */
   }
return 1;
}

int fun_echo(/*FILE *fhnd*/){
int nPrecision = SW_PRECISION ? PRECISION : 13;
   if ( CADDR ){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1;//1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){

            echo_matrix( pSource, nPrecision, (char *)TOKENIZER, (FILE *)stdout/*fhnd*/ );
         }else{
            echo_single( pSource, nPrecision, (FILE*)stdout /*fhnd*/ );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
      //CADDR += SWKEEP; SWKEEP = 0;
      SWKEEP = 0; fflush(stdout);
/*      hb_arraySize(pSTK_ADDR,0);
      hb_arraySize(pSTK_ADDR,nSizeStack);
      hb_ret();
      hb_gcCollect(); */
   }
return 1;
}


int fun_putstr(/* unsigned int nItem */){
int sw=1;
int nPrecision = SW_PRECISION ? PRECISION : 13;
//while(1){
   unsigned int nItem=(unsigned int)STK_PRG[++CP];
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY(pSource))
      print_matrix( pSource, nPrecision, (char *)TOKENIZER );
   else
      print_single( pSource, nPrecision );
   hb_itemRelease(pSource);
    fflush(stdout);
//   if(STK_PRG[ CP+1 ] != 288) break; else ++CP; // para el ajuste de comando
//}
return sw;
}

int fun_putstack(){
int sw=1;
int nPrecision = SW_PRECISION ? PRECISION : 13;
//while(CADDR){
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--); // lee dato
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_ARRAY(pSource))
      print_matrix( pSource, nPrecision, (char *)TOKENIZER );
   else
      print_single( pSource, nPrecision );
   hb_itemRelease(pSource);
    fflush(stdout);
//   if(STK_PRG[ CP+1 ] != 195) break; else ++CP; // para el ajuste de comando
//}
return sw;
}


#define XUINC1D   1
#define XUINC2D   1
#define XUDEC1D   2
#define XUDEC2D   2
void xu_incdec1d( PHB_ITEM pSource,/* PHB_ITEM pSTK_REG,*/ long nARG, HB_MAXINT d1, int CODE, int xcremento ){
    long i;
    //PHB_ITEM pARRAY = hb_itemArrayNew( d1 );  // crea un array vacío.
    for( i=1; i<=d1; i++ ){
        PHB_ITEM pNum = hb_itemArrayGet( pSource, i );
        
        switch( CODE ){
            //case XUINC1D: {put_inc_value(pARRAY, i, pNum,xcremento); break;}
            case XUINC1D: {put_inc_value(pSource, i, pNum,xcremento); break;}
            //case XUDEC1D: {put_dec_value(pARRAY, i, pNum,xcremento); break;}
            case XUDEC1D: {put_dec_value(pSource, i, pNum,xcremento); break;}
        }
        hb_itemRelease(pNum);
    }
    //hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pARRAY );
    hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pSource );
    //hb_itemRelease(pARRAY); 
}
                          
void xu_incdec2d( PHB_ITEM pSource, /*PHB_ITEM pSTK_REG,*/ long nARG, HB_MAXINT d1, HB_MAXINT d2, int CODE,int xcremento ){
   long i;
   //PHB_ITEM pARRAY = hb_itemArrayNew( d1 );  // crea un array vacío.
   for( i=1; i<=d1; i++ ){
        long j;
        PHB_ITEM pSource2 = hb_itemArrayGet( pSource, i );
        //PHB_ITEM pARRAY1 = hb_itemArrayNew( d2 );
        for( j=1; j<=d2; j++ ){ 
            PHB_ITEM pNum = hb_itemArrayGet( pSource2, j );

            switch( CODE ){
                //case XUINC2D: {put_inc_value(pARRAY1, j, pNum,xcremento); break;}
                case XUINC2D: {put_inc_value(pSource2, j, pNum,xcremento); break;}

                //case XUDEC2D: {put_dec_value(pARRAY1, j, pNum,xcremento); break;}
                case XUDEC2D: {put_dec_value(pSource2, j, pNum,xcremento); break;}

            }
            hb_itemRelease(pNum);
        }
        hb_arraySet( pSource, i, (PHB_ITEM) pSource2 );
        hb_itemRelease(pSource2);
        //hb_arraySet( pARRAY, i, (PHB_ITEM) pARRAY1 );
        //hb_itemRelease(pARRAY1);
        //hb_itemRelease(pSource2);
   }
   hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pSource );
   //hb_itemRelease(pSource);
   //hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pARRAY );
   //hb_itemRelease(pARRAY);
}

void xu_incdec3d( PHB_ITEM pSource, /*PHB_ITEM pSTK_REG,*/ long nARG, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, 
                  int CODE,int xcremento ){
   long i;
   //PHB_ITEM pARRAY = hb_itemArrayNew( d1 );  // crea un array vacío.
   for( i=1; i<=d1; i++ ){
        long j;
        PHB_ITEM pSource2 = hb_itemArrayGet( pSource, i );
        //PHB_ITEM pARRAY1 = hb_itemArrayNew( d2 );
        for( j=1; j<=d2; j++ ){ 
            PHB_ITEM pNum = hb_itemArrayGet( pSource2, j );
            //PHB_ITEM pARRAY2 = hb_itemArrayNew( d3 );
            long k;
            for( k=1; k<=d3; k++ ){ 
               PHB_ITEM pNum2 = hb_itemArrayGet( pNum, k );
               switch( CODE ){
                   //case XUINC2D: {put_inc_value(pARRAY2, k, pNum2,xcremento); break;}
                   case XUINC2D: {put_inc_value(pNum, k, pNum2,xcremento); break;}  
                   //case XUDEC2D: {put_dec_value(pARRAY2, k, pNum2,xcremento); break;}
                   case XUDEC2D: {put_dec_value(pNum, k, pNum2,xcremento); break;}

               }
               hb_itemRelease(pNum2);
            }
            hb_arraySet( pSource2, j, (PHB_ITEM) pNum );
            hb_itemRelease(pNum);
            //hb_arraySet( pARRAY1, j, (PHB_ITEM) pARRAY2 );
            //hb_itemRelease(pNum);
            //hb_itemRelease(pARRAY2);
        }
        hb_arraySet( pSource, i, (PHB_ITEM) pSource2 );
        hb_itemRelease(pSource2);
        //hb_arraySet( pARRAY, i, (PHB_ITEM) pARRAY1 );
        //hb_itemRelease(pARRAY1);
        //hb_itemRelease(pSource2);
   }
   hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pSource );
   //hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pARRAY );
   //hb_itemRelease(pARRAY);
}

void put_operator_value(PHB_ITEM pSTK_REG, unsigned int nARGo, PHB_ITEM pSource1, double num2, int OpCode){
   switch(OpCode){
      case 0:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(hb_itemGetND( pSource1 ) * num2, PRECISION) :
                                                            hb_itemGetND( pSource1 ) * num2 ) ; 
                                                            break;}
      case 1:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(hb_itemGetND( pSource1 ) / num2, PRECISION) :
                                                            hb_itemGetND( pSource1 ) / num2 ) ; 
                                                            break;}
      case 2:{hb_arraySetNL( pSTK_REG, nARGo, 
                             (long) (hb_itemGetND( pSource1 ) / num2 )) ; 
                                                            break;}
      case 3:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(pow(hb_itemGetND( pSource1 ), num2), PRECISION) :
                                                            pow(hb_itemGetND( pSource1 ), num2) ) ; 
                                                            break;}
      case 4:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(fmod(hb_itemGetND( pSource1 ), num2), PRECISION) :
                                                            fmod(hb_itemGetND( pSource1 ), num2) ) ; 
                                                            break;}
      case 5:{hb_arraySetNI( pSTK_REG, nARGo, 
                             (int) (hb_itemGetNI( pSource1 ) >> (int)num2 ) ); 
                                                            break;}
      case 6:{hb_arraySetNI( pSTK_REG, nARGo, 
                             (int) (hb_itemGetNI( pSource1 ) << (int)num2 )) ; 
                                                            break;}
      case 7:{hb_arraySetNL( pSTK_REG, nARGo, 
                             (long) (hb_itemGetNL( pSource1 ) | (long)num2 )) ; 
                                                            break;}
      case 8:{hb_arraySetNL( pSTK_REG, nARGo, 
                             (long) (hb_itemGetNL( pSource1 ) & (long)num2 )) ; 
                                                            break;}
      case 9:{hb_arraySetNI( pSTK_REG, nARGo, 
                             (int) (hb_itemGetNI( pSource1 ) ^ (int)num2 )) ; 
                                                            break;}
   }
}

int fun_opeCode(){
int sw=1;

//do{
   //unsigned int nARGo = (unsigned int)STK_PRG[++CP];  //OPCODE
   //PHB_ITEM pOpCode   = hb_itemArrayGet( pSTK_REG, nARGo);
   int OpCode = (unsigned int)STK_PRG[++CP]-1;  //OPCODE
   
   unsigned int nARG1 = (unsigned int)STK_PRG[++CP];  //OPERANDO 1, RECIPIENTE
   PHB_ITEM pSource1  = hb_itemArrayGet( pSTK_REG, nARG1);
   unsigned int nARG2 = (unsigned int)STK_PRG[++CP];  //OPERANDO 2
   PHB_ITEM pSource2  = hb_itemArrayGet( pSTK_REG, nARG2);
   if( HB_IS_NUMERIC( pSource2 ) ){   // operando 2 debe ser numero
      double num2 = hb_itemGetND(pSource2);
      //int OpCode = hb_itemGetNI(pOpCode);
      if( HB_IS_NUMERIC( pSource1 ) ) {  // operando 1 es numero
         put_operator_value((PHB_ITEM)pSTK_REG,nARG1, pSource1, num2, OpCode);
         
      }else if( HB_IS_ARRAY(pSource1) ){   // es array
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
         get_size( (PHB_ITEM) pSource1, &nDim, &d1, &d2, &d3, &type); 
         if ( type == 11 ){
            switch( nDim ){
               case 1:{
                  long i;
                  for( i=1; i<=d1; i++ ){
                     PHB_ITEM pNum1 = hb_itemArrayGet( pSource1, i );
                     put_operator_value(pSource1,i, pNum1, num2, OpCode);
                     hb_itemRelease(pNum1);
                  }
                 // hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pSource1 );
                  break;
               }case 2:{
                  long i;
                  for( i=1; i<=d1; i++ ){
                     PHB_ITEM pNum1 = hb_itemArrayGet( pSource1, i );
                     long j;
                     for( j=1; j<=d2; j++ ){
                        PHB_ITEM pNum11 = hb_itemArrayGet( pNum1, j );
                        put_operator_value(pNum1,j, pNum11, num2, OpCode);
                        hb_itemRelease(pNum11);
                     }
                     hb_arraySet( pSource1, i, (PHB_ITEM) pNum1 );
                     hb_itemRelease(pNum1);
                  }
                 // hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pSource1 );
                  break;
               }case 3:{
                  long i;
                  for( i=1; i<=d1; i++ ){
                     PHB_ITEM pNum1 = hb_itemArrayGet( pSource1, i );
                     long j;
                     for( j=1; j<=d2; j++ ){
                        PHB_ITEM pNum11 = hb_itemArrayGet( pNum1, j );
                        long k;
                        for( k=1; k<=d3; k++ ){
                           PHB_ITEM pNum111 = hb_itemArrayGet( pNum11, k );
                           put_operator_value(pNum11,k, pNum111, num2, OpCode);
                           hb_itemRelease(pNum111);
                        }
                        hb_arraySet( pNum1, j, (PHB_ITEM) pNum11 );
                        hb_itemRelease(pNum11);
                     }
                     hb_arraySet( pSource1, i, (PHB_ITEM) pNum1 );
                     hb_itemRelease(pNum1);
                  }
                //  hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pSource1 );

                  break;
               }default:{
                    sw=0;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "<ope>= ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "?<ope>=... ARGUMENT ERROR - TYPE NUMBER REQUERED",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "REG<ope>=? ARGUMENT ERROR - SINGLE TYPE NUMBER REQUERED",103);
   }
   hb_itemRelease(pSource2);
   hb_itemRelease(pSource1);
 //  hb_itemRelease(pOpCode);
   //++CP;
//}while ( STK_PRG[CP]==305 ); // CP==operator code +=, -=
//--CP;
return sw;
}


int funInc_one(){
int sw=1;

//do{
   ///short Tipo = nPCP == 202 ? 0 : 1;
   // extrae argumentos:

   int incremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);

/*   if( HB_IS_NUMERIC( pSource ) ) {
      put_inc_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource); */
   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource )+1)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )+1 ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource )+1) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUINC1D,incremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUINC2D,incremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUINC2D,incremento);break;}
            default:{
                 sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR - NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==202 ); // CP==operator code +=, -=
//--CP;
return sw;
}

int funInc_much(){
int sw=1;

//do{
   //short Tipo = nPCP == 202 ? 0 : 1;
   // extrae argumentos:

   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);

   unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
   int incremento = hb_itemGetNInt(pSop2);
   hb_itemRelease(pSop2);

/*   if( HB_IS_NUMERIC( pSource ) ) {
      put_inc_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);
*/
   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource ) + incremento)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )+ incremento ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource ) + incremento) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);

   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUINC1D,incremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUINC2D,incremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUINC2D,incremento);break;}
            default:{
                 sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR - NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==207 ); // CP==operator code +=, -=
//--CP;
return sw;
}

int funDec_one(){
int sw=1;
//do{
   //short Tipo = nPCP == 203 ? 0 : 1;
   // extrae argumentos:
   int decremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);

   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource )-1)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )-1 ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource )-1) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);

   }else if( HB_IS_STRING(pSource) ){
      put_dec_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);
      
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUDEC1D,decremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUDEC2D,decremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUDEC2D,decremento);break;}
            default:{
               sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==203 ); // CP==operator code +=, -=
//--CP;
return sw;
}

int funDec_much(){
int sw=1;

//do{
//short Tipo = nPCP == 203 ? 0 : 1;
   // extrae argumentos:
   //int decremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);
//   if( Tipo ){   // es 1: saco sguiente elemento.
      unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
      PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
      int decremento = hb_itemGetNInt(pSop2);
      hb_itemRelease(pSop2);
//   }

   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource ) - decremento)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )- decremento ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource ) - decremento) );
      hb_itemRelease(pSource);

   }else if( HB_IS_STRING(pSource) ){
      put_dec_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);
      
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUDEC1D,decremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUDEC2D,decremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUDEC2D,decremento);break;}
            default:{
               sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==209 ); // CP==operator code +=, -=
//--CP;
return sw;
}
/*int funInc(){
int sw=1;

do{
   short Tipo = nPCP == 202 ? 0 : 1;
   // extrae argumentos:
//   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_PRG, ++CP);
//   long nARG1 = hb_itemGetNInt( pARG1 );
   int incremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);
   if( Tipo ){   // es 1: saco sguiente elemento.
      unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
      PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
      incremento = hb_itemGetND(pSop2);
      hb_itemRelease(pSop2);
   }
   if( HB_IS_NUMERIC( pSource )  || HB_IS_STRING(pSource) ) {
      put_inc_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, XUINC1D,incremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, XUINC2D,incremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, d3, XUINC2D,incremento);break;}
            default:{
                 sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR - NUMBER REQUERED",103);
   }
//   hb_itemRelease(pSource);
//   hb_itemRelease(pARG1);
return sw;
}*/

/*int funDec(){
int sw=1;
short Tipo = nPCP == 203 ? 0 : 1;
   // extrae argumentos:
   int decremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);
   if( Tipo ){   // es 1: saco sguiente elemento.
      unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
      PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
      decremento = hb_itemGetND(pSop2);
      hb_itemRelease(pSop2);
   }

   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource ) - decremento)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )- decremento ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource ) - decremento) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);

   }else if( HB_IS_STRING(pSource) ){
      put_dec_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);
      
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, XUDEC1D,decremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, XUDEC2D,decremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, d3, XUDEC2D,decremento);break;}
            default:{
               sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- NUMBER REQUERED",103);
   }
return sw;
}*/

/********************************************************
               FUNCIONES STRING
 ********************************************************/

int concatenate_item( PHB_ITEM pARG1, PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR ){
   int sw=1;
   const char * pString1 = hb_itemGetCPtr( pARG1 );
   long nLen1 = hb_itemGetCLen( pARG1 );
   const char * pString2 = hb_itemGetCPtr( pARG2 );
   long nLen2 = hb_itemGetCLen( pARG2 );

   char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
   if ( pTarget == NULL ){
       sw=0;
       free(pTarget);
   }else{
     //  char * Temp = pTarget;
       hb_xmemcpy( pTarget, pString1, nLen1 );
       hb_xmemcpy( pTarget + nLen1, pString2, nLen2 );
       pTarget[nLen1 + nLen2 + 1] = '\0';
       hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pTarget );
       free(pTarget);
   }
   return sw;
}

int replicate_item(PHB_ITEM pTEXT, PHB_ITEM pSTK_ADDR, int CADDR, PHB_ITEM pTIMES){

   long nTimes = hb_itemGetNL( pTIMES );
   const char *szText = hb_itemGetCPtr( pTEXT );
   long nLen = hb_itemGetCLen( pTEXT );
   long nTotalLen = ( nLen * nTimes );
   char * szResult = (char *) calloc(( nTotalLen + 1),1);

   if ( szResult == NULL ) return 0;
     
   char * szPtr = szResult;

   while(nTimes)
   {
      int j=nLen;
      while(j--) szPtr[j] = szText[j];
      szPtr += nLen;
      --nTimes;
   }
   szResult[ nTotalLen ] = '\0';
   const char * pszResult = szResult;
   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
   free(szResult);
   return 1;
}

int stuff_item( PHB_ITEM pARG1, PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR, PHB_ITEM pPos, PHB_ITEM pDel ){
   int sw=1;
   const char * pString2 = hb_itemGetCPtr( pARG2 );  // lo que se corta.
   long nText = hb_itemGetCLen( pARG2 );
   
   long nPos = hb_itemGetNL( pPos );
   
   long nDel = ( pDel ) ? hb_itemGetNL( pDel ) : nText;
   
   const char * pString1;
   long nInsert;
   if( pARG1 != NULL ){
      pString1 = hb_itemGetCPtr( pARG1 );  // fuente
      nInsert = hb_itemGetCLen( pARG1 );
   }else{
      pString1 = "";
      nInsert=0;
   }
   long nTotalLen;
      if( nPos ){
         if( nPos < 1 || nPos > nText ){
            nPos = nText;
         }else{
            nPos--;
         }
      }

      if( nDel ){
         if( nDel < 1 || nDel > nText - nPos )  nDel = nText - nPos;
      }

      if( ( nTotalLen = nText + nInsert - nDel ) > 0 ){
         char * szResult = ( char * ) calloc( nTotalLen + 1, 1 );
         if( szResult != NULL ) {
             hb_xmemcpy( szResult, pString2, nPos );
             hb_xmemcpy( szResult + nPos, pString1, nInsert );
             hb_xmemcpy( szResult + nPos + nInsert, pString2 + nPos + nDel, nText - ( nPos + nDel ) );

             szResult[ nTotalLen ] = '\0';
             const char * pszResult = szResult;
             hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
             free(szResult);
         }else{
             sw=0;
         }
      }
      else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
      }
   return sw;
}

int strtran_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK, int NDX, long nInicio, long nCuenta ){
         
   int sw=1;
   if(!HB_IS_STRING(pARG3)){
       hb_arraySet( pSTK, NDX, pARG3 );
       return sw;
   }
   
   HB_SIZE nText = hb_itemGetCLen( pARG3 );
   HB_SIZE nSeek = hb_itemGetCLen( pARG2 );
         
   HB_SIZE nStart = nInicio<=0 ? 1 : nInicio;
   HB_SIZE nCount = nCuenta<=0 ? -1 : nCuenta;

   if( nSeek && nSeek <= nText && nStart > 0 ) {
      HB_SIZE nReplace; 
      const char * szReplace;
      if ( pARG1!=NULL ){
         szReplace = hb_itemGetCPtr( pARG1 );
         nReplace = hb_itemGetCLen( pARG1 ); 
      }else{
         szReplace = "";
         nReplace = 0;
      }
      
      const char * szText = hb_itemGetCPtr( pARG3 );
      const char * szSeek = hb_itemGetCPtr( pARG2 );
      HB_SIZE nFound = 0;
      HB_SIZE nReplaced = 0;
      HB_SIZE nT = 0;
      HB_SIZE nS = 0;

      while( nT < nText && nText - nT >= nSeek - nS ) {
         if( szText[ nT ] == szSeek[ nS ] ){
            ++nT;
            if( ++nS == nSeek ){
               if( ++nFound >= nStart ){
                  nReplaced++;
                  if( --nCount == 0 )
                     nT = nText;
               }
                  nS = 0;
            }
         }else if( nS ){
            nT -= nS - 1;
            nS = 0;
         }else
            ++nT;
      }

      if( nReplaced ){
         HB_SIZE nLength = nText;

         if( nSeek > nReplace )
            nLength -= ( nSeek - nReplace ) * nReplaced;
         else
            nLength += ( nReplace - nSeek ) * nReplaced;

         if( nLength ){
            char * szResult = ( char * ) calloc( nLength + 1, 1 );
            if ( szResult != NULL ){
               char * szPtr = szResult;

               nFound -= nReplaced;
               nT = nS = 0;
               do{
                  if( nReplaced && szText[ nT ] == szSeek[ nS ] ){
                     ++nT;
                     if( ++nS == nSeek ){
                        const char * szCopy;
   
                        if( nFound ){
                           nFound--;
                           szCopy = szSeek;
                        }else{
                           nReplaced--;
                           szCopy = szReplace;
                           nS = nReplace;
                        }
                        while( nS ){
                           *szPtr++ = *szCopy++;
                           --nS;
                        }
                     }
                  }else{
                     if( nS ){
                        nT -= nS;
                        nS = 0;
                     }
                     *szPtr++ = szText[ nT++ ];
                  }
               }while( nT < nText );
   
               const char * pszResult = szResult;
               hb_arraySetC( pSTK, NDX, (const char *) pszResult );
               
               free(szResult);
            }else{
               sw=0;
            }
         }else{
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
            hb_arraySet( pSTK, NDX, pARG3 );
         }
      }else{
         hb_arraySetC( pSTK, NDX, (const char *) szText );
      }
   }else{
      const char * szText = hb_itemGetCPtr( pARG3 );
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) szText );
   }
   return sw;
}
int strtran_item_single( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, long nInicio, long nCuenta ){
         
   int sw=1;
   if(!HB_IS_STRING(pARG3)){
       hb_arraySet( pSTK_ADDR, CADDR, pARG3 );
       return sw;
   }
   
   HB_SIZE nText = hb_itemGetCLen( pARG3 );
   HB_SIZE nSeek = hb_itemGetCLen( pARG2 );
         
   HB_SIZE nStart = nInicio<=0 ? 1 : nInicio;
   HB_SIZE nCount = nCuenta<=0 ? -1 : nCuenta;

   if( nSeek && nSeek <= nText && nStart > 0 ) {
      HB_SIZE nReplace; 
      const char * szReplace;
      if ( pARG1!=NULL ){
         szReplace = hb_itemGetCPtr( pARG1 );
         nReplace = hb_itemGetCLen( pARG1 ); 
      }else{
         szReplace = "";
         nReplace = 0;
      }
      
      const char * szText = hb_itemGetCPtr( pARG3 );
      const char * szSeek = hb_itemGetCPtr( pARG2 );
      HB_SIZE nFound = 0;
      HB_SIZE nReplaced = 0;
      HB_SIZE nT = 0;
      HB_SIZE nS = 0;

      while( nT < nText && nText - nT >= nSeek - nS ) {
         if( szText[ nT ] == szSeek[ nS ] ){
            ++nT;
            if( ++nS == nSeek ){
               if( ++nFound >= nStart ){
                  nReplaced++;
                  if( --nCount == 0 )
                     nT = nText;
               }
                  nS = 0;
            }
         }else if( nS ){
            nT -= nS - 1;
            nS = 0;
         }else
            ++nT;
      }

      if( nReplaced ){
         HB_SIZE nLength = nText;

         if( nSeek > nReplace )
            nLength -= ( nSeek - nReplace ) * nReplaced;
         else
            nLength += ( nReplace - nSeek ) * nReplaced;

         if( nLength ){
            char * szResult = ( char * ) calloc( nLength + 1, 1 );
            if ( szResult != NULL ){
               char * szPtr = szResult;

               nFound -= nReplaced;
               nT = nS = 0;
               do{
                  if( nReplaced && szText[ nT ] == szSeek[ nS ] ){
                     ++nT;
                     if( ++nS == nSeek ){
                        const char * szCopy;
   
                        if( nFound ){
                           nFound--;
                           szCopy = szSeek;
                        }else{
                           nReplaced--;
                           szCopy = szReplace;
                           nS = nReplace;
                        }
                        while( nS ){
                           *szPtr++ = *szCopy++;
                           --nS;
                        }
                     }
                  }else{
                     if( nS ){
                        nT -= nS;
                        nS = 0;
                     }
                     *szPtr++ = szText[ nT++ ];
                  }
               }while( nT < nText );
   
               const char * pszResult = szResult;
               hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
               
               free(szResult);
            }else{
               sw=0;
            }
         }else{
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
            hb_arraySet( pSTK_ADDR, CADDR, pARG3 );
         }
      }else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) szText );
      }
   }else{
      const char * szText = hb_itemGetCPtr( pARG3 );
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) szText );
   }
   return sw;
}

int substr_item( PHB_ITEM pText, PHB_ITEM pPos, PHB_ITEM pLen, PHB_ITEM pSTK_ADDR, int CADDR){
   int sw=1;
   if(!HB_IS_STRING(pText)){
       hb_arraySet( pSTK_ADDR, CADDR, pText );
       return sw;
   }
      long nPos = hb_itemGetNL( pPos );
      //HB_ISIZ nSize = 0;//hb_itemGetCLen( pText );
      HB_ISIZ nSize = hb_itemGetCLen( pText );
      
/*      char *szDest;
      const char *Text;
      int swUTF8=1;
      if(swUTF8){
         szDest = convertSTR( (PHB_ITEM) pText);
         Text = szDest;
         nSize = hb_cdpUTF8StringLength( hb_itemGetCPtr( pText ), hb_itemGetCLen( pText ) );
      }else{
         const char * Text = hb_itemGetCPtr( pText );
         nSize = hb_itemGetCLen( pText );
      }*/

      if( nPos < 0 ){
         nPos += nSize;
         if( nPos < 0 )
            nPos = 0;
      }
      else if( nPos ){
         nPos--;
      }

      if( nPos < nSize ){
         HB_ISIZ nLen;

         if ( pLen ) { 
               nLen = hb_itemGetNL( pLen );

               if( nLen > nSize - nPos )
                  nLen = nSize - nPos;
         }else{
            nLen = nSize - nPos;
         }
         
         if( nLen > 0 ){
            if( nLen == nSize ){
               const char * Text = hb_itemGetCPtr( pText );
               hb_arraySetC( pSTK_ADDR, CADDR, (const char *) Text  );
            }else{
               const char * Text = hb_itemGetCPtr( pText );

               char * szResult = ( char * ) calloc( nLen + 1, 1 );
               if ( szResult != NULL ){
                   Text = Text + nPos;
                   hb_xmemcpy( szResult, Text, nLen );
                   szResult[ nLen ] = '\0';
                   const char * pszResult = szResult;
                   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
                   free(szResult);
               }else{
                   sw=0;
               }
            }
         }else{
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
            hb_arraySet( pSTK_ADDR, CADDR, pText );
         }
      }else{
         //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
         hb_arraySet( pSTK_ADDR, CADDR, pText );
      }
   
 /*  if(swUTF8){
      free(szDest);
   }*/
   
   return sw;
}

int str_index_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pMATCH, PHB_ITEM pSTK_ADDR, int CADDR ){
int sw=1;
   const char *pcStringToMatch = hb_itemGetCPtr( pSTRING );
   HB_SIZE sStrToMatchLen = hb_itemGetCLen( pSTRING );
      
   const char *pcString = hb_itemGetCPtr( pTEXT );
   HB_SIZE sStrLen = hb_itemGetCLen( pTEXT );

   HB_SIZE sIgnore=0, sMatchStrLen = 0;
   HB_SIZE nCounter;
   const char *pc = NULL;

   /* nth match or last match ? */
   if( pMATCH != NULL ){
      /* find the <nCounter>th match */
      const char *pcSubStr;
      HB_SIZE sSubStrLen;
      HB_SIZE nMatchCounter = 0;

      pcSubStr = pcString;
      sSubStrLen = sStrLen;
      nCounter = hb_itemGetNL( pMATCH );
      
      if( nCounter > 0 ){
         while( nMatchCounter < nCounter ){
            pc = ct_at_exact_forward( pcSubStr, sSubStrLen, pcStringToMatch,
                                               sStrToMatchLen, &sMatchStrLen );
            if( pc == NULL ){
               /* no match found; if this happens at this point,
                  there are no <nCounter> matches, so return an empty string */
               hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
               return sw;
            }
            nMatchCounter++;

            if( MULTIPASS )
               pcSubStr = pc + 1;
            else
               pcSubStr = pc + sMatchStrLen;
            sSubStrLen = sStrLen - ( pcSubStr - pcString );
         }
      }else{  // busca igual como si no existiera el último
         pc = ct_at_exact_backward( pcString, sStrLen, pcStringToMatch,
                                          sStrToMatchLen, &sMatchStrLen );
         if( pc == NULL ){
            /* ATNUM */
            hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
           return sw;
         } 
      }
   }else{
      pc = ct_at_exact_backward( pcString, sStrLen, pcStringToMatch,
                                          sStrToMatchLen, &sMatchStrLen );
      if( pc == NULL ){
         /* ATNUM */
         hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
         return sw;
      }
   }
   hb_arraySetNInt( pSTK_ADDR, CADDR, ( pc - ( pcString - sIgnore ) + 1 ) );
return sw;
}

int str_count_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pIGNORE, PHB_ITEM pSTK, int NDX ){
int sw=1;
      const char *pcStringToMatch = hb_itemGetCPtr( pSTRING );
      HB_SIZE sStrToMatchLen = hb_itemGetCLen( pSTRING );
      
      const char *pcString = hb_itemGetCPtr( pTEXT );
      HB_SIZE sStrLen = hb_itemGetCLen( pTEXT );
      
      HB_SIZE sIgnore, sMatchStrLen = 0, sSubStrLen;
      HB_SIZE nCounter;
      const char *pc, *pcSubStr;

      /* eventually ignore some characters */
      if( pIGNORE!=NULL )
         sIgnore = hb_itemGetNL( pIGNORE );
      else
         sIgnore = 0;

      if( sIgnore >= sStrLen ){
         hb_arraySetNInt( pSTK, NDX, 0 );
         return sw;
      }else{
         pcString += sIgnore;
         sStrLen -= sIgnore;
      }

      nCounter = 0;
      pcSubStr = pcString;
      sSubStrLen = sStrLen;

      do{
         pc = ct_at_exact_forward( pcSubStr, sSubStrLen, pcStringToMatch,
                                   sStrToMatchLen, &sMatchStrLen );
         nCounter++;
         if( MULTIPASS ){
            pcSubStr = pc + 1;
         }else{
            pcSubStr = pc + sMatchStrLen;
         }
         sSubStrLen = sStrLen - ( pcSubStr - pcString );
      }while( pc != NULL );

      hb_arraySetNInt( pSTK, NDX, ( nCounter - 1 ) );
return sw;
}

int str_count_at_single( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pIGNORE ){
int sw=1;
      const char *pcStringToMatch = hb_itemGetCPtr( pSTRING );
      HB_SIZE sStrToMatchLen = hb_itemGetCLen( pSTRING );
      
      const char *pcString = hb_itemGetCPtr( pTEXT );
      HB_SIZE sStrLen = hb_itemGetCLen( pTEXT );
      
      HB_SIZE sIgnore, sMatchStrLen = 0, sSubStrLen;
      HB_SIZE nCounter;
      const char *pc, *pcSubStr;

      /* eventually ignore some characters */
      if( pIGNORE!=NULL )
         sIgnore = hb_itemGetNL( pIGNORE );
      else
         sIgnore = 0;

      if( sIgnore >= sStrLen ){
         hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
         return sw;
      }else{
         pcString += sIgnore;
         sStrLen -= sIgnore;
      }

      nCounter = 0;
      pcSubStr = pcString;
      sSubStrLen = sStrLen;

      do{
         pc = ct_at_exact_forward( pcSubStr, sSubStrLen, pcStringToMatch,
                                   sStrToMatchLen, &sMatchStrLen );
         nCounter++;
         if( MULTIPASS ){
            pcSubStr = pc + 1;
         }else{
            pcSubStr = pc + sMatchStrLen;
         }
         sSubStrLen = sStrLen - ( pcSubStr - pcString );
      }while( pc != NULL );

      hb_arraySetNInt( pSTK_ADDR, CADDR, ( nCounter - 1 ) );
return sw;
}


int str_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pSTK, int NDX ){
int sw=1;
   const char * pText = hb_itemGetCPtr( pTEXT );  // String base
   long nLenText = hb_itemGetCLen( pTEXT );
   const char * pSub = hb_itemGetCPtr( pSTRING );  // string to search
   long nLenSub = hb_itemGetCLen( pSTRING );

   hb_arraySetNInt( pSTK, NDX, hb_strAt( pSub, nLenSub, pText, nLenText ) );

return sw;
}
int str_at_single( PHB_ITEM pTEXT, PHB_ITEM pSTRING ){
int sw=1;
   const char * pText = hb_itemGetCPtr( pTEXT );  // String base
   long nLenText = hb_itemGetCLen( pTEXT );
   const char * pSub = hb_itemGetCPtr( pSTRING );  // string to search
   long nLenSub = hb_itemGetCLen( pSTRING );

   hb_arraySetNInt( pSTK_ADDR, CADDR, hb_strAt( pSub, nLenSub, pText, nLenText ) );

return sw;
}

int fun_mask_item( PHB_ITEM pARG, PHB_ITEM pMASK, PHB_ITEM pRELL, PHB_ITEM pSTK_ADDR, int CADDR ) {
int sw=1;
   
   const char * numero = hb_itemGetCPtr( pARG );
   const char * car = hb_itemGetCPtr( pRELL );
   const char * formato = hb_itemGetCPtr( pMASK );
   
   long ln = hb_itemGetCLen( pARG );
   long lf = hb_itemGetCLen( pMASK );
   
   char *buffer, *pBuf;

   pBuf = (char *)calloc(lf+1,1);
   if (pBuf==NULL) return 0;

   buffer = pBuf;
   int16_t i=lf, k=lf; 

   char c; 
   --lf; --ln; --k;
   while (lf>=0 && ln>=0) {
      c = formato[lf];
      if (c=='#') buffer[k] = numero[ln--]; 
      else buffer[k] = c;
      --k;
      --lf;
   }
   while (lf>=0) {
      c = formato[lf];
      if (*car) {
         if (c=='#') buffer[k] = *car;
         else buffer[k] = c;
      } else {
         buffer[k] = ' ';
      }
      --lf;
      --k;
   }
   buffer[i]='\0';
   const char * pBuffer = buffer; 
   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pBuffer );
   free(pBuf);
   
return sw;
}

int fun_money_item(PHB_ITEM pARG,PHB_ITEM pDEC,PHB_ITEM pSTK_ADDR,int CADDR){
int sw=1;
   double numero = hb_itemGetND( pARG );
   
   int decimales = hb_itemGetNI( pDEC );
   char *buffer = (char *)calloc (1024,1); 
   if (buffer==NULL) return 0;
   char *num = (char *)calloc (1024,1); 
   if (num==NULL) return 0;
   
   char *buf = buffer;

   int i=0,j=0,swNeg=0;
   if( numero < 0 ) {
      swNeg=1;
      numero *= -1;
   }
   
   uint16_t size = sprintf(buf,"%.*lf",decimales, numero);
   int intSize=size;
   if( decimales>0 ){
      intSize=size-decimales-1;  // longitud entero
   }

   if( swNeg ){  
      num[0] = '-';
      ++i;
   }
   num[i] = buf[0];
   ++j;++i;
   --intSize;
   
   while( intSize ){
      if( buf[j]=='.' ) {
         num[i++] = buf[j];
         break;
      }else{
         if( fmod(intSize,3) )
            num[i++] = buf[j];
         else{
            num[i++] = ',';
            num[i++] = buf[j];
         }
      }
      ++j;
      --intSize;
      --size;
   }
   while( size ){
      num[i++] = buf[j];
      --size;
      ++j;
   }
   free(buffer);
 // completar signo, moneda y pad.  
   num[i]='\0';
   const char * pBuffer = num; 
   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pBuffer );
   free(num);

return sw;
}

int fun_str_item( PHB_ITEM pARG, PHB_ITEM pSTK, int NDX, int tCompare ){
int sw=1;

   switch( tCompare ){
      case 0:{
         //long cLen = hb_cdpUTF8StringLength( hb_itemGetCPtr( pARG ), hb_itemGetCLen( pARG ) );   
         long cLen = hb_itemGetCLen( pARG );
         hb_arraySetNL( pSTK, NDX, cLen ) ;
         break;  // LEN
      }case 1:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strUpper( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK, NDX, Buffer ); // UPPER
         else
            hb_arraySetC( pSTK, NDX, "error-memory-upper" );
         free(cBuffer);
         //free(Buffer);
         break;
      }case 2:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strLower( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK, NDX, Buffer ); // LOWER
         else
            hb_arraySetC( pSTK, NDX, "error-memory-lower" );
         free(cBuffer);
         //free(Buffer);
         break; 
      }case 3:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_alltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK, NDX, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK, NDX, "error-memory-trim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 4:{
         const char * Buffer = hb_itemGetCPtr( pARG );    // ASC
         hb_arraySetNInt( pSTK, NDX, ( HB_UCHAR ) Buffer[0] );
         break;
      }case 5:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_rtrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK, NDX, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK, NDX, "error-memory-rtrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 6:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_ltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK, NDX, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK, NDX, "error-memory-ltrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
         
      }case 7:{
         /*if( HB_IS_LOGICAL( pARG ) ){
            HB_BOOL lDato = hb_itemGetL( pARG );
            hb_arraySetNI( pSTK_ADDR, CADDR, (int) lDato ? 1 : 0 );
            
         }else*/ if( HB_IS_STRING( pARG ) ){
            const char * szText = hb_itemGetCPtr( pARG );  // XTONUM
            int iWidth, iDec, iLen = ( int ) hb_itemGetCLen( pARG );
            HB_BOOL fDbl;
            HB_MAXINT lValue;
            double dValue;

            fDbl = hb_valStrnToNum( szText, iLen, &lValue, &dValue , &iDec, &iWidth );

            if( !fDbl ){
               hb_arraySetNL( pSTK, NDX, (HB_MAXINT) lValue );
            }else{
               hb_arraySetND( pSTK, NDX, (double) dValue );
            }
         }else if( HB_IS_INTEGER(pARG)){
            int nInt = hb_itemGetNI( pARG );
            hb_arraySetNI( pSTK, NDX, (int) nInt );
         }else if( HB_IS_LONG(pARG)){
            long nLong = hb_itemGetNL( pARG );
            hb_arraySetNL( pSTK, NDX, (long) nLong );
         }else if( HB_IS_DOUBLE(pARG)){
            double nDouble = hb_itemGetND( pARG );
            hb_arraySetND( pSTK, NDX, (double) nDouble );
         }else{
            sw=0;
         }
         break;
         
      }default: sw=0;
   }

return sw;
}

int fun_str_item_single( PHB_ITEM pARG, int tCompare ){
int sw=1;

   switch( tCompare ){
      case 0:{
         long cLen = hb_itemGetCLen( pARG );
         hb_arraySetNL( pSTK_ADDR, CADDR, cLen ) ;
         break;  // LEN
      }case 1:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strUpper( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // UPPER
         else
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-upper" );
         free(cBuffer);
         //free(Buffer);
         break;
      }case 2:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strLower( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // LOWER
         else
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-lower" );
         free(cBuffer);
         //free(Buffer);
         break; 
      }case 3:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_alltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-trim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 4:{
         const char * Buffer = hb_itemGetCPtr( pARG );    // ASC
         hb_arraySetNInt( pSTK_ADDR, CADDR, ( HB_UCHAR ) Buffer[0] );
         break;
      }case 5:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_rtrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-rtrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 6:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_ltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-ltrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
         
      }case 7:{
         if( HB_IS_STRING( pARG ) ){
            const char * szText = hb_itemGetCPtr( pARG );  // XTONUM
            int iWidth, iDec, iLen = ( int ) hb_itemGetCLen( pARG );
            HB_BOOL fDbl;
            HB_MAXINT lValue;
            double dValue;

            fDbl = hb_valStrnToNum( szText, iLen, &lValue, &dValue , &iDec, &iWidth );

            if( !fDbl ){
               hb_arraySetNL( pSTK_ADDR, CADDR, (HB_MAXINT) lValue );
            }else{
               hb_arraySetND( pSTK_ADDR, CADDR, (double) dValue );
            }
         }else if( HB_IS_INTEGER(pARG)){
            int nInt = hb_itemGetNI( pARG );
            hb_arraySetNI( pSTK_ADDR, CADDR, (int) nInt );
         }else if( HB_IS_LONG(pARG)){
            long nLong = hb_itemGetNL( pARG );
            hb_arraySetNL( pSTK_ADDR, CADDR, (long) nLong );
         }else if( HB_IS_DOUBLE(pARG)){
            double nDouble = hb_itemGetND( pARG );
            hb_arraySetND( pSTK_ADDR, CADDR, (double) nDouble );
         }else{
            sw=0;
         }
         break;
         
      }default: sw=0;
   }

return sw;
}


int fun_num_item( PHB_ITEM pARG, PHB_ITEM pSTK, int NDX, int tCompare){//, int PRECISION ){
int sw=1;

   switch( tCompare ){
      case 0:{   // EXP
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( exp( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           exp( hb_itemGetND( pARG ) ) );
         break;
      }case 1:{  // INT
         hb_arraySetNL( pSTK, NDX, (long) ( hb_itemGetND( pARG ) ) );
         break;
      }case 2:{  // SIGN
         double nItem = hb_itemGetND( pARG );
         hb_arraySetNI( pSTK, NDX, (int) ( nItem > 0 ? 1 : nItem < 0 ? -1 : 0 ) );
         break;
      }case 3:{  // LOG
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( log( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           log( hb_itemGetND( pARG ) ) );
         break;
      }case 4:{  // LOG10
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( log10( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           log10( hb_itemGetND( pARG ) ) );
         break;
      }case 5:{  // SQRT
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( sqrt( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           sqrt( hb_itemGetND( pARG ) ) );
         break;
      }case 6:{  // SIN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( sin( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           sin( hb_itemGetND( pARG ) ) );
         break;
      }case 7:{  // COS
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( cos( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           cos( hb_itemGetND( pARG ) ) );
         break;
      }case 8:{  // TAN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( tan( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           tan( hb_itemGetND( pARG ) ) );
         break;
      }case 9:{  // SINH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( sinh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           sinh( hb_itemGetND( pARG ) ) );
         break;
      }case 10:{  // COSH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( cosh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           cosh( hb_itemGetND( pARG ) ) );
         break;
      }case 11:{  // TANH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( tanh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           tanh( hb_itemGetND( pARG ) ) );
         break;
      }case 12:{  // XTOSTR
         //itoa( hb_itemGetND( pARG ), cText);
         if ( HB_IS_INTEGER ( pARG ) ){
            int pNum = hb_itemGetNInt( pARG );
            char * buf = (char *)calloc(32,1);
            /*int size = */sprintf(buf,"%d", pNum);
            const char * pString = buf;
            hb_arraySetC( pSTK, NDX, pString );
            free(buf);
         }else if( HB_IS_NUMERIC( pARG ) ) {
            double pDbl = hb_itemGetND( pARG );
            
            char * buf = (char *)calloc(80,1);
            if(SW_PRECISION){
               sprintf(buf,"%.*lf",PRECISION, pDbl);

            }else{

               sprintf(buf,"%lf",pDbl);
            }
            const char * pString = buf;
            hb_arraySetC( pSTK, NDX, pString );
            free(buf);
         }else if( HB_IS_LONG( pARG ) ) {
            long pLong = hb_itemGetNL( pARG );
            char * buf = (char *)calloc(64,1);
            /*int size = */sprintf(buf,"%ld", pLong);
            const char * pString = buf;
            hb_arraySetC( pSTK, NDX, pString );
            free(buf);

         }else{  // es un string.
            const char* pString = hb_itemGetCPtr( pARG );
            hb_arraySetC( pSTK, NDX, pString );
         }
         break;
      }case 13:{  // FLOOR
         hb_arraySetNL( pSTK, NDX, (long)  floor( hb_itemGetND( pARG ) ) );
         break;
      }case 14:{  // ABS
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( fabs( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           fabs( hb_itemGetND( pARG ) ) );
         break;
      }case 15:{  // CHR
         hb_arraySetC( pSTK, NDX, hb_szAscii[ (int)hb_itemGetNInt( pARG ) & 0xFF ] );
         break;
      }case 16:{  // CEIL
         hb_arraySetNL( pSTK, NDX, (long) ceil( hb_itemGetND( pARG ) ) );
         break;
      }case 17:{  // EXP2
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( exp2( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           exp2( hb_itemGetND( pARG ) ) );
         break;
      }case 18:{  // LOG2
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( log2( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           log2( hb_itemGetND( pARG ) ) );
         break;
      }case 19:{  // EXP10
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( exp10( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           exp10( hb_itemGetND( pARG ) ) );
         break;
      }case 20:{  // HEX
         long pLong = hb_itemGetNL( pARG );
         char * buf = (char *)calloc(64,1);
         /*int size = */sprintf(buf,"%lX", pLong);
         const char * pString = buf;
         hb_arraySetC( pSTK, NDX, pString );
         free(buf);

         break;
      }case 21:{  // BIN
         long k, c, nNum = hb_itemGetNL( pARG );
         int size=63;
         if(SIZE_BINARY>0) size = SIZE_BINARY;
         char * buffer = (char *)calloc(size+2,1);
         for (c = size; c >= 0; c--){
            k = nNum >> c;
            if (k & 1)
               buffer[size-c] = '1';
            else
               buffer[size-c] = '0';
         }
         buffer[size+1] = '\0';
         const char * pString = buffer;
         if(!SIZE_BINARY){  // quita los ceros de más
            while(*pString!='1') pString++;
         }
         
         hb_arraySetC( pSTK, NDX, pString );
         free(buffer);

         break;
      }case 22:{  // OCT
         HB_MAXINT decimal = hb_itemGetNL( pARG );
/*         HB_MAXINT octal=0;
         int i=1;
//         printf("\nNUM = %ld\n",octal);
         while (decimal != 0){
            octal += (decimal % 8) * i;
            decimal /= 8;
            i *= 10;
         }*/
//         printf("\nOCTAL = %ld\n",octal);
//         hb_arraySetNL( pSTK, NDX, octal );
         char * buf = (char *)calloc(64,1);
         /*int size = */sprintf(buf,"%lo", decimal);
         const char * pString = buf;
         hb_arraySetC( pSTK, NDX, pString );
         free(buf);

         break;
      }case 23:{  // lennum
         hb_arraySetNI( pSTK, NDX, (int)ceil(log10( hb_itemGetND( pARG ) )) );
         break;
      }case 24:{  // FACTORIAL
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( FFACTORIAL( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           FFACTORIAL( hb_itemGetND( pARG ) ) );
         break;
      }case 25:{  // SCI, NOTATION
         char buf[1024];
         sprintf(buf,"%e", (double) hb_itemGetND( pARG ));
         //char *buf = fun_notation( (double) hb_itemGetND( pARG ), (double) PRECISION );
         const char * buffer = buf;
         hb_arraySetC( pSTK, NDX, buffer );
         //free(buf);
         break;
      }case 26:{   // D2R
         double dInput = hb_itemGetND( pARG );
         double dResult = ( 3.14159265358979323846 / 180.0 ) * dInput;
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision(dResult, PRECISION) : dResult );

         break;
      }case 27:{   // R2D
         double dInput = hb_itemGetND( pARG );
         double dResult = ( 180.0 / 3.14159265358979323846 ) * dInput;
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision(dResult, PRECISION) : dResult );
         
         break;
      }case 28:{   // CBRT raíz cubica
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( cbrt( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           cbrt( hb_itemGetND( pARG ) ) );
         break;
      }case 29:{   // RAND
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( ( hb_random_num() * hb_itemGetND( pARG ) ), PRECISION ) :
                                                           ( hb_random_num() * hb_itemGetND( pARG ) ) );
         break;
      }case 30:{   // TRUNC
         hb_arraySetNL( pSTK, NDX, (long) trunc( hb_itemGetND( pARG ) ));
         break;
      }case 31:{   // EVEN
         hb_arraySetNI( pSTK, NDX, (int) ( fmod(hb_itemGetND( pARG ),2 )==0 ? 1 : 0 ) );
         break;
      }case 32:{   // NEG
         if( HB_IS_DOUBLE( pARG ) )         hb_arraySetND( pSTK, NDX, (double) -hb_itemGetND(pARG) );
         else if( HB_IS_LONG( pARG ) )       hb_arraySetNL( pSTK, NDX, (long)   -hb_itemGetNL(pARG) );
         else if( HB_IS_INTEGER( pARG ) )    hb_arraySetNI( pSTK, NDX, (int)    -hb_itemGetNI(pARG) );
         else sw=0;
         break;
      }case 33:{  // ASIN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( asin( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           asin( hb_itemGetND( pARG ) ) );
         break;
      }case 34:{  // ACOS
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( acos( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           acos( hb_itemGetND( pARG ) ) );
         break;
      }case 35:{  // ATAN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( atan( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           atan( hb_itemGetND( pARG ) ) );
         break;
      }case 36:{  // ASINH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( asinh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           asinh( hb_itemGetND( pARG ) ) );
         break;
      }case 37:{  // ACOSH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( acosh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           acosh( hb_itemGetND( pARG ) ) );
         break;
      }case 38:{  // ATANH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( atanh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           atanh( hb_itemGetND( pARG ) ) );
         break;
      }case 39:{  // NOT NEG
         hb_arraySetND( pSTK, NDX, (double) hb_itemGetND( pARG ) >= 0 );
         break;
      }case 40:{  // NOT POS
         hb_arraySetND( pSTK, NDX, (double) hb_itemGetND( pARG ) <= 0 );
         break;

      }default: sw=0;
   }
return sw;
}

int fun_pad_item( PHB_ITEM pARG, PHB_ITEM pPAD, PHB_ITEM pRELL, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
   const char * cText = hb_itemGetCPtr( pARG );
   const char * cRelleno = hb_itemGetCPtr( pRELL );
   HB_MAXINT nSize = hb_itemGetCLen( pARG );
   HB_MAXINT nLen = hb_itemGetNL( pPAD );

   if( nLen <= nSize ){
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) cText );
   }else{
      switch( tCompare){
         case 0: {   // PADC 
            char * szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = cRelleno[0];
            HB_ISIZ nPad = ( ( HB_SIZE ) nLen - nSize ) >> 1;
            //cPad = ' '; //( HB_ISCHAR( 3 ) ? *( hb_parc( 3 ) ) : ' ' );
            memset( szResult, cPad, nPad );
            memcpy( szResult + nPad, cText, nSize );
            memset( szResult + nPad + nSize, cPad, ( HB_SIZE ) nLen - nSize - nPad );
            const char * milenka = szResult;
            hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            free( szResult );
            break;
         }case 1: {  // PADR
            char * szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = cRelleno[0];
//            cPad = ' ';
            memcpy( szResult, cText, nSize );
            memset( szResult + nSize, cPad, ( HB_SIZE ) nLen - nSize );
            const char * milenka = szResult;
            hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            free( szResult );
            break;
         }case 2: {  // PADL
            char * szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = cRelleno[0];
//            cPad = ' ';
            memset( szResult, cPad, ( HB_SIZE ) nLen - nSize );
            memcpy( szResult + ( HB_SIZE ) nLen - nSize, cText, nSize );
            const char * milenka = szResult;
            hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            free( szResult );
            break;
         }
      }
   }
return sw;
}

int fun_getseptok(){
int sw=1;
if(CADDR<nSizeStack){
   const char* tokenizer = TOKENIZER;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) tokenizer );
   
}else{
   sw=put_error((PHB_ITEM) pRET, "GET TOKEN SEPARATOR STACK UNDERFLOW",102); 
}
return sw;
}

int settokenizer(){
int sw=1;
   if( CADDR>0 ){
      PHB_ITEM pToken = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      CADDR += SWKEEP; SWKEEP = 0;
      const char * cToken = hb_itemGetCPtr( pToken );
      hb_itemRelease(pToken);
      TOKENIZER[0]=cToken[0];
   }else{
      sw=put_error((PHB_ITEM) pRET, "DEFINE TOKEN STACK UNDERFLOW",102); 
   }
return sw;
}

int fun_modtoken_item( PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pCTOKEN, PHB_ITEM pSTK_ADDR, int CADDR,char *TOKENIZER ){
int sw=1;

   long cLen = hb_itemGetCLen( pTEXT );
   
   if(cLen){
      long rLen = hb_itemGetCLen( pCTOKEN );
      const char * cTXT = hb_itemGetCPtr( pTEXT );
      const char * cTOK = hb_itemGetCPtr( pCTOKEN );
      int nToken = hb_itemGetNInt( pTOKEN );
   //if(rLen){
      const char* tokenizer = TOKENIZER;
      char *cTexto = (char *)calloc( cLen + 100, 1 );
      char *cFinal = (char *)calloc( cLen + rLen + 100, 1 );
      memcpy( cTexto, cTXT, cLen );
      char* token; 

   //printf("\nCTOK= [%s]\n",cTOK);

      int nTok=1;
      token = strtok(cTexto, tokenizer);
      if( !token ){
         sw=put_error((PHB_ITEM) pRET, "MOD TOKEN|$$ TOKEN SEPARATOR NOT FOUND",103); 
      }else{
      while( token ){
         if( nTok == nToken ){ // guardo el reemplazo
            if( nTok>1 ){
               strncat(cFinal, tokenizer,1 );
            }
            if( cTOK!=NULL ) {
               strcat(cFinal, cTOK );
            }
         }else{  // guardo el token leido
            if(nTok>1) {
               strncat(cFinal, tokenizer,1 );
            }
           /* if( token ) */strcat(cFinal, token );
            
         }  
         token = strtok(0, tokenizer);
         ++nTok;
      }
      }
      if( *cFinal ){
        // cFinal[ strlen(cFinal)]='\0';
         int nLen = strlen(cFinal)-1;
        // printf("LEN = %d- [%s] CHAR = %c\n",nLen,cFinal,cFinal[nLen]);
         if(cFinal[ nLen ]==*tokenizer){
            cFinal[ nLen ]='\0';
         }
         const char * pFinal = cFinal;
         if(*pFinal==*tokenizer){
            ++pFinal;
         }
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pFinal );
         
      }else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "*");//cTXT );
      }
      free(cTexto);
      free(cFinal);
   }else{
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "*" );
   }
return sw;
}

int tottoken( /*int nItem */){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_REG, nItem );
   long cLen = hb_itemGetCLen( pTEXT );
   const char * cTXT = hb_itemGetCPtr( pTEXT );
   
   if( CADDR<nSizeStack ){

      const char* tokenizer = TOKENIZER;
      char *cTexto = (char *)calloc( cLen + 1, 1 );
      memcpy( cTexto, cTXT, cLen );
      char* token; 
      //char* rest = cTexto; 
      int nTok=0;
      token = strtok(cTexto, tokenizer);
      if( !token ){
         sw=put_error((PHB_ITEM) pRET, "TOTAL TOKEN - TOKEN SEPARATOR NOT FOUND",103); 
      }else{

         while( token ){
            token = strtok(0, tokenizer);
            ++nTok;

         }  

         ++CADDR;
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) nTok );
      }
      free(cTexto);
   }else{
      sw=put_error((PHB_ITEM) pRET, "TOTAL TOKEN STACK UNDERFLOW",102);
   }
   hb_itemRelease(pTEXT);
return sw;
}

int fun_gettoken_item( PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pSTK_ADDR, int CADDR, char *TOKENIZER ){
int sw=1;
   long cLen = hb_itemGetCLen( pTEXT );
   const char * cTXT = hb_itemGetCPtr( pTEXT );
   int nToken = hb_itemGetNInt( pTOKEN );
   
      const char* tokenizer = TOKENIZER;
      char *cTexto = (char *)calloc( cLen + 1, 1 );
      memcpy( cTexto, cTXT, cLen );
      char* token; 

      int nTok=1;
      token = strtok(cTexto, tokenizer);
      if( !token ){
         sw=put_error((PHB_ITEM) pRET, "GET TOKEN|$ - TOKEN SEPARATOR NOT FOUND",103); 
      }else{

      if( nToken > 1 ){
         while( token ){
            token = strtok(0, tokenizer);
            ++nTok;
            if( nTok==nToken) break;
         }  
      }
      //++CADDR;
      if( token ){
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) token );
      }else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "*" );
      }
      }
      free(cTexto);
   
return sw;
}


int fun_pad_matrix_item( PHB_ITEM pARG, PHB_ITEM pPAD, PHB_ITEM pRELL, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);

   int swArrPad=0; //,swDoble=0;

   if( HB_IS_ARRAY(pPAD)){
      swArrPad=1;
   }
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         if(swArrPad){
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
               PHB_ITEM pPAD2 = hb_itemArrayGet( pPAD, i);
               sw=fun_pad_item( (PHB_ITEM)pARG22,(PHB_ITEM)pPAD2,(PHB_ITEM)pRELL,(PHB_ITEM)pRows,(int)i, (int) tCompare );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPAD2);
            }
         }else{
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
               sw=fun_pad_item( (PHB_ITEM)pARG22,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pRows,(int)i, (int) tCompare );
               hb_itemRelease(pARG22);
            }         
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            if(swArrPad){
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPAD2 = hb_itemArrayGet( pPAD, j);
                  sw=fun_pad_item( (PHB_ITEM)pARG222,(PHB_ITEM)pPAD2,(PHB_ITEM)pRELL,(PHB_ITEM)pCols,(int)j, (int) tCompare );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPAD2);
               }
            }else{
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  sw=fun_pad_item( (PHB_ITEM)pARG222,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pCols,(int)j, (int) tCompare );
                  hb_itemRelease(pARG222);
               }
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            if(swArrPad){
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPAD2 = hb_itemArrayGet( pPAD, j);
                  PHB_ITEM pPag = hb_itemArrayNew( d3 );
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     sw=fun_pad_item( (PHB_ITEM)pARG2222,(PHB_ITEM)pPAD2,(PHB_ITEM)pRELL,(PHB_ITEM)pPag,(int)k, (int) tCompare );
                     hb_itemRelease(pARG2222);
                  }
                  hb_arraySet( pCols, j, pPag );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPAD2);
                  hb_itemRelease(pPag);
               }
            }else{
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPag = hb_itemArrayNew( d3 );
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     sw=fun_pad_item( (PHB_ITEM)pARG2222,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pPag,(int)k, (int) tCompare );
                     hb_itemRelease(pARG2222);
                  }
                  hb_arraySet( pCols, j, pPag );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPag);
               }
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int strtran_matrix_item_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                              PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG3, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            sw=strtran_item( (PHB_ITEM) pARG33, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       i, nStart, nCount ) ;
            hb_itemRelease(pARG33);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               sw=strtran_item( (PHB_ITEM) pARG333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pCols,
                                                       j, nStart, nCount ) ;
               hb_itemRelease(pARG333);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG3333 = hb_itemArrayGet( pARG333, k);
                  sw=strtran_item( (PHB_ITEM) pARG3333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pPag,
                                                         k, nStart, nCount ) ;
                  hb_itemRelease(pARG3333);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG333);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int strtran_item_matrix_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                              PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   if(type!=10 || nDim!=1) return 0;

   PHB_ITEM pRows  = hb_itemArrayNew( 1 );
   
   PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, 1);
   sw=strtran_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

   hb_itemRelease(pARG22);
   int i;
   for (i=2; i<=d1; i++ ){
      PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
      PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
      sw=strtran_item( (PHB_ITEM) pString, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

      hb_itemRelease(pARG22);
      hb_itemRelease(pString);
   }
   PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
   hb_arraySet(pSTK_ADDR, CADDR, pString);
   hb_itemRelease(pRows);
   hb_itemRelease(pString);
return sw;
}

int strtran_item_matrix_matrix( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                                PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   HB_MAXINT nDim1=0,d11=0,d12=0, d13=0,type1=0;
   get_size( (PHB_ITEM) pARG1, &nDim1, &d11, &d12, &d13, &type1);
   if(type1!=10) return 0;
   
   if( type==type1 && d1==d11 && d2==d12 && d3==d13 && nDim==nDim1 ){
      PHB_ITEM pRows  = hb_itemArrayNew( 1 );
   
      PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, 1);
      PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, 1);
      sw=strtran_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

      hb_itemRelease(pARG11);
      hb_itemRelease(pARG22);
      int i;
      for (i=2; i<=d1; i++ ){
         PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
         PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
         PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
         sw=strtran_item( (PHB_ITEM) pString, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

         hb_itemRelease(pARG11);
         hb_itemRelease(pARG22);
         hb_itemRelease(pString);
      }
      PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
      hb_arraySet(pSTK_ADDR, CADDR, pString);
      hb_itemRelease(pRows);
      hb_itemRelease(pString);
   }else{
      //printf("T1=%ld DIM1=%ld D1=%ld D2=%ld D3=%ld\n",type,nDim,d1,d2,d3);
      //printf("T2=%ld DIM2=%ld D1=%ld D2=%ld D3=%ld\n",type1,nDim1,d11,d12,d13);
      sw=0;
   }
   
return sw;
}

int strtran_matrix_matrix_matrix( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                                  /*PHB_ITEM pSTK_ADDR, int CADDR,*/ int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG3, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            sw=strtran_item_matrix_matrix( (PHB_ITEM) pARG33, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       i, nStart, nCount ) ;
            hb_itemRelease(pARG33);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               sw=strtran_item_matrix_matrix( (PHB_ITEM) pARG333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pCols,
                                                       j, nStart, nCount ) ;
               hb_itemRelease(pARG333);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG3333 = hb_itemArrayGet( pARG333, k);
                  sw=strtran_item_matrix_matrix( (PHB_ITEM) pARG3333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pPag,
                                                       k, nStart, nCount ) ;
                  hb_itemRelease(pARG3333);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG333);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int strtran_matrix_matrix_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                                PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG3, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            sw=strtran_item_matrix_item( (PHB_ITEM) pARG33, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       i, nStart, nCount ) ;
            hb_itemRelease(pARG33);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               sw=strtran_item_matrix_item( (PHB_ITEM) pARG333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pCols,
                                                       j, nStart, nCount ) ;
               hb_itemRelease(pARG333);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG3333 = hb_itemArrayGet( pARG333, k);
                  sw=strtran_item_matrix_item( (PHB_ITEM) pARG3333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pPag,
                                                       k, nStart, nCount ) ;
                  hb_itemRelease(pARG3333);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG333);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int stuff_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR, PHB_ITEM pPos, PHB_ITEM pDelete ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;

            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               PHB_ITEM pPOS = hb_itemArrayGet( pPos, i);
               //PHB_ITEM pDELETE = ( HB_IS_ARRAY ( pDelete ) ) ? hb_itemArrayGet( pDelete, i) : pDelete;//NULL;
               sw=(int)stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG22, (PHB_ITEM) pRows, i, (PHB_ITEM) pPOS, (PHB_ITEM) pDelete );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPOS);
               //hb_itemRelease(pDELETE);
            }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;

            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               PHB_ITEM pPOS = hb_itemArrayGet( pPos, i);
              // PHB_ITEM pDELETE = hb_itemArrayGet( pDelete, i);
               PHB_ITEM pCols = hb_itemArrayNew( d2 );
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, j);
                 // PHB_ITEM pDELETE1 = hb_itemArrayGet( pDELETE, j);
                  sw=(int)stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG222, (PHB_ITEM) pCols, j, (PHB_ITEM) pPOS1, 
                                      (PHB_ITEM) pDelete );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPOS1);
                 // hb_itemRelease(pDELETE1);
               }
               hb_arraySet( pRows, i, pCols );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPOS);
               //hb_itemRelease(pDELETE);
               hb_itemRelease(pCols);
            }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         //if( pDelete ){
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               PHB_ITEM pPOS = hb_itemArrayGet( pPos, i);
               //PHB_ITEM pDELETE = hb_itemArrayGet( pDelete, i);
               PHB_ITEM pCols = hb_itemArrayNew( d2 );
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, j);
                  //PHB_ITEM pDELETE1 = hb_itemArrayGet( pDELETE, j);
                  PHB_ITEM pPag = hb_itemArrayNew( d3 );
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     PHB_ITEM pPOS11 = hb_itemArrayGet( pPOS1, k);
                     //PHB_ITEM pDELETE11 = hb_itemArrayGet( pDELETE1, k);
                     sw=(int)stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2222, (PHB_ITEM) pPag, k, (PHB_ITEM) pPOS11, 
                                         (PHB_ITEM) pDelete );
                     hb_itemRelease(pARG2222);
                     hb_itemRelease(pPOS11);
                 //    hb_itemRelease(pDELETE11);
                  }
                  hb_arraySet( pCols, j, pPag );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPOS1);
                 // hb_itemRelease(pDELETE1);
                  hb_itemRelease(pPag);
               }
               hb_arraySet( pRows, i, pCols );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPOS);
              // hb_itemRelease(pDELETE);
               hb_itemRelease(pCols);
            }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}



/***********************************************
     HEADER DE ACCESO MATRICIAL A FUNCIONES
 ***********************************************/

/* FUNCION INDEX AT */
int matrix_index_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pMATCH, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=str_index_at( (PHB_ITEM) pTEXT1, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=str_index_at( (PHB_ITEM) pTEXT11, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=str_index_at( (PHB_ITEM) pTEXT111, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int funIndexAt(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // String base
      PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string to search
      PHB_ITEM pMATCH = NULL;
      if( CADDR>0 ){
         pMATCH = hb_itemArrayGet( pSTK_ADDR, CADDR--);   // carcateres a ignorar
      }
      CADDR += SWKEEP; SWKEEP = 0;
      
      if( HB_IS_STRING( pTEXT ) ){
         if( HB_IS_STRING( pSTRING ) ){
            ++CADDR;
            str_index_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
         }else{
            sw=put_error((PHB_ITEM) pRET, "INDEX AT SECOND ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTEXT ) ){
         ++CADDR;

         sw=matrix_index_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "INDEX AT FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pMATCH);
      hb_itemRelease(pSTRING);
      hb_itemRelease(pTEXT);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INDEX AT STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION COUNT AT */
int matrix_count_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pIGNORE, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=str_count_at( (PHB_ITEM) pTEXT1, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=str_count_at( (PHB_ITEM) pTEXT11, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=str_count_at( (PHB_ITEM) pTEXT111, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int funCountAt(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // String base
      PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string to search
      PHB_ITEM pIGNORE = NULL;
      if( CADDR>0 ){
         pIGNORE = hb_itemArrayGet( pSTK_ADDR, CADDR--);   // carcateres a ignorar
      }
      CADDR += SWKEEP; SWKEEP = 0;
      
      if( HB_IS_STRING( pTEXT ) ){
         if( HB_IS_STRING( pSTRING ) ){
            ++CADDR;
            str_count_at_single( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE/*, (PHB_ITEM) pSTK_ADDR, (int) CADDR*/ );
         }else{
            sw=put_error((PHB_ITEM) pRET, "COUNTER AT SECOND ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTEXT ) ){
         ++CADDR;

         sw=matrix_count_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "COUNTER AT FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pIGNORE);
      hb_itemRelease(pSTRING);
      hb_itemRelease(pTEXT);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COUNTER AT STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION AT */
int matrix_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=str_at( (PHB_ITEM) pTEXT1, (PHB_ITEM) pSTRING, (PHB_ITEM) pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=str_at( (PHB_ITEM) pTEXT11, (PHB_ITEM) pSTRING, (PHB_ITEM) pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=str_at( (PHB_ITEM) pTEXT111, (PHB_ITEM) pSTRING, (PHB_ITEM) pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}
int funAt(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // String base
      PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string to search
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pTEXT ) ){
         if( HB_IS_STRING( pSTRING ) ){
            ++CADDR;
            sw=str_at_single( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING /*, (PHB_ITEM) pSTK_ADDR, (int) CADDR */);
         }else{
            sw=put_error((PHB_ITEM) pRET, "AT SECOND ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTEXT ) ){
         ++CADDR;

         sw=matrix_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "AT FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pSTRING);
      hb_itemRelease(pTEXT);
   }else{
      sw=put_error((PHB_ITEM) pRET, "AT STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCIONES DE STRING DE UN ARGUMENTO */

int fun_str_matrix_item( PHB_ITEM pTEXT, PHB_ITEM pSTK_REG, int CREGISTER, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_str_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i, (int) tCompare );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_str_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j, (int) tCompare );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_str_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k, (int) tCompare );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}

//"len"=>60, "upper"=>61, "lower"=>62, "trim"=>63, "asc"=>64, "rtrim"=>65, "ltrim"=>66, "val"=>67,;
int funStrOneArg( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP-60;
   if ( CADDR>=1 ){
      PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG ) || ( HB_IS_NUMERIC( pARG ) && tCompare==7 ) ){
         ++CADDR;
         sw=fun_str_item_single( (PHB_ITEM) pARG,/* (PHB_ITEM) pSTK_ADDR, (int) CADDR,*/ (int) tCompare );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_str_matrix_item( (PHB_ITEM) pARG, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int) tCompare );
      }else{
         sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(STR) FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(STR) STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCIONES MATEMATICAS DE UN ARGUMENTO */
int fun_num_matrix_item( PHB_ITEM pTEXT, /*PHB_ITEM pSTK_REG, int CREGISTER,*/ int tCompare){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_num_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i, (int) tCompare);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_num_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j, (int) tCompare);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_num_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k, (int) tCompare);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}


// "exp"=>80, "int"=>81, "sign"=>82, "log"=>83, "log10"=>84, "sqrt"=>85, "sin"=>86, "cos"=>87, "tan"=>88,;
// "sinh"=>89, "cosh"=>90, "tanh"=>91, "str"=>92, "floor"=>93, "abs"=>94, "chr"=>95, "ceil"=>96, "exp10"=>97;
int funNumOneArg( /*int tCompare */){
int sw=1;
int tCompare = nPCP<322 ? nPCP-80 : nPCP > 327 ? nPCP - 322 : nPCP-289 ;
   if ( CADDR>=1 ){
      PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_NUMERIC( pARG ) ){
         ++CADDR;
         sw=fun_num_item( (PHB_ITEM) pARG, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int) tCompare);//, (int) PRECISION );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_num_matrix_item( (PHB_ITEM) pARG, (int) tCompare);//, (int) PRECISION );
      }else{
         sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(NUM) FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(NUM) STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION MONEY */
int fun_money_matrix_item(PHB_ITEM pARG, PHB_ITEM pDEC, PHB_ITEM pSTK_REG,int CREGISTER){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG1 = hb_itemArrayGet( pARG, i);
            sw=fun_money_item((PHB_ITEM) pARG1, (PHB_ITEM) pDEC, pRows, i);
            hb_itemRelease(pARG1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               sw=fun_money_item((PHB_ITEM) pARG11, (PHB_ITEM) pDEC, pCols, j);
               hb_itemRelease(pARG11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, k);
                  sw=fun_money_item((PHB_ITEM) pARG111, (PHB_ITEM) pDEC, pPag, k);
                  hb_itemRelease(pARG111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}

int fun_money(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pARG  = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento: numero
      PHB_ITEM pDEC = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // decimales
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_NUMERIC( pARG ) ){
         ++CADDR;
         sw=fun_money_item((PHB_ITEM)pARG,(PHB_ITEM)pDEC,(PHB_ITEM)pSTK_ADDR,(int)CADDR);
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_money_matrix_item((PHB_ITEM)pARG,(PHB_ITEM)pDEC,(PHB_ITEM)pSTK_ADDR,(int) CADDR);
      }else{
         sw=put_error((PHB_ITEM) pRET, "MONEY ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
      hb_itemRelease(pDEC);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MONEY STACK UNDERFLOW",102); 
   }
return sw;
}

int fun_pad(/* int tCompare */){
int sw=1;
int tCompare = nPCP-167;
   if ( CADDR>=3 ){
      PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento: numero
      PHB_ITEM pPAD = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // pad
      PHB_ITEM pRELL = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // "relleno"
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG ) ){
         ++CADDR;
         sw=fun_pad_item( (PHB_ITEM)pARG,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pSTK_ADDR,(int)CADDR, (int) tCompare );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;
         sw=fun_pad_matrix_item( (PHB_ITEM)pARG,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pSTK_ADDR,(int) CADDR, (int) tCompare );
      }else{
         sw=put_error((PHB_ITEM) pRET, "PAD ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
      hb_itemRelease(pPAD);
      hb_itemRelease(pRELL);
   }else{
      sw=put_error((PHB_ITEM) pRET, "PAD STACK UNDERFLOW",102); 
   }   
return sw;
}

/* FUNCION MASK */
int fun_mask_matrix_item( PHB_ITEM pTEXT, PHB_ITEM pMASK, PHB_ITEM pRELL, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_mask_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_mask_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_mask_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int fun_mask(){
int sw=1;
   if ( CADDR>=3 ){
      PHB_ITEM pARG  = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento
      PHB_ITEM pMASK = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // mascara
      PHB_ITEM pRELL = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // caracter de relleno
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG ) ){
         ++CADDR;
         sw=fun_mask_item( (PHB_ITEM) pARG, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_mask_matrix_item( (PHB_ITEM) pARG, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "MASK ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
      hb_itemRelease(pMASK);
      hb_itemRelease(pRELL);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MASK STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION DE MODIFICACION DE TOKENS */
int fun_modtoken_matrix(PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pCTOKEN,
                                  PHB_ITEM pSTK_REG, int CREGISTER, char * TOKENIZER) {
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT1,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,
                                (PHB_ITEM)pRows,(int)i,(char *)TOKENIZER);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT11,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,
                                (PHB_ITEM)pCols,(int)j,(char *)TOKENIZER);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT111,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,
                                (PHB_ITEM)pPag,(int)k,(char *)TOKENIZER);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int modtoken( /*int nItem*/ ){
int sw=1;
if( CADDR>=2 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_REG, nItem );
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pCTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;
      sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;

      sw=(int)fun_modtoken_matrix((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else{
      sw=put_error((PHB_ITEM) pRET, "$$|MOD TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pCTOKEN);
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|MOD TOKEN STACK UNDERFLOW",102);
}
return sw;
}

int stack_modtoken(){
int sw=1;
if( CADDR>=3 ){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pCTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;
      sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;

      sw=(int)fun_modtoken_matrix((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else{
      sw=put_error((PHB_ITEM) pRET, "$$|MOD TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pCTOKEN);
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|MOD TOKEN STACK UNDERFLOW",102);
}
return sw;
}

/* FUNCIONES OBTENCION DE TOKEN */
int fun_gettoken_matrix( PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pSTK_REG, int CREGISTER, char * TOKENIZER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_gettoken_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pTOKEN, (PHB_ITEM) pRows, (int) i, (char *)TOKENIZER );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_gettoken_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pTOKEN, (PHB_ITEM) pCols, (int) j, (char *)TOKENIZER );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_gettoken_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pTOKEN, (PHB_ITEM) pPag, (int) k, (char *)TOKENIZER );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}


int gettoken( /*int nItem*/ ){
int sw=1;
if( CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_REG, nItem );
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;
      sw=(int)fun_gettoken_item( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;

      sw=(int)fun_gettoken_matrix( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else{
      sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN STACK UNDERFLOW",102);
}
return sw;
}

int stack_gettoken(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;
      sw=(int)fun_gettoken_item( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;

      sw=(int)fun_gettoken_matrix( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else{
      sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN STACK UNDERFLOW",102);
}
return sw;
}

/* FUNCION COPY - SUBSTR común */
int substr_matrix_item(PHB_ITEM pTEXTO, PHB_ITEM pPOS, PHB_ITEM pLONG, PHB_ITEM pSTK_REG, int CREGISTER){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXTO, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            sw=substr_item(pTEXTO1, pPOS, pLONG, (PHB_ITEM) pRows, i);
            hb_itemRelease(pTEXTO1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               sw=substr_item(pTEXTO11, pPOS, pLONG, (PHB_ITEM) pCols, j);
               hb_itemRelease(pTEXTO11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXTO111 = hb_itemArrayGet( pTEXTO11, k);
                  sw=substr_item(pTEXTO111, pPOS, pLONG, (PHB_ITEM) pPag, k);
                  hb_itemRelease(pTEXTO111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXTO11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}

int substr_matrix_matrix(PHB_ITEM pTEXTO, PHB_ITEM pPOS, PHB_ITEM pLONG, PHB_ITEM pSTK_REG, int CREGISTER) {
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXTO, &nDim, &d1, &d2, &d3, &type);
HB_MAXINT nDim2=0,d12=0,d22=0,d32=0,type2=0;
get_size( (PHB_ITEM) pPOS, &nDim2, &d12, &d22, &d32, &type2);
if( nDim!=nDim2 || d1!=d12 || d2!=d22 || d3!=d32 ){
   return -1;
}
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, i);
            sw=substr_item(pTEXTO1, pPOS1, pLONG, (PHB_ITEM) pRows, i);
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pPOS1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               PHB_ITEM pPOS11 = hb_itemArrayGet( pPOS1, j);
               sw=substr_item(pTEXTO11, pPOS11, pLONG, (PHB_ITEM) pCols, j);
               hb_itemRelease(pTEXTO11);
               hb_itemRelease(pPOS11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pPOS1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               PHB_ITEM pPOS11 = hb_itemArrayGet( pPOS1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXTO111 = hb_itemArrayGet( pTEXTO11, k);
                  PHB_ITEM pPOS111 = hb_itemArrayGet( pPOS11, k);
                  sw=substr_item(pTEXTO111, pPOS111, pLONG, (PHB_ITEM) pPag, k);
                  hb_itemRelease(pTEXTO111);
                  hb_itemRelease(pPOS111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXTO11);
               hb_itemRelease(pPOS11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pPOS1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=-1;
      }
   }

return sw;
}

int funSubstr(){
int sw=1;
   if (CADDR>=2){
      PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
      PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string
      if (HB_IS_NUMERIC( pARG1 )){
         if( HB_IS_STRING(pARG2) ){   // tiene un solo argumento: nPos
            if( CADDR > 0 ){    // asume la existencia del tercer parámetro
               PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // porcion a copiar
               CADDR += SWKEEP; SWKEEP = 0;
               if( HB_IS_NUMERIC( pARG3 )){
                  ++CADDR;
                  if( !substr_item(pARG2, pARG1, pARG3, (PHB_ITEM) pSTK_ADDR, CADDR) ){
                     sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR",103); 
               }
               hb_itemRelease(pARG3);
            }else{  // solo actúa con la posición.
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;
               if( !substr_item(pARG2, pARG1, NULL, (PHB_ITEM) pSTK_ADDR, CADDR) ){
                  sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
               }
            }
         }else if( HB_IS_ARRAY( pARG2 ) ){   // es un array. POS puede ser un array, pero 3er arg no. 
            //HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            //get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
            //if( type==10 ){
               if( CADDR > 0 ){    // asume la existencia del tercer parámetro
                  PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // porcion a copiar
                  CADDR += SWKEEP; SWKEEP = 0;
                  if( HB_IS_NUMERIC( pARG3 )){   // solo debe ser numero.
                     ++CADDR;

                     if( !substr_matrix_item(pARG2, pARG1, pARG3, (PHB_ITEM) pSTK_ADDR, CADDR /*, nDim, d1, d2, d3*/) ){
                        sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pARG3);
               }else{
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;

                  if( !substr_matrix_item(pARG2, pARG1, NULL, (PHB_ITEM) pSTK_ADDR, CADDR/*, nDim, d1, d2, d3*/) ){
                     sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                  }
               }
            //}else{
            //   sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR - TYPE MISMATCH",104); 
            //}
         }else{
            sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR - TYPE MISMATCH",104); 
         }
      }else if( HB_IS_ARRAY( pARG1 ) ){   // POS es array.
         if( HB_IS_ARRAY( pARG2 ) ){    // argumento principal debe ser un array, porque POS es array. 3er arg debe ser escalar.
            //HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            //get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
           // HB_MAXINT nDim1=0,d11=0,d22=0,d33=0,type1=0;
            //get_size( (PHB_ITEM) pARG1, &nDim1, &d11, &d22, &d33, &type1);
            //if( type==10 && type1==11 && nDim==nDim1 && d1==d11 && d2==d22 ){
               if( CADDR > 0 ){    // asume la existencia del tercer parámetro
                  PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // porcion a copiar
                  CADDR += SWKEEP; SWKEEP = 0;
                  if( HB_IS_NUMERIC( pARG3 )){   // solo debe ser numero.
                     ++CADDR;

                     if( !substr_matrix_matrix(pARG2, pARG1, pARG3, (PHB_ITEM) pSTK_ADDR, CADDR /*, nDim, d1, d2, d3*/) ){
                        sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pARG3);
               }else{
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;

                  if( !substr_matrix_matrix(pARG2, pARG1, NULL, (PHB_ITEM) pSTK_ADDR, CADDR /*, nDim, d1, d2, d3*/) ){
                     sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                  }
               }
            //}else{
            //   sw=put_error((PHB_ITEM) pRET, "COPY DIMENSION|RANGE|TYPE ERROR",105); 
            //}
         }else{
            sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR - TYPE MISMATCH",104);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "COPY (INITIAL POS) ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG2);
      hb_itemRelease(pARG1);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COPY STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUN_CAT concatena items */

int fun_cat_item_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG2, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM)pARG22, (PHB_ITEM) pRows, (int) i );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM)pARG222, (PHB_ITEM) pCols, (int) j );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM)pARG2222, (PHB_ITEM) pPag, (int) k );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_cat_matrix_item( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=(int)concatenate_item( (PHB_ITEM) pARG11, (PHB_ITEM)pARG2, (PHB_ITEM) pRows, (int) i );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=(int)concatenate_item( (PHB_ITEM) pARG111, (PHB_ITEM)pARG2, (PHB_ITEM) pCols, (int) j );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=(int)concatenate_item( (PHB_ITEM) pARG1111, (PHB_ITEM)pARG2, (PHB_ITEM) pPag, (int) k );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_cat_matrix_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);

HB_MAXINT nDim2=0,d12=0,d22=0,d32=0,type2=0;
get_size( (PHB_ITEM)pARG2, &nDim2, &d12, &d22, &d32, &type2);

if( nDim!=nDim2 || d1!=d12 || d2!=d22 || d3!=d32 ){
   return -1;
} 
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=(int)concatenate_item( (PHB_ITEM) pARG11, (PHB_ITEM)pARG22, (PHB_ITEM) pRows, (int) i );
            hb_itemRelease(pARG11);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=(int)concatenate_item( (PHB_ITEM) pARG111, (PHB_ITEM)pARG222, (PHB_ITEM) pCols, (int) j );
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=(int)concatenate_item( (PHB_ITEM) pARG1111, (PHB_ITEM)pARG2222, (PHB_ITEM) pPag, (int) k );
                  hb_itemRelease(pARG2222); hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222); hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22); hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}
int fun_cat(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // primer argumento ARG1 + ARG2
      PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // segundo argumento

      CADDR += SWKEEP; SWKEEP = 0;
      
      /* evalua POSTFIX */  
  /*    if(SW_POSTFIX){    // está dentro de #MATH: invierte operandos.
         PHB_ITEM TMP = pARG1;
         pARG1 = pARG2;
         pARG2 = TMP;
      }*/
      /******************/ 
      if( HB_IS_STRING( pARG1 ) ){
         if( HB_IS_STRING( pARG2 ) ){
            ++CADDR;
            sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, (int) CADDR );

         }else if( HB_IS_ARRAY( pARG2 ) ){
            ++CADDR;

            sw=fun_cat_item_matrix( (PHB_ITEM)pARG1,(PHB_ITEM)pARG2 /*,(PHB_ITEM)pSTK_ADDR,(int)CADDR*/ );
         }else{
            sw=put_error((PHB_ITEM) pRET, "CAT ARGUMENT ERROR",103); 
         }
         
      }else if( HB_IS_ARRAY( pARG1 ) ){
         if( HB_IS_STRING( pARG2 ) ){
            ++CADDR;

            sw=fun_cat_matrix_item( (PHB_ITEM)pARG1,(PHB_ITEM)pARG2 /*,(PHB_ITEM)pSTK_ADDR,(int)CADDR */);
         }else if( HB_IS_ARRAY( pARG2 ) ){
            ++CADDR;

            sw=fun_cat_matrix_matrix( (PHB_ITEM)pARG1,(PHB_ITEM)pARG2 /*,(PHB_ITEM)pSTK_ADDR,(int)CADDR */);
         }else{
            sw=put_error((PHB_ITEM) pRET, "CAT ARGUMENT ERROR",103); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "CAT ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG2);
      hb_itemRelease(pARG1);
   }else{
      sw=put_error((PHB_ITEM) pRET, "CAT STACK UNDERFLOW",102); 
   }
   if( sw==-1) sw=put_error((PHB_ITEM) pRET, "CAT DIMENSION ERROR",106); 
return sw;
}

int fun_delete(){
int sw=1;
if ( CADDR >= 2 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   PHB_ITEM pARG1 = NULL; //hb_itemPutCLPtr( NULL, "", 0 ); //hb_itemPutStrLen( NULL, HB_CDP_ENDIAN_NATIVE, "", 1 );  // operando 1
   if ( HB_IS_STRING( pARG2 ) ){   
     // if ( HB_IS_STRING( pARG1 ) ){   // borra ARG1 en ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         PHB_ITEM pDelete = NULL;
                          
         if ( HB_IS_NUMERIC( pPos ) ){   // borra desde posicion!
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               CADDR += SWKEEP; SWKEEP = 0;
               if( HB_IS_NUMERIC( pDelete )){          
                  ++CADDR;
                  if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                     sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT (TO DELETE) ERROR",103);
               }
            }else{  // borra todo nomás.
               //pDelete = hb_itemPutNInt( NULL, (HB_MAXINT) hb_itemGetCLen( pARG2 ) );
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;  
               if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                  sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
               }
               //sw=put_error((PHB_ITEM) pRET, "DELETE STACK UNDERFLOW");
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT (TO INSERT) ERROR",103);
         }
         hb_itemRelease(pPos);
         if ( pDelete )
            hb_itemRelease(pDelete);
    //  }else{
    //     sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT STR-NULL ERROR");
    //  }
   }else if( HB_IS_ARRAY( pARG2 ) ){
      //if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en array ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         if ( HB_IS_ARRAY( pPos ) ){   // inserta en posicion! POSICION DEBE SER UN ARRAY
            PHB_ITEM pDelete = NULL;
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               CADDR += SWKEEP; SWKEEP = 0;
               if( !HB_IS_ARRAY( pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR (I NEED AN ARRAY)",103);
               }else{
                  ++CADDR;
                  if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                                     (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
                      sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
                  }
               }
            }else{
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;
               if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                                  (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
               }
               //sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT (TO DELETE) ERROR");
            }
            if ( pDelete )
               hb_itemRelease(pDelete);
         }else{
            sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
      //}else{
      //   sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR",103);
      //}                      
   }else{
      sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG2);
   //hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "DELETE STACK UNDERFLOW",102); 
}

return sw;          
}

int fun_insert(){
int sw=1;
if ( CADDR >= 3 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 1
   if ( HB_IS_STRING( pARG2 ) ){   
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         PHB_ITEM pDelete = hb_itemPutNInt( NULL, (HB_MAXINT) 0 ); //hb_itemGetCLen( pARG2 ) );  //NULL;

         CADDR += SWKEEP; SWKEEP = 0;
         
         if ( HB_IS_NUMERIC( pPos ) ){   // inserta en posicion!
            //if(CADDR>=1) pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
            ++CADDR;
            if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
               sw=put_error((PHB_ITEM) pRET, "INSERT NOT ENOUGHT MEMORY",100); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
         if ( pDelete )
            hb_itemRelease(pDelete);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
      }
   }else if( HB_IS_ARRAY( pARG2 ) ){
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en array ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         if ( HB_IS_ARRAY( pPos ) ){   // inserta en posicion! POSICION DEBE SER UN ARRAY
            PHB_ITEM pDelete = hb_itemPutNInt( NULL, (HB_MAXINT) 0 ); //NULL;
            //if(CADDR>=1) {
              /// pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
            //   if( !HB_IS_ARRAY( pDelete ) ){
            //      sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR");
            //   }
           // }
            CADDR += SWKEEP; SWKEEP = 0;
            
            ++CADDR;
            if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                               (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
               sw=put_error((PHB_ITEM) pRET, "INSERT NOT ENOUGHT MEMORY",100); 
            }
            if ( pDelete )
               hb_itemRelease(pDelete);
         }else{
            sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
      }                      
   }else{
      sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "INSERT STACK UNDERFLOW",102); 
}

return sw;          
}

int fun_replace(){
int sw=1;
if ( CADDR >= 3 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 1
   if ( HB_IS_STRING( pARG2 ) ){   
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         PHB_ITEM pDelete = NULL;
                          
         if ( HB_IS_NUMERIC( pPos ) ){   // inserta en posicion!
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               CADDR += SWKEEP; SWKEEP = 0;
               
               if( !HB_IS_NUMERIC( pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
               }else{
                  ++CADDR;
                  if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                     sw=put_error((PHB_ITEM) pRET, "REPLACE NOT ENOUGHT MEMORY",100); 
                  }
               }
            }else{
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;
               if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                  sw=put_error((PHB_ITEM) pRET, "REPLACE NOT ENOUGHT MEMORY",100); 
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
         if ( pDelete )
            hb_itemRelease(pDelete);
      }else{
         sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
      }
   }else if( HB_IS_ARRAY( pARG2 ) ){
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en array ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         if ( HB_IS_ARRAY( pPos ) ){   // inserta en posicion! POSICION DEBE SER UN ARRAY
            PHB_ITEM pDelete = NULL;
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               //if( !HB_IS_ARRAY( pDelete ) ){
               if( !HB_IS_NUMERIC( pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            ++CADDR;
            if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                               (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
               sw=put_error((PHB_ITEM) pRET, "REPLACE NOT ENOUGHT MEMORY",100); 
            }
            if ( pDelete )
               hb_itemRelease(pDelete);
         }else{
            sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
      }else{
         sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
      }                      
   }else{
      sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "REPLACE STACK UNDERFLOW",102); 
}

return sw;          
}

/* REPLICATE FUNCION */

// pARG1 = TEXTO, pARG2 = TIMES

int fun_replicate_matrix_item( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=(int)replicate_item( (PHB_ITEM) pARG11, (PHB_ITEM) pRows, (int) i, (PHB_ITEM) pARG2 );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=(int)replicate_item( (PHB_ITEM) pARG111, (PHB_ITEM) pCols, (int) j, (PHB_ITEM) pARG2 );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=(int)replicate_item( (PHB_ITEM) pARG1111, (PHB_ITEM) pPag, (int) k, (PHB_ITEM) pARG2 );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_replicate_matrix_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);

HB_MAXINT nDim2=0,d12=0,d22=0,d32=0,type2=0;
get_size( (PHB_ITEM)pARG2, &nDim2, &d12, &d22, &d32, &type2);

if( nDim!=nDim2 || d1!=d12 || d2!=d22 || d3!=d32 ){
   return -1;
} 
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=(int)replicate_item( (PHB_ITEM) pARG11, (PHB_ITEM) pRows, (int) i, (PHB_ITEM) pARG22 );
            hb_itemRelease(pARG11);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=(int)replicate_item( (PHB_ITEM) pARG111, (PHB_ITEM) pCols, (int) j, (PHB_ITEM) pARG222 );
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=(int)replicate_item( (PHB_ITEM) pARG1111, (PHB_ITEM) pPag, (int) k, (PHB_ITEM) pARG2222 );
                  hb_itemRelease(pARG2222); hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222); hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22); hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_replicate(/*int nItem*/){
int sw=1;
int nItem = nPCP == 171 ? 0 : STK_PRG[ ++CP ];
//   if ( CADDR>=2 ){
   PHB_ITEM pTIMES;      // primer argumento: num
   if( nItem==0 ){
      pTIMES = hb_itemArrayGet( pSTK_ADDR, CADDR--);  
   }else{   // valor diferente de 0 = numero de registro
      pTIMES = hb_itemArrayGet( pSTK_REG, nItem );
   }
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  //segundo argumento string, replicate(ARG1, ARG2)
      
   CADDR += SWKEEP; SWKEEP = 0;
   
      if(HB_IS_NUMERIC( pTIMES )){
         if( HB_IS_STRING( pTEXT ) ){
            ++CADDR;
            if(! (int)replicate_item( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (PHB_ITEM) pTIMES )){
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            }
         }else if( HB_IS_ARRAY( pTEXT ) ){
            ++CADDR;
          /*****  
            PHB_ITEM pBUFFER = hb_itemArrayNew(3);
            hb_arraySet(pBUFFER,1,(PHB_ITEM) pTEXT);
            hb_arraySet(pBUFFER,2,(PHB_ITEM) pTIMES);
            hb_arraySet(pBUFFER,3,(PHB_ITEM) pSTK_ADDR);
            if(!(int)fun_generico_matrix_item((PHB_ITEM) pBUFFER, 3, 8))
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            hb_itemRelease(pBUFFER);
          *****/
            if(!fun_replicate_matrix_item( (PHB_ITEM)pTEXT, /*(PHB_ITEM) pSTK_ADDR, (int) CADDR, */(PHB_ITEM) pTIMES )){
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTIMES ) && HB_IS_ARRAY( pTEXT ) ){
            ++CADDR;
          /*****  
            PHB_ITEM pBUFFER = hb_itemArrayNew(3);
            hb_arraySet(pBUFFER,1,(PHB_ITEM) pTEXT);
            hb_arraySet(pBUFFER,2,(PHB_ITEM) pTIMES);
            hb_arraySet(pBUFFER,3,(PHB_ITEM) pSTK_ADDR);
            if(!(int)fun_generico_matrix_matrix((PHB_ITEM) pBUFFER, 3, 1))
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            hb_itemRelease(pBUFFER);
          *****/           
            if(!fun_replicate_matrix_matrix( (PHB_ITEM)pTEXT, /*(PHB_ITEM) pSTK_ADDR, (int) CADDR,*/ (PHB_ITEM) pTIMES )){
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            }
      }else{
         sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pTIMES);
      hb_itemRelease(pTEXT);
//   }else{
//      sw=put_error((PHB_ITEM) pRET, "REPLICATE STACK UNDERFLOW",102); 
//   }
   
return sw;
}

int fun_transform(){
int sw=1;
if ( CADDR >= 3 ) {
   PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // el string base
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // el reemplazo
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // lo que busca
   

   if( HB_IS_STRING( pARG1 ) ){   // el nuevo string es un escalar.
      if( HB_IS_STRING( pARG2 ) ){   // el string a reemplazar es un escalar.
         if( HB_IS_STRING( pARG3 ) ){  // string base es un escalar
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_item_single( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, /* (PHB_ITEM) pSTK_ADDR, 
                                     CADDR,*/ 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY",100); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_item_single( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,/* (PHB_ITEM) pSTK_ADDR,
                                        CADDR,*/ nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY",100); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_item_single( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,/* (PHB_ITEM) pSTK_ADDR,
                                        CADDR,*/ nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY",100);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else if( HB_IS_ARRAY( pARG3 ) ){  // string base es un array
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_matrix_item_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                 (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_matrix_item_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_matrix_item_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "TRANSFORM SOURCE STRING ARGUMENT ERROR",103);
         }
      }else if( HB_IS_ARRAY( pARG2 ) ){   // el nuevo string es un array de posibles string a reemplazar.
         if( HB_IS_STRING( pARG3 ) ){  // string base es un escalar
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_item_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                 (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_item_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_item_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else if( HB_IS_ARRAY( pARG3 ) ){  // string base es un array
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_matrix_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                   (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  } 
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_matrix_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_matrix_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "TRANSFORM SOURCE STRING ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "TRANSFORM STRING TO REPLACE ARGUMENT ERROR",103);
      }
   }else if( HB_IS_ARRAY( pARG1 ) ){   // nuevo string es un array
      if( HB_IS_ARRAY( pARG2 ) ){   // strnig a remplazar DEBE sER un array
         if( HB_IS_STRING( pARG3 ) ){  // string base es un escalar
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_item_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                   (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_item_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_item_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else if( HB_IS_ARRAY( pARG3 ) ){  // string base es un array
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_matrix_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                     /*(PHB_ITEM) pSTK_ADDR, CADDR,*/ 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "(1)TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_matrix_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                        /*(PHB_ITEM) pSTK_ADDR, CADDR,*/ nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "(2)TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_matrix_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                        /*(PHB_ITEM) pSTK_ADDR, CADDR,*/ nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "(3)TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "TRANSFORM SOURCE STRING ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "TRANSFORM STRING TO REPLACE ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "TRANSFORM NEW STRING ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG3);
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "TRANSFORM STACK UNDERFLOW",102); 
}
return sw;
}


/****************************************************
    FUNCIONES DE ASIGNACIONES Y MANEJO DE STACK
 ****************************************************/

//int PushCopyReg(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int PushCopyReg(/* long nARG*/ ){

   // extrae argumentos:
int sw=1;
///do{
   long nARG = STK_PRG[ ++CP ];
   ++CADDR;  // aumenta CADDR
   // CHEQUEAR SI ES ARRAY LO QUE METE EN PILA
   if ( CADDR > nSizeStack ){ //ERROR
      sw=put_error((PHB_ITEM) pRET, "PUSH STACK OVERFLOW",101);
   }else{
      // obtengo valor de registro:
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG);
      if ( !HB_IS_ARRAY( pSource ) ){   // no es un array
         hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pSource  );  // parece que con esto basta. single copia igual

      }else{
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 ); // creo array ajustado a los rangos.
               int i;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                  put_value(pRows, pARGS, i, PRECISION);
                  hb_itemRelease(pARGS);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pCols, pARGC, j, PRECISION);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARGF);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               int i;
               for(i=1; i<=d1; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  int j;
                  for(j=1; j<=d2; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k;
                     for(k=d1; k<=d3; k++){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAYP, pARGP, k, PRECISION);
                        hb_itemRelease(pARGP);
                     }
                     hb_arraySet(pARRAYC, j, pARRAYP);
                     hb_itemRelease(pARRAYP);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet(pARRAY, i, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }
         }
      }
      hb_itemRelease(pSource);
   }
//}while ( STK_PRG[++CP] ); // CP==1 pushcopyreg
//--CP;
return sw;
}


int PushReg( /*long nARG*/ ){
   // extrae argumentos:
int sw=1;
do{
   long nARG = STK_PRG[ ++CP ];
   ++CADDR;  // aumenta CADDR
   // CHEQUEAR SI ES ARRAY LO QUE METE EN PILA
   if ( CADDR > nSizeStack ){ //ERROR
      sw=put_error((PHB_ITEM) pRET, "PUSH STACK OVERFLOW",101);
      return sw;
   }else{
      // obtengo valor de registro:
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG);    
      // chequea tipo de valor obtenido y guarda en STK_ADDR:
      hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pSource  );  // parece que con esto basta. single copia igual
      //put_value(pSTK_ADDR, pSource, CADDR, PRECISION);
      hb_itemRelease(pSource);
   }
}while ( STK_PRG[++CP]==0 && sw); // CP==0 pushreg
--CP;
return sw;
}


//int PushDS( int STK_PRG[], PHB_ITEM pSTK_DS, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){//,
int PushDS( /*long nItem */){
int sw=1;
//do{
   // extrae argumentos:
   long nItem = STK_PRG[ ++CP ];
   PHB_ITEM pRegSource = hb_itemArrayGet( pSTK_REG, nItem );
   
   // obtengo valor de registro:
              
   ++CADDR;  // aumenta CADDR
   if ( CADDR > nSizeStack ){
      //ERROR
      sw=put_error((PHB_ITEM) pRET, "PUSH STACK OVERFLOW",101);
      hb_itemRelease(pRegSource);
      return sw;
   }else{
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_DS, hb_itemGetNInt( pRegSource ) );
      
      if ( HB_IS_ARRAY( pSource ) ){   // es un array
         PHB_ITEM pSourceA = hb_itemArrayGet( pSource, 1);
         // obtengo valor de registro:
         hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pSourceA  );
         hb_itemRelease(pSourceA);
      }else{
         // chequea tipo de valor obtenido y guarda en STK_ADDR:
         put_value(pSTK_ADDR, pSource, CADDR, PRECISION);
      }
      hb_itemRelease(pSource);
      hb_itemRelease(pRegSource);
   }   

//}while ( STK_PRG[++CP]==2 ); // CP==2 pushds
//--CP;
return sw;
}



/* 1=CPY: copia un dato del stack a un registro, igual que MOV, pero sin sacarlo */
/* 0=MOV: mueve el resultado a un registro. Si hay marcas, mueve el rango asociado */
int move_stack_reg( /*int nARGd,*//* int TIPO*/){
int sw=1;
//do{
   int nARGd = STK_PRG[++CP];
   if (CADDR >0){
      // extrae argumentos:

      //unsigned int nARGd=(unsigned int)STK_PRG[++CP];
      // obtengo valor de registro:
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, nPCP==245 ? CADDR : CADDR--); // lee dato
      
      if ( HB_IS_ARRAY( pSource ) ){  // es un array!!
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1:{
               int nIni=1, nFin=d1;
            //   if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
            //   if( OFFSET_POS ) {nFin=OFFSET_POS;}
               PHB_ITEM pRows  = hb_itemArrayNew( nFin - nIni + 1 ); // creo array ajustado a los rangos.
               int i, nPos=1;
               for (i=nIni; i<=nFin; i++ ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                  put_value(pRows, pARGS, nPos++, PRECISION);
                  hb_itemRelease(pARGS);
               }
               hb_arraySet(pSTK_REG, nARGd, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
            
               PHB_ITEM pRows = hb_itemArrayNew( nFinR - nIniR + 1 );
               int i,rPos=1;
               for( i=nIniR; i<=nFinR; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  PHB_ITEM pCols = hb_itemArrayNew( nFinC - nIniC + 1 );
                  int j,cPos=1;
                  for( j=nIniC; j<=nFinC; j++){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pCols, pARGC, cPos++, PRECISION);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet( pRows, rPos++, pCols );
                  hb_itemRelease(pARGF);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_REG, nARGd, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               int nPagIni=1, nPagFin=d3;
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;

   
               PHB_ITEM pARRAY = hb_itemArrayNew( nFinR - nIniR + 1 );
               int i, rPos=1;
               for(i=nIniR; i<=nFinR; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( nFinC - nIniC + 1 );
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  int j, cPos=1;
                  for(j=nIniC; j<=nFinC; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( nPagFin - nPagIni + 1 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k,kPos=1;
                     for(k=nPagIni; k<=nPagFin; k++){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAYP, pARGP, kPos++, PRECISION);
                        hb_itemRelease(pARGP);
                     }
                     hb_arraySet(pARRAYC, cPos++, pARRAYP);
                     hb_itemRelease(pARRAYP);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet(pARRAY, rPos++, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }
         }
      }else{
         put_value(pSTK_REG, pSource, nARGd, PRECISION);
      }
      hb_itemRelease(pSource);
/*      if(!TIPO) {
         hb_arrayDel(pSTK_ADDR,nSizeStack);
         hb_ret();
         hb_gcCollect();
      } */

   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "MOV|CPY STACK UNDERFLOW",102);                 
   }
  /* if(STK_PRG[CP+1]==201 || STK_PRG[CP+1]==245){ // mov o cpy
      ++CP;
      sw=move_stack_reg();
   }*/
//   ++CP;
//}while ( STK_PRG[CP]==201 || STK_PRG[CP]==245 ); // CP==1 pushreg
//--CP;
return sw;
}

/* DETERMINA LARGO DE LA DIMENSION A DEFINIR EN NUEVO ARRAY 
   PARA GETARRAY, PUTARRAY Y LET */
int get_length(int nIni, int nFin, int nInc){

   int n1 = nFin - nIni + 1;
   int n2 = (int) (n1 / nInc);
   return  n2 + (fmod(n1,nInc)>0 ? 1 : 0 );
}


//int LetReg(PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pRET, int PRECISION){//,
//int LetReg(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pRET){//, int PRECISION){//,
int LetReg(){
int sw=1;

//do{
int nARGd = STK_PRG[ ++CP ]; // destino
int nARGs = STK_PRG[ ++CP ]; // source
PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nARGd);
if (!HB_IS_ARRAY(pSource) && !HB_IS_ARRAY(pPRE)){
    put_value(pSTK_REG, pSource, nARGd, PRECISION);
    hb_itemRelease(pSource);hb_itemRelease(pPRE);
    return sw;
}

if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   //int nARGd = STK_PRG[ ++CP ]; // destino
   //int nARGs = STK_PRG[ ++CP ]; // source
   //PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
   if(HB_IS_ARRAY( pSource )){
      switch(RANGEDIM){
         case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==RANGEDIM){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                        
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i);
                  PHB_ITEM pELEM = hb_itemArrayGet( pSource, hb_itemGetNI(pCOORD));
                  put_value(pRows, pELEM, i, PRECISION);
                  hb_itemRelease(pELEM);
                  hb_itemRelease(pCOORD);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }case 2:{   // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==2 && RANGECOL==2){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                        
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  put_value(pRows, pELEMCOL, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pCOORDROW);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else if(nDim1==3 && RANGECOL==3){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                        
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  PHB_ITEM pELEMPAG = hb_itemArrayGet( pELEMCOL, hb_itemGetNI(pROWP));
                  put_value(pRows, pELEMPAG, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pROWP);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pELEMPAG);
                  hb_itemRelease(pCOORDROW);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }
      }
   }else{ // fuente no es array, pero target si.
      //sw=put_error((PHB_ITEM) pRET, "LET REGISTER TYPE MUST BE ARRAY WITH RANGE",104);
      //PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nARGd);
/*      if(!HB_IS_ARRAY(pPRE)){
         sw=put_error((PHB_ITEM) pRET, "LET TARGET TYPE MUST BE ARRAY",104);
      }else{*/
         if(HB_IS_ARRAY(pPRE)){   // target es array?
            switch(RANGEDIM){
               case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==RANGEDIM){
                     unsigned int i;
                     //PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                        
                        put_value(pPRE, pSource, hb_itemGetNI(pCOORD), PRECISION);

                        hb_itemRelease(pCOORD);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==2 && RANGECOL==2){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango


                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
   
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                  
                        put_value(pROW, pSource, hb_itemGetNI(pROWY), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else if(nDim1==3 && RANGECOL==3){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                       
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
      
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                        PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                        PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                        put_value(pCOL, pSource, hb_itemGetNI(pROWP), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);
                        hb_itemRelease(pROWP);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOL);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }
            }
         }else{  // es solo una asignación a una variable tipo simple
           // sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET TYPE MUST BE ARRAY",104);
            if( SW_PUNTERO ) hb_arraySet(pSTK_REG, nARGd, pSource); 
            else             put_value(pSTK_REG, pSource, nARGd, PRECISION);
         }
//      }
      hb_itemRelease(pPRE);
   }
   hb_itemRelease(pSource);
}else{

   int swOffset=0;
   // extrae argumentos:
   //int nARGd = STK_PRG[ ++CP ]; // destino
   //int nARGs = STK_PRG[ ++CP ]; // source
   // obtengo valor de registro:
   //PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
   // si quiero copiar un array en un registro, el destino debe ser un array?
   // ver hb_itemCopy y hb_itemMove. o dejo ARRAYSET, dado que funciona con PUSH.
   
   if ( HB_IS_ARRAY( pSource ) ){   // es un array. OK!
      if( SW_PUNTERO ){
         hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pSource  );  // esto copia el puntero. 
      }else{
     /* DECISION:
       X ¿copiare solo una porcion del arreglo segun rangos, creando una nueva matriz con rango ajustado?
        ¿crearé nueva matriz con dimensiones identicas al Source, pero solo copiaré lo definido por los rangos? */
     /* PROBLEMA: Si marco [2],[1:5,1] (una columna y una página), me genera un array 3D de size=5,1,1. Eso está mal.
        Debería generar un array simple de 5 elementos.
        Mismo caso para array simples desde donde saco solo un elemento ==> debería ser SINGLE.
        1D = OK
        2D = 
        3D = 
        TODO! */
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
      switch( nDim ){
         case 1:{
           // printf("\nENTRE A 1D INI=%d, FIN=%d",1,d1);
            unsigned int nIni=1, nFin=d1;
            //if( MARK_POS == 999999999 ) MARK_POS=d1;
            //if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
            if (normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)){
               if( OFFSET_POS ) {
                  if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                  nFin=OFFSET_POS;
               }
               if( nIni != nFin ){

                    PHB_ITEM pRows ; // = hb_itemArrayNew( nFin - nIni + 1 );
                    int nInc=SET_INTERVAL_ROW,i=nIni;
                    if(nFin < nIni){
                       int nTmp = nIni; nIni = nFin; nFin=nTmp; nInc=-SET_INTERVAL_ROW;
                    }
                    //int nLong=nFin - nIni + 1;
                    int nLong=get_length(nIni,nFin,SET_INTERVAL_ROW);
                    pRows  = hb_itemArrayNew( nLong );
                    int nPos=1;
                    while ( nLong-- ){
                       PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                       put_value(pRows, pARGS, nPos++, PRECISION);
                       hb_itemRelease(pARGS);
                       i = i + nInc;
                    }

                     hb_arraySet(pSTK_REG, nARGd, pRows);
                     hb_itemRelease(pRows);

               }else{   // solo devuelve un elemento  SINGLE.
                  if( MARK_POS<=d1 ){
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_POS );
                     put_value(pSTK_REG, pARGS, nARGd, PRECISION);
                     hb_itemRelease(pARGS);               
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET MARK OVERFLOW",101);
                  }
               }
            }
            break;
         }case 2:{
            //printf("\nENTRE A 2D\n");
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
           // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
            if( !( sw=normaliza_indices_2d( &nIniR, &nFinR, &nIniC, &nFinC, d1, d2, &swOffset,
                                            &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL) ) ){
                hb_itemRelease(pSource);hb_itemRelease(pPRE);
                return sw;
            }
          //  printf("\nPASA 2\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
          /* 4 CASOS:  
                1.- OFFSET ROW=OFFSET_COL=0     => devuelve SINGLE
                2.- OFFSET_ROW>0, OFFSET_COL=0  => devuelve array 1D
                3.- OFFSET_ROW=0, OFFSET_ROW>0  => devuelve array 1D
                4.- OFFSET_ROW>0, OFFSET_COL>0  => devuelve array 2D. Ya hecho. */
               
            if( !OFFSET_COL ){   // SINGLE
               if( !OFFSET_ROW ){
                  
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                  PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                  put_value(pSTK_REG, pARGC, nARGd, PRECISION);
                  hb_itemRelease(pARGC);
                  hb_itemRelease(pARGS);
               
               }else{  // ARRAY 1D (recorre las filas)
                  int nInc=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                  }
                  //int nLong=nFinR - nIniR + 1;
                  int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int rPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     put_value(pRows, pARGC, rPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     i = i + nInc;
                  }
                  hb_arraySet(pSTK_REG, nARGd, pRows);
                  hb_itemRelease(pRows);
               }   
            }else{ 
               if( !OFFSET_ROW ){  // ARRAY 1D (recorre las columnas)
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                  int nInc=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                  }
                  //int nLong=nFinC - nIniC + 1;
                  int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int cPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pRows, pARGC, cPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     j = j + nInc;                  
                  }
                  hb_itemRelease(pARGF);
                  hb_arraySet(pSTK_REG, nARGd, pRows);
                  hb_itemRelease(pRows);
               }else{   // 2D
                  int nIncR=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                  }
                  //int nLongR=nFinR - nIniR + 1;
                  int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLongR );
                  int rPos=1;
                  int nIncC=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                  }
                  //int nLongC=nFinC - nIniC + 1;
                  int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  int cTmp = j;  // guardo para reasignar dentro del ciclo
                  while ( nLongR-- ){
                     int cLongCTmp=nLongC;
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pCols  = hb_itemArrayNew( cLongCTmp );
                     int cPos=1, j=cTmp;
                     while ( cLongCTmp-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                        put_value(pCols, pARGC, cPos++, PRECISION);
                        hb_itemRelease(pARGC);
                        j = j + nIncC;
                     }
                     hb_arraySet( pRows, rPos++, pCols );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pCols);
                     i = i + nIncR;
                  }
                  
                  hb_arraySet(pSTK_REG, nARGd, pRows);
                  hb_itemRelease(pRows);
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
            break;
         }case 3:{
            unsigned int nPagIni=1, nPagFin=d3;
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
            if( !(sw=normaliza_indices_3d(&nIniR, &nFinR, &nIniC, &nFinC, &nPagIni, &nPagFin, d1, d2, d3, &swOffset,
                         &MARK_PAGE, &OFFSET_POS, &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL)) ){
                 hb_itemRelease(pSource);hb_itemRelease(pPRE);
                 return sw; 
            }

           /* CASOS:
               1.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS=0     => SINGLE
               2.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS=0     => 1D
               3.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS=0     => 1D
               4.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS=0     => 2D
               5.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS>0     => 1D
               6.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS>0     => 2D
               7.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS>0     => 2D
               8.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS>0     => 3D
           */
            if( !OFFSET_POS ){
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // SINGLE
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                     PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE );
                     put_value(pSTK_REG, pARGP, nARGd, PRECISION);
                     hb_itemRelease(pARGP);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGS);
                  }else{   // lee solo columnas: array 1D
                     int nInc=SET_INTERVAL_COL,i=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                     }
                     //int nLong=nFinC - nIniC + 1;
                     int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLong );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, i);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        i = i + nInc;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY);                   
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // lee solo filas: array 1D
                     int nInc=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                     }
                    // int nLong=nFinR - nIniR + 1;
                     int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nInc;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                    // int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongR );
                     int rPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                           put_value(pARRAYC, pARGP, cPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);  
                  }
               }
            }else{    // existe desplazamiento de páginas
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // solo desplaza un elemento por página: array 1D
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                    // int nLong=nPagFin - nPagIni + 1;
                     int nLong=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int kPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAY, pARGP, kPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        k = k + nIncP;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     
                     hb_itemRelease(pARRAY);

                  }else{   // lee solo columnas por página: array 2D
                     // esto está mal: deben haber OFFSET_POS filas, y OFFSET_COL columnas, o sea, a verre.
                     // ahora sí:
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongP );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int kPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongP-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYP = hb_itemArrayNew( cLongCTmp );
                        int pPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYP, pARGP, pPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, kPos++, pARRAYP);
                        hb_itemRelease(pARRAYP);
                        k = k + nIncP;
                     }
                     
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY); 
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // recorre solo filas, una columna, por página: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = k;
                     while( nLongR-- ){
                        int cLongPTmp=nLongP;
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);  // leo fila
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);  // leo única columna
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongPTmp );  // m-columnas                        
                        int kPos=1, k=cTmp;
                        while( cLongPTmp-- ){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYC, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           k = k + nIncP;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }

                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas y páginas: array 3D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = j;
                     int kTmp = k;
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1;
                        j=cTmp;
                        while( cLongCTmp-- ){
                           int cLongPTmp=nLongP;
                           PHB_ITEM pARRAYP = hb_itemArrayNew( cLongPTmp );
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           int kPos=1;
                           k=kTmp;
                           while( cLongPTmp-- ){
                              PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                              put_value(pARRAYP, pARGP, kPos++, PRECISION);
                              hb_itemRelease(pARGP);
                              k = k + nIncP;
                           }
                           hb_arraySet(pARRAYC, cPos++, pARRAYP);
                           hb_itemRelease(pARRAYP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }

                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);                  
                  }
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0; }
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "LET SOURCE DIMENSION ERROR",106);
         }
      }
      }
   }else {     // fuente no es un array
         // determinar get_size 
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pPRE, &nDim, &d1, &d2, &d3, &type);
         ///printf("DESTINO ARRAY indice = %d\n",nARGd); fflush(stdout);
         switch( nDim ){
            case 1: {
               unsigned int i;
               
               unsigned int nIni=1, nFin=d1;

               if (normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)){
                  if( OFFSET_POS ) {
                     if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                     nFin=OFFSET_POS;
                  }
               
                  unsigned int nInc=SET_INTERVAL_ROW; //,i=nIni;
                  if(nFin < nIni){
                      unsigned int nTmp = nIni; nIni = nFin; nFin=nTmp;// nInc=-SET_INTERVAL_ROW;
                  }
                  for(i=nIni; i<=nFin; i+=nInc){
                     put_value(pPRE, pSource, i, PRECISION);
                  }
                  hb_arraySet( pSTK_REG, nARGd, pPRE );
               }
               break;
            }case 2: {
               unsigned int i;

               unsigned int nIniR=1, nFinR=d1;
               unsigned int nIniC=1, nFinC=d2;
               if( !( sw=normaliza_indices_2d( &nIniR, &nFinR, &nIniC, &nFinC, d1, d2, &swOffset,
                                               &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL) ) ){
                   hb_itemRelease(pSource);hb_itemRelease(pPRE);
                   return sw;
               }
           // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);

               unsigned int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               unsigned int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               for(i=nIniR; i<=nFinR; i+=nIncR){
                  PHB_ITEM pREGF = hb_itemArrayGet( pPRE, i); 
                  unsigned int j;
                  for(j=nIniC; j<=nFinC; j+=nIncC){
                     put_value(pREGF, pSource, j, PRECISION);
                  }
                  hb_arraySet( pPRE, i, pREGF );
                  hb_itemRelease(pREGF);
               }
               hb_arraySet( pSTK_REG, nARGd, pPRE );
               break;
            }case 3: {

               unsigned int nPagIni=1, nPagFin=d3;
               unsigned int nIniR=1, nFinR=d1;
               unsigned int nIniC=1, nFinC=d2;
               if( !(sw=normaliza_indices_3d(&nIniR, &nFinR, &nIniC, &nFinC, &nPagIni, &nPagFin, d1, d2, d3, &swOffset,
                                             &MARK_PAGE, &OFFSET_POS, &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL)) ){
                   hb_itemRelease(pSource);hb_itemRelease(pPRE);
                   return sw; 
               }

               unsigned int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        unsigned int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               unsigned int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        unsigned int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               unsigned int nIncP=SET_INTERVAL_PAG; //,k=nIniP;
               if(nFinC < nIniC){
                        unsigned int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               unsigned int k=0;
               for(k=nPagIni; k<=nPagFin; k+=nIncP){
                  unsigned int i;
                  for( i=nIniR; i<=nFinR; i+=nIncR ){
                     PHB_ITEM pREGF = hb_itemArrayGet( pPRE, i);      // saco fila de REG
                     unsigned int j;
                     for( j=nIniC; j<=nFinC; j+=nIncC ){
                        PHB_ITEM pREGC = hb_itemArrayGet( pREGF, j);     // columna del registro
                        hb_arraySet( pREGC, k, pSource );
                        hb_arraySet( pREGF, j, pREGC );
                        hb_itemRelease( pREGC );
                     }
                     hb_arraySet( pPRE, i, pREGF );
                     hb_itemRelease( pREGF );
                  }
               }
               hb_arraySet(pSTK_REG, nARGd, pPRE);
               break;
            }default:{
               sw=put_error((PHB_ITEM) pRET, "LET TARGET DIMENSION ERROR",106);
            }
         }
   }
   SW_PUNTERO=0;
   hb_itemRelease(pSource);
   hb_itemRelease(pPRE);
}
//}while ( STK_PRG[++CP]==3 ); // CP==3 letreg
//--CP;
return sw;
}


int LetDS( /*long nARGd, long nARGs*/){

/* OJO: AQUI NO HAY PUNTEROS A ASIGNAR, PORQUE VIENE DEL STACK INTERNO DE HARBOUR */

SW_PUNTERO=0;   // RESETEO PUNTERO, POR SI EL PROGRAMADOR SACOHUEA SE EQUIVOCO
   
int sw=1;
//   int swOffset=0;
   // extrae argumentos:

if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   int nARGd = STK_PRG[ ++CP ]; // destino
   int nARGs = STK_PRG[ ++CP ]; // source
   PHB_ITEM pRegSource = hb_itemArrayGet( pSTK_REG, nARGs );//(int)STK_PRG[ ++CP ] );
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_DS, hb_itemGetNInt( pRegSource ));
   
   hb_itemRelease(pRegSource);
      PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nARGd);

         if(HB_IS_ARRAY(pPRE)){   // target es array?
            switch(RANGEDIM){
               case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==RANGEDIM){
                     unsigned int i;
                     //PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                        
                        put_value(pPRE, pSource, hb_itemGetNI(pCOORD), PRECISION);

                        hb_itemRelease(pCOORD);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==2 && RANGECOL==2){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
   
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                  
                        put_value(pROW, pSource, hb_itemGetNI(pROWY), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else if(nDim1==3 && RANGECOL==3){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                       
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
      
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                        PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                        PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                        put_value(pCOL, pSource, hb_itemGetNI(pROWP), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);
                        hb_itemRelease(pROWP);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOL);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }
            }
         }else{
           // sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET TYPE MUST BE ARRAY",104);
            if( SW_PUNTERO ) hb_arraySet(pSTK_REG, nARGd, pSource); 
            else             put_value(pSTK_REG, pSource, nARGd, PRECISION);
         }

      hb_itemRelease(pPRE);

      hb_itemRelease(pSource);
}else{   
   long nARGd = STK_PRG[ ++CP ]; // destino
   long nARGs = STK_PRG[ ++CP ]; // source
   
   PHB_ITEM pRegSource = hb_itemArrayGet( pSTK_REG, nARGs );//(int)STK_PRG[ ++CP ] );
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_DS, hb_itemGetNInt( pRegSource ));
   
   hb_itemRelease(pRegSource);
   // CHEQUEA ARRAY en DESTINO.
              
   if( ! HB_IS_ARRAY( pSource ) ){    // fuente no es un array?

      PHB_ITEM pARRAYTMP = hb_itemArrayGet( pSTK_REG, nARGd);
      if ( HB_IS_ARRAY( pARRAYTMP ) ) {      // destino es un array? 
         // determinar get_size 
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pARRAYTMP, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1: {
               int i;

               int nIni=1, nFin=d1;
               if( MARK_POS == 999999999 ) MARK_POS=d1;
               if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
               if( OFFSET_POS ) {
                  if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                  nFin=OFFSET_POS;
               }
               
               int nInc=SET_INTERVAL_ROW; //,i=nIni;
               if(nFin < nIni){
                   int nTmp = nIni; nIni = nFin; nFin=nTmp;// nInc=-SET_INTERVAL_ROW;
               }
               for(i=nIni; i<=nFin; i+=nInc){
                  put_value(pARRAYTMP, pSource, i, PRECISION);
               }
               hb_arraySet( pSTK_REG, nARGd, pARRAYTMP );
               break;
            }case 2: {
               int i;

               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
           // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "LET ROW'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniR=MARK_ROW;nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET ROW'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
              //    swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "LET COL'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniC=MARK_COL;nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET COL'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
            //      swOffset=1;
                  OFFSET_COL=nFinC;
               }

               int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               for(i=nIniR; i<=nFinR; i+=nIncR){
                  PHB_ITEM pREGF = hb_itemArrayGet( pARRAYTMP, i); 
                  int j;
                  for(j=nIniC; j<=nFinC; j+=nIncC){
                     put_value(pREGF, pSource, j, PRECISION);
                  }
                  hb_arraySet( pARRAYTMP, i, pREGF );
                  hb_itemRelease(pREGF);
               }
               hb_arraySet( pSTK_REG, nARGd, pARRAYTMP );
               break;
            }case 3: {

               int nPagIni=1, nPagFin=d3;
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
               if( MARK_PAGE ){
                  if( MARK_PAGE == 999999999 ) MARK_PAGE=d3;
                  if( MARK_PAGE>d3 ){
                     sw=put_error((PHB_ITEM) pRET, "LET PAGE'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nPagIni=MARK_PAGE; nPagFin=MARK_PAGE;
                  if( OFFSET_POS ){
                     if( OFFSET_POS == 999999999 ) OFFSET_POS=d3;
                     if( OFFSET_POS<=d3 ){
                        nPagFin=OFFSET_POS;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET PAGE'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  } 
               }else{  // si no existe marca de página, se asume todo; luego:
   //               swOffset=1;
                  OFFSET_POS=nPagFin; 
               }
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "LET ROW'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniR=MARK_ROW;nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET ROW'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
                  //swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "LET COL'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniC=MARK_COL;nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET COL'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
         //         swOffset=1;
                  OFFSET_COL=nFinC;
               }


               int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               int nIncP=SET_INTERVAL_PAG; //,k=nIniP;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               int k=0;
               for(k=nPagIni; k<=nPagFin; k+=nIncP){
                  int i;
                  for( i=nIniR; i<=nFinR; i+=nIncR ){
                     PHB_ITEM pREGF = hb_itemArrayGet( pARRAYTMP, i);      // saco fila de REG
                     int j;
                     for( j=nIniC; j<=nFinC; j+=nIncC ){
                        PHB_ITEM pREGC = hb_itemArrayGet( pREGF, j);     // columna del registro
                        hb_arraySet( pREGC, k, pSource );
                        hb_arraySet( pREGF, j, pREGC );
                        hb_itemRelease( pREGC );
                     }
                     hb_arraySet( pARRAYTMP, i, pREGF );
                     hb_itemRelease( pREGF );
                  }
               }
               hb_arraySet(pSTK_REG, nARGd, pARRAYTMP);
               break;
            }default:{
               sw=put_error((PHB_ITEM) pRET, "LET TARGET DIMENSION ERROR",106);
            }
         }
      }else{    // destino no es un array    
         // chequea tipo de valor obtenido y guarda en STK_ADDR:
         if( SW_PUNTERO ) hb_arraySet(pSTK_REG, nARGd, pSource); 
         else             put_value(pSTK_REG, pSource, nARGd, PRECISION);
      }
      hb_itemRelease(pARRAYTMP);

   }else{  // esto NUNCA debería pasar.
      sw=put_error((PHB_ITEM) pRET, "LET TYPE MISMATCH",101);
   }
   hb_itemRelease(pSource);
}
return sw;
}


/****************************************************
    FUNCIONES DE SALTO Y SALTO CON RETORNO
 ***************************************************/

//int jumpEQ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpEQ( /* long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){
   long Jumper = STK_PRG[ ++CP ] - 1;
///   ++CP;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       double pDbl1 = hb_itemGetND( pARG1 );
       double pDbl2 = hb_itemGetND( pARG2 );
       // guardar dirección de retorno.
       if ( pDbl2 == pDbl1 ) CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
       const char * pString1 = hb_itemGetCPtr( pARG1 );
       const char * pString2 = hb_itemGetCPtr( pARG2 );
                      // guardar dirección de retorno.
       if ( strcmp(pString2,pString1) == 0 ) CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else{
       sw=put_error((PHB_ITEM) pRET, "JEQ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JEQ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNEQ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNEQ( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       double pDbl1 = hb_itemGetND( pARG1 );
       double pDbl2 = hb_itemGetND( pARG2 );
       // guardar dirección de retorno.
       if ( pDbl2 != pDbl1 ) CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
       const char * pString1 = hb_itemGetCPtr( pARG1 );
       const char * pString2 = hb_itemGetCPtr( pARG2 );
       // guardar dirección de retorno.
       if ( strcmp(pString2,pString1) != 0)  CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else{
       sw=put_error((PHB_ITEM) pRET, "JNEQ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNEQ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpLT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpLT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) < hb_itemGetND( pARG2 ) )  CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else{
       sw=put_error((PHB_ITEM) pRET, "JLT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JLT STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpLTE( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpLTE( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) <= hb_itemGetND( pARG2 ) ) CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JLT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JLT STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpGT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpGT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) > hb_itemGetND( pARG2 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JGT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JGT STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpGTE( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpGTE( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) >= hb_itemGetND( pARG2 ) ) CP = Jumper; //STK_PRG[ CP ] - 1;

   }else{
       sw=put_error((PHB_ITEM) pRET, "JGE ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JGE STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

 /*  if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else{
       sw=put_error((PHB_ITEM) pRET, "JT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JT STACK UNDERFLOW",102); 
}
return sw;
}

int jumpSpecialT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
 ///  CADDR += SWKEEP; SWKEEP = 0;

 /*  if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else{
       sw=put_error((PHB_ITEM) pRET, "JST ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JST STACK UNDERFLOW",102); 
}
return sw;
}

int jumpSpecialNT(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
/////   CADDR += SWKEEP; SWKEEP = 0;

 /*  if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( !hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( !hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
        else  ++CADDR;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( !hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else{
       
       sw=put_error((PHB_ITEM) pRET, "JSNT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JSNT STACK UNDERFLOW",102); 
}
return sw;
}


//int jumpNT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNT(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

/*   if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( !hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( !hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( !hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       
       sw=put_error((PHB_ITEM) pRET, "JNT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNT STACK UNDERFLOW",102); 
}
return sw;
}


//int jumpV( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpV( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_STRING( pARG1 ) ) {
       // guardar dirección de retorno.hb_itemGetCLen( pSource )
       if ( !hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JV ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JV STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNV( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNV(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_STRING( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1; 
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNV ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNV STACK UNDERFLOW",102); 
}
return sw;
}


int jumpNNeg(){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) >=0  )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNNEG ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNNEG STACK UNDERFLOW",102); 
}
return sw;
}

int jumpNPos(){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   if (SWKEEP){
       CADDR += SWKEEP; SWKEEP = 0;
   }
   //CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) <=0  )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNPOS ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNPOS STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpZ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpZ( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( !hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JZ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JZ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNZ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNZ(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNZ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNZ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNEG( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNEG(/* long Jumper */){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) < 0 )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNEG ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNEG STACK UNDERFLOW",102); 
}
return sw;
}


//int jumpPOS( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpPOS( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) > 0 )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else{
       sw=put_error((PHB_ITEM) pRET, "JPOS ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JPOS STACK UNDERFLOW",102); 
}
return sw;
}

int jumpSingle(){
              ++CP;
              CP = STK_PRG[ CP ] - 1;
return 1;
}
//int jumpJSUB( int STK_PRG[], PHB_ITEM pRET ){
int jumpJSUB( ){
int sw=1;

unsigned int nJump = STK_PRG[ ++CP ];
              sw= (int) push_label( (int) (CP+1) ) ;
              CP = nJump - 1;

return sw;
}


//int jumpGOSUB( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpGOSUB(/* long nJump */){
int sw=1;
if ( CADDR >= 1 ){

   long nJump = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // no consume: va a usar el contenido del stack
   CADDR += SWKEEP; SWKEEP = 0;
   
 /*  if( HB_IS_LOGICAL ( pARG1 )) {  // quita el valor del stack
      // CADDR--;
       if ( hb_itemGetL( pARG1 ) ) {
          sw= (int) push_label( (int) (CP+1) ) ;
          CP = nJump; // - 1; 
       }
       
   }else */if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) ) {
          sw= (int) push_label( (int) (CP+1) );
          CP = nJump; // - 1;
       }
   
   }else if( HB_IS_STRING ( pARG1 )) {
       if ( hb_itemGetCLen( pARG1 ) ) {
          sw= (int) push_label( (int) (CP+1) ) ;
          CP = nJump; // - 1;
       }

   }else if( HB_IS_ARRAY ( pARG1 )) {
       sw= (int) push_label( (int) (CP+1) ) ;
       CP = nJump; // - 1;
   
   }else{
       sw=put_error((PHB_ITEM) pRET, "GOSUB ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "GOSUB STACK UNDERFLOW",102); 
}
return sw;
}


/****************************************************
    FUNCIONES LOGICAS Y MATEMATICAS
 ****************************************************/


int fun_matrix_mul(){
int sw=1;
if( CADDR>=2 ){
    PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
    PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
    CADDR += SWKEEP; SWKEEP = 0;
    
    if( HB_IS_ARRAY( pA ) && HB_IS_ARRAY( pB ) ){
       HB_MAXINT nDimA=0,dA1=0,dA2=0, dA3=0,typeA=0;
       get_size( (PHB_ITEM) pA, &nDimA, &dA1, &dA2, &dA3, &typeA);
       HB_MAXINT nDimB=0,dB1=0,dB2=0, dB3=0,typeB=0;
       get_size( (PHB_ITEM) pB, &nDimB, &dB1, &dB2, &dB3, &typeB);
       
       unsigned int pRow = (unsigned int) dA1;
       unsigned int pCol1 = (unsigned int) dA2;   // cols1
       unsigned int pCol2 = (unsigned int) dB2;   // cols2
       
       if( nDimA == nDimB && dA2 == dB1 ){
          unsigned int ehx,eix,ejx;
          double ESX;
          PHB_ITEM pCWM = hb_itemArrayNew( pRow ); // CWM
          for( ehx=1; ehx<=pRow; ehx++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, ehx);
             PHB_ITEM pCC = hb_itemArrayNew( pCol2 ); // CWM
             for( ejx=1; ejx<=pCol2; ejx++){
                ESX = 0;
                for( eix=1; eix<=pCol1; eix++){
                   PHB_ITEM pA2 = hb_itemArrayGet( pAA, eix);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, eix);
                   PHB_ITEM pB2 = hb_itemArrayGet( pBB, ejx );
                   ESX = ESX + hb_itemGetND( pA2 ) *
                               hb_itemGetND( pB2 );
                   hb_itemRelease( pA2 );
                   hb_itemRelease( pB2 );
                   hb_itemRelease( pBB );
                } 
                hb_arraySetND( pCC, ejx, ESX );  
             }
             hb_arraySet( pCWM, ehx, pCC );
             hb_itemRelease(pCC);
             hb_itemRelease(pAA);
          }
          hb_arraySet( pSTK_ADDR, ++CADDR, pCWM );
          hb_itemRelease(pCWM);
       }else{
          sw=put_error((PHB_ITEM) pRET, "MATRICIAL MULTIPLICATION DIMENSION ERROR",106);
       }
    }else{
       sw=put_error((PHB_ITEM) pRET, "MATRICIAL MULTIPLICATION ARGUMENT ERROR",103);
    }
    hb_itemRelease(pB);
    hb_itemRelease(pA);    
}else{
    sw=put_error((PHB_ITEM) pRET, "MATRICIAL MULTIPLICATION INNER-STACK OVERFLOW",101);
}
return sw;
}


int compare_str_item(PHB_ITEM pSTK_ADDR, PHB_ITEM pARG2, PHB_ITEM pARG1, int CADDR, int tCompare){
int sw=1;
   switch( tCompare ){
      case 0:{hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( strcmp(hb_itemGetCPtr( pARG2 ),hb_itemGetCPtr( pARG1 )) == 0 ) );break;}
      case 1:{hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( strcmp(hb_itemGetCPtr( pARG2 ),hb_itemGetCPtr( pARG1 )) != 0 ) );break;}
      case 8:{hb_arraySetNI( pSTK_ADDR, CADDR, (int)  hb_strAt( hb_itemGetCPtr( pARG2 ), hb_itemGetCLen( pARG2 ),
                                                                    hb_itemGetCPtr( pARG1 ), hb_itemGetCLen( pARG1 ) ) > 0 );
              break;}
      case 9:{hb_arraySetNI( pSTK_ADDR, CADDR, (int)  hb_striAt( hb_itemGetCPtr( pARG2 ), hb_itemGetCLen( pARG2 ),
                                                                    hb_itemGetCPtr( pARG1 ), hb_itemGetCLen( pARG1 ) ) > 0 );
              break;}
      case 51:{   // xtobool  str-->bool
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) hb_itemGetCLen(pARG2));
         break;
      }default: sw=0;
   }
return sw;
}


int compare_item(PHB_ITEM pSTK, PHB_ITEM pARG2, PHB_ITEM pARG1, int ndx, int tCompare){
int sw=1;
   switch( tCompare ){
      case 0:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) == hb_itemGetND( pARG1 )) ); break;}
      case 1:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) != hb_itemGetND( pARG1 )) ); break;}
      case 2:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) <  hb_itemGetND( pARG1 )) ); break;}
      case 3:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) <= hb_itemGetND( pARG1 )) ); break;}
      case 4:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) >  hb_itemGetND( pARG1 )) ); break;}
      case 5:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) >= hb_itemGetND( pARG1 )) ); break;}
      case 6:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) < 0 )); break;}
      case 7:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) > 0 )); break;}
      case 10:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) == 0 )); break;}
      case 51:{  // xtobool num->bool
         hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) ));
         break;
      }
      default: sw=0;
   }
return sw;
}


int logic_num_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=compare_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=compare_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=compare_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int logic_num_matrix_item(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=compare_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, i, (int) tCompare);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=compare_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG1, j, (int) tCompare);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=compare_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1, k, (int) tCompare);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int logic_str_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int logic_str_matrix_item(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG1, (PHB_ITEM) pARG22, i, (int) tCompare);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG1, (PHB_ITEM) pARG222, j, (int) tCompare);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2222, k, (int) tCompare);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

// "eqto"=>267, "neqto"=>268,"lthan"=>269,"lethan"=>270,"gthan"=>271,"gethan"=>272,
int logical_espCompare( /*int nReg,*/ /*int tCompare*/){
int sw=1;
int tCompare = nPCP-267;
if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo. 
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pARG2  = hb_itemArrayGet( pSTK_REG, nReg);
   //printf("\nPASS...%d; %d\n",HB_IS_NUMERIC( pARG2 ),HB_IS_NUMERIC( pARG1 ));
   if ( HB_IS_NUMERIC( pARG2 ) && HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      if(!compare_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
      ++CADDR;
      if(!compare_str_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG1 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG2 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG2 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG2 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG1, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "(1)LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",103); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "(2)LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else if( HB_IS_ARRAY( pARG2 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG1 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG1 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG1 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG2, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",106); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "(3)LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else{
      sw=put_error((PHB_ITEM) pRET, "(4)LOGICAL COMPARE ARGUMENT ERROR",103); 
   }
  // if( tCompare!=6&&tCompare!=7&&tCompare!=10&&tCompare!=51 ){
      hb_itemRelease(pARG2);
  // }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE STACK UNDERFLOW",102); 
}
return sw;
}
              
//int logicalCompare( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET, int tCompare ){
int logicalCompare( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP != 51 ? (int)nPCP-23 : 51;
if ( CADDR >= 1 ){
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo. 
   PHB_ITEM pARG1 = NULL; 
   
   if( tCompare==6||tCompare==7||tCompare==10||tCompare==51 ){
      //pARG2 = pARG1;
      pARG1 = pARG2;
   }else{
      if( CADDR == 0){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE STACK UNDERFLOW",102); 
         hb_itemRelease(pARG2);
         hb_itemRelease(pARG1);
         return sw;
      }
      pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      /* evalua POSTFIX */  
    /*  if(SW_POSTFIX){    // está dentro de #MATH: invierte operandos.
         PHB_ITEM TMP = pARG1;
         pARG1 = pARG2;
         pARG2 = TMP;
      }*/
      /******************/  
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if ( HB_IS_NUMERIC( pARG2 ) && HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      if(!compare_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
      ++CADDR;
      if(!compare_str_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG1 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG2 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG2 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG2 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG1, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",103); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else if( HB_IS_ARRAY( pARG2 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG1 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG1 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG1 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG2, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",106); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else{
      sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
   }
   if( tCompare!=6&&tCompare!=7&&tCompare!=10&&tCompare!=51 ){
      hb_itemRelease(pARG2);
   }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE STACK UNDERFLOW",102); 
}
return sw;
}


int logic_eqarr_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT nDim, 
                            HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3,int TIPO){
int swOK=1;
   double nArg1, nArg2;
   const char * cArg1, * cArg2;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            if(TIPO){
               nArg1 = hb_itemGetND(pARG11);
               nArg2 = hb_itemGetND(pARG22);
            }else{
               cArg1 = hb_itemGetCPtr( pARG11 );
               cArg2 = hb_itemGetCPtr( pARG22 );
            }
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            if(TIPO){
               if( nArg1!=nArg2 ){
                   swOK=0; break;
               }
            }else{
               if ( strcmp( cArg1 , cArg2 ) != 0 ){
                   swOK=0; break;
               }
            }
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               if(TIPO){
                  nArg1 = hb_itemGetND(pARG111);
                  nArg2 = hb_itemGetND(pARG222);
               }else{
                  cArg1 = hb_itemGetCPtr( pARG111 );
                  cArg2 = hb_itemGetCPtr( pARG222 );
               }
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);

               if(TIPO){
                  if( nArg1!=nArg2 ){
                      swOK=0; break;
                  }
               }else{
                  if ( strcmp( cArg1 , cArg2 ) != 0 ){
                      swOK=0; break;
                  }
               }
            }
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            if(!swOK) break;
         }
         break;
      }case 3:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  if(TIPO){
                     nArg1 = hb_itemGetND(pARG1111);
                     nArg2 = hb_itemGetND(pARG2222);
                  }else{
                     cArg1 = hb_itemGetCPtr( pARG1111 );
                     cArg2 = hb_itemGetCPtr( pARG2222 );
                  }
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
                  if(TIPO){
                     if( nArg1!=nArg2 ){
                         swOK=0; break;
                     }
                  }else{
                     if ( strcmp( cArg1 , cArg2 ) != 0 ){
                        swOK=0; break;
                     }
                  }
               }
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               if(!swOK) break;
            }
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            if(!swOK) break;
         }
         break;
      }
   }
return swOK;
}
/*

*/

int fun_eqarr(){
int sw=1;

if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pARG2 = NULL;
   if (nPCP == 339 || nPCP == 340 ) {
      if (CADDR>=1)
         pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      else{
         sw=put_error((PHB_ITEM) pRET, "EQARR STACK UNDERFLOW",102);
         hb_itemRelease(pARG1);
         return sw;
      }
   }else{
      int nARG2 = STK_PRG[++CP];
      pARG2 = hb_itemArrayGet( pSTK_REG, nARG2 );
   }
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_ARRAY( pARG1 ) && HB_IS_ARRAY( pARG2 )){

      HB_MAXINT nDim1=0,d1=0,d21=0,d31=0,type1=0;
      get_size( (PHB_ITEM) pARG1, &nDim1, &d1, &d21, &d31, &type1);       
      HB_MAXINT nDim2=0,d2=0,d22=0,d32=0,type2=0;
      get_size( (PHB_ITEM) pARG2, &nDim2, &d2, &d22, &d32, &type2);
      if( type1 == type2 && nDim1 == nDim2 && d1 == d2 && d21 == d22 && d31 == d32 ){
          if(type1 == 11 ){  // numeros
               int lEqual = logic_eqarr_matrix_matrix(pARG1, pARG2, nDim1, d1, d21, d31,1);
               if ( nPCP == 339 || nPCP == 375)  // EQARR|EQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, lEqual );
               else               // NEQARR|NEQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, ! lEqual );
          }else if(type1 == 10){  // strings
               int lEqual = logic_eqarr_matrix_matrix(pARG2, pARG1, nDim1, d1, d21, d31,0);
               if ( nPCP == 339 || nPCP == 375)  // EQARR|EQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, lEqual );
               else               // NEQARR|NEQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, ! lEqual );
          }else{
               sw=put_error((PHB_ITEM) pRET, "EQARR|TO ARGUMENT ERROR",103); 
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "EQARR|TO DIMENSION ERROR",106); 
      }
   }else{
       sw=put_error((PHB_ITEM) pRET, "EQARR|TO ARGUMENT ERROR: MUST BE ARRAYS",103); 
   }
   hb_itemRelease(pARG1);
   hb_itemRelease(pARG2);
}else{
   sw=put_error((PHB_ITEM) pRET, "EQARR|TO STACK UNDERFLOW",102); 
}
return sw;
}

/* operación con cuadrados.
   1) todos son escalares
    */
int fun_sqrcompute(){
int sw=1;
int tCompare = nPCP - 333; /* 334=diff, 335=add, 336=hypot, 337=mulall, 338=sumall */
if (CADDR>=2){
//   PHB_ITEM pARGY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // X^2
//   PHB_ITEM pARGX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Y^2
   
//   if(HB_IS_NUMERIC(pARGX) && HB_IS_NUMERIC(pARGY)){
//      double nARGX = hb_itemGetND( pARGX );
//      double nARGY = hb_itemGetND( pARGY );
      int nIndex=1;
      switch(tCompare){
         case 1:{ //  DIFF SQR
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, nIndex++);
            --CADDR;
            double nARG = hb_itemGetND( pARG );
            double nRES = SW_PRECISION ? xu_funprecision( nARG*nARG, PRECISION ) : nARG*nARG ;
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, nIndex++);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES -= (double) SW_PRECISION ? xu_funprecision( nARGZ*nARGZ, PRECISION ) : nARGZ*nARGZ;
               hb_itemRelease(pARGZ);
               --CADDR;
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);

/*                  CADDR += SWKEEP; SWKEEP = 0;
                  hb_arraySetND(pSTK_ADDR, ++CADDR, ( (double) SW_PRECISION ? xu_funprecision( nARGX*nARGX - nARGY*nARGY, PRECISION ) : nARGX*nARGX - nARGY*nARGY )); */
                  break; 
         }case 2:{ // ADD SQR 
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, nIndex++);
            --CADDR;
            double nARG = hb_itemGetND( pARG );
            double nRES = SW_PRECISION ? xu_funprecision( nARG*nARG, PRECISION ) : nARG*nARG ;
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, nIndex++);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES += (double) SW_PRECISION ? xu_funprecision( nARGZ*nARGZ, PRECISION ) : nARGZ*nARGZ;
               hb_itemRelease(pARGZ);
               --CADDR;
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);
            
/*                  CADDR += SWKEEP; SWKEEP = 0; 
                  hb_arraySetND(pSTK_ADDR, ++CADDR, ( (double) SW_PRECISION ? xu_funprecision( nARGX*nARGX + nARGY*nARGY, PRECISION ) : nARGX*nARGX + nARGY*nARGY )); */
                  break;
         }case 3:{  // HYPOT
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, nIndex++);
            --CADDR;
            double nARG = hb_itemGetND( pARG );
            double nRES = SW_PRECISION ? xu_funprecision( nARG*nARG, PRECISION ) : nARG*nARG ;
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, nIndex++);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES += (double) SW_PRECISION ? xu_funprecision( nARGZ*nARGZ, PRECISION ) : nARGZ*nARGZ;
               hb_itemRelease(pARGZ);
               --CADDR;
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) SW_PRECISION ? xu_funprecision( sqrt(nRES), PRECISION ) : sqrt(nRES));
/*                   CADDR += SWKEEP; SWKEEP = 0;
                   hb_arraySetND(pSTK_ADDR, ++CADDR, (double) SW_PRECISION ? xu_funprecision( sqrt( nARGX*nARGX + nARGY*nARGY ), PRECISION ) : sqrt( nARGX*nARGX + nARGY*nARGY )); */
                  break;
         }case 4:{   // MULALL
            //double nRES = (double) SW_PRECISION ? xu_funprecision( nARGX*nARGY, PRECISION ) : nARGX*nARGY;
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
            double nRES = hb_itemGetND( pARG );
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, CADDR--);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES = (double) SW_PRECISION ? xu_funprecision( nARGZ*nRES, PRECISION ) : nARGZ*nRES;
               hb_itemRelease(pARGZ);
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);
            break;
         }case 5:{   // SUMALL
            //double nRES = (double) SW_PRECISION ? xu_funprecision( nARGX+nARGY, PRECISION ) : nARGX+nARGY;
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
            double nRES = hb_itemGetND( pARG );
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, CADDR--);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES = (double) SW_PRECISION ? xu_funprecision( nARGZ+nRES, PRECISION ) : nARGZ+nRES;
               hb_itemRelease(pARGZ);
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);
            break;
         }
      }
//   }else{
//      sw=put_error((PHB_ITEM) pRET, "SQUARE OPERATION ARGUMENT ERROR",103);
//   }
//   hb_itemRelease(pARGX);
//   hb_itemRelease(pARGY);
}else{
   sw=put_error((PHB_ITEM) pRET, "SQUARE OPERATION STACK UNDERFLOW",102);
}
return sw;
}

//int between( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int between(){
int sw=1;
if( CADDR>=5 ){
   
   PHB_ITEM pTIPO2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo2 = hb_itemGetNI(pTIPO2); hb_itemRelease(pTIPO2);
   PHB_ITEM pARGf = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fin
   PHB_ITEM pTIPO1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo1 = hb_itemGetNI(pTIPO1); hb_itemRelease(pTIPO1);
   PHB_ITEM pARGi = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ini
   PHB_ITEM pARGv = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // variable
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(!HB_IS_ARRAY(pARGv)){
      long nARGv = hb_itemGetND( pARGv );
      ++CADDR;
      if(nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv >= hb_itemGetND( pARGi ) && nARGv <= hb_itemGetND( pARGf )) );
      else if( nTipo1 && !nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv >= hb_itemGetND( pARGi ) && nARGv < hb_itemGetND( pARGf )) );
      else if( !nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv > hb_itemGetND( pARGi ) && nARGv <= hb_itemGetND( pARGf )) );
      else
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv > hb_itemGetND( pARGi ) && nARGv < hb_itemGetND( pARGf )) );
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARGv, &nDim, &d1, &d2, &d3, &type);
      long nARGi = hb_itemGetND( pARGi );
      long nARGf = hb_itemGetND( pARGf );
      if (type>10){
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  long nARG22 = hb_itemGetND( pARG22 );
                  if( nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 >= nARGi && nARG22 <= nARGf ) );
                  else if( nTipo1 && !nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 >= nARGi && nARG22 < nARGf ) );
                  else if( !nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 > nARGi && nARG22 <= nARGf ) );
                  else
                     hb_arraySetNI( pRows, i, (int) ( nARG22 > nARGi && nARG22 < nARGf ) );
                  hb_itemRelease(pARG22);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     long nARG222 = hb_itemGetND( pARG222 );
                     if( nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 >= nARGi && nARG222 <= nARGf ) );
                     else if( nTipo1 && !nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 >= nARGi && nARG222 < nARGf ) );
                     else if( !nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 > nARGi && nARG222 <= nARGf ) );
                     else
                        hb_arraySetNI( pCols, j, (int) ( nARG222 > nARGi && nARG222 < nARGf ) );
                     
                     hb_itemRelease(pARG222);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     PHB_ITEM pPag = hb_itemArrayNew( d3 );
                     int k;
                     for( k=1; k<=d3; k++){
                        PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                        long nARG2222 = hb_itemGetND( pARG2222 );
                        if( nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 >= nARGi && nARG2222 <= nARGf ) );
                        else if( nTipo1 && !nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 >= nARGi && nARG2222 < nARGf ) );
                        else if( !nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 > nARGi && nARG2222 <= nARGf ) );
                        else
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 > nARGi && nARG2222 < nARGf ) );

                        hb_itemRelease(pARG2222);
                     }
                     hb_arraySet( pCols, j, pPag );
                     hb_itemRelease(pARG222);
                     hb_itemRelease(pPag);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=0;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "BETWEEN TYPE MISMATCH",104);
      }
   }
   hb_itemRelease(pARGf);
   hb_itemRelease(pARGi);
   hb_itemRelease(pARGv);
}else{
   sw=put_error((PHB_ITEM) pRET, "BETWEEN STACK UNDERFLOW",102); 
}
return sw;
}

int fun_outbetween(){
int sw=1;
if( CADDR>=5 ){
   
   PHB_ITEM pTIPO2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo2 = hb_itemGetNI(pTIPO2); hb_itemRelease(pTIPO2);
   PHB_ITEM pARGf = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fin
   PHB_ITEM pTIPO1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo1 = hb_itemGetNI(pTIPO1); hb_itemRelease(pTIPO1);
   PHB_ITEM pARGi = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ini
   PHB_ITEM pARGv = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // variable
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(!HB_IS_ARRAY(pARGv)){
      long nARGv = hb_itemGetND( pARGv );
      ++CADDR;
      if(nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv <= hb_itemGetND( pARGi ) || nARGv >= hb_itemGetND( pARGf )) );
      else if( nTipo1 && !nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv <= hb_itemGetND( pARGi ) || nARGv > hb_itemGetND( pARGf )) );
      else if( !nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv < hb_itemGetND( pARGi ) || nARGv >= hb_itemGetND( pARGf )) );
      else
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv < hb_itemGetND( pARGi ) || nARGv > hb_itemGetND( pARGf )) );
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARGv, &nDim, &d1, &d2, &d3, &type);
      long nARGi = hb_itemGetND( pARGi );
      long nARGf = hb_itemGetND( pARGf );
      if (type>10){
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  long nARG22 = hb_itemGetND( pARG22 );
                  if( nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 <= nARGi || nARG22 >= nARGf ) );
                  else if( nTipo1 && !nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 <= nARGi || nARG22 > nARGf ) );
                  else if( !nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 < nARGi || nARG22 >= nARGf ) );
                  else
                     hb_arraySetNI( pRows, i, (int) ( nARG22 < nARGi || nARG22 > nARGf ) );
                  hb_itemRelease(pARG22);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     long nARG222 = hb_itemGetND( pARG222 );
                     if( nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 <= nARGi || nARG222 >= nARGf ) );
                     else if( nTipo1 && !nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 <= nARGi || nARG222 > nARGf ) );
                     else if( !nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 < nARGi || nARG222 >= nARGf ) );
                     else
                        hb_arraySetNI( pCols, j, (int) ( nARG222 < nARGi || nARG222 > nARGf ) );
                     
                     hb_itemRelease(pARG222);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     PHB_ITEM pPag = hb_itemArrayNew( d3 );
                     int k;
                     for( k=1; k<=d3; k++){
                        PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                        long nARG2222 = hb_itemGetND( pARG2222 );
                        if( nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 <= nARGi || nARG2222 >= nARGf ) );
                        else if( nTipo1 && !nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 <= nARGi || nARG2222 > nARGf ) );
                        else if( !nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 < nARGi || nARG2222 >= nARGf ) );
                        else
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 < nARGi || nARG2222 > nARGf ) );

                        hb_itemRelease(pARG2222);
                     }
                     hb_arraySet( pCols, j, pPag );
                     hb_itemRelease(pARG222);
                     hb_itemRelease(pPag);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=0;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "OUTBETWEEN TYPE MISMATCH",104);
      }
   }
   hb_itemRelease(pARGf);
   hb_itemRelease(pARGi);
   hb_itemRelease(pARGv);
}else{
   sw=put_error((PHB_ITEM) pRET, "OUTBETWEEN STACK UNDERFLOW",102); 
}
return sw;
}

int fun_naninf_matrix( PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
if (type>10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            if( tCompare )
               hb_arraySetNI( pRows, i, (int) isnan( hb_itemGetND( pARG22 ) ) );
            else
               hb_arraySetNI( pRows, i, (int) isinf( hb_itemGetND( pARG22 ) ) );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               if( tCompare )
                  hb_arraySetNI( pCols, j, (int) isnan( hb_itemGetND( pARG222 ) ) );
               else
                  hb_arraySetNI( pCols, j, (int) isinf( hb_itemGetND( pARG222 ) ) );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  if( tCompare )
                     hb_arraySetNI( pPag, k, (int) isnan( hb_itemGetND( pARG2222 ) ) );
                  else
                     hb_arraySetNI( pPag, k, (int) isinf( hb_itemGetND( pARG2222 ) ) );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_isnaninf( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP-57;
if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   if ( HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      if( tCompare )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) isnan( hb_itemGetND( pARG1 ) ) );
      else
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) isinf( hb_itemGetND( pARG1 ) ) );
   }else if( HB_IS_ARRAY( pARG1 ) ){
      ++CADDR;
      if(!(int) fun_naninf_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int)tCompare )){
         sw=put_error((PHB_ITEM) pRET, "ISNAN|ISINF ARGUMENT ERROR",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "ISNAN|ISINF ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "ISNAN|ISINF STACK UNDERFLOW",103); 
}   
return sw;
}

int fun_anyall_matrix( PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
if (type==10 || type==11){
   switch( nDim ){
      case 1:{
         
         int i;
         int swAll=1, swAny=0;
         if( HB_IS_NUMERIC(pARG1) ){
            double nDato = hb_itemGetND( pARG1 );
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               if( tCompare ){  // is any
                  if ( nDato == hb_itemGetND( pARG22 ) ){
                     swAny=1;
                  }
               }else{     // is all
                  if ( nDato != hb_itemGetND( pARG22 ) ){
                     swAll=0; 
                  }
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else if( HB_IS_STRING(pARG1) ){
            const char * cDato = hb_itemGetCPtr( pARG1 );
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               if( tCompare ){  // is any
                  if ( strcmp( cDato , hb_itemGetCPtr( pARG22 ) ) == 0 ){
                     swAny=1;
                  }
               }else{     // is all
                  if ( strcmp( cDato , hb_itemGetCPtr( pARG22 ) ) != 0 ){
                     swAll=0; 
                  }
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else{
            sw=0;
         }
         hb_arraySetNI(pSTK_ADDR, CADDR, (int) tCompare ? swAny : swAll);
         break;
      }case 2:{
         int i;
         int swAll=1, swAny=0;
         if( HB_IS_NUMERIC(pARG1) ){
            double nDato = hb_itemGetND( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  if( tCompare ){  // is any
                     if ( nDato == hb_itemGetND( pARG222 ) ){
                        swAny=1;
                     }
                  }else{     // is all
                     if ( nDato != hb_itemGetND( pARG222 ) ){
                        swAll=0; 
                     }
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else if( HB_IS_STRING(pARG1) ){
            const char * cDato = hb_itemGetCPtr( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  if( tCompare ){  // is any
                     if ( strcmp( cDato , hb_itemGetCPtr( pARG222 ) ) == 0 ){
                        swAny=1;
                     }
                  }else{     // is all
                     if ( strcmp( cDato , hb_itemGetCPtr( pARG222 ) ) != 0 ){
                        swAll=0; 
                     }
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else{
            sw=0;
         }
         hb_arraySetNI(pSTK_ADDR, CADDR, (int) tCompare ? swAny : swAll);
         break;
      }case 3:{
         
         int i;
         int swAll=1, swAny=0;
         if( HB_IS_NUMERIC(pARG1) ){
            double nDato = hb_itemGetND( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     if( tCompare ){  // is any
                        if ( nDato == hb_itemGetND( pARG2222 ) ){
                           swAny=1;
                        }
                     }else{     // is all
                        if ( nDato != hb_itemGetND( pARG2222 ) ){
                           swAll=0; 
                        }
                     }
                     hb_itemRelease(pARG2222);
                     if( swAny || !swAll ) break;
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else if( HB_IS_STRING(pARG1) ){
            const char * cDato = hb_itemGetCPtr( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     if( tCompare ){  // is any
                        if ( strcmp( cDato , hb_itemGetCPtr( pARG2222 ) ) == 0 ){
                           swAny=1;
                        }
                     }else{     // is all
                        if ( strcmp( cDato , hb_itemGetCPtr( pARG2222 ) ) != 0 ){
                           swAll=0; 
                        }
                     }
                     hb_itemRelease(pARG2222);
                     if( swAny || !swAll ) break;
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else{
            sw=0;
         }
         hb_arraySetNI(pSTK_ADDR, CADDR, (int) tCompare ? swAny : swAll);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_isanyall( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP-68;
if ( CADDR >= 2 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // matriz
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor a evaluar
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_ARRAY( pARG1 ) && (HB_IS_NUMERIC( pARG2 ) || HB_IS_STRING( pARG2 ))){
      ++CADDR;
      if(!(int) fun_anyall_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int)tCompare )){
         sw=put_error((PHB_ITEM) pRET, "ISANY|ISALL ARGUMENT ERROR",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "ISANY|ISALL ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
   hb_itemRelease(pARG2);
}else{
   sw=put_error((PHB_ITEM) pRET, "ISANY|ISALL STACK UNDERFLOW",102); 
}   
return sw;
}

int fun_boolean_matrix( PHB_ITEM pARG, PHB_ITEM pSTK_ADDR, int CADDR ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);
if (type>10 ){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            hb_arraySetNI( pRows, i, (int) !( hb_itemGetNI( pARG22 ) ) );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               hb_arraySetNI( pCols, j, (int) !( hb_itemGetNI( pARG222 ) ) );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, j);
                  hb_arraySetNI( pPag, k, (int) !( hb_itemGetNI( pARG2222 ) ) );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int boolean_not(){
int sw=1;
if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if ( /*HB_IS_LOGICAL( pARG1 ) ||*/ HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      hb_arraySetNI( pSTK_ADDR, CADDR, (int) !( hb_itemGetNI( pARG1 ) ) );
   }else if( HB_IS_ARRAY( pARG1 ) ){
      ++CADDR;
      if(!(int) fun_boolean_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pSTK_ADDR, (int) CADDR )){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN NOT ARGUMENT ERROR",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "BOOLEAN NOT ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "BOOLEAN NOT STACK UNDERFLOW",102); 
}   
return sw;
}


int compare_bool_item(PHB_ITEM pSTK, PHB_ITEM pARG2, PHB_ITEM pARG1, int ndx, int tCompare){
int sw=1;
   switch( tCompare ){
      case 0:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetNI( pARG2 ) || hb_itemGetNI( pARG1 )) ); break;}
      case 1:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetNI( pARG2 ) && hb_itemGetNI( pARG1 )) ); break;}
      case 2:{
              int lArg1 = hb_itemGetNI( pARG1 );
              int lArg2 = hb_itemGetNI( pARG2 );
              hb_arraySetNI( pSTK, ndx, (int) ( (lArg1 && !lArg2) || (!lArg1 && lArg2)  ) ); 
              break;}
      case 3:{hb_arraySetNI( pSTK, ndx, (int) !(hb_itemGetNI( pARG2 ) || hb_itemGetNI( pARG1 )) ); break;}
      case 4:{hb_arraySetNI( pSTK, ndx, (int) !(hb_itemGetNI( pARG2 ) && hb_itemGetNI( pARG1 )) ); break;}
      default: sw=0;
   }
return sw;
}

int compare_bool_matrix_item( PHB_ITEM pSTK_ADDR, PHB_ITEM pARG2, PHB_ITEM pARG1, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
if (type>10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            //sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, i, (int) tCompare);
            sw=compare_bool_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, i, (int) tCompare);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               //sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG1, j, (int) tCompare);
               sw=compare_bool_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG1, j, (int) tCompare);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  //sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1, k, (int) tCompare);
                  sw=compare_bool_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1, k, (int) tCompare);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int compare_bool_matrix_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pARG2, PHB_ITEM pARG1, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
get_size( (PHB_ITEM) pARG1, &nDim1, &d11, &d12, &d13, &type1);
if (type>10 && d1==d11 && d2==d12 && d3==d13){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            //sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            sw=compare_bool_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               //sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               sw=compare_bool_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  //sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  sw=compare_bool_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int boolean_compare(/* int tCompare */){
int sw=1;
int tCompare = nPCP-125;
if ( CADDR >= 2 ){
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if ( /*(HB_IS_LOGICAL( pARG1 ) ||*/ HB_IS_NUMERIC( pARG1 ) && /*(HB_IS_LOGICAL( pARG2 ) ||*/ HB_IS_NUMERIC( pARG2 ) ){
      ++CADDR;
      if(!compare_bool_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG2 ) && (/*HB_IS_LOGICAL( pARG1 ) ||*/ HB_IS_NUMERIC( pARG1 ))){
      ++CADDR;
      if(!compare_bool_matrix_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }      
   }else if( HB_IS_ARRAY( pARG1 ) && ( /*HB_IS_LOGICAL( pARG2 ) || */HB_IS_NUMERIC( pARG2 )) ){
      PHB_ITEM pTEMP = pARG1;
      pARG1=pARG2;
      pARG2=pTEMP;
      ++CADDR;
      if(!compare_bool_matrix_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG2 ) && HB_IS_ARRAY( pARG1 ) ){
      ++CADDR;
      if(!compare_bool_matrix_matrix((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
   hb_itemRelease(pARG2);
}else{
   sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE STACK UNDERFLOW",102); 
}
return sw;
}

double min(double x, double y){
   return x<y?x:y;
}

double max(double x, double y){
   return x>y?x:y;
}

/* 
    COMPUTO BASICO Y COMPUTO BASICO ESPECIAL 
                                               */
/* COMPUTE ITEMS SINGLE CON OPCION A VARIABLE */
void fun_compute_add_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) + xu_funprecision(nARG2,PRECISION) : (nARG1 + nARG2 ) );
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) + xu_funprecision(nARG2,PRECISION) : (nARG1 + nARG2 ) ); 
}

void fun_compute_sub_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) - xu_funprecision(nARG2,PRECISION) : (nARG1 - nARG2 ) );
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) - xu_funprecision(nARG2,PRECISION) : (nARG1 - nARG2 ) );
}

void fun_compute_mul_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) * xu_funprecision(nARG2,PRECISION) : (nARG1 * nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) * xu_funprecision(nARG2,PRECISION) : (nARG1 * nARG2 ) ); 
}
void fun_compute_div_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}

void fun_compute_idiv_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetNL( pSTK_REG, PUSH_VAR, (long)   SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetNL( pSTK, ndx, (long)   SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}

void fun_compute_pow_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(pow(nARG1, nARG2),PRECISION) : pow(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(pow(nARG1, nARG2),PRECISION) : pow(nARG1, nARG2 ) ); 
}

void fun_compute_mod_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR,  (double) SW_PRECISION ? xu_funprecision(fmod(nARG1, nARG2),PRECISION) : fmod(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(fmod(nARG1, nARG2),PRECISION) : fmod(nARG1, nARG2 ) ); 
}

void fun_compute_round_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if( nARG2 ){
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) xu_funprecision(nARG1, nARG2 ) );
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) xu_funprecision(nARG1, nARG2 ) ); 
       }
   }else{
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (long) xu_funprecision(nARG1, 0 ) ); 
           PUSH_VAR=-1;
       }else{
           hb_arraySetNL( pSTK, ndx, (long) xu_funprecision(nARG1, 0 ) ); 
       }
   }
}
void fun_compute_max_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(max(nARG1, nARG2),PRECISION) : max(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(max(nARG1, nARG2),PRECISION) : max(nARG1, nARG2 ) ); 
}

void fun_compute_min_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(min(nARG1, nARG2),PRECISION) : min(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(min(nARG1, nARG2),PRECISION) : min(nARG1, nARG2 ) ); 
}

void fun_compute_gcd_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){

   if( nARG1>0 && nARG2>0 ){
       while (nARG1!=nARG2){
          if (nARG1>nARG2) nARG1=nARG1-nARG2;
          else     nARG2=nARG2-nARG1;
       }
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) : nARG1 ); 
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) : nARG1 ); 
       }
   }else{
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) 0.0 );
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) 0.0 ); // error: ambos deben ser positivos
       }
   }
}

void fun_compute_lcm_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   double w;
   if( nARG1>0 && nARG2>0 ){
       w=nARG1*nARG2;
       while (nARG1!=nARG2){
           if (nARG1>nARG2)   nARG1=nARG1-nARG2;
           else       nARG2=nARG2-nARG1;
       }
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(w/nARG1,PRECISION) : w/nARG1 ); 
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(w/nARG1,PRECISION) : w/nARG1 ); 
       }
   }else{
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) 0.0 );
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) 0.0 );  // error: ambos deben ser positivos
       }
   }
}


/* COMPUTE ITEMS */
void fun_compute_add(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) + xu_funprecision(nARG2,PRECISION) : (nARG1 + nARG2 ) ); 
}

void fun_compute_sub(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) - xu_funprecision(nARG2,PRECISION) : (nARG1 - nARG2 ) );
}

void fun_compute_mul(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) * xu_funprecision(nARG2,PRECISION) : (nARG1 * nARG2 ) ); 
}
void fun_compute_div(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}
void fun_compute_idiv(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetNL( pSTK, ndx, (long)   SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}
void fun_compute_pow(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(pow(nARG1, nARG2),PRECISION) : pow(nARG1, nARG2 ) ); 
}
void fun_compute_mod(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(fmod(nARG1, nARG2),PRECISION) : fmod(nARG1, nARG2 ) ); 
}
void fun_compute_round(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   //double prec = hb_itemGetND( pARG2 );
   if( nARG2 )
       hb_arraySetND( pSTK, ndx, (double) xu_funprecision(nARG1, nARG2 ) ); 
   else
       hb_arraySetNL( pSTK, ndx, (long) xu_funprecision(nARG1, 0 ) ); 
}
void fun_compute_max(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(max(nARG1, nARG2),PRECISION) : max(nARG1, nARG2 ) ); 
}
void fun_compute_min(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(min(nARG1, nARG2),PRECISION) : min(nARG1, nARG2 ) ); 
}
void fun_compute_gcd(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   //double x = hb_itemGetND( pARG1 );
   //double y = hb_itemGetND( pARG2 );
   if( nARG1>0 && nARG2>0 ){
       while (nARG1!=nARG2){
          if (nARG1>nARG2) nARG1=nARG1-nARG2;
          else     nARG2=nARG2-nARG1;
       }
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) : nARG1 ); 
   }else{
       hb_arraySetND( pSTK, ndx, (double) 0.0 ); // error: ambos deben ser positivos
   }
}

void fun_compute_lcm(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   double w;
//   double x = hb_itemGetND( nARG1 );
//   double y = hb_itemGetND( nARG2 );
   if( nARG1>0 && nARG2>0 ){
       w=nARG1*nARG2;
       while (nARG1!=nARG2){
           if (nARG1>nARG2)   nARG1=nARG1-nARG2;
           else       nARG2=nARG2-nARG1;
       }
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(w/nARG1,PRECISION) : w/nARG1 ); 
   }else{
       hb_arraySetND( pSTK, ndx, (double) 0.0 );  // error: ambos deben ser positivos
   }
}

struct {
   void (*p)(PHB_ITEM,double,double,int);
}funComputeItem_single[12] = { /*    0: */{fun_compute_add_single},
                               /*    1: */{fun_compute_sub_single},
                               /*    2: */{fun_compute_mul_single},
                               /*    3: */{fun_compute_div_single},
                               /*    4: */{fun_compute_idiv_single},
                               /*    5: */{fun_compute_pow_single},
                               /*    6: */{fun_compute_mod_single},
                               /*    7: */{fun_compute_round_single},
                               /*    8: */{fun_compute_max_single},
                               /*    9: */{fun_compute_min_single},
                               /*   10: */{fun_compute_gcd_single},
                               /*   11: */{fun_compute_lcm_single}
                             };

struct {
   void (*p)(PHB_ITEM,double,double,int);
}funComputeItem[12] = { /*    0: */{fun_compute_add},
                        /*    1: */{fun_compute_sub},
                        /*    2: */{fun_compute_mul},
                        /*    3: */{fun_compute_div},
                        /*    4: */{fun_compute_idiv},
                        /*    5: */{fun_compute_pow},
                        /*    6: */{fun_compute_mod},
                        /*    7: */{fun_compute_round},
                        /*    8: */{fun_compute_max},
                        /*    9: */{fun_compute_min},
                        /*   10: */{fun_compute_gcd},
                        /*   11: */{fun_compute_lcm}
                        };

/* COMPUTE MATRIX-ITEM */

int fun_compute_matrix_item_1d(double nARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d2=d2+d3;  // basura!
    PHB_ITEM pRows  = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for (i=1; i<=d1; i++ ){
        PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
        double nARG11 = hb_itemGetND( pARG11 );
        //compute_item((PHB_ITEM) pRows, (PHB_ITEM) pARG11, (PHB_ITEM) pARG2, i, (int) tCompare);
        (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pRows,(double) nARG11,(double) nARG2, i );
        hb_itemRelease(pARG11);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);

return sw;
}

int fun_compute_matrix_item_2d(double nARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d3=d3+0;
    PHB_ITEM pRows = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for( i=1; i<=d1; i++){
        PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
        PHB_ITEM pCols = hb_itemArrayNew( d2 );
        HB_MAXINT j;
        for( j=1; j<=d2; j++){
            PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
            double nARG111 = hb_itemGetND( pARG111 );
            //compute_item((PHB_ITEM) pCols, (PHB_ITEM) pARG111, (PHB_ITEM) pARG2, j, (int) tCompare);
            (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pCols, (double)nARG111, (double)nARG2, j );
            hb_itemRelease(pARG111);
        }
        hb_arraySet( pRows, i, pCols );
        hb_itemRelease(pARG11);
        hb_itemRelease(pCols);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);

return sw;
}

int fun_compute_matrix_item_3d(double nARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for(i=1; i<=d1; i++){
        PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
        PHB_ITEM pARGF = hb_itemArrayGet( pARG1, i);
        HB_MAXINT j;
        for(j=1; j<=d2; j++){
             PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
             PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
             HB_MAXINT k;
             for(k=1; k<=d3; k++){
                 PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                 double nARGP = hb_itemGetND( pARGP );
                 //compute_item((PHB_ITEM) pARRAYP, (PHB_ITEM) pARGP, (PHB_ITEM) pARG2, k, (int) tCompare);
                 (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pARRAYP,(double) nARGP,(double) nARG2, k );
                 hb_itemRelease(pARGP);
             }
             hb_arraySet(pARRAYC, j, pARRAYP);
             hb_itemRelease(pARRAYP);
             hb_itemRelease(pARGC);
        }
        hb_arraySet(pARRAY, i, pARRAYC);
        hb_itemRelease(pARRAYC);
        hb_itemRelease(pARGF);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, (PHB_ITEM) pARRAY );
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    }
    //hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    hb_itemRelease(pARRAY);
return sw;
}

struct {
   int (*p)(double,PHB_ITEM,HB_MAXINT,HB_MAXINT,HB_MAXINT,int);
}funComputeMatrixItem[3] = {/*    0: */{fun_compute_matrix_item_1d},
                            /*    1: */{fun_compute_matrix_item_2d},
                            /*    2: */{fun_compute_matrix_item_3d}};

int compute_matrix_item(PHB_ITEM pARG1, double nARG2, int tCompare){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
   if (type==11){
       sw = (int)(*funComputeMatrixItem[nDim-1].p)((double) nARG2, (PHB_ITEM) pARG1, d1,d2,d3, tCompare);
   }else{
       sw=0;
   }
return sw;
}

/* COMPUTE ITEM-MATRIX */

int fun_compute_item_matrix_1d(PHB_ITEM pARG2, double nARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d2=d2+d3;  // basura!
    PHB_ITEM pRows  = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for (i=1; i<=d1; i++ ){
        PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
        double nARG2 = hb_itemGetND( pARG22 );
        //compute_item((PHB_ITEM) pRows, (PHB_ITEM) pARG1, (PHB_ITEM) pARG22, i, (int) tCompare);
        (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pRows, (double) nARG1, (double) nARG2, i );
        hb_itemRelease(pARG22);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_item_matrix_2d(PHB_ITEM pARG2, double nARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d3=d3+0;  // basura!
    PHB_ITEM pRows = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for( i=1; i<=d1; i++){
        PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
        PHB_ITEM pCols = hb_itemArrayNew( d2 );
        HB_MAXINT j;
        for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               double nARG2 = hb_itemGetND( pARG222 );
               //compute_item((PHB_ITEM) pCols, (PHB_ITEM) pARG1, (PHB_ITEM) pARG222, j, (int) tCompare);
               (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pCols, (double) nARG1, (double) nARG2, j );
               hb_itemRelease(pARG222);
        }
        hb_arraySet( pRows, i, pCols );
        hb_itemRelease(pARG22);
        hb_itemRelease(pCols);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_item_matrix_3d(PHB_ITEM pARG2, double nARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for(i=1; i<=d1; i++){
        PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
        PHB_ITEM pARGF = hb_itemArrayGet( pARG2, i);
        HB_MAXINT j;
        for(j=1; j<=d2; j++){
            PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
            PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
            HB_MAXINT k;
            for(k=1; k<=d3; k++){
                     PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                     double nARG2 = hb_itemGetND( pARGP );
                     //compute_item((PHB_ITEM) pARRAYP, (PHB_ITEM) pARG1, (PHB_ITEM) pARGP, k, (int) tCompare);
                     (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pARRAYP, (double) nARG1, (double) nARG2, k );
                     hb_itemRelease(pARGP);
            }
            hb_arraySet(pARRAYC, j, pARRAYP);
            hb_itemRelease(pARRAYP);
            hb_itemRelease(pARGC);
        }
        hb_arraySet(pARRAY, i, pARRAYC);
        hb_itemRelease(pARRAYC);
        hb_itemRelease(pARGF);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, (PHB_ITEM) pARRAY );
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    }
    //hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    hb_itemRelease(pARRAY);

return sw;
}

struct {
   int (*p)(PHB_ITEM,double,HB_MAXINT,HB_MAXINT,HB_MAXINT,int);
}funComputeItemMatrix[3] = {/*    0: */{fun_compute_item_matrix_1d},
                            /*    1: */{fun_compute_item_matrix_2d},
                            /*    2: */{fun_compute_item_matrix_3d}};


int compute_item_matrix(double nARG1, PHB_ITEM pARG2, int tCompare){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   if( type == 11 ){
       sw = (int)(*funComputeItemMatrix[nDim-1].p)((PHB_ITEM) pARG2, (double) nARG1, d1,d2,d3, tCompare);
   }else{
      sw=0;
   }
return sw;
}

/* COMPUTE MATRIX-MATRIX */

int fun_compute_matrix_matrix_1d(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d2=d2+d3;  // basura!
    PHB_ITEM pRows  = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            double nARG22 = hb_itemGetND( pARG22 );
            double nARG11 = hb_itemGetND( pARG11 );
            //compute_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pRows, (double)nARG22, (double)nARG11, i );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_matrix_matrix_2d(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d3=d3+0;  // basura!
    PHB_ITEM pRows = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for( i=1; i<=d1; i++){
        PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
        PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
        PHB_ITEM pCols = hb_itemArrayNew( d2 );
        HB_MAXINT j;
        for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               double nARG222 = hb_itemGetND( pARG222 );
               double nARG111 = hb_itemGetND( pARG111 );
               //compute_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pCols, (double)nARG222, (double)nARG111, j );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
        }
        hb_arraySet( pRows, i, pCols );
        hb_itemRelease(pARG22);
        hb_itemRelease(pARG11);
        hb_itemRelease(pCols);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_matrix_matrix_3d(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
   HB_MAXINT i;
   for(i=1; i<=d1; i++){
       PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
       PHB_ITEM pREGF2 = hb_itemArrayGet( pARG2, i);      // saco fila de primer item
       PHB_ITEM pREGF1 = hb_itemArrayGet( pARG1, i);      // saco fila de segundo item
       HB_MAXINT j;
       for(j=1; j<=d2; j++){
           PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
           PHB_ITEM pREGC1 = hb_itemArrayGet( pREGF1, j);     // columna del registro
           PHB_ITEM pREGC2 = hb_itemArrayGet( pREGF2, j);     // columna del registro
           HB_MAXINT k;
           for(k=1; k<=d3; k++){
                     PHB_ITEM pREGP1 = hb_itemArrayGet( pREGC1, k);
                     PHB_ITEM pREGP2 = hb_itemArrayGet( pREGC2, k);
                     double nREGP1 = hb_itemGetND( pREGP1 );
                     double nREGP2 = hb_itemGetND( pREGP2 );
                     //compute_item((PHB_ITEM) pARRAYP, (PHB_ITEM) pREGP2, (PHB_ITEM) pREGP1, k, (int) tCompare);
                     (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pARRAYP, (double)nREGP2, (double)nREGP1, k );
                     hb_itemRelease(pREGP1);
                     hb_itemRelease(pREGP2);
           }
           hb_arraySet(pARRAYC, j, pARRAYP);
           hb_itemRelease(pARRAYP);
           hb_itemRelease(pREGC1);
           hb_itemRelease(pREGC2);
       }
       hb_arraySet(pARRAY, i, pARRAYC);
       hb_itemRelease(pARRAYC);
       hb_itemRelease(pREGF2);
       hb_itemRelease(pREGF1);
   }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, (PHB_ITEM) pARRAY );
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    }
   //hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
   hb_itemRelease(pARRAY);
return sw;
}

struct {
   int (*p)(PHB_ITEM,PHB_ITEM,HB_MAXINT,HB_MAXINT,HB_MAXINT,int);
}funComputeMatrixMatrix[3] = {/*    0: */{fun_compute_matrix_matrix_1d},
                              /*    1: */{fun_compute_matrix_matrix_2d},
                              /*    2: */{fun_compute_matrix_matrix_3d}
                              };
                            

int compute_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1,int tCompare){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
HB_MAXINT nDim1=0,d11=0,d21=0,d31=0,type1=0;
get_size( (PHB_ITEM) pARG2, &nDim1, &d11, &d21, &d31, &type1);
   
if ( type==11 && type1==type && nDim == nDim1 && d1==d11 && d2==d21 && d3==d31){
   sw = (int)(*funComputeMatrixMatrix[nDim-1].p)((PHB_ITEM) pARG2, (PHB_ITEM) pARG1, d1,d2,d3, tCompare);
}else{
   sw=0;
}
return sw;
}


int computo_especial(){
//"divby"=>257, "idivby"=>258,"powby"=>259,"modit"=>260,"subit"=>261,"addit"=>262,"mulit"=>263
int sw=1;
int tCompare = nPCP!=277 ? nPCP-257: 7;
static int Compare[8]={3,4,5,6,1,0,2,7};

if(CADDR>=1){

  /// if( tCompare==277) tCompare=7; // round by
   
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pARG2  = hb_itemArrayGet( pSTK_REG, nReg);
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   
   CADDR += SWKEEP; SWKEEP = 0;
   if(PUSH_VAR==-1) ++CADDR;
   
   if( HB_IS_NUMERIC( pARG1 ) ){
      double nARG1 = hb_itemGetND( pARG1 );
      if( HB_IS_NUMERIC( pARG2 ) ) {   // operacion normal
         double nARG2 = hb_itemGetND( pARG2 );
         
         (void)(*funComputeItem_single[Compare[tCompare]].p)( (PHB_ITEM)pSTK_ADDR, (double)nARG1, (double)nARG2, CADDR );
         //compute_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, Compare[tCompare]);  //OK

      }else if( HB_IS_ARRAY( pARG2 ) ){   // operacion escalar numerico - ARRAY
         //++CADDR;
         if (!compute_item_matrix((double) nARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) Compare[tCompare])){
            sw=put_error((PHB_ITEM) pRET, "(1)COMPUTE-ESP INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
         }
      }else{
         // combinacion no coincide.
         sw=put_error((PHB_ITEM) pRET, "COMPUTE-ESP INVALID ARGUMENT ERROR",103); 
      }
   }else if( HB_IS_ARRAY( pARG1 ) ){   // operando 1 es array; op 2 escalar. izq->der, ARG2 op ARG1
      if( HB_IS_ARRAY( pARG2 ) ){    // operando 2 es array
         //++CADDR;   
         if( !compute_matrix_matrix((PHB_ITEM) pARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) Compare[tCompare]) ){
            sw=put_error((PHB_ITEM) pRET, "(2)COMPUTE-ESP(ARRAY-NUM ? ARRAY-NUM) NOT ENOUGHT MEMORY",100);
         }
      }else{                           // operando 1 es escalar
         // array  escalar
         if( HB_IS_NUMERIC( pARG2 ) ){   // MATRIZ num op escalar num. div, idiv, pow y mod son diferentes. Resto, igual
            double nARG2 = hb_itemGetND( pARG2 );
            //++CADDR;
            if (!compute_matrix_item((PHB_ITEM) pARG1, (double) nARG2, /*(PHB_ITEM) pSTK_ADDR,*/ (int) Compare[tCompare])){
               sw=put_error((PHB_ITEM) pRET, "(3)COMPUTE-ESP INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "COMPUTE-ESP INVALID ARGUMENT ERROR",103); 
         }
      }
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "COMPUTE-ESP STACK UNDERFLOW(1)",102);
}
return sw;
}
int computo(/*int tCompare*/){
int sw=1;
int tCompare;
if( nPCP==343 || nPCP == 344 ) tCompare = nPCP-333; // dejo 10 y 11 para gcd y para lcm!
else tCompare = nPCP-40;
if ( CADDR >= 2 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 1
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   
   CADDR += SWKEEP; SWKEEP = 0;
   if(PUSH_VAR==-1) ++CADDR;
      /* evalua POSTFIX */  
/*      if(SW_POSTFIX){    // está dentro de #MATH: invierte operandos.
         PHB_ITEM TMP = pARG1;
         pARG1 = pARG2;
         pARG2 = TMP;
      }*/
      /******************/ 
   // chequear el tipo, y evaluar. Por ahora: numeros
   if( HB_IS_NUMERIC( pARG1 ) ){
      double nARG1 = hb_itemGetND( pARG1 );
      if( HB_IS_NUMERIC( pARG2 ) ) {   // operacion normal
         double nARG2 = hb_itemGetND( pARG2 );
         //if(PUSH_VAR==-1) ++CADDR;
         (void)(*funComputeItem_single[tCompare].p)( (PHB_ITEM)pSTK_ADDR, (double)nARG1, (double)nARG2, CADDR );
         //compute_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, tCompare);  //OK

      }else if( HB_IS_ARRAY( pARG2 ) ){   // operacion escalar numerico - ARRAY
         //++CADDR;
         if (!compute_item_matrix((double) nARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) tCompare)){
            sw=put_error((PHB_ITEM) pRET, "(1)COMPUTE INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
         }
      }else{
         // combinacion no coincide.
         sw=put_error((PHB_ITEM) pRET, "COMPUTE INVALID ARGUMENT ERROR",103); 
      }
   }else if( HB_IS_ARRAY( pARG1 ) ){   // operando 1 es array; op 2 escalar. izq->der, ARG2 op ARG1
      if( HB_IS_ARRAY( pARG2 ) ){    // operando 2 es array
         //++CADDR;   
         if( !compute_matrix_matrix((PHB_ITEM) pARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) tCompare) ){
            sw=put_error((PHB_ITEM) pRET, "(2)COMPUTE(ARRAY-NUM ? ARRAY-NUM) NOT ENOUGHT MEMORY",100);
         }
      }else{                           // operando 1 es escalar
         // array  escalar
         if( HB_IS_NUMERIC( pARG2 ) ){   // MATRIZ num op escalar num. div, idiv, pow y mod son diferentes. Resto, igual
            double nARG2 = hb_itemGetND( pARG2 );
            //++CADDR;
            if (!compute_matrix_item((PHB_ITEM) pARG1, (double) nARG2, /*(PHB_ITEM) pSTK_ADDR,*/ (int) tCompare)){
               sw=put_error((PHB_ITEM) pRET, "(3)COMPUTE INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "COMPUTE INVALID ARGUMENT ERROR",103); 
         }
      }
      
   }else{
      sw=put_error((PHB_ITEM) pRET, "COMPUTE ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "COMPUTE STACK UNDERFLOW(2)",102); 
}
return sw;
}

int logicalEmpty_matrix(PHB_ITEM pARG2, /*PHB_ITEM pSTK_ADDR,*/ HB_MAXINT nDim, 
                        HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            hb_arraySetNI( (PHB_ITEM) pRows, i, (int) (! hb_itemGetCLen( pARG22 )) );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               hb_arraySetNI( (PHB_ITEM) pCols, j, (int) (! hb_itemGetCLen( pARG222 )) );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  hb_arraySetNI( (PHB_ITEM) pPag, k, (int) (! hb_itemGetCLen( pARG2222 )) );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

//int logicalEmpty( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int logicalEmpty(){
int sw=1;

   if( CADDR ){
      PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);

      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG1 )){
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (! hb_itemGetCLen( pARG1 )) );
      }else if( HB_IS_ARRAY( pARG1 ) ){
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
         get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
         if(type==10){
            ++CADDR;
            sw=(int)logicalEmpty_matrix((PHB_ITEM) pARG1, /*(PHB_ITEM) pSTK_ADDR,*/ (HB_MAXINT) nDim, 
                                        (HB_MAXINT) d1, (HB_MAXINT) d2, (HB_MAXINT) d3);
         }else{
            sw=put_error((PHB_ITEM) pRET, "EMPTY ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "EMPTY ARGUMENT ERROR",103);
      }
      hb_itemRelease(pARG1);
   }else{
      sw=put_error((PHB_ITEM) pRET, "EMPTY STACK UNDERFLOW",102); 
   }
return sw;
}

/* obtiene los primeros N elementos positivos desde cualquier array, y devuelve un array 
   Usos:
   [1:100] getpositive(v)  dejará los primeros 100 positivos que encuentre en v
   [1000] getpositive(v)   dejará el elemento #1000 positivo en v
   [1000] getpositive(-1)  dejará el elemento #1000 positivo en el stack, y así para los arrays
*/

PHB_ITEM fun_getNegativeItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){//, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)<0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)<0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonZeroItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){//, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)!=0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)!=0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonVoidItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){//, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }

   nTotal = get_length(nIni,nFin,1);
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_STRING(pROW)){
               if(strlen( hb_itemGetCPtr(pROW) )>0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_STRING(pROW)){
               if(strlen( hb_itemGetCPtr(pROW) )>0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}


PHB_ITEM fun_getPositiveItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){ //, unsigned int d2, unsigned int d3){

   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)>0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)>0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getPositiveItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)>0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)>0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNegativeItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   ///printf("nTOTAL = %d\n",nTotal); fflush(stdout);
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)<0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)<0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonZeroItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)!=0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)!=0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonVoidItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
   if( nTotal>1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_STRING(pCOL)){
                   if(strlen( hb_itemGetCPtr(pCOL) )>0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_STRING(pCOL)){
                   if(strlen( hb_itemGetCPtr(pCOL) )>0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

struct {
   PHB_ITEM (*p)(PHB_ITEM,unsigned int,int*); //,unsigned int,unsigned int);
}funGetPorcion1d[4] = { /*    0: */{fun_getPositiveItems1d},
                        /*    1: */{fun_getNegativeItems1d},
                        /*    2: */{fun_getNonZeroItems1d},
                        /*    3: */{fun_getNonVoidItems1d}
                      };

struct {
   PHB_ITEM (*p)(PHB_ITEM,unsigned int,unsigned int,int*); //,unsigned int,unsigned int);
}funGetPorcion2d[4] = { /*    0: */{fun_getPositiveItems2d},
                        /*    1: */{fun_getNegativeItems2d},
                        /*    2: */{fun_getNonZeroItems2d},
                        /*    3: */{fun_getNonVoidItems2d}
                      };

int fun_getsomething(){
int sw=1;

if (CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTarget = hb_itemArrayGet( pSTK_REG, nItem );

   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--);

   CADDR += SWKEEP; SWKEEP = 0;

   int esAbstracta = hb_itemGetNInt(pTarget);
   int tCompare = nPCP-394;
   
   if (HB_IS_ARRAY(pSource)){ //  es array: puedo proseguir
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
      PHB_ITEM pRESULT = NULL;
      
      switch(nDim){
          case 1: {pRESULT = (PHB_ITEM)(*funGetPorcion1d[tCompare].p)(pSource,d1,&sw); break;}
          case 2: {pRESULT = (PHB_ITEM)(*funGetPorcion2d[tCompare].p)(pSource,d1,d2,&sw); break;}
          //case 3: {pRESULT = (PHB_ITEM)(*funGetPorcion3d[tCompare].p)(pSource,nDim,d1,d2,d3); break;}
      }
      if ( sw ){
          if (hb_arrayLen(pRESULT) == 1){
              if (esAbstracta!=-1){ // meto en pSTK_REG
                  put_value(pSTK_REG, pRESULT, nItem, PRECISION);
              }else{  // meto en pSTK_ADDR
                  put_value(pSTK_ADDR, pRESULT, ++CADDR, PRECISION);
              }          
          }else{      
              if (esAbstracta!=-1){ // meto en pSTK_REG
                  hb_arraySet(pSTK_REG, nItem, pRESULT);
              }else{  // meto en pSTK_ADDR
                  hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
              }
          }
          hb_itemRelease(pRESULT);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET SOMETHING ARRAY ARGUMENT ERROR",103);
   }
   hb_itemRelease(pTarget);hb_itemRelease(pSource);
}else{
   sw=put_error((PHB_ITEM) pRET, "GET SOMETHING STACK UNDERFLOW",102);
}
return sw;
}


int fun_compact(){
int sw=1;
if(CADDR){
   PHB_ITEM pSOUR = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pSOUR, &nDim, &d1, &d2, &d3, &type);
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pROW = hb_itemArrayGet( pSOUR, i);
            if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)!=0.0)
                  hb_arrayAdd(pRESULT, pROW);
            }else if(HB_IS_STRING(pROW)){
               if(hb_itemGetCLen(pROW)>0)
                  hb_arrayAdd(pRESULT, pROW);
           /* }else if(HB_IS_LOGICAL(pROW)){
               if(hb_itemGetL(pROW))
                  hb_arrayAdd(pRESULT, pROW);*/
            }
            hb_itemRelease(pROW);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pROW = hb_itemArrayGet( pSOUR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                  if(hb_itemGetND(pCOL)!=0.0)
                     hb_arrayAdd(pRESULT, pCOL);
               }else if(HB_IS_STRING(pCOL)){
                  if(hb_itemGetCLen(pCOL)>0)
                     hb_arrayAdd(pRESULT, pCOL);
              /* }else if(HB_IS_LOGICAL(pCOL)){
                  if(hb_itemGetL(pCOL))
                     hb_arrayAdd(pRESULT, pCOL);*/
               }
               hb_itemRelease(pCOL);
            }
            hb_itemRelease(pROW);
         }
         break;
      }case 3:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pROW = hb_itemArrayGet( pSOUR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pPAG = hb_itemArrayGet( pCOL, k);
                  if(HB_IS_NUMERIC(pPAG)){
                     if(hb_itemGetND(pPAG)!=0.0)
                        hb_arrayAdd(pRESULT, pPAG);
                  }else if(HB_IS_STRING(pPAG)){
                     if(hb_itemGetCLen(pPAG)>0)
                        hb_arrayAdd(pRESULT, pPAG);
                 /* }else if(HB_IS_LOGICAL(pPAG)){
                     if(hb_itemGetL(pPAG))
                        hb_arrayAdd(pRESULT, pPAG);*/
                  }
                  hb_itemRelease(pPAG);
               }
               hb_itemRelease(pCOL);
            }
            hb_itemRelease(pROW);
         }
         break;
      }default:{
         sw=0;
      }
   }
   hb_itemRelease(pSOUR);
   if ( PUSH_VAR != -1 ){
      hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
      PUSH_VAR=-1;
   }else{
      hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
   }
   hb_itemRelease(pRESULT);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "COMPACT STACK UNDERFLOW",102);
}
return sw;
}


/****************************************************
    FUNCIONES DE SISTEMA, FUNCIONES INTERNAS
 ****************************************************/

int fun_exec(){
int sw=1;
if(CADDR>=1){
   SW_PUNTERO=0;   // RESETEO PUNTERO, POR SI EL PROGRAMADOR SACOHUEA SE EQUIVOCO
   
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pSource ) ){

        // procesar:
      HB_MAXINT nLen = hb_itemGetCLen( pSource );
      char * s = (char*) calloc( nLen + 100, 1 );  // era 43
      const char * execstr = hb_itemGetCPtr( pSource );
      memcpy( s, execstr, nLen );
      s[nLen]='\0';
      
      if(nPCP==188){  // ejecuta y devuelve resutado      
        // generar nombre de archivo temporal:
         srand(time(NULL));
         long numrand = 10000 + rand() % (100000001 - 10000);
         char tmpFile[100];
         int ltmpf = sprintf(tmpFile," > /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
         tmpFile[ltmpf]='\0';

         memcpy( s + nLen, tmpFile, ltmpf ); 
         //memcpy( s + nLen, " > /tmp/tmpmacroMurrayfile000000000000.tmp", 42 ); 
      
         const char * t=s;
   
         int ret = system(t);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC CHILD TERMINATED",102);
         }
         free(s);
         if (sw){
            FILE *fp;
            char ch;
   
            //if( (fp=fopen("/tmp/tmpmacroMurrayfile000000000000.tmp","r"))!=NULL ){
            ltmpf = sprintf(tmpFile,"/tmp/tmpmacroMurrayfile%ld.tmp",numrand);
            tmpFile[ltmpf]='\0';
            if( (fp=fopen(tmpFile,"r"))!=NULL ){
               fseek(fp, 0L, SEEK_END);
               long int nFinalPos  = ftell( fp ) ;
       
               rewind( fp );
               fseek( fp, 0L, SEEK_CUR) ;

               char * output = (char *)calloc(nFinalPos + 2, 1);
               if( output ){
                  long int i=0;
                  while ((ch = fgetc(fp)) != EOF){
                     output[i++] = ch;
                  }
                  output[i] = '\0';
                  const char * cbuffer = output;
                  hb_arraySetC( pSTK_ADDR, ++CADDR, cbuffer );
                  free(output);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC NOT ENOUGH MEMORY",100);
               }
               fclose(fp);
              // rm file:
               int ltmpf = sprintf(tmpFile,"rm /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
               tmpFile[ltmpf]='\0';
               int ret = system(tmpFile);
               if (WIFSIGNALED(ret) &&
                  (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
                  sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC CHILD TERMINATED",102);
               }
               //system("rm /tmp/tmpmacroMurrayfile000000000000.tmp");
            }else{
               sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC TEMPFILE CREATION ERROR",107);
            }
         }
      }else{   // 198: ejecuta nada más: no devuelve nada
         const char * t=s;
         int ret = system(t);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV CHILD TERMINATED",102);
         }
         free(s);
      }
   
   }else if (HB_IS_ARRAY( pSource )){  // solo puede ser un array de strings
      if(nPCP!=188){ 
         int i;
         HB_MAXINT nLen = hb_arrayLen( pSource );
         for (i=1; i<=nLen; i++){
            PHB_ITEM pELEM = hb_itemArrayGet( pSource, i);
            if( HB_IS_STRING( pELEM ) ){
               const char * execstr = hb_itemGetCPtr( pELEM );
               int ret = system(execstr);
               if (WIFSIGNALED(ret) &&
                  (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
                  sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV CHILD TERMINATED",102);
                  hb_itemRelease(pELEM);
                  break;
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV ARGUMENT ARRAY NOT STRING ERROR",103);
               hb_itemRelease(pELEM);
               break;
            }
            hb_itemRelease(pELEM);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV ARGUMENT ARRAY ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC|EXECV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pSource );
}else{
   sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC|EXECV INNER-STACK UNDERFLOW",102);
}
return sw;
}

//int LetMacro(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pRET){//,
int LetMacro( /*long nARGr, long nARGs */){
int sw=1;
   
   SW_PUNTERO=0;   // RESETEO PUNTERO, POR SI EL PROGRAMADOR SACOHUEA SE EQUIVOCO
   long nARGr = STK_PRG[ ++CP ];
   long nARGs = STK_PRG[ ++CP ];
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
   
  // generar nombre de archivo temporal:
   srand(time(NULL));
   long numrand = 10000 + rand() % (100000001 - 10000);
   char tmpFile[100];
   int ltmpf = sprintf(tmpFile," > /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
   tmpFile[ltmpf]='\0';
  // procesar:

   HB_MAXINT nLen = hb_itemGetCLen( pSource );
   char * s = (char*) calloc( nLen + 43, 1 );
   const char * execstr = hb_itemGetCPtr( pSource );
   memcpy( s, execstr, nLen );
   memcpy( s + nLen, tmpFile, ltmpf );
   //memcpy( s + nLen, " > /tmp/tmpmacroMurrayfile000000000000.tmp", 42 ); 
   const char * t=s;
   
   int ret = system(t);
   if (WIFSIGNALED(ret) &&
      (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
      sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` CHILD TERMINATED",102);
   }
   free(s);
   if(sw){
      FILE *fp;
      char ch;
      ltmpf = sprintf(tmpFile,"/tmp/tmpmacroMurrayfile%ld.tmp",numrand);
      tmpFile[ltmpf]='\0';
      if( (fp=fopen(tmpFile,"r"))!=NULL ){
      //if( (fp=fopen("/tmp/tmpmacroMurrayfile000000000000.tmp","r"))!=NULL ){
         fseek(fp, 0L, SEEK_END);
         long int nFinalPos  = ftell( fp ) ;
      
         rewind( fp );
         fseek( fp, 0L, SEEK_CUR) ;

         char * output = (char *)calloc(nFinalPos + 2, 1);
         if( output ){
            long int i=0;
            while ((ch = fgetc(fp)) != EOF){
               output[i++] = ch;
            }
            output[i] = '\0';
            const char * cbuffer = output;
            hb_arraySetC( pSTK_REG, nARGr, cbuffer );
            free(output);
         }else{
            sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` NOT ENOUGH MEMORY",100);
         }
         fclose(fp);
         // rm file:
         ltmpf = sprintf(tmpFile,"rm /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
         tmpFile[ltmpf]='\0';
//         system(tmpFile);
         int ret = system(tmpFile);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` CHILD TERMINATED",102);
         }
         ///system("rm /tmp/tmpmacroMurrayfile000000000000.tmp");
      }else{
         sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` TEMPFILE CREATION ERROR",107);
      }
   }
   hb_itemRelease( pSource );
   return sw;
}

int put_precision( /*unsigned int nARG, int tCompare*/){
int sw=1;
int tCompare = nPCP;
   //PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_PRG, ++CP);
   unsigned int nARG=(unsigned int)STK_PRG[++CP];
   PHB_ITEM pPREC = NULL;
   switch( tCompare ){
      case 204: {
         pPREC = hb_itemArrayGet( pSTK_REG, nARG );//hb_itemGetNInt( pARG1 ));
         PRECISION = (unsigned) hb_itemGetNInt( pPREC );
         SW_PRECISION=1;
         if( PRECISION>15 /*|| PRECISION<0*/ ) SW_PRECISION=0;
         break;
      }case 215: {
         pPREC = hb_itemArrayGet( pSTK_DS, nARG );//hb_itemGetNInt( pARG1 ));
         PRECISION = (unsigned) hb_itemGetNInt( pPREC );
         SW_PRECISION=1;
         if( PRECISION>15 /*|| PRECISION<0*/ ) SW_PRECISION=0;
         break;
/*      }default: {
         *PRECISION = nARG;  //(unsigned) hb_itemGetNInt( pARG1 );
         SW_PRECISION=1;
         if( *PRECISION>=10 || *PRECISION<0 ) SW_PRECISION=0; */
      }
   }
   hb_itemRelease(pPREC);
//   hb_itemRelease(pARG1);
return sw;
}

/* Con estas coordenadas, se accederá a los datos de los arrays con GET y PUT.
   Con cada seteo, se realzan los cálculos */
int fun_cartesian(){
int sw=1;
if(CADDR>=1){
   PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_ARRAY(pARG)){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);
//      if(type>=11){  // numericos y logicos
         switch(nDim){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( 0 ); // creo array ajustado a los rangos.
               int i;
               int nSize=0;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pELEM = hb_itemArrayGet( pARG, i);
                  /*if(HB_IS_LOGICAL(pELEM)){
                     if(hb_itemGetL(pELEM)){
                        hb_arraySize(pRows, ++nSize);
                        hb_arraySetNI(pRows, nSize, i);
                     }
                  }else */if(HB_IS_NUMERIC(pELEM)){
                     double vonD = hb_itemGetND(pELEM);
                     if(vonD!=0 && !isnan(vonD) && !isinf(vonD)){
                     ////if(hb_itemGetND(pELEM)!=0){
                        hb_arraySize(pRows, ++nSize);
                        hb_arraySetNI(pRows, nSize, i);
                     }
                  }else if(HB_IS_STRING(pELEM)){
                     if(hb_itemGetCLen(pELEM)>0){
                        hb_arraySize(pRows, ++nSize);
                        hb_arraySetNI(pRows, nSize, i);
                     }
                  }
                  hb_itemRelease(pELEM);
               }
               hb_arraySet(pSTK_ADDR, ++CADDR, pRows);
               hb_itemRelease(pRows);
               break;               
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( 0 );
               int i;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pARG, i);
                  
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pELEM = hb_itemArrayGet( pARGF, j);
                    /* if(HB_IS_LOGICAL(pELEM)){
                        if(hb_itemGetL(pELEM)){
                           PHB_ITEM pCols = hb_itemArrayNew( 2 );
                           hb_arraySetNI(pCols, 1, i);
                           hb_arraySetNI(pCols, 2, j);
                           hb_arrayAdd( pRows, pCols );
                           hb_itemRelease(pCols);
                        }
                     }else */if(HB_IS_NUMERIC(pELEM)){
                        double vonD = hb_itemGetND(pELEM);
                        if(vonD!=0 && !isnan(vonD) && !isinf(vonD)){
                        ////if(hb_itemGetND(pELEM)!=0){
                           PHB_ITEM pCols = hb_itemArrayNew( 2 );
                           hb_arraySetNI(pCols, 1, i);
                           hb_arraySetNI(pCols, 2, j);
                           hb_arrayAdd( pRows, pCols );
                           hb_itemRelease(pCols);
                        }
                     }else if(HB_IS_STRING(pELEM)){
                        if(hb_itemGetCLen(pELEM)>0){
                           PHB_ITEM pCols = hb_itemArrayNew( 2 );
                           hb_arraySetNI(pCols, 1, i);
                           hb_arraySetNI(pCols, 2, j);
                           hb_arrayAdd( pRows, pCols );
                           hb_itemRelease(pCols);
                        }
                     }
                     hb_itemRelease(pELEM);
                  }
                  hb_itemRelease(pARGF);
               }
               hb_arraySet(pSTK_ADDR, ++CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( 0 );
               int i;
               for(i=1; i<=d1; i++){

                  PHB_ITEM pARGF = hb_itemArrayGet( pARG, i);
                  int j;
                  for(j=1; j<=d2; j++){
                     
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k;
                     for(k=1; k<=d3; k++){
                        PHB_ITEM pELEM = hb_itemArrayGet( pARGC, k);
                       /* if(HB_IS_LOGICAL(pELEM)){
                           if(hb_itemGetL(pELEM)){
                              PHB_ITEM pCols = hb_itemArrayNew( 3 );
                              hb_arraySetNI(pCols, 1, i);
                              hb_arraySetNI(pCols, 2, j);
                              hb_arraySetNI(pCols, 3, k);
                              hb_arrayAdd( pRows, pCols );
                              hb_itemRelease(pCols);
                           }
                        }else */if(HB_IS_NUMERIC(pELEM)){
                           double vonD = hb_itemGetND(pELEM);
                           if(vonD!=0 && !isnan(vonD) && !isinf(vonD)){
                           ////if(hb_itemGetND(pELEM)!=0){
                              PHB_ITEM pCols = hb_itemArrayNew( 3 );
                              hb_arraySetNI(pCols, 1, i);
                              hb_arraySetNI(pCols, 2, j);
                              hb_arraySetNI(pCols, 3, k);
                              hb_arrayAdd( pRows, pCols );
                              hb_itemRelease(pCols);
                           }
                        }else if(HB_IS_STRING(pELEM)){
                           if(hb_itemGetCLen(pELEM)>0){
                              PHB_ITEM pCols = hb_itemArrayNew( 3 );
                              hb_arraySetNI(pCols, 1, i);
                              hb_arraySetNI(pCols, 2, j);
                              hb_arraySetNI(pCols, 3, k);
                              hb_arrayAdd( pRows, pCols );
                              hb_itemRelease(pCols);
                           }
                        }
                        hb_itemRelease(pELEM);
                     }
                     hb_itemRelease(pARGC);
                  }
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=put_error((PHB_ITEM) pRET, "CART REDIMENSION ERROR",111);
            }
         }
//      }else{
//         sw=put_error((PHB_ITEM) pRET, "CART ARGUMENT ERROR - MUST BE NUMBER OR LOGIC",103);
//      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "CART ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG);
}else{
   sw=put_error((PHB_ITEM) pRET, "CART STACK UNDERFLOW",102);
}
return sw;
}   


//int put_coordinates_2D( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, int tCompare){
int put_coordinates_2D(){
int sw=1;
   PHB_ITEM pPREC = NULL;
   PHB_ITEM pPRER = NULL;
   if(nPCP==208){
      int ARGC = STK_PRG[++CP];
      int ARGR = STK_PRG[++CP];
      pPREC = hb_itemArrayGet( pSTK_REG, ARGC );
      pPRER = hb_itemArrayGet( pSTK_REG, ARGR );
   }else{
      if(CADDR>=2){
         pPREC = hb_itemArrayGet( pSTK_ADDR, CADDR--);
         pPRER = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOC2 STACK UNDERFLOW",102);
      }
   }
   MARK_ROW = (unsigned) hb_itemGetNInt( pPRER );
   MARK_COL = (unsigned) hb_itemGetNInt( pPREC );

   hb_itemRelease(pPREC);
   hb_itemRelease(pPRER);
return sw;
}

//int put_coordinates_1D( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, int tCompare){
int put_coordinates_1D( /*int ARG*/ ){
int sw=1;
   
   PHB_ITEM pPRE = NULL;
   if(nPCP==212){
      int ARG = STK_PRG[++CP];
      pPRE = hb_itemArrayGet( pSTK_REG, ARG );//hb_itemGetNInt( pARG ));
   }else{
      if(CADDR>=1)
         pPRE = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      else
         sw=put_error((PHB_ITEM) pRET, "LOC1 STACK UNDERFLOW",102);
   }   
   MARK_POS = (unsigned) hb_itemGetNInt( pPRE );
   MARK_PAGE=MARK_POS;

   hb_itemRelease(pPRE);
return sw;
}

int put_offset(){
int sw=1;
   if( CADDR>=1 ){      
      PHB_ITEM pARGC = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // saca solo 1
      OFFSET_POS = (unsigned int)hb_itemGetNInt( pARGC );
      hb_itemRelease(pARGC);
      /*if(OFFSET_POS>0){
         if(OFFSET_POS<MARK_POS){
            sw=put_error((PHB_ITEM) pRET, "OFFSET OFFSET POINT MINOR THAN INITIAL LOCATE",112);
         }
      }*///else if(OFFSET_POS<0) sw=put_error((PHB_ITEM) pRET, "OFFSET MUST NOT BE NEGATIVE");
      if(MARK_POS==0) MARK_POS=1;  // por default.
   }else{
      sw=put_error((PHB_ITEM) pRET, "OFFSET STACK UNDERFLOW",102);
   }
return sw;
}

int put_offset2D(){
int sw=1;
   if( CADDR>=2 ){
      PHB_ITEM pARGC = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // saca 2
      PHB_ITEM pARGR = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      OFFSET_ROW=(unsigned int)hb_itemGetNInt( pARGR ); 
      OFFSET_COL=(unsigned int)hb_itemGetNInt( pARGC );
      hb_itemRelease(pARGC);
      hb_itemRelease(pARGR);
     /* if( OFFSET_ROW>0 ) {
         if( OFFSET_ROW<MARK_ROW ) {
            sw=put_error((PHB_ITEM) pRET, "OFFSET OFFSET POINT MINOR THAN INITIAL LOCATE",112);
         }
      }
      if( OFFSET_COL>0 ){
         if( OFFSET_COL<MARK_COL ) {
            sw=put_error((PHB_ITEM) pRET, "OFFSET OFFSET POINT MINOR THAN INITIAL LOCATE",112);
         }
      }*/
      if(MARK_ROW==0) MARK_ROW=1;
      if(MARK_COL==0) MARK_COL=1;
   }else{
      sw=put_error((PHB_ITEM) pRET, "OFFSET STACK UNDERFLOW",102);
   }
return sw;
}

int fun_interval(){
int sw=1;
if(nPCP==123){
   if( CADDR>=3 ){  // {pag, col, fil}
      PHB_ITEM pIPAG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      PHB_ITEM pICOL = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      PHB_ITEM pIROW = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      SET_INTERVAL_ROW = hb_itemGetNI(pIROW);
      SET_INTERVAL_COL = hb_itemGetNI(pICOL);
      SET_INTERVAL_PAG = hb_itemGetNI(pIPAG);
      if(SET_INTERVAL_ROW<=0) SET_INTERVAL_ROW=1;
      if(SET_INTERVAL_COL<=0) SET_INTERVAL_COL=1;
      if(SET_INTERVAL_PAG<=0) SET_INTERVAL_PAG=1;
      hb_itemRelease(pIROW);
      hb_itemRelease(pICOL);
      hb_itemRelease(pIPAG);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INTERVAL 3D STACK UNDERFLOW",102);
   }
}else if(nPCP==122){
   if(CADDR>=2){  // {col, fil}
      PHB_ITEM pICOL = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      PHB_ITEM pIROW = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      SET_INTERVAL_ROW = hb_itemGetNI(pIROW);
      SET_INTERVAL_COL = hb_itemGetNI(pICOL);
      if(SET_INTERVAL_ROW<=0) SET_INTERVAL_ROW=1;
      if(SET_INTERVAL_COL<=0) SET_INTERVAL_COL=1;
      hb_itemRelease(pIROW);
      hb_itemRelease(pICOL);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INTERVAL 2D STACK UNDERFLOW",102);
   }
}else{   // nPCP==121
   if(CADDR>=1){  // {fil}
      PHB_ITEM pIROW = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      SET_INTERVAL_ROW = hb_itemGetNI(pIROW);
      if(SET_INTERVAL_ROW<=0) SET_INTERVAL_ROW=1;
      hb_itemRelease(pIROW);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INTERVAL 1D STACK UNDERFLOW",102);
   }
}
return sw;
}

int fun_reshape_1D2D( PHB_ITEM pSTK_REG, PHB_ITEM pARRAY,PHB_ITEM pFILA,PHB_ITEM pCOLS, int nReg ){
int sw=1;
   
   HB_MAXINT nFIL=hb_itemGetNInt( pFILA );
   HB_MAXINT nCOL=hb_itemGetNInt( pCOLS );

   HB_MAXINT nLen = (HB_MAXINT)hb_arrayLen( pARRAY );
   if( nFIL * nCOL == nLen ){
      HB_MAXINT ndx=0;
      PHB_ITEM pRows  = hb_itemArrayNew( nFIL );
      int i;
      for(i=1; i<=nFIL; i++){
         PHB_ITEM pCols  = hb_itemArrayNew( nCOL );
         int j;
         for(j=1; j<=nCOL; j++){
            PHB_ITEM pREG1 = hb_itemArrayGet( pARRAY, ++ndx );
            put_value(pCols, pREG1, j, PRECISION);
            hb_itemRelease(pREG1);
         }
         hb_arraySet( pRows, i, pCols );
         hb_itemRelease(pCols);
      }
      hb_arraySet( pSTK_REG, nReg, pRows );
      hb_itemRelease(pRows);
   }else{
      PHB_ITEM pRows  = hb_itemArrayNew( 0 );
      hb_arraySet( pSTK_REG, nReg, pRows );
      hb_itemRelease(pRows);
      sw=0;
   }
return sw;
}

int fun_reshape_1D3D( PHB_ITEM pSTK_REG, PHB_ITEM pARRAY,PHB_ITEM pFILA,PHB_ITEM pCOLS, PHB_ITEM pPAGS, int nReg ){
int sw=1;
   
   HB_MAXINT nFIL=hb_itemGetNInt( pFILA );
   HB_MAXINT nCOL=hb_itemGetNInt( pCOLS );
   HB_MAXINT nPAG=hb_itemGetNInt( pPAGS );

   HB_MAXINT nLen = (HB_MAXINT)hb_arrayLen( pARRAY );
   HB_MAXINT ndx = nFIL * nCOL * nPAG;
   if( ndx == nLen ){
      HB_MAXINT i,j,n=1,m=1,o=1;
      // creo array receptor
      PHB_ITEM pA = hb_itemArrayNew( 0 ); // 
      for (i=1; i<=nFIL; i++){
         PHB_ITEM pAA = hb_itemArrayNew( 0 ); // 
         for (j=1; j<=nCOL; j++){
            PHB_ITEM pAAA = hb_itemArrayNew( nPAG ); // 
            hb_arrayAdd( pAA, pAAA );
            hb_itemRelease( pAAA );
         }
         hb_arrayAdd( pA, pAA );
         hb_itemRelease( pAA );
      }
      for( i=1; i<=ndx; i++){
         PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
         PHB_ITEM pC = hb_itemArrayGet( pARRAY, i );
         hb_arraySet( pAAA, o, pC );
         //put_value(pAAA, pC, o, PRECISION);
         if ( ++m > nCOL ){ 
            m=1; 
            if ( ++n > nFIL ){ 
               n=1; 
               ++o; 
            } 
         }
         hb_itemRelease( pC );
         hb_itemRelease( pAAA );
         hb_itemRelease( pAA );
      }
      hb_arraySet( pSTK_REG, nReg, pA );
      hb_itemRelease(pA);
   }else{
      PHB_ITEM pA  = hb_itemArrayNew( 0 );
      hb_arraySet( pSTK_REG, nReg, pA );
      hb_itemRelease(pA);
      sw=0;
   }
return sw;
}

PHB_ITEM fun_reshape_1D( PHB_ITEM pREG, PHB_ITEM pFILA,PHB_ITEM pCOLS, PHB_ITEM pPAGS, int *Dim, int tDim ){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pREG, &nDim, &d1, &d2, &d3, &type);
   PHB_ITEM pARRAY = NULL;
   switch(nDim){
      case 1:{
         if(tDim!=1){
            int i;
            pARRAY = hb_itemArrayNew( d1 );
            for(i=1; i<=d1; i++){
               PHB_ITEM pREG1 = hb_itemArrayGet( pREG, i);
               put_value(pARRAY, pREG1, i, PRECISION);
               hb_itemRelease(pREG1);
            }
         }else{
            nDim=0;
         }
         break;
      }case 2:{
         if(tDim==2 && d1 == hb_itemGetNInt( pFILA ) && d2 == hb_itemGetNInt( pCOLS ) ){
            nDim=0;
            break;
         }else{
            int i,ndx=0;
            pARRAY  = hb_itemArrayNew( d1 * d2 );
            for(i=1; i<=d1; i++){
               PHB_ITEM pREG1 = hb_itemArrayGet( pREG, i);
               int j;
               for(j=1; j<=d2; j++){
                  PHB_ITEM pREG2 = hb_itemArrayGet( pREG1, j);
                  put_value(pARRAY, pREG2, ++ndx, PRECISION);
                  hb_itemRelease(pREG2);
               }
               hb_itemRelease(pREG1);
            }
         }
         break;
      }case 3:{
         if(tDim==3 && d1 == hb_itemGetNInt( pFILA ) && d2 == hb_itemGetNInt( pCOLS ) && d3 == hb_itemGetNInt( pPAGS ) ){
            nDim=0;
            break;
         }else{
            HB_MAXINT ndx=d1 * d2 * d3;
            HB_MAXINT i,n=1,m=1,o=1;
            pARRAY  = hb_itemArrayNew( ndx );
            for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pREG, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                //hb_arraySetC( pARRAY, i, (const char *) hb_itemGetCPtr( pAAAA ) );
                hb_arraySet( pARRAY, i, pAAAA );
                if ( ++m > d2 ){ 
                   m=1; 
                   if ( ++n > d1 ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
            }
         }
         break;
      }
   }
   *Dim = nDim;
return pARRAY;
}

int fun_reshape( /*int nReg */){
int sw=1;
int tDim=0;
PHB_ITEM pFILA = NULL;
PHB_ITEM pCOLS = NULL;
PHB_ITEM pPAGS = NULL;

if( CADDR == 1){
   pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   tDim=1;
}else if(CADDR==2){
   pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // COLUMNAS
   pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   tDim=2;
}else if (CADDR >= 3 ){
   pPAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PAGINAS
   pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // COLUMNAS
   pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   tDim=3;
/*}else if( CADDR==0 ){
   tDim=0;*/
}
if(tDim){
/*if ( CADDR >= 1 ) {
   PHB_ITEM pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   int tDim=1;
   PHB_ITEM pCOLS = NULL;
   PHB_ITEM pPAGS = NULL;
   if( CADDR>=1){
      pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // COLUMNAS
      tDim=2;
      if( CADDR>=1){  // 3D
         pPAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PAGINAS
         tDim=3;
      }
   } */
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, nReg);
   if( HB_IS_ARRAY( pREG ) ){
      //PHB_ITEM pARRAY;   // array a procesar
      // pasar el array a 1D
      int nDim=0;
      PHB_ITEM pARRAY=fun_reshape_1D( (PHB_ITEM) pREG, (PHB_ITEM) pFILA, (PHB_ITEM) pCOLS, (PHB_ITEM) pPAGS, &nDim, (int) tDim);

      switch(nDim){
         case 1:{
            if( tDim==2 )
               sw=(int)fun_reshape_1D2D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(int)nReg );
            else if( tDim==3 )
               sw=(int)fun_reshape_1D3D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(PHB_ITEM) pPAGS,(int)nReg );
            break;
         }case 2:{
            if( tDim==1 )
               hb_arraySet( pSTK_REG, nReg, pARRAY );
            else if( tDim==3 )
               sw=(int)fun_reshape_1D3D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(PHB_ITEM) pPAGS,(int)nReg );
            else if( tDim==2 )
               sw=(int)fun_reshape_1D2D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(int)nReg );
            break;
         }case 3:{
            if( tDim==1 )
               hb_arraySet( pSTK_REG, nReg, pARRAY );
            else if( tDim==2 )
               sw=(int)fun_reshape_1D2D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(int)nReg );
            else if( tDim==3 )
               sw=(int)fun_reshape_1D3D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(PHB_ITEM) pPAGS,(int)nReg );
            break;
         }
      }
      if( pARRAY ) hb_itemRelease(pARRAY);
      if ( !sw )
         sw=put_error((PHB_ITEM) pRET, "RESHAPE REDIMENSION ERROR",111); 
   }else{
      sw=put_error((PHB_ITEM) pRET, "RESHAPE IS NOT ARRAY - TYPE MISMATCH",104); 
   }

   hb_itemRelease(pREG);
/*   hb_itemRelease(pFILA);
   hb_itemRelease(pCOLS);
   hb_itemRelease(pPAGS); */
}else{
   sw=put_error((PHB_ITEM) pRET, "RESHAPE STACK UNDERFLOW",102); 
}
hb_itemRelease(pFILA);
/*if( pCOLS )*/ hb_itemRelease(pCOLS);
/*if( pPAGS )*/ hb_itemRelease(pPAGS);
return sw;
}


/*
   MODIFICADO: ES NECESARIO, PORQUE PONE EN EL STACK DIRECTAMENTE LO COPIADO, NO COMO LET, QUE LO
   ASIGNA A UNA VARIABLE.
   */


// RANGE: establece rango para acceder a matrices. 
int fun_range(){
int sw=1;
//if(CADDR>=1){

   int nReg = STK_PRG[ ++CP ];   // variable array   
   PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, nReg);

   if(!HB_IS_ARRAY(pREG)){
      //sw=put_error((PHB_ITEM) pRET, "RANGE ARGUMENT ERROR",103);
      // es abstracta:
      SW_ORIGIN_RANGE=0;
      PHB_ITEM pSTK  = hb_itemArrayGet( pSTK_ADDR, CADDR);
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSTK, &nDim, &d1, &d2, &d3, &type);
      switch(nDim){
         case 1:{
            SW_USERANGE = CADDR;
            RANGEDIM=1;
            RANGEROW=d1;
            RANGECOL=0;
            break;
         }case 2:{
            SW_USERANGE = CADDR;
            RANGEDIM=2;
            RANGEROW=d1;
            RANGECOL=d2;
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "RANGE RANGE DIMENSION ERROR",111);
            break;
         }
      }
      hb_itemRelease(pSTK);
   }else{
      SW_ORIGIN_RANGE=1;
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pREG, &nDim, &d1, &d2, &d3, &type);
      switch(nDim){
         case 1:{
/*            int i;
            for(i=1;i<=d1;i++){
               PHB_ITEM pRow = hb_itemArrayGet( pREG, i);
               if(!HB_IS_NUMERIC(pRow)){
                  sw=put_error((PHB_ITEM) pRET, "RANGE ARGUMENT ERROR - MUST BE NUMERIC",103);
                  break;
               }
               hb_itemRelease(pRow);
            }*/
            //if(sw){
               SW_USERANGE = nReg;
               RANGEDIM=1;
               RANGEROW=d1;
               RANGECOL=0;
               
            //}
            break;
         }case 2:{
/*            int i;
            for(i=1;i<=d1;i++){
               PHB_ITEM pRow = hb_itemArrayGet( pREG, i);
               int j;
               for(j=1;j<=d2;j++){
                  PHB_ITEM pCol = hb_itemArrayGet( pRow, j);
                  if(!HB_IS_NUMERIC(pCol)){
                     sw=put_error((PHB_ITEM) pRET, "RANGE ARGUMENT ERROR - MUST BE NUMERIC",103);
                     break;
                  }
                  hb_itemRelease(pCol);
               }
               hb_itemRelease(pRow);
            }*/
            //if(sw){
               SW_USERANGE = nReg;
               RANGEDIM=2;
               RANGEROW=d1;
               RANGECOL=d2;
           // }
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "RANGE RANGE DIMENSION ERROR",111);
            break;
         }
      }
   }
   hb_itemRelease(pREG);
//}else{   // instruccion con ()
//   sw=put_error((PHB_ITEM) pRET, "RANGE STACK UNDERFLOW",102);
//}
return sw;
}

// este no tiene validacion: se asume que hay un arary 1D, o un string?
int get_ewarray(){
int sw=1;
/*PHB_ITEM pARG = hb_itemArrayGet( pSTK_PRG, ++CP);
long nItem = hb_itemGetNInt( pARG );
hb_itemRelease(pARG);*/
int nItem = STK_PRG[++CP];
PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nItem );

if(HB_IS_ARRAY( pSource )){
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
              if( MARK_POS == 999999999 ) MARK_POS=d1;
              if( MARK_POS<=d1 ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_POS );
                  if ( PUSH_VAR != -1 ){
                      //hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
                      put_value(pSTK_REG, pARGS, PUSH_VAR, PRECISION);
                      PUSH_VAR=-1;
                  }else{
                      //hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
                      put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                  }
               //   put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                  hb_itemRelease(pARGS);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "GET MARK POSITION OVERFLOW",101);
               }
              break;
     }case 2:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                     if ( PUSH_VAR != -1 ){
                         //hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
                         put_value(pSTK_REG, pARGC, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                     }else{
                         //hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
                         put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                     }
                     //put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGS);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "GET MARK COLUMN OVERFLOW",101);
                  }
              }else{
                  sw=put_error((PHB_ITEM) pRET, "GET MARK ROW OVERFLOW",101);
              }
              break;
     }case 3:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_POS == 999999999 ) MARK_POS=d3;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                      if( MARK_POS<=d3 ){
                          PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                          PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                          PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE );
                          if ( PUSH_VAR != -1 ){
                              //hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
                              put_value(pSTK_REG, pARGP, PUSH_VAR, PRECISION);
                              PUSH_VAR=-1;
                          }else{
                              //hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
                              put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                          }
                          //put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                          hb_itemRelease(pARGP);
                          hb_itemRelease(pARGC);
                          hb_itemRelease(pARGS);
                      }else{
                          sw=put_error((PHB_ITEM) pRET, "GET MARK PAGE OVERFLOW",101); 
                      }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "GET MARK COLUMN OVERFLOW",101);
                  }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "GET MARK ROW OVERFLOW",101);
              }
              break;
     }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "GET REGISTER TYPE MUST BE ARRAY WITH RANGE",104);
}
hb_itemRelease(pSource);
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
}*/
return sw;
}

int get_array(){
int sw=1;
int swOffset=0;

int nItem = STK_PRG[++CP];
PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nItem );


if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   if(HB_IS_ARRAY( pSource )){
      switch(RANGEDIM){
         case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==RANGEDIM){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                     
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i);
                  PHB_ITEM pELEM = hb_itemArrayGet( pSource, hb_itemGetNI(pCOORD));
                  put_value(pRows, pELEM, i, PRECISION);
                  hb_itemRelease(pELEM);
                  hb_itemRelease(pCOORD);
               }
               if ( PUSH_VAR != -1 ){
                   hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                   PUSH_VAR=-1;
               }else{
                   hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               }
               //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "GET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }case 2:{   // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==2 && RANGECOL==2){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                     
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  put_value(pRows, pELEMCOL, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pCOORDROW);
               }
               if ( PUSH_VAR != -1 ){
                   hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                   PUSH_VAR=-1;
               }else{
                   hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               }
               //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else if(nDim1==3 && RANGECOL==3){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                     
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  PHB_ITEM pELEMPAG = hb_itemArrayGet( pELEMCOL, hb_itemGetNI(pROWP));
                  put_value(pRows, pELEMPAG, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pROWP);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pELEMPAG);
                  hb_itemRelease(pCOORDROW);
               }
               if ( PUSH_VAR != -1 ){
                   hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                   PUSH_VAR=-1;
               }else{
                   hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               }
               ///hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "GET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET REGISTER TYPE MUST BE ARRAY WITH RANGE",104);
   }
}else{
   if(HB_IS_ARRAY( pSource )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
      switch( nDim ){
         case 1:{
            unsigned int nIni=1, nFin=d1;
            if (normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)){
               if( OFFSET_POS ) {
                  if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                  nFin=OFFSET_POS;
                  
                  PHB_ITEM pRows ; // = hb_itemArrayNew( nFin - nIni + 1 );
                  int nInc=SET_INTERVAL_ROW, i=nIni;
                  if(nFin < nIni){
                        int nTmp = nIni; nIni = nFin; nFin=nTmp; nInc=-SET_INTERVAL_ROW;
                  }
                  int nLong=get_length(nIni,nFin,SET_INTERVAL_ROW); //nFin - nIni + 1;
                  pRows  = hb_itemArrayNew( nLong );
                  int nPos=1;
                  while ( nLong-- ){
                        PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                        put_value(pRows, pARGS, nPos++, PRECISION);
                        hb_itemRelease(pARGS);
                        i = i + nInc;
                  }
                  if ( PUSH_VAR != -1 ){
                      hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  ///hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }else{   // solo devuelve un elemento  SINGLE.
                  if( MARK_POS<=d1 ){
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_POS );
                     if ( PUSH_VAR != -1 ){
                         put_value(pSTK_REG, pARGS, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                     }else{
                         put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                     }
                     //put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                     hb_itemRelease(pARGS);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "GET MARK OVERFLOW",101);
                  }
               }
            } // solo si estan normalizados
            break;
         }case 2:{
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
//            printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
            if( !( sw=normaliza_indices_2d( &nIniR, &nFinR, &nIniC, &nFinC, d1, d2, &swOffset,
                                            &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL) ) ){
                hb_itemRelease(pSource);
                return sw;
            }

//            printf("\nPASA 2\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL); 
          /* 4 CASOS:  
                1.- OFFSET ROW=OFFSET_COL=0     => devuelve SINGLE
                2.- OFFSET_ROW>0, OFFSET_COL=0  => devuelve array 1D
                3.- OFFSET_ROW=0, OFFSET_ROW>0  => devuelve array 1D
                4.- OFFSET_ROW>0, OFFSET_COL>0  => devuelve array 2D. Ya hecho. */
            if( !OFFSET_COL ){   // SINGLE
               if( !OFFSET_ROW ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                  PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                  if ( PUSH_VAR != -1 ){
                         put_value(pSTK_REG, pARGC, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                  }else{
                         put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                  }
                  //put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                  hb_itemRelease(pARGC);
                  hb_itemRelease(pARGS);
               
               }else{  // ARRAY 1D (recorre las filas)
                  int nInc=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                  }
                  //int nLong=nFinR - nIniR + 1;
                  int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int rPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     put_value(pRows, pARGC, rPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     i = i + nInc;
                  }
                  if ( PUSH_VAR != -1 ){
                      hb_arraySet( pSTK_REG, PUSH_VAR, pRows );
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }   
            }else{ 
               if( !OFFSET_ROW ){  // ARRAY 1D (recorre las columnas)
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                  int nInc=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                  }
                  //int nLong=nFinC - nIniC + 1;
                  int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int cPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pRows, pARGC, cPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     j = j + nInc;                  
                  }
                  hb_itemRelease(pARGF);
                  
                  if ( PUSH_VAR != -1 ){
                      hb_arraySet( pSTK_REG, PUSH_VAR, pRows );
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }else{   // 2D
                  int nIncR=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                  }
                  //int nLongR=nFinR - nIniR + 1;
                  int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLongR );
                  int rPos=1;
                  int nIncC=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                  }
                  //int nLongC=nFinC - nIniC + 1;
                  int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  int cTmp = j;  // guardo para reasignar dentro del ciclo
                  while ( nLongR-- ){
                     int cLongCTmp=nLongC;
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pCols  = hb_itemArrayNew( cLongCTmp );
                     int cPos=1, j=cTmp;
                     while ( cLongCTmp-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                        put_value(pCols, pARGC, cPos++, PRECISION);
                        hb_itemRelease(pARGC);
                        j = j + nIncC;
                     }
                     hb_arraySet( pRows, rPos++, pCols );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pCols);
                     i = i + nIncR;
                  }

                  if ( PUSH_VAR != -1 ){
                      hb_arraySet( pSTK_REG, PUSH_VAR, pRows );
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
            break;
         }case 3:{
            unsigned int nPagIni=1, nPagFin=d3;
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
            if( !(sw=normaliza_indices_3d(&nIniR, &nFinR, &nIniC, &nFinC, &nPagIni, &nPagFin, d1, d2, d3, &swOffset,
                         &MARK_PAGE, &OFFSET_POS, &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL)) ){
                 hb_itemRelease(pSource);
                 return sw; 
            }

           /* CASOS:
               1.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS=0     => SINGLE
               2.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS=0     => 1D
               3.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS=0     => 1D
               4.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS=0     => 2D
               5.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS>0     => 1D
               6.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS>0     => 2D
               7.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS>0     => 2D
               8.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS>0     => 3D
           */
            if( !OFFSET_POS ){
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // SINGLE
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                     PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE );
                     if ( PUSH_VAR != -1 ){
                         put_value(pSTK_REG, pARGP, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                     }else{
                         put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                     }
                     //put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                     hb_itemRelease(pARGP);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGS);
                  }else{   // lee solo columnas: array 1D
                     int nInc=SET_INTERVAL_COL,i=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                     }
                     //int nLong=nFinC - nIniC + 1;
                     int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLong );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, i);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        i = i + nInc;
                     }

                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY);                   
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // lee solo filas: array 1D
                     int nInc=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                     }
                     //int nLong=nFinR - nIniR + 1;
                     int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nInc;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongR );
                     int rPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                           put_value(pARRAYC, pARGP, cPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);  
                  }
               }
            }else{    // existe desplazamiento de páginas
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // solo desplaza un elemento por página: array 1D
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLong=nPagFin - nPagIni + 1;
                     int nLong=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int kPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAY, pARGP, kPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        k = k + nIncP;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     
                     hb_itemRelease(pARRAY);

                  }else{   // lee solo columnas por página: array 2D
                     // esto está mal: deben haber OFFSET_POS filas, y OFFSET_COL columnas, o sea, a verre.
                     // ahora sí:
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongP );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int kPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongP-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYP = hb_itemArrayNew( cLongCTmp );
                        int pPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYP, pARGP, pPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, kPos++, pARRAYP);
                        hb_itemRelease(pARRAYP);
                        k = k + nIncP;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY); 
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // recorre solo filas, una columna, por página: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = k;
                     while( nLongR-- ){
                        int cLongPTmp=nLongP;
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);  // leo fila
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);  // leo única columna
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongPTmp );  // m-columnas                        
                        int kPos=1, k=cTmp;
                        while( cLongPTmp-- ){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYC, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           k = k + nIncP;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas y páginas: array 3D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = j;
                     int kTmp = k;
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1;
                        j=cTmp;
                        while( cLongCTmp-- ){
                           int cLongPTmp=nLongP;
                           PHB_ITEM pARRAYP = hb_itemArrayNew( cLongPTmp );
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           int kPos=1;
                           k=kTmp;
                           while( cLongPTmp-- ){
                              PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                              put_value(pARRAYP, pARGP, kPos++, PRECISION);
                              hb_itemRelease(pARGP);
                              k = k + nIncP;
                           }
                           hb_arraySet(pARRAYC, cPos++, pARRAYP);
                           hb_itemRelease(pARRAYP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);                  
                  }
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0; }
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "GET DIMENSION ERROR",106);
         }
      }
   }else if(HB_IS_STRING(pSource)){  // si es STRING: obtengo la porción requerida:
      const char * cString = hb_itemGetCPtr(pSource);
      long nLen = hb_itemGetCLen(pSource);
      ///long nLen = hb_cdpUTF8StringLength( hb_itemGetCPtr( pSource ), hb_itemGetCLen( pSource ) );
      long nIni=1,nFin=nLen;
      if( MARK_POS == 999999999 ) MARK_POS=nFin;
      if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
      if( OFFSET_POS ) {  // devuelve una porción
         if( OFFSET_POS == 999999999 ) OFFSET_POS=nLen;

         if(MARK_POS>0 && MARK_POS<=nLen && OFFSET_POS<=nLen && OFFSET_POS>=MARK_POS){
            nFin=OFFSET_POS;
            cString = cString + (nIni-1);
            char * cChar = (char*)calloc(nFin+nFin,1);
            memcpy(cChar, cString, nFin-nIni+1);

            const char * pChar=cChar;
            
            if ( PUSH_VAR != -1 ){
                hb_arraySetC( pSTK_REG, PUSH_VAR, (const char*) pChar );
                PUSH_VAR=-1;
            }else{
                hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
            }
            ///hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
            free(cChar);
         }else{
            sw=put_error((PHB_ITEM) pRET, "GET MARK|OFFSET OVERFLOW",101);
         }
      }else{   // solo devuelve un elemento  SINGLE.
         if( MARK_POS<=nFin && MARK_POS>0 ){
            char cChar[2];
            //cString = cString + MARK_POS-1;
            //cChar[0]=*cString; //cString[MARK_POS-1]; 
            cChar[0]=cString[MARK_POS-1]; 
            cChar[1] = '\0';

            const char * pChar=cChar;

            if ( PUSH_VAR != -1 ){
                hb_arraySetC( pSTK_REG, PUSH_VAR, (const char*) pChar );
                PUSH_VAR=-1;
            }else{
                hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
            }
            //hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
         }else{
            sw=put_error((PHB_ITEM) pRET, "GET MARK OVERFLOW",101);
         }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET REGISTER TYPE IS NOT AN ARRAY OR STRING",104);
   }
}
hb_itemRelease(pSource);
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
   fun_clear_interval();
}*/

return sw;
}


int put_ewarray(){
int sw=1;

int nItem = STK_PRG[++CP];

if(CADDR){

   PHB_ITEM pTarget = hb_itemArrayGet( pSTK_REG, nItem );
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // Source
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(HB_IS_ARRAY( pTarget )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pTarget, &nDim, &d1, &d2, &d3, &type);
      switch( nDim ){
         case 1:{
              if( MARK_POS == 999999999 ) MARK_POS=d1;
              if( MARK_POS<=d1 ){
                  put_value(pTarget, pSource, MARK_POS, PRECISION);
                  //hb_arraySet( pSTK_REG, nItem, pPRE );
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT MARK POSITION OVERFLOW",101);
               }
              break;
        }case 2:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pTarget, MARK_ROW );
                     put_value((PHB_ITEM) pPRE1, pSource, MARK_COL, PRECISION );
                    // hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "PUT MARK COLUMN OVERFLOW",101);
                  }
              }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT MARK ROW OVERFLOW",101);
              }
              break;
        }case 3:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_POS == 999999999 ) MARK_POS=d3;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                      if( MARK_POS<=d3 ){
                          PHB_ITEM pARGS = hb_itemArrayGet( pTarget, MARK_ROW );
                          PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                          put_value(pARGC, pSource, MARK_POS, PRECISION);
                        //  hb_arraySet( pARGS, MARK_COL, pARGC );
                        //  hb_arraySet( pPRE, MARK_ROW, pARGS );
                        //  hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                          hb_itemRelease(pARGC);
                          hb_itemRelease(pARGS);
                      }else{
                          sw=put_error((PHB_ITEM) pRET, "PUT MARK PAGE OVERFLOW",101); 
                      }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "PUT MARK COLUMN OVERFLOW",101);
                  }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "PUT MARK ROW OVERFLOW",101);
              }
              break;
        }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PUT REGISTER TYPE MUST BE ARRAY",104);
   }
   hb_itemRelease(pSource);
   hb_itemRelease(pTarget);
}else{
   sw=put_error((PHB_ITEM) pRET, "PUT STACK UNDERFLOW",102);
}
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
}*/
return sw;
}


/* MODIFICAR PORQUE EST┴ COMO EL PICO: hecho! */
int put_array(/* long nIndexReg*/ ){
int sw=1;
int swOffset=0;

int nIndexReg = STK_PRG[++CP];

if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   PHB_ITEM pARRAYRES = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // Source
   PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nIndexReg );  // Target.
   if(HB_IS_ARRAY( pARRAYRES )){
      if(HB_IS_ARRAY(pPRE)){
         switch(RANGEDIM){
            case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==RANGEDIM){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                     PHB_ITEM pELEM = hb_itemArrayGet( pARRAYRES, i);
                     put_value(pPRE, pELEM, hb_itemGetNI(pCOORD), PRECISION);
                     hb_itemRelease(pELEM);
                     hb_itemRelease(pCOORD);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==2 && RANGECOL==2){
                  unsigned int i;
                  PHB_ITEM pREG  = NULL; //hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                    // caso elemento de array source:
                     PHB_ITEM pELEMROW = hb_itemArrayGet( pARRAYRES, i);

                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     
                     put_value(pROW, pELEMROW, hb_itemGetNI(pROWY), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pELEMROW);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else if(nDim1==3 && RANGECOL==3){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                  /// = hb_itemArrayGet( pSTK_REG, SW_USERANGE);

                  for(i=1;i<=RANGEROW;i++){
                     
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
   
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                     PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                     PHB_ITEM pELEMROW = hb_itemArrayGet( pARRAYRES, i);
                     
                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                     put_value(pCOL, pELEMROW, hb_itemGetNI(pROWP), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pROWP);
                     hb_itemRelease(pELEMROW);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOL);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "PUT TARGET TYPE MUST BE ARRAY",104);
      }
   }else{
///      sw=put_error((PHB_ITEM) pRET, "PUT SOURCE TYPE MUST BE ARRAY",104);
      if(HB_IS_ARRAY(pPRE)){
         switch(RANGEDIM){
            case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==RANGEDIM){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                  //hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                     put_value(pPRE, pARRAYRES, hb_itemGetNI(pCOORD), PRECISION);
                     hb_itemRelease(pCOORD);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==2 && RANGECOL==2){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                  // = hb_itemArrayGet( pSTK_REG, SW_USERANGE);

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                    // caso elemento de array source:

                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     
                     put_value(pROW, pARRAYRES, hb_itemGetNI(pROWY), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else if(nDim1==3 && RANGECOL==3){
                  unsigned int i;
                  PHB_ITEM pREG = NULL; // = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
   
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                     PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                     put_value(pCOL, pARRAYRES, hb_itemGetNI(pROWP), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pROWP);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOL);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "PUT TARGET TYPE MUST BE ARRAY",104);
      }

   }
   hb_itemRelease(pARRAYRES);
   hb_itemRelease(pPRE);
}else{
if( CADDR>=1 ){
//   PHB_ITEM pARG = hb_itemArrayGet( pSTK_PRG, ++CP);
//   long nIndexReg = hb_itemGetNInt( pARG );
//   hb_itemRelease(pARG);
   PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nIndexReg );  // Target.
 
 // pPRE puede debe ser un array, porque recibe. Si no lo es, debe dar error, lo mismo lo que está en STACK.
   int swARR = 0;
   PHB_ITEM pARRAYRES = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // Source
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_ARRAY( pARRAYRES )){
      swARR=1;
   }else if(HB_IS_STRING(pPRE) && HB_IS_STRING(pARRAYRES)){  // si es STRING: copio la porción requerida:
      const char * cStringT = hb_itemGetCPtr(pPRE);     // target
      const char * cStringS = hb_itemGetCPtr(pARRAYRES);// Source
      long nLenT = hb_itemGetCLen(pPRE);
      long nLenS = hb_itemGetCLen(pARRAYRES);
      long nIni=1,nFin=nLenT;
      
      if( MARK_POS == 999999999 ) MARK_POS=nFin;
      if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
      if( OFFSET_POS ) {  // devuelve una porción
         if( OFFSET_POS == 999999999 ) OFFSET_POS=nLenT;
      }else{
         OFFSET_POS=MARK_POS;
      }
      if(MARK_POS>0 && MARK_POS<=nLenT && OFFSET_POS<=nLenT && OFFSET_POS>=MARK_POS){
         nFin=OFFSET_POS;
         char * buffer = (char*)calloc(nLenT+nLenS+1,1);
         if(nIni-1)
            memcpy(buffer, cStringT, (nIni-1));
         memcpy(buffer + (nIni-1), cStringS, nLenS);
         if(nFin<=nLenT){
            cStringT = cStringT + (nFin);
            memcpy(buffer + (nIni-1)+nLenS, cStringT, strlen(cStringT));

            hb_arraySetC( pSTK_REG, nIndexReg, (const char*) buffer );
            free(buffer);
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT MARK|OFFSET OVERFLOW",101);
         }

      }
      hb_itemRelease(pARRAYRES);
      hb_itemRelease(pPRE);
      return sw;
   }
    
   if(!HB_IS_ARRAY( pPRE )){
      sw=put_error((PHB_ITEM) pRET, "PUT REGISTER TYPE IS NOT AN ARRAY",104);
      hb_itemRelease(pPRE);
      //hb_itemRelease(pARG);
      hb_itemRelease(pARRAYRES);
      return sw;
   }
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pPRE, &nDim, &d1, &d2, &d3, &type);

   switch( nDim ){
      case 1:{
         if(MARK_POS>0) {
            if( !swARR ){
               if( MARK_POS == 999999999 ) MARK_POS=d1;
               if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
               
               if(MARK_POS<=d1 ){  // es un elemento
                  if( OFFSET_POS==0 ){
                     put_value(pPRE, pARRAYRES, MARK_POS, PRECISION);
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                  }else{
                     unsigned int i;
                    // int ndx=1;
                     for (i=MARK_POS; i<=OFFSET_POS; i+=SET_INTERVAL_ROW){//i++){
                        put_value((PHB_ITEM) pPRE, pARRAYRES, i, PRECISION);
                     }
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                 //   printf("PASO AQUI\n");
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT INITIAL LOCATE OVERFLOW",113);
               }
            }else{   // hay desplazamiento, Ya se sabe que OFFSET_POS>=MARK_POS
               if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
              // if(OFFSET_POS<=d1 && MARK_POS<=d1){ 
                  unsigned int i;
                  int ndx=1;
                  if(MARK_POS<=OFFSET_POS){
                     for (i=MARK_POS; i<=OFFSET_POS; i+=SET_INTERVAL_ROW){
                        PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                        put_value((PHB_ITEM) pPRE, pPRE1, i, PRECISION);
                        hb_itemRelease(pPRE1);
                     }
                  }else{
                     for (i=MARK_POS; i>=OFFSET_POS; i-=SET_INTERVAL_ROW){
                        PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                        put_value((PHB_ITEM) pPRE, pPRE1, i, PRECISION);
                        hb_itemRelease(pPRE1);
                     }                  
                  }
                 // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT MARK 1D ERROR",113);
         }
         break;
      }case 2:{
         if(MARK_ROW>0 && MARK_COL>0){
               int /*nIniR=1,*/ nFinR=d1;
               int /*nIniC=1,*/ nFinC=d2;
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT ROW'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                  //   hb_itemRelease(pARG);
                     return sw;               
                  }
                  /*nIniR=MARK_ROW;*/nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT ROW'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                      //  hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
                  swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT COL'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                   //  hb_itemRelease(pARG);
                     return sw;               
                  }
                  /*nIniC=MARK_COL;*/nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT COL'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                     //   hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
                  swOffset=1;
                  OFFSET_COL=nFinC;
               }

            if ( swARR ){
               HB_MAXINT nDimS=0,d1S=0,d2S=0,d3S=0,typeS=0;
               get_size( (PHB_ITEM) pARRAYRES, &nDimS, &d1S, &d2S, &d3S, &typeS);
               
///  aqui iba control de rows y offset
            
               if(OFFSET_ROW==0){
                  if(OFFSET_COL==0){
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                     put_value((PHB_ITEM) pPRE1, pARRAYRES, MARK_COL, PRECISION );
                     hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }else{
                     if( nDimS == 1 ){
                        PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                        unsigned int j;
                        int ndx=1;
                        if(MARK_COL<=OFFSET_COL){
                           for( j=MARK_COL; j<=OFFSET_COL; j+=SET_INTERVAL_COL){
                              PHB_ITEM pPRE2 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              put_value((PHB_ITEM) pPRE1, pPRE2, j, PRECISION);
                              hb_itemRelease(pPRE2);
                           }
                        }else{
                           for( j=MARK_COL; j>=OFFSET_COL; j-=SET_INTERVAL_COL){
                              PHB_ITEM pPRE2 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              put_value((PHB_ITEM) pPRE1, pPRE2, j, PRECISION);
                              hb_itemRelease(pPRE2);
                           }
                        }
                        hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                       // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                        hb_itemRelease(pPRE1);
                     }else{
                        sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION 1D ERROR",113);
                     }
                  }
               }else{
                  if(OFFSET_COL==0){   // desplazamiento por una columna marcada por MARK_COL
                     if( nDimS == 1 ){
                        unsigned int i;
                        int ndx=1;
                        if(MARK_ROW<=OFFSET_ROW){
                           for( i=MARK_ROW; i<=OFFSET_ROW; i+=SET_INTERVAL_ROW){
                              PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              PHB_ITEM pPROW  = hb_itemArrayGet( pPRE, i);
                              put_value((PHB_ITEM) pPROW, pPRE1, MARK_COL, PRECISION);
                              hb_arraySet( pPRE, i, pPROW );
                              hb_itemRelease(pPROW);   
                              hb_itemRelease(pPRE1);
                           }
                        }else{
                           for( i=MARK_ROW; i>=OFFSET_ROW; i-=SET_INTERVAL_ROW){
                              PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              PHB_ITEM pPROW  = hb_itemArrayGet( pPRE, i);
                              put_value((PHB_ITEM) pPROW, pPRE1, MARK_COL, PRECISION);
                              hb_arraySet( pPRE, i, pPROW );
                              hb_itemRelease(pPROW);   
                              hb_itemRelease(pPRE1);
                           }
                        }
                       // hb_arraySet(pSTK_REG, nIndexReg, pPRE);
                     }else{
                        sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION 1D ERROR",113);
                     }
                  }else{   // desplaza por filas y columnas, un rectángulo
                     if( nDimS == 2 ){
                        int nIniR = MARK_ROW, nFinR = OFFSET_ROW;
                        int nIniC = MARK_COL, nFinC = OFFSET_COL; 
                        int nIncR=SET_INTERVAL_ROW,i=nIniR;
                        if(nFinR < nIniR){
                           int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                        }
                        //int nLongR=nFinR - nIniR + 1;
                        int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                        int nIncC=SET_INTERVAL_COL,j=nIniC;
                        if(nFinC < nIniC){
                           int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                        }
                        //int nLongC=nFinC - nIniC + 1;
                        int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                        int cTmp = j;  // guardo para reasignar dentro del ciclo
                        int ndx=1;
                        while ( nLongR-- ){
                           int cLongCTmp=nLongC;
                           PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                           PHB_ITEM pPROW  = hb_itemArrayGet( pPRE, i);
                           int j=cTmp;
                           int ndx2=1;
                           while ( cLongCTmp-- ){
                              PHB_ITEM pPRE2 = hb_itemArrayGet( pPRE1, ndx2++ );
                              put_value((PHB_ITEM) pPROW, pPRE2, j, PRECISION);
                              hb_itemRelease(pPRE2);
                              j = j + nIncC;
                           }
                           hb_arraySet(pPRE, i, pPROW);
                           hb_itemRelease(pPROW);
                           hb_itemRelease(pPRE1);
                           i = i + nIncR;
                        }

                     }else{
                        sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION 2D ERROR",113);
                     }
                  }
               }
            }else{  // es solo un elemento asignado a un array
               if(OFFSET_ROW==0){
                  if(OFFSET_COL==0){
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                     put_value((PHB_ITEM) pPRE1, pARRAYRES, MARK_COL, PRECISION );
                     hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }else{
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                     int nIniC = MARK_COL, nFinC = OFFSET_COL; 
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     while ( nLongC-- ){
                        put_value((PHB_ITEM) pPRE1, pARRAYRES, j, PRECISION);
                        j = j + nIncC;
                     }

                     hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                   //  hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }
               }else{
                  if(OFFSET_COL==0){   // desplazamiento por una columna marcada por MARK_COL

                     int nIniR = MARK_ROW, nFinR = OFFSET_ROW;
                     int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
                     }
                     int i;
                     for(i=nIniR; i<=nFinR; i+=nIncR){
                        PHB_ITEM pPROW = hb_itemArrayGet( pPRE, i); 
                        put_value(pPROW, pARRAYRES, MARK_COL, PRECISION);
                        hb_arraySet( pPRE, i, pPROW );
                        hb_itemRelease(pPROW);
                      }

                  }else{   // desplaza por filas y columnas, un rectángulo
                     int nIniR = MARK_ROW, nFinR = OFFSET_ROW;
                     int nIniC = MARK_COL, nFinC = OFFSET_COL; 
                     int nIncR=SET_INTERVAL_ROW;//,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp;// nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nIncC=SET_INTERVAL_COL; //,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp;// nIncC=-SET_INTERVAL_COL;
                     }
                     int i;
                     for(i=nIniR; i<=nFinR; i+=nIncR){
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, i); 
                        int j;
                        for(j=nIniC; j<=nFinC; j+=nIncC){
                            put_value((PHB_ITEM) pROW, pARRAYRES, j, PRECISION);
                         }
                        hb_arraySet( pPRE, i, pROW );
                        hb_itemRelease(pROW);
                     }

                  }
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT INITIAL 2D LOCATE ERROR",113);
         }
         if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
         break;
      }case 3: { 
         if(MARK_ROW && MARK_COL && MARK_POS){
               int nPagIni=1, nPagFin=d3;
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
               if( MARK_PAGE ){
                  if( MARK_PAGE == 999999999 ) MARK_PAGE=d3;
                  if( MARK_PAGE>d3 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT PAGE'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                   //  hb_itemRelease(pARG);
                     return sw;               
                  }
                  nPagIni=MARK_PAGE; nPagFin=MARK_PAGE;
                  if( OFFSET_POS ){
                     if( OFFSET_POS == 999999999 ) OFFSET_POS=d3;
                     if( OFFSET_POS<=d3 ){
                        nPagFin=OFFSET_POS;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT PAGE'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                     //   hb_itemRelease(pARG);
                        return sw;
                     }
                  } 
               }else{  // si no existe marca de página, se asume todo; luego:
                  swOffset=1;
                  OFFSET_POS=nPagFin; 
                  //printf("\nPASE POR AQUI\nMARK_PAGE=%d\n",MARK_PAGE);
               }
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT ROW'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                    // hb_itemRelease(pARG);
                     return sw;               
                  }
                  nIniR=MARK_ROW;nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT ROW'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                      //  hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
                  swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT COL'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                   //  hb_itemRelease(pARG);
                     return sw;               
                  }
                  nIniC=MARK_COL;nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT COL'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                      //  hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
                  swOffset=1;
                  OFFSET_COL=nFinC;
               } 

            if( swARR ){
               HB_MAXINT nDimS=0,d1S=0,d2S=0,d3S=0,typeS=0;
               get_size( (PHB_ITEM) pARRAYRES, &nDimS, &d1S, &d2S, &d3S, &typeS);

// aquí iba calculo de offset y marcas
               
               if( !OFFSET_POS ){
                  if( !OFFSET_ROW ){
                     if( !OFFSET_COL ){   // SINGLE
                        PHB_ITEM pARGS = hb_itemArrayGet( pPRE, MARK_ROW );
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                        put_value(pARGC, pARRAYRES, MARK_PAGE, PRECISION);

                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGS);
                     }else{   // lee solo columnas: array 1D
                        if( nDimS == 1 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int cPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              j=cTmp;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }
                     }
                  }else{  // existe desplazamiento de filas y/o columnas, en una página
                     if( !OFFSET_COL ){  // lee solo filas: array 1D
                        if( nDimS == 1 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int cPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              j=cTmp;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }
                     }else{  // lee filas y columnas: array 2D
                        if( nDimS == 2 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int rPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, rPos++);
                              j=cTmp;
                              int cPos=1;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, cPos++);
                                    put_value(pARGC, pARRAY2, k, PRECISION);
                                    hb_itemRelease(pARRAY2);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              hb_itemRelease(pARRAY1);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        } 
                     }
                  }
               }else{    // existe desplazamiento de páginas
                  if( !OFFSET_ROW ){
                     if( !OFFSET_COL ){   // solo desplaza un elemento por página: array 1D
                        if( nDimS == 1 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int cPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              j=cTmp;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }
                     }else{   // lee solo columnas por página: array 2D
                        // esto está mal: deben haber OFFSET_POS filas, y OFFSET_COL columnas, o sea, a verre.
                        // ahora sí:
                        if( nDimS == 2 ){
                           int jRES;
                              int nIncR=SET_INTERVAL_ROW,i=nIniR;
                              if(nFinR < nIniR){
                                 int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                              }
                              //int nLongR=nFinR - nIniR + 1;
                              int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                              int nIncC=SET_INTERVAL_COL,j=nIniC;
                              if(nFinC < nIniC){
                                 int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                              }
                             // int nLongC=nFinC - nIniC + 1;
                              int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                              if(nPagFin < nPagIni){
                                 int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                              }
                              //int nLongP=nPagFin - nPagIni + 1;
                              int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                              int kTmp = k;
                              int iTmp = i;
                            //  int cLongCTmp = nLongC;

                           for(jRES=1; jRES<=d2S; jRES++){  // columnas source

                              int iRES;
                              PHB_ITEM pNEW = hb_itemArrayNew(d1S);
                              for(iRES=1; iRES<=d1S; iRES++){   // filas source
                                 PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, iRES);
                                 PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, jRES);
                                 put_value(pNEW, pARRAY2, iRES, PRECISION); // obtengo primera columna
                                 hb_itemRelease(pARRAY2);
                                 hb_itemRelease(pARRAY1);
                              }

                              int cPos=1;
                              int cLongRTmp=nLongR;
                              i=iTmp;
                              while ( cLongRTmp-- ){
                                 PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 int cLongPTmp=nLongP;
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pNEW, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 hb_itemRelease(pARGF);
                                 i = i + nIncR;
                              }
                              j = j + nIncC;
                              // guardo en cada elemento de cada pagina de la fila y columna asignada.

                              hb_itemRelease(pNEW);
                              
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }  
                     }
                  }else{  // existe desplazamiento de filas y/o columnas, en una página
                     if( !OFFSET_COL ){  // recorre solo filas, una columna, por página: array 2D
                        if( nDimS == 2 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int rPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, rPos++);
                              j=cTmp;
                              int cPos=1;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, cPos++);
                                    put_value(pARGC, pARRAY2, k, PRECISION);
                                    hb_itemRelease(pARRAY2);
                                    k = k + nIncP;
                                 }
                               //  hb_arraySet(pARGF, j, pARGC);
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                            //  hb_arraySet(pPRE, i, pARGF);
                              hb_itemRelease(pARGF);
                              hb_itemRelease(pARRAY1);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        } 
                     }else{  // lee filas y columnas y páginas: array 3D
                        if( nDimS == 3 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int rPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, rPos++);
                              j=cTmp;
                              int cPos=1;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, cPos++);
                                 k=kTmp;
                                 int pPos=1;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY3 = hb_itemArrayGet( pARRAY2, pPos++);
                                    put_value(pARGC, pARRAY3, k, PRECISION);
                                    hb_itemRelease(pARRAY3);
                                    k = k + nIncP;
                                 }
                               //  hb_arraySet(pARGF, j, pARGC);
                                 hb_itemRelease(pARGC);
                                 hb_itemRelease(pARRAY2);
                                 j = j + nIncC;
                              }
                            //  hb_arraySet(pPRE, i, pARGF);
                              hb_itemRelease(pARGF);
                              hb_itemRelease(pARRAY1);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }                
                     }
                  }
               }
            }else{   // es un elemento que se es asignado a una porción del arreglo. Debo modificar
               int nIncR=SET_INTERVAL_ROW,i=nIniR;
               if(nFinR < nIniR){
                  int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
               }
               //int nLongR=nFinR - nIniR + 1;
               int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
               int nIncC=SET_INTERVAL_COL,j=nIniC;
               if(nFinC < nIniC){
                  int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
               }
               //int nLongC=nFinC - nIniC + 1;
               int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
               int nIncP=SET_INTERVAL_PAG,k=nPagIni;
               if(nPagFin < nPagIni){
                  int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
               }
               //int nLongP=nPagFin - nPagIni + 1;
               int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);

               int cTmp = j;
               int kTmp = k;
               while ( nLongR-- ){
                  int cLongCTmp=nLongC;
                  PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                  j=cTmp;
                  while( cLongCTmp-- ){
                     int cLongPTmp=nLongP;
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     k=kTmp;
                     while( cLongPTmp-- ){
                        put_value(pARGC, pARRAYRES, k, PRECISION);
                        k = k + nIncP;
                     }
                    // hb_arraySet(pARGF, j, pARGC);
                     hb_itemRelease(pARGC);
                     j = j + nIncC;
                  }
                 // hb_arraySet(pPRE, i, pARGF);
                  hb_itemRelease(pARGF);
                  i = i + nIncR;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT INITIAL 3D LOCATE ERROR",113);
         }
         if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0; }
         break;
      }default: {
         sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION ERROR",113);
      }
   }
   hb_itemRelease(pARRAYRES);
   hb_itemRelease(pPRE);
//   hb_itemRelease(pARG);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "PUT STACK UNDERFLOW",102);
}
}
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
   fun_clear_interval();
}*/

return sw;
}

/* realiza un volcado del array en el Stack. Sirve para no repetir líneas
   con GET y MOV. Mejor hago GET de una y luego los MOV.
   Atencion! si el array es largo, saturará el stack. */
int fun_dump_array(){
int sw=1;
   PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
   if( nDim==1 ){
       long i;
       for(i=1; i<=d1; ++i){
           PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
           //hb_arrayAdd(pSTACK, pREG);
           if (++CADDR <= nSizeStack ) {
               hb_arraySet(pSTK_ADDR, CADDR, pREG);
           }else{
              /* DECISION: aumentar el size del stack. Si dejo esto así
                 Es probable que logre saturar el stack con un array muy grande...
                 Mejor lo mando a la mierda!! */
              sw=put_error((PHB_ITEM) pRET, "DUMPARRAY STACK OVERFLOW",101); 
           }
           hb_itemRelease(pREG);
       }
   }else{
       sw=put_error((PHB_ITEM) pRET, "DUMPARRAY ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
   }
   hb_itemRelease(pDATO);
return sw;
}
   
   
/* Saca las columnas --desde el stack-- de un array y las deja en el stack. */
int getcol(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "GETCOL ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   CADDR += SWKEEP; SWKEEP = 0;
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "GETCOL REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d2) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim <= 3 ){
          PHB_ITEM pARRAY = hb_itemArrayNew( d1 ); // filas existentes.
          HB_MAXINT i;
          for(i=1; i<=d1; i++){
              PHB_ITEM pARRAYC = hb_itemArrayNew( nLong );
              PHB_ITEM pROW = hb_itemArrayGet( pPREG, i);  // tomo fila "i"
              HB_MAXINT j;

              for(j=0; j<nLong; ++j){
                  PHB_ITEM pCOL = hb_itemArrayGet( pROW, nColDel[ j ] );  // era j
                  put_value((PHB_ITEM) pARRAYC, pCOL, j + 1, PRECISION); // era j + 1
                  hb_itemRelease(pCOL);
              }
              hb_arraySet( pARRAY, i, pARRAYC);
              hb_itemRelease(pARRAYC);
              hb_itemRelease(pROW);
          }
          hb_arraySet(pSTK_ADDR, ++CADDR, pARRAY);
          hb_itemRelease(pARRAY);
          hb_itemRelease(pPREG);
      }else{
          sw=put_error((PHB_ITEM) pRET, "GETCOL SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "GETCOL STACK UNDERFLOW",102);
}
return sw;
}

/* Saca las filas --indicadas en stack-- desde un array y las deja disponibles en stack.
   podría dejar disponibles en una variable: pushvar(X);getrow; */
int getrow(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "GETROW ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   CADDR += SWKEEP; SWKEEP = 0;
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "GETROW REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d1) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim <= 3 ){
          PHB_ITEM pARRAY = hb_itemArrayNew( 0 );
          long i;
          for(i=0; i<nLong; ++i){
              PHB_ITEM pROW = hb_itemArrayGet( pPREG, nColDel[i]);
              hb_arrayAdd( pARRAY, pROW);
              hb_itemRelease(pROW);
          }
          hb_arraySet(pSTK_ADDR, ++CADDR, pARRAY);
          hb_itemRelease(pARRAY);
          hb_itemRelease(pPREG);
      }else{
          sw=put_error((PHB_ITEM) pRET, "GETROW SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "GETROW STACK UNDERFLOW",102);
}
return sw;
}

/* Saca las paginas --indicadas en stack-- desde un array 3D y las deja disponibles en stack.
   podría dejar disponibles en una variable: pushvar(X);getrow; */
int getpage(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "GETPAGE ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   CADDR += SWKEEP; SWKEEP = 0;
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "GETPAGE REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d3) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 3 ){
          
          PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                   long j, cPos=1;
                   for(j=1; j<=d2; j++){
                       PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                       PHB_ITEM pARRAYP = hb_itemArrayNew( nLong );
                       long k,kPos=1;

                       for(k=0; k<nLong; k++){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, nColDel[k]);
                           put_value(pARRAYP, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                       }
                       hb_itemRelease(pARGC);
                       hb_arraySet(pARRAYC, cPos++, pARRAYP);
                       hb_itemRelease(pARRAYP);
                   }
                   hb_arraySet(pARRAY, rPos++, pARRAYC);
                   hb_itemRelease(pARRAYC);
                   hb_itemRelease(pARGF);
               }
               //hb_itemRelease(pPREG);
               //hb_arraySet( pSTK_REG, nItem, pARRAY );
               //hb_itemRelease(pARRAY);
               
          hb_arraySet(pSTK_ADDR, ++CADDR, pARRAY);
          hb_itemRelease(pARRAY);
          hb_itemRelease(pPREG);
      }else{
          sw=put_error((PHB_ITEM) pRET, "GETPAGE SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "GETPAGE STACK UNDERFLOW",102);
}
return sw;
}


/*int catvector(){
int sw=1;

return sw;
}*/

int catrow(/* long nIndexReg*/ ){
int sw=1;
if( CADDR>=1 ){

   int nIndexReg = STK_PRG[++CP];

   PHB_ITEM pARRAY = hb_itemArrayNew( 0 );  // array retorno
      
   // obtener el oprimero: ese manda!
   PHB_ITEM pARRFIRST = (PHB_ITEM) hb_itemArrayGet( pSTK_ADDR, CADDR); // si resto CADDR, me salto el primer array
   if(!HB_IS_ARRAY( pARRFIRST)){
      sw=put_error((PHB_ITEM) pRET, "CATROW REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease( pARRFIRST );
      hb_itemRelease( pARRAY );
//      hb_itemRelease(pPRE);
      //hb_itemRelease(pARG);
      return sw;
   }
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARRFIRST, &nDim, &d1, &d2, &d3, &type);
   hb_itemRelease(pARRFIRST);
   int nLenCol = d2==0?d1:d2;  // un array simple se copiará con "transpuesta".
   
   
   while( CADDR ){
      PHB_ITEM pARRSTACK = (PHB_ITEM) hb_itemArrayGet( pSTK_ADDR, CADDR--);
      if( HB_IS_ARRAY(pARRSTACK) ){
            nDim=0,d1=0,d2=0,d3=0,type=0;
            get_size( (PHB_ITEM) pARRSTACK, &nDim, &d1, &d2, &d3, &type);
            switch(nDim){
               case 1:{
                  if(d1 == nLenCol){
                     hb_arrayAdd( pARRAY, pARRSTACK);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "CATROW SIZE(1D) COLUMN ERROR",113);
                  }
                  break;
               }case 2:{
                  if(d2 == nLenCol){
                     HB_MAXINT i;
                     for(i=1; i<=d1; i++){
                        PHB_ITEM pRow = hb_itemArrayGet( (PHB_ITEM) pARRSTACK, i );
                        hb_arrayAdd( pARRAY, pRow);
                        hb_itemRelease( pRow );
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "CATROW SIZE(2D) COLUMN ERROR",113);
                  }
                  break;
               }default:{
                  sw=put_error((PHB_ITEM) pRET, "CATROW DIMENSION ERROR: MUST BE 1D|2D ARRAY",113);
                  break;
               }
            }
      }else{
         sw=put_error((PHB_ITEM) pRET, "CATROW TYPE MISMATCH",104);
      }
      hb_itemRelease(pARRSTACK);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   hb_arraySet(pSTK_REG, nIndexReg, pARRAY);
   hb_itemRelease( pARRAY );
//   hb_itemRelease(pPRE);
 //  hb_itemRelease(pARG);
}else{
   sw=put_error((PHB_ITEM) pRET, "CATROW STACK UNDERFLOW",102);
}
return sw;
}

/* DECISION: añadir opción para seleccionar columnas en 3D, con MARK_PAGE, o solo dejarlo para 2D y VERIFICAR ESO */
int catcol(/* long nIndexReg */){
int sw=1;
if( CADDR>=2 ){

   int nIndexReg = STK_PRG[++CP];

   int nNumCols = 0;
   PHB_ITEM pCols[CADDR];  // arrays de punteros PHB_ITEM 
   int numCols[CADDR];
   
   pCols[ nNumCols ] = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   if (!HB_IS_ARRAY(pCols[ nNumCols ])){
      sw=put_error((PHB_ITEM) pRET, "CATCOL REGISTER TYPE IS NOT AN ARRAY",103);
//      hb_itemRelease(pPRE);
     // hb_itemRelease(pARG);
      return sw;
   }
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pCols[ nNumCols ], &nDim, &d1, &d2, &d3, &type);
   int nLenRow = d1, nLenCol=d2==0?1:d2;
   numCols[nNumCols] = d2;

   while( CADDR ){
      nNumCols++;
      pCols[ nNumCols ] = (PHB_ITEM) hb_itemArrayGet( pSTK_ADDR, CADDR--);
      if( !HB_IS_ARRAY( (PHB_ITEM)pCols[ nNumCols ] ) ){
         sw=put_error((PHB_ITEM) pRET, "CATCOL TYPE MISMATCH",104);
//         hb_itemRelease(pPRE);
       //  hb_itemRelease(pARG);
         int i;
         for(i=0; i<=nNumCols; i++){
            hb_itemRelease( pCols[ i ] );
         }
         return sw;      
      }
      nDim=0;d1=0;d2=0;d3=0;type=0;
      get_size( (PHB_ITEM) pCols[ nNumCols ], &nDim, &d1, &d2, &d3, &type);
      if(d1 != nLenRow){
         sw=put_error((PHB_ITEM) pRET, "CATCOL SIZE ROW ERROR",106);
//         hb_itemRelease(pPRE);
       //  hb_itemRelease(pARG);
         int i;
         for(i=0; i<=nNumCols; i++){
            hb_itemRelease( pCols[ i ] );
         }
         return sw;
      }
      numCols[nNumCols] = d2;

      nLenCol += d2==0?1:d2;
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   PHB_ITEM pARRAY = hb_itemArrayNew( 0 );

   HB_MAXINT j;

   for(j=1; j<=nLenRow; j++){
      int nArray=0;
      PHB_ITEM pARRAYADD = hb_itemArrayNew( nLenCol );
      int i;
      for(i=0; i<=nNumCols; i++){  // recorro cada array
         if(numCols[i]>0){   // matriz: añado la fila j.
            PHB_ITEM pRow = hb_itemArrayGet( (PHB_ITEM) pCols[ i ], j );  // fila i, de array i
            HB_MAXINT k;
            for(k=1; k<=numCols[i]; k++){
               PHB_ITEM pCol = hb_itemArrayGet( pRow, k );
               put_value((PHB_ITEM) pARRAYADD, pCol, ++nArray, PRECISION);
               hb_itemRelease( pCol );
            }
            hb_itemRelease( pRow );
         }else{   // array simple: añado el elemento de esa fila j en particular
            PHB_ITEM pCol = hb_itemArrayGet( (PHB_ITEM) pCols[ i ], j );
            put_value((PHB_ITEM) pARRAYADD, pCol, ++nArray, PRECISION);
            hb_itemRelease( pCol );
         }
      }
      hb_arrayAdd( pARRAY, pARRAYADD);
      hb_itemRelease( pARRAYADD );
   } 
   hb_arraySet(pSTK_REG, nIndexReg, pARRAY);
   hb_itemRelease( pARRAY );
   HB_MAXINT h;
   for(h=0; h<=nNumCols; h++){
      hb_itemRelease( (PHB_ITEM)pCols[ h ] );
   }
//   hb_itemRelease(pPRE);
 //  hb_itemRelease(pARG);

}else{
   sw=put_error((PHB_ITEM) pRET, "CATCOL STACK UNDERFLOW",102);
}
return sw;
}


//int putpage( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int putpage( /*long nIndexReg*/ ){
int sw=1;
if( CADDR>0 ){

   long nIndexReg = STK_PRG[ ++CP ];

   PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nIndexReg );
   
   if( HB_IS_ARRAY(pPRE)){

      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pPRE, &nDim, &d1, &d2, &d3, &type);  // verificar si registro destino puede recibir los datos
      if( nDim==3 && d3>0 ){
         if( MARK_PAGE<=d3 && MARK_PAGE>0 ){
            int i;
            if( CADDR>0 ){
               PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               CADDR += SWKEEP; SWKEEP = 0;
               if(HB_IS_ARRAY(pARRAY)){
                  HB_MAXINT nDim1=0,d11=0,d21=0, d31=0,type1=0;
                  get_size( (PHB_ITEM) pARRAY, &nDim1, &d11, &d21, &d31, &type1);
                  type=0; type1=0;
                  if( nDim1==2 && d1==d11 && d2==d21 ){
                     for( i=1; i<=d1; i++ ){
                        PHB_ITEM pARRAYF = hb_itemArrayGet( pARRAY, i);  // saco fila de STACK
                        PHB_ITEM pREGF = hb_itemArrayGet( pPRE, i);      // saco fila de REG
               
                        int j;
                        for( j=1; j<=d2; j++ ){
                           PHB_ITEM pARRAYC = hb_itemArrayGet( pARRAYF, j);   // columna del stack
                           PHB_ITEM pREGC = hb_itemArrayGet( pREGF, j);     // columna del registro
                           hb_arraySet( pREGC, MARK_PAGE, pARRAYC );
                           hb_arraySet( pREGF, j, pREGC );
                           hb_itemRelease( pREGC );
                           hb_itemRelease( pARRAYC );
                        }
                      //  hb_arraySet( pPRE, i, pREGF );
                        hb_itemRelease( pREGF );
                        hb_itemRelease( pARRAYF );
                     }
                    // hb_arraySet(pSTK_REG, nIndexReg, pPRE);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "PUTPAGE DIMENSION SOURCE ERROR",106);
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUTPAGE ARRAY TYPE IS NOT AN ARRAY",103);
               }
               hb_itemRelease(pARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "PUTPAGE STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUTPAGE MARK PAGE OVERFLOW",113);
         }   
      }else{
         sw=put_error((PHB_ITEM) pRET, "PUTPAGE DIMENSION TARGET ERROR",106);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PUTPAGE REGISTER TYPE IS NOT AN ARRAY",103);
   }
//   hb_itemRelease(pARG);
   hb_itemRelease(pPRE);
}else{
   sw=put_error((PHB_ITEM) pRET, "PUTPAGE STACK UNDERFLOW",102);
}
return sw;
}


int fun_mklist(){
int sw=1;
if(CADDR){
   int nIndex=0;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(nIndex<=CADDR){
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, ++nIndex);
      const char * Escape = hb_itemGetCPtr(pDATO);
      hb_itemRelease(pDATO);
      if (Escape[0]=='\033') break;
   }
   int nTope = nIndex; // para borra ESC.
 //  printf("FOUND = %d\n",nTope);
 //  hb_arraySetNI( pSTK_ADDR, nTope, 0 );
   nIndex++;
   while(nIndex<=CADDR){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "MKLIST ARGUMENT ERROR (ARRAY DIMENSION <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      ///hb_arrayAdd( pSTACK, pDATO );
      hb_itemRelease(pDATO);
   }
   //CADDR += SWKEEP; 
   SWKEEP = 0;
   CADDR = nTope-1;
 //  printf("NEWCADDR = %d\n",CADDR);
   hb_arraySet( pSTK_ADDR, ++CADDR, pSTACK );
   hb_itemRelease(pSTACK);
   
}
return sw;
}

int fun_pushall(){
   int sw=1;
   int nItem = STK_PRG[++CP];
   int nIndex=1;
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
   while(CADDR){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "PUSHALL ARGUMENT ERROR (ARRAY DIMENSION <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   hb_itemRelease(pSTACK);
   CADDR += SWKEEP; SWKEEP = 0;
   return sw;
}

int add_item_row(){
int sw=1;

   if ( CADDR>0 ){

      int nItem = STK_PRG[ ++CP ];

      PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); //
      
      
      unsigned int nMasterLong=CADDR;
      
      long uarray = hb_arrayLen( pPREG );
      PHB_ITEM pARR = hb_itemArrayGet( pPREG, 1 );
      long uiArrayLenReg = ( long ) hb_arrayLen( pARR );
      hb_itemRelease(pARR);
      
      PHB_ITEM pARRAY=hb_itemArrayNew(nMasterLong);
      int ndx = 1;
      while(CADDR && sw){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndx );
         if (!HB_IS_ARRAY(pSource)){  // 1-NOV-2022
            put_value( pARRAY, pSource, ndx, PRECISION);
         }else{
            //sw=put_error((PHB_ITEM) pRET, "ADDROW ARGUMENT ERROR (NOT SINGLE VALUE)",103);
            HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
            get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
            if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pSource );
                hb_arraySize(pARRAY,--nMasterLong);
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pSource, i);
                    hb_arrayAdd(pARRAY, pREG);
                    hb_itemRelease(pREG);
                }
            }else{
                sw=put_error((PHB_ITEM) pRET, "ADDROW ARGUMENT ERROR (ARRAY DIMENSION <> 1)",103);
            }
         }
         hb_itemRelease(pSource);
         ++ndx;
         --CADDR;
      }
      CADDR += SWKEEP; SWKEEP = 0;
      if(sw){
         if( uarray > 0 ){  // ya hay datos en REG
            long uiArrayLenARRAY = ( long ) hb_arrayLen( pARRAY );
            if( uiArrayLenARRAY == uiArrayLenReg ){
               hb_arraySize( pPREG, uarray + 1 );
               hb_arraySet( pPREG, uarray + 1, (PHB_ITEM) pARRAY );
            }else{
               sw=put_error((PHB_ITEM) pRET, "ADDROW DIMENSION ERROR",106);
            }
         }else{
            hb_arrayAdd( pPREG, (PHB_ITEM) pARRAY );
         }
      }
      hb_itemRelease(pPREG);
      hb_itemRelease(pARRAY);
   }else{
      sw=put_error((PHB_ITEM) pRET, "ADDROW STACK OVERFLOW",101);
   }
return sw;
}

int fun_inspags(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "INSPAGS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "INSPAGS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nPagIns[nLong], nPagSup=0, nValid=0, cPos=0;
   
   long i;
   for(i=0;i<nLong;++i) nPagIns[i]=0; // para que valgrind no patalee!!
   
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0) {--nLong;/*--tLong;*/}  // para que no omita la última columna
       else if(nValid>d3) {
           int nAdd = nValid>d3+nPagSup ? (nValid - d3 - nPagSup) : 0;
           nPagSup += nAdd;
           --nLong;
           //nPagIns[cPos++] = nValid;
           }
       else {nPagIns[cPos++] = nValid;}
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 3 ){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 );
               //int ntPagSup = nPagSup;
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                   long j=0, cPos=1;
                   for (j=1; j<=d2; j++){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                        PHB_ITEM pPAGS = hb_itemArrayNew( d3 + nLong + nPagSup );
                        
                        long k,kPos=1;
                        for(k=1; k<=d3; k++){
                            long c;
                            for (c=0; c<nLong; c++){
                                if ( k == nPagIns[c] ){
                                    hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                                    //--ntPagSup;
                                    break;
                                }
                            }
                            PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                            put_value(pPAGS, pARGP, kPos++, PRECISION);
                            hb_itemRelease(pARGP);
                        }
                        for(k=1; k<=nPagSup; k++){
                            hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                        }
                        hb_arraySet(pCOLS, cPos++, pPAGS);
                        hb_itemRelease(pPAGS);
                        hb_itemRelease(pARGC);
                   }
                   hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                   hb_itemRelease(pCOLS);
                   hb_itemRelease(pARGF);
               }

              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);   

      }else{
          sw=put_error((PHB_ITEM) pRET, "INSPAGS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "INSPAGS STACK UNDERFLOW",102);
}
return sw;
}


int fun_insrows(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "INSROWS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "INSROWS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nRowIns[nLong], nRowSup=0, nValid=0, cPos=0;
   
   long i;
   for(i=0;i<nLong;++i) nRowIns[i]=0; // para que valgrind no patalee!!
   
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0) {--nLong;}  // para que no omita la última columna
       else if(nValid>d1) {
           int nAdd = nValid>d1+nRowSup ? (nValid - d1 - nRowSup) : 0;
           nRowSup += nAdd;
           --nLong;
           }
       else {nRowIns[cPos++] = nValid;}
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 + nLong + nRowSup );
                 long i=0, rPos=1;
                 int ntRowSup = nRowSup;
                 for (i=1; i<=d1; i++){  // busco cada fila que quiero insertar
                     long c;
                     for (c=0; c<nLong; c++){
                         if ( i == nRowIns[c] ){
                             PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                             long j=0, cPos=1;
                             for (j=1; j<=d2; j++){ 
                                 hb_arraySetND(pCOLS, cPos++, CTE_NAN);
                             }
                             hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                             hb_itemRelease(pCOLS);
                             //--ntRowSup;
                             break;
                         }
                     }
                     PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                     long j=0, cPos=1;
                     for (j=1; j<=d2; j++){ 
                         PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                         put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                         hb_itemRelease(pCOLUMNA);
                     }
                     hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                     hb_itemRelease(pFILA);
                 }
                 int extraFila=0;
                 for (extraFila=rPos; extraFila<rPos+ntRowSup; ++extraFila){
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                     long j=0, cPos=1;
                     for (j=1; j<=d2; j++){
                          hb_arraySetND(pCOLS, cPos++, CTE_NAN);
                     }
                     hb_arraySet( pROWS, extraFila, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                 }
              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);

      }else if (nDim == 3){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 + nLong + nRowSup );
               int ntRowSup = nRowSup;
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   long c;
                   for (c=0; c<nLong; c++){
                       if ( i == nRowIns[c] ){
                           PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                           long j=0, cPos=1;
                           for (j=1; j<=d2; j++){ 
                               PHB_ITEM pPAGS = hb_itemArrayNew( d3 );
                               long k,kPos=1;
                               for(k=1; k<=d3; k++){
                                  hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                               }
                               hb_arraySet(pCOLS, cPos++, pPAGS);
                               hb_itemRelease(pPAGS);
                           }
                           hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                           hb_itemRelease(pCOLS);
                           //--ntRowSup;
                           break; 
                       }
                   }
                   PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   long j=0, cPos=1;
                   for (j=1; j<=d2; j++){ 
                       PHB_ITEM pPAGS = hb_itemArrayNew( d3 );
                       PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                       long k,kPos=1;
                       for(k=1; k<=d3; k++){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pPAGS, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                       }
                       hb_arraySet(pCOLS, cPos++, pPAGS);
                       hb_itemRelease(pPAGS);
                       hb_itemRelease(pARGC);
                   }
                   hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                   hb_itemRelease(pCOLS);
                   hb_itemRelease(pARGF);
               }
               int extraFila=0;
               for (extraFila=rPos; extraFila<rPos+ntRowSup; ++extraFila){
                   PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                   long j=0, cPos=1;
                   for (j=1; j<=d2; j++){
                       PHB_ITEM pPAGS = hb_itemArrayNew( d3 );
                       long k,kPos=1;
                       for(k=1; k<=d3; k++){
                           hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                       }
                       hb_arraySet(pCOLS, cPos++, pPAGS);
                       hb_itemRelease(pPAGS);
                   }
                   hb_arraySet( pROWS, extraFila, (PHB_ITEM) pCOLS );
                   hb_itemRelease(pCOLS);
               }
              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);   

      }else{
          sw=put_error((PHB_ITEM) pRET, "INSROWS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "INSROWS STACK UNDERFLOW",102);
}
return sw;
}

int fun_inscols(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "INSCOLS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "INSCOLS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColIns[nLong], nColSup=0, nValid=0, cPos=0;
   
   long i;
   for(i=0;i<nLong;++i) nColIns[i]=0; // para que valgrind no patalee!!
   
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0) {--nLong;}  // para que no omita la última columna
       else if(nValid>d2) {
           int nAdd = nValid>d2+nColSup ? (nValid - d2 - nColSup) : 0;
           nColSup += nAdd;
           --nLong;
           }
       else {nColIns[cPos++] = nValid;}
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 );
                 long i=0, rPos=1;
                 
                 for (i=1; i<=d1; i++){  // busco cada columna que quiero borrar
                     int ntColSup = nColSup;
                     PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 + nLong + nColSup  ); // Si
                     long j=0, cPos=1;
                     for (j=1; j<=d2; j++){  // busco cada columna que quiero borrar
                         long c;
                         for (c=0; c<nLong; c++){
                             if ( j == nColIns[c] ){
                                 hb_arraySetND(pCOLS, cPos++, CTE_NAN);
                                 //--ntColSup;
                                 break;
                             }
                         }
                         PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                         put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                         hb_itemRelease(pCOLUMNA);
                     }
                     int extraColumna=0;
                     for (extraColumna=cPos; extraColumna<cPos+ntColSup; ++extraColumna){
                         hb_arraySetND(pCOLS, extraColumna, CTE_NAN);
                        // put_value(pCOLS, pNAN, extraColumna, PRECISION);
                     }
                     hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                     hb_itemRelease(pFILA);
                 }
                 
              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);

      }else if (nDim == 3){
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;

               for(i=1; i<=d1; i++){
                  int ntColSup = nColSup;
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 + nLong + nColSup );
                  PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                  long j, cPos=1;
                  for(j=1; j<=d2; j++){
                     long c;
                     for (c=0; c<nLong; c++){
                         if ( j == nColIns[c] ){
                             PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                             long k,kPos=1;
                             for(k=1; k<=d3; k++){
                                hb_arraySetND(pARRAYP, kPos++, CTE_NAN);
                             }
                             hb_arraySet(pARRAYC, cPos++, pARRAYP);
                             hb_itemRelease(pARRAYP);
                             //--ntColSup;
                             break;
                         }
                     }

                     PHB_ITEM pARRAYP1 = hb_itemArrayNew( d3 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     long k,kPos=1;
                     for(k=1; k<=d3; k++){
                         PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                         put_value(pARRAYP1, pARGP, kPos++, PRECISION);
                         hb_itemRelease(pARGP);
                     }
                     hb_itemRelease(pARGC);
                     hb_arraySet(pARRAYC, cPos++, pARRAYP1);

                     hb_itemRelease(pARRAYP1);
                  }
                  int extraColumna=0;
                  for (extraColumna=cPos; extraColumna<cPos+ntColSup; ++extraColumna){
                      PHB_ITEM pARRAYP1 = hb_itemArrayNew( d3 );
                      long k,kPos=1;
                      for(k=1; k<=d3; k++){
                          hb_arraySetND(pARRAYP1, kPos++, CTE_NAN);
                      }
                      hb_arraySet(pARRAYC, extraColumna, pARRAYP1);
                      hb_itemRelease(pARRAYP1);
                  }
                  hb_arraySet(pARRAY, rPos++, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
      }else{
          sw=put_error((PHB_ITEM) pRET, "INSCOLS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "INSCOLS STACK UNDERFLOW",102);
}
return sw;
}

int fun_delpags(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "DELPAGS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "DELPAGS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d3) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if (nDim == 3){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                   long j, cPos=1;
                   for(j=1; j<=d2; j++){
                       PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                       PHB_ITEM pARRAYP = hb_itemArrayNew( d3 - nLong );
                       long k,kPos=1;
                       for(k=1; k<=d3; k++){
                           long c;
                           int swRetiene=1;
                           for (c=0; c<nLong; c++){
                               if ( k == nColDel[c] ){
                                    swRetiene=0;break;
                               }
                           }
                           if (swRetiene){
                               PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                               put_value(pARRAYP, pARGP, kPos++, PRECISION);
                               hb_itemRelease(pARGP);
                           }
                       }
                       hb_itemRelease(pARGC);
                       hb_arraySet(pARRAYC, cPos++, pARRAYP);
                       hb_itemRelease(pARRAYP);
                   }
                   hb_arraySet(pARRAY, rPos++, pARRAYC);
                   hb_itemRelease(pARRAYC);
                   hb_itemRelease(pARGF);
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELPAGS #PAGES TO DEL > #PAGES OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "DELPAGS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "DELPAGS STACK UNDERFLOW",102);
}
return sw;
}


int fun_delrows(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "DELROWS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "DELROWS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d1) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pROWS = hb_itemArrayNew( d1 - nLong );
              
                 long i, rPos=1;
                 for (i=1; i<=d1; i++){  // busco cada fila que quiero borrar
                     long c;
                     int swRetiene=1;
                     for (c=0; c<nLong; c++){
                         if ( i == nColDel[c] ){
                             swRetiene=0;break;
                         }
                     }
                     if (swRetiene){
                         PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                         PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                         long j, cPos=1;
                         for (j=1; j<=d2; j++){
                             PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                             put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                             hb_itemRelease(pCOLUMNA);
                         }
                         hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                         hb_itemRelease(pCOLS);
                         hb_itemRelease(pFILA);
                     }
                 }
                 hb_itemRelease(pPREG);
                 hb_arraySet( pSTK_REG, nItem, pROWS);
                 hb_itemRelease(pROWS);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELROWS #ROWS TO DEL > #ROWS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else if (nDim == 3){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 - nLong );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   long c;
                   int swRetiene=1;
                   for (c=0; c<nLong; c++){
                       if ( i == nColDel[c] ){
                             swRetiene=0;break;
                       }
                   }
                   if (swRetiene){
                       PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                       PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                       long j, cPos=1;
                       for(j=1; j<=d2; j++){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                           long k,kPos=1;
                           for(k=1; k<=d3; k++){
                               PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                               put_value(pARRAYP, pARGP, kPos++, PRECISION);
                               hb_itemRelease(pARGP);
                           }
                           hb_itemRelease(pARGC);
                           hb_arraySet(pARRAYC, cPos++, pARRAYP);
                           hb_itemRelease(pARRAYP);
                       }
                       hb_arraySet(pARRAY, rPos++, pARRAYC);
                       hb_itemRelease(pARRAYC);
                       hb_itemRelease(pARGF);
                   }
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELROWS #ROWS TO DEL > #ROWS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "DELROWS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "DELROWS STACK UNDERFLOW",102);
}
return sw;
}


int fun_delcols(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "DELCOLS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "DELCOLS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d2) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pROWS = hb_itemArrayNew( d1 );
              
                 long i, rPos=1;
                 for (i=1; i<=d1; i++){  // busco cada columna que quiero borrar
                     PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 - nLong ); // Si
                     long j, cPos=1;
                     for (j=1; j<=d2; j++){  // busco cada columna que quiero borrar
                         long c;
                         int swRetiene=1;
                         for (c=0; c<nLong; c++){
                             if ( j == nColDel[c] ){
                                 swRetiene=0;break;
                             }
                         }
                         if (swRetiene){
                             PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                             put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                             hb_itemRelease(pCOLUMNA);
                         }
                     }
                     hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                     hb_itemRelease(pFILA);
                 }

              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELCOLS #COLUMNS TO DEL > #COLUMNS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else if (nDim == 3){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 - nLong );
                  PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                  long j, cPos=1;
                  for(j=1; j<=d2; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                     long c;
                     int swRetiene=1;
                     for (c=0; c<nLong; c++){
                         if ( j == nColDel[c] ){
                             swRetiene=0;break;
                         }
                     }
                     if (swRetiene){
                         PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                         long k,kPos=1;
                         for(k=1; k<=d3; k++){
                            PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                            put_value(pARRAYP, pARGP, kPos++, PRECISION);
                            hb_itemRelease(pARGP);
                         }
                         hb_itemRelease(pARGC);
                         hb_arraySet(pARRAYC, cPos++, pARRAYP);
                     }
                     hb_itemRelease(pARRAYP);
                  }
                  hb_arraySet(pARRAY, rPos++, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELCOLS #COLUMNS TO DEL > #COLUMNS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "DELCOLS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "DELCOLS STACK UNDERFLOW",102);
}
return sw;
}


int revisa_cadena(const char * cText, HB_SIZE nLen, int *nPos, int Search, int tipo){
int vRet=1;
unsigned int i;
const char *pText = cText;
for(i=0;i<nLen;i++){
   char c = *pText;
   switch(tipo){
      case 0: {  // isalpha
         if(Search){
            if( !isalpha(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isalpha(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 1: {  // isdigit
         if(Search){
            if( !isdigit(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isdigit(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 2: {  // isalnum
         if(Search){
            if( !isalnum(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{   
            if( !isalnum(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 3: {  // isascii
         if(Search){
            if( !isascii(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isascii(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 4: {  // iscntrl
         if(Search){
            if( !iscntrl(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !iscntrl(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 5: {  // isgraph
         if(Search){
            if( !isgraph(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isgraph(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 6: {  // ispunct
         if(Search){
            if( !ispunct(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !ispunct(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 7: {  // isspace
         if(Search){
            if( !isspace(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isspace(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 8: {  // isxdigit
         if(Search){
            if( !isxdigit(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isxdigit(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 9: {  // isprint
         if(Search){
            if( !isprint(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isprint(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 10: {  // isupper
         if(Search){
            if( !isupper(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isupper(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 11: {  // islower
         if(Search){
            if( !islower(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !islower(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 12: {  // isblank
         if(Search){
            if( !isblank(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isblank(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }
   }
   ++pText;
}
return vRet;
}

// {v,"tipo consultado"}type char? -> T o F
int type_item_string(){
int sw=1;
if( CADDR >= 2 ){
   PHB_ITEM pTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pVAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( !HB_IS_ARRAY( pVAR ) ){
      const char * cText = hb_itemGetCPtr(pVAR);
      HB_SIZE nLen = hb_itemGetCLen(pVAR);
      const char * cType = hb_itemGetCPtr(pTYPE);
      int nPos = 0;
      int Search = nPCP == 346? 1:0;
      if (strcmp(cType,"alpha")==0) { 
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 0);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"digit")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 1);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"alnum")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 2);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"ascii")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 3);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"cntrl")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 4);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"graph")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 5);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"punct")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 6);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"space")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 7);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"xdigit")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 8);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"print")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 9);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"upper")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 10);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"lower")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 11);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"blank")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 12);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else{
         sw=put_error((PHB_ITEM) pRET, "TYPE STRING? TYPE ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "TYPE STRING? ARGUMENT ERROR",103);
   }
   hb_itemRelease(pTYPE);
   hb_itemRelease(pVAR);
}else{
   sw=put_error((PHB_ITEM) pRET, "TYPE STRING? INNER-STACK OVERFLOW",101);
}
return sw;
}
// {v,"tipo consultado"}type char? -> T o F
int type_item_char(){
int sw=1;
if( CADDR >= 2 ){
   PHB_ITEM pTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pVAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( !HB_IS_ARRAY( pVAR ) ){
      const char * cText = hb_itemGetCPtr(pVAR);
      const char * cType = hb_itemGetCPtr(pTYPE);
      char c = cText[0];  // primer caracter.
      if (strcmp(cType,"alpha")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isalpha(c) );
      else if (strcmp(cType,"digit")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isdigit(c) );
      else if (strcmp(cType,"alnum")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isalnum(c) );
      else if (strcmp(cType,"ascii")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isascii(c) );
      else if (strcmp(cType,"cntrl")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  iscntrl(c) );
      else if (strcmp(cType,"graph")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isgraph(c) );
      else if (strcmp(cType,"punct")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  ispunct(c) );
      else if (strcmp(cType,"space")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isspace(c) );
      else if (strcmp(cType,"xdigit")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isxdigit(c) );
      else if (strcmp(cType,"print")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isprint(c) );
      else if (strcmp(cType,"upper")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isupper(c) );
      else if (strcmp(cType,"lower")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  islower(c) );
      else if (strcmp(cType,"blank")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isblank(c) );
      else
         sw=put_error((PHB_ITEM) pRET, "TYPE CHAR? TYPE ARGUMENT ERROR",103);
   }else{
      sw=put_error((PHB_ITEM) pRET, "TYPE CHAR? ARGUMENT ERROR",103);
   }
   hb_itemRelease(pTYPE);
   hb_itemRelease(pVAR);
}else{
   sw=put_error((PHB_ITEM) pRET, "TYPE CHAR? INNER-STACK OVERFLOW",101);
}
return sw;
}

//int type_item( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int type_item(/* int nItem*/ ){
int sw=1;
if( CADDR < nSizeStack ){

   
  // determinar si es instrucción o función
   PHB_ITEM pARRAY;
   if(nPCP == 226){
      int nItem = STK_PRG[ ++CP ];
      pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   }else{
      pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
   }
   if( !HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT type=0;
      get_item_type( (PHB_ITEM) pARRAY, &type);
      switch( type ){
         case 10: {   // string
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "string" );
            break;
         }case 11: case 12: case 13: {  // numint, double, long
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "number" );
            break;
         }case 14: {   // logical
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "boolean" );
            break;
         }
      }
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      switch(type){
         case 10: hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "<string>"  ); break;
         case 11: hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "<number>"  ); break;
         case 12: hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "<boolean>"  ); break;
      }
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "TYPE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_pages(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, d3 );

   }else{
      sw=put_error((PHB_ITEM) pRET, "PAGES ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "PAGES INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_cols(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, d2 );

   }else{
      sw=put_error((PHB_ITEM) pRET, "COLS ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "COLS INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_rows(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, d1 );

   }else{
      sw=put_error((PHB_ITEM) pRET, "ROWS ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "ROWS INNER-STACK OVERFLOW",101);
}
return sw;
}
int fun_get_dims(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, nDim );

   }else{
      sw=put_error((PHB_ITEM) pRET, "DIMS ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "DIMS INNER-STACK OVERFLOW",101);
}
return sw;
}
//int size_array( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int size_array(/* int nItem*/ ){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      PHB_ITEM pSIZE = hb_itemArrayNew( nDim + 1 );
      hb_arraySetNInt( pSIZE, 1, (HB_MAXINT)  nDim  );
      hb_arraySetNInt( pSIZE, 2, (HB_MAXINT)  d1  );
      if(nDim==2) hb_arraySetNInt( pSIZE, 3, (HB_MAXINT)  d2  );
      if(nDim==3) {hb_arraySetNInt( pSIZE, 3, (HB_MAXINT)  d2  );
                   hb_arraySetNInt( pSIZE, 4, (HB_MAXINT)  d3  );}
      hb_arraySet( pSTK_ADDR, ++CADDR, pSIZE );
      hb_itemRelease(pSIZE);
   }else{
      //sw=put_error((PHB_ITEM) pRET, "SIZE ARGUMENT ERROR");
      PHB_ITEM pSIZE = hb_itemArrayNew( 2 );
      hb_arraySetNInt( pSIZE, 1, (HB_MAXINT)  0  );
      HB_MAXINT size = 0;
      if( HB_IS_STRING( pARRAY ) )          size = sizeof(char) * hb_itemGetCLen(pARRAY) ;
      else if( HB_IS_DOUBLE( pARRAY ) )    size = sizeof( hb_itemGetND(pARRAY) );
      else if( HB_IS_LONG( pARRAY ) )       size = sizeof( hb_itemGetNL(pARRAY) );
      else if( HB_IS_INTEGER( pARRAY ) )    size = sizeof( hb_itemGetNInt(pARRAY) );

      hb_arraySetNInt( pSIZE, 2, (HB_MAXINT) size  );

      hb_arraySet( pSTK_ADDR, ++CADDR, pSIZE );
      hb_itemRelease(pSIZE);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "SIZE INNER-STACK OVERFLOW",101);
}
return sw;
}


int fun_create_fun_array( /*int nARG1,*/ /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP==210 ? 5 : nPCP==321 ? 6 : nPCP-230;
   // extrae argumentos:
   long nARG1 = STK_PRG[++CP];  // indice de REG
////   printf("nARG1 = %d\nSTK_PRG = %ld\n",nARG1,hb_itemGetNInt(hb_itemArrayGet(pSTK_REG,nARG1)));
   PHB_ITEM pDato=NULL; //hb_itemNew(NULL);
   if(tCompare==5/*210*/){ // primer dato del stack será el elemento para relleno
//      tCompare=5;
      if(CADDR>=2){
         //hb_itemClear(pDato);
         pDato = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      }
   }
   PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nARG1);
   int esAbstracta = hb_itemGetNInt(pABSTRACT);
  // printf("ABSTRACT = %d",esAbstracta);
   hb_itemRelease(pABSTRACT);
   
   // saco dato desde ADDR para size de ARRAY: 1,2 y 3.
   if( CADDR==0 || (tCompare==5 && !pDato ) ){
      sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE ERROR",106);
   }else if( CADDR==1 ){  // 1D
      PHB_ITEM pSize = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( HB_IS_NUMERIC( pSize ) ) {
         HB_MAXINT nSize = hb_itemGetNL( pSize );
         if (nSize > 0){
            PHB_ITEM pARRAY = hb_itemArrayNew( nSize );
            HB_MAXINT i;
            for(i=1; i<=nSize; i++){
               switch( tCompare ){
                  case 1:{ hb_arraySetND(pARRAY, i, hb_random_num()); break; }
                  case 2:{ hb_arraySetNInt(pARRAY, i, 0); break; }
                  case 3: case 4: { hb_arraySetNInt(pARRAY, i, 1); break; }
                  case 5:{ hb_arraySet(pARRAY, i, pDato); break; }
                  case 6:{ hb_arraySetND(pARRAY, i, CTE_NAN); break; }  // nan array
               }
            }
            /* Es una matriz abstracta, o una matriz concreta? 0=abstracta */
         
            if (esAbstracta==-1 )  // es abstracta!
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
            else
               hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
            hb_itemRelease(pARRAY);
         }else{
            sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(1D) NEGATIVE OR ZERO ARGUMENT ERROR",106);
         }
      }else{
         //eRROR
         sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(1D) NOT A NUMBER ARGUMENT ERROR",106);
      }
      hb_itemRelease(pSize);
   }else if( CADDR==2 ){   // 2D
      PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizeCol ) ) {
         PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         if( HB_IS_NUMERIC( pSizeRow ) ) {
            HB_MAXINT i;
            HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
            if (nSizeRow > 0){
               HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
               if (nSizeCol > 0){        
                  PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
                  for(i=1; i<=nSizeRow; i++){
                     PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
                     HB_MAXINT j;
                     for(j=1; j<=nSizeCol; j++){
                        switch( tCompare ){
                           case 1:{ hb_arraySetND(pARRAYC, j, hb_random_num()); break; }
                           case 2:{ hb_arraySetNInt(pARRAYC, j, 0); break; }
                           case 3:{ hb_arraySetNInt(pARRAYC, j, 1); break; }
                           case 4:{
                              if(i == j) hb_arraySetNInt(pARRAYC, j, 1);
                              else       hb_arraySetNInt(pARRAYC, j, 0);
                              break;
                           }
                           case 5:{ hb_arraySet(pARRAYC, j, pDato); break; }
                           case 6:{ hb_arraySetND(pARRAYC, j, CTE_NAN); break; }  // nan array
                        }
//                        hb_arraySetND(pARRAYC, j, hb_random_num());
                     }
                     hb_arraySet(pARRAY, i, pARRAYC);
                     hb_itemRelease(pARRAYC);
                  }
            /* Es una matriz abstracta, o una matriz concreta? 0=abstracta */
                  if (esAbstracta==-1 )  // es abstracta!
                     hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
                  else
                     hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
                  hb_itemRelease(pARRAY);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NEGATIVE OR ZERO ARGUMENT ERROR",106);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NEGATIVE OR ZERO ARGUMENT ERROR",106);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NOT A NUMBER ARGUMENT ERROR",106);
         }
         hb_itemRelease(pSizeRow);
      }else{
         sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NOT A NUMBER ARGUMENT ERROR",106);
      }
      hb_itemRelease(pSizeCol);
   }else if( CADDR>=3 ){   // 3D
      PHB_ITEM pSizePag = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizePag ) ) {
         PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         if( HB_IS_NUMERIC( pSizeCol ) ) {
            PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
            CADDR += SWKEEP; SWKEEP = 0;
            if( HB_IS_NUMERIC( pSizeRow ) ) {
               HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
               HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
               HB_MAXINT nSizePag = hb_itemGetNInt( pSizePag );
               if(nSizeRow > 0){
                  if(nSizeCol > 0){
                     if(nSizePag > 0){
                        HB_MAXINT i;
                          
                        PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
                        for(i=1; i<=nSizeRow; i++){
                           HB_MAXINT j;
                           PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
                           for(j=1; j<=nSizeCol; j++){
                              PHB_ITEM pARRAYP = hb_itemArrayNew( nSizePag );
                              HB_MAXINT k;
                              for(k=1; k<=nSizePag; k++){
                                 switch( tCompare ){
                                    case 1:{ hb_arraySetND(pARRAYP, k, hb_random_num()); break; }
                                    case 2:{ hb_arraySetNInt(pARRAYP, k, 0); break; }
                                    case 3:{ hb_arraySetNInt(pARRAYP, k, 1); break; }
                                    case 4:{
                                       if(i == j) hb_arraySetNInt(pARRAYP, k, 1);
                                       else       hb_arraySetNInt(pARRAYP, k, 0);
                                    break;
                                    }
                                    case 5:{ hb_arraySet(pARRAYP, k, pDato); break; }
                                    case 6:{ hb_arraySetND(pARRAYP, k, CTE_NAN); break; }  // nan array
                                 }
                                 //hb_arraySetND(pARRAYP, k, hb_random_num());
                              }   
                              hb_arraySet(pARRAYC, j, pARRAYP);
                              hb_itemRelease(pARRAYP);
                           }
                           hb_arraySet(pARRAY, i, pARRAYC);
                           hb_itemRelease(pARRAYC);
                        }
                        /* Es una matriz abstracta, o una matriz concreta? 0=abstracta */
                        if (esAbstracta==-1 )  // es abstracta!
                           hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
                        else
                           hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
                        hb_itemRelease(pARRAY);
                     }else{
                        sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NEGATIVE OR ZERO ARGUMENT ERROR",106);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NEGATIVE OR ZERO ARGUMENT ERROR",106);
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(PAG) NEGATIVE OR ZERO ARGUMENT ERROR",106);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NOT A NUMBER ARGUMENT ERROR",103);
            }
            hb_itemRelease(pSizeRow);
         }else{
            sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NOT A NUMBER ARGUMENT ERROR",103);
         }
         hb_itemRelease(pSizeCol);
      }else{
         sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(PAGE) NOT A NUMBER ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSizePag);
   }
   if(pDato) hb_itemRelease(pDato);
return sw;
}

int fun_size_binary( /*int nItem*/ ){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pSIZE = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_NUMERIC( pSIZE) ){
      SIZE_BINARY = hb_itemGetNInt( pSIZE );
   }else{
      sw=put_error((PHB_ITEM) pRET, "SIZEBIN ARGUMENT ERROR",103);
   }
   hb_itemRelease(pSIZE);
return sw;
}

int fun_emptyarray( /*int nItem*/ ){
int sw=1;
if( CADDR < nSizeStack ){
   PHB_ITEM pARRAY=NULL;
//   printf("TIPO CODE = %d\n",nPCP);
   if(nPCP == 230){
      int nItem = STK_PRG[++CP];
      pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   }else{
      if(CADDR >= 1){
         pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      }else{
         sw=put_error((PHB_ITEM) pRET, "EMPTY INNER-STACK UNDERFLOW",102);
      }
   }
   if (sw){
      if( HB_IS_ARRAY( pARRAY ) ){
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) !hb_arrayLen( pARRAY ) );
      }else{
         sw=put_error((PHB_ITEM) pRET, "EMPTY ARGUMENT ERROR",103);
      }
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "EMPTY INNER-STACK OVERFLOW",101);
}
return sw;
}

int put_sequenceSpaced(/* int nItem*/ ){
int sw=1;
if( CADDR >= 3 ){
   PHB_ITEM pTOTAL = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pHASTA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDESDE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nItem = STK_PRG[++CP];
   if(HB_IS_NUMERIC(pDESDE)){
      if(HB_IS_NUMERIC(pHASTA)){
         if(HB_IS_NUMERIC(pTOTAL)){
            double pDesde    = hb_itemGetND( pDESDE );
            double pHasta    = hb_itemGetND( pHASTA );
            unsigned pTotal  = hb_itemGetNInt( pTOTAL );
   
            double inc = (pHasta - pDesde) / ( pTotal - 1);
            long n;
            PHB_ITEM pC = hb_itemArrayNew( pTotal );
   
            hb_arraySetND( pC, 1,     (double) pDesde );
            hb_arraySetND( pC, pTotal,(double) pHasta );
   
            for( n=2; n<=pTotal-1; n++){
               PHB_ITEM pCC = hb_itemArrayGet( pC, n-1);
               hb_arraySetND( pC, n, hb_itemGetND( pCC ) + inc );
               hb_itemRelease(pCC);
            }
            
            PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nItem);
            int esAbstracta = hb_itemGetNInt(pABSTRACT);
            hb_itemRelease(pABSTRACT);
            if( esAbstracta==-1 )
                hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pC );
            else
                hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pC );
            hb_itemRelease( pC );
         }else{
            sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED (NUM-ELEMENTS) ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED (END-RANGE) ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED (INI-RANGE) ARGUMENT ERROR",103);
   }
   hb_itemRelease( pTOTAL );
   hb_itemRelease( pHASTA );
   hb_itemRelease( pDESDE );
}else{
   sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED INNER-STACK OVERFLOW",101);
}   
return sw;
}

int put_sequence( /*int nItem */){
int sw=1;
if( CADDR >= 3 ){
   PHB_ITEM pTOTAL = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pINC   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDESDE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nItem = STK_PRG[++CP];
   if(HB_IS_NUMERIC(pDESDE)){
      if(HB_IS_NUMERIC(pINC)){
         if(HB_IS_NUMERIC(pTOTAL)){

            double pDesde    = hb_itemGetND( pDESDE );
            double pInc      = hb_itemGetND( pINC );
            unsigned pTotal  = hb_itemGetNInt( pTOTAL );

            long n;
            PHB_ITEM pC = hb_itemArrayNew( pTotal );
   
            hb_arraySetND( pC, 1,     (double) pDesde );
   
            for( n=2; n<=pTotal; n++){
               PHB_ITEM pCC = hb_itemArrayGet( pC, n-1);
               hb_arraySetND( pC, n, hb_itemGetND( pCC ) + pInc );
               hb_itemRelease(pCC);
            }
            
            PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nItem);
            int esAbstracta = hb_itemGetNInt(pABSTRACT);
            hb_itemRelease(pABSTRACT);
            if( esAbstracta==-1 )
                hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pC );
            else
                hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pC );
            ///hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pC );
            hb_itemRelease( pC );
         }else{
            sw=put_error((PHB_ITEM) pRET, "SEQUENCE (NUM-ELEMENTS) ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SEQUENCE (INCREMENT) ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SEQUENCE (INIT-VALUE) ARGUMENT ERROR",103);
   }

   hb_itemRelease( pTOTAL );
   hb_itemRelease( pINC );
   hb_itemRelease( pDESDE );
}else{
   sw=put_error((PHB_ITEM) pRET, "SEQUENCE INNER-STACK OVERFLOW",101);
}   
return sw;
}

int fun_voidarray(){
int sw=1;
long nARG1 = STK_PRG[++CP]; // indice de REG
PHB_ITEM pARRAY = hb_itemArrayNew( 0 );  // crea un array vacío.
hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
hb_itemRelease(pARRAY);
return sw;
}

int fun_create_array( /*int nARG1 */){
int sw=1;
   // extrae argumentos:

   long nARG1 = STK_PRG[++CP]; // indice de REG
   PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nARG1);
   int esAbstracta = hb_itemGetNInt(pABSTRACT);
  // printf("ABSTRACT = %d",esAbstracta);
   hb_itemRelease(pABSTRACT);
   
   // saco dato desde ADDR para size de ARRAY: 1,2 y 3.
   if( CADDR==0 ){
      PHB_ITEM pARRAY = hb_itemArrayNew( 0 );  // crea un array vacío.
      if (esAbstracta==-1 )  // es abstracta!
          hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
      else
          hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
      //hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
      hb_itemRelease(pARRAY);
   }else if( CADDR==1 ){  // 1D
      PHB_ITEM pSize = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( HB_IS_NUMERIC( pSize ) ) {
         PHB_ITEM pARRAY = hb_itemArrayNew( hb_itemGetNInt( pSize ) );
         if (esAbstracta==-1 )  // es abstracta!
             hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
         else
             hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
    //     hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
         hb_itemRelease(pARRAY);
      }else{
         //eRROR
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(1D) ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSize);
   }else if( CADDR==2 ){   // 2D
      PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizeCol ) ) {
         PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         if( HB_IS_NUMERIC( pSizeRow ) ) {
            HB_MAXINT i;
            HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
                       
            HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
                       
            PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
            for(i=1; i<=nSizeRow; i++){
               PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
               hb_arraySet(pARRAY, i, pARRAYC);
               hb_itemRelease(pARRAYC);
            }
            if (esAbstracta==-1 )  // es abstracta!
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
            else
               hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
            ///hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
            hb_itemRelease(pARRAY);
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(ROW) ARGUMENT ERROR",103);
         }
         hb_itemRelease(pSizeRow);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(COL) ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSizeCol);
   }else if( CADDR>=3 ){   // 3D
      PHB_ITEM pSizePag = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizePag ) ) {
         PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         if( HB_IS_NUMERIC( pSizeCol ) ) {
            PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
            CADDR += SWKEEP; SWKEEP = 0;
            if( HB_IS_NUMERIC( pSizeRow ) ) {
               HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
               HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
               HB_MAXINT nSizePag = hb_itemGetNInt( pSizePag );

               HB_MAXINT i;
                          
               PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
               for(i=1; i<=nSizeRow; i++){
                  HB_MAXINT j;
                  PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
                  for(j=1; j<=nSizeCol; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( nSizePag );
                     HB_MAXINT k;
                     for(k=1; k<=nSizePag; k++){
                        hb_arraySetC(pARRAYP, k, "");
                     }   
                     hb_arraySet(pARRAYC, j, pARRAYP);
                     hb_itemRelease(pARRAYP);
                  }
                  hb_arraySet(pARRAY, i, pARRAYC);
                  hb_itemRelease(pARRAYC);
               }
               hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(ROW) ARGUMENT ERROR",103);
            }
            hb_itemRelease(pSizeRow);
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(COL) ARGUMENT ERROR",103);
         }
         hb_itemRelease(pSizeCol);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(PAGE) ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSizePag);
   }
return sw;
}


int fun_ifenv(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      char * cValue = getenv( hb_itemGetCPtr(pVARIABLE) );
      if( cValue ){
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
      }else{
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "IFENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "IFENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_getenv_num(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      char * cValue = getenv( hb_itemGetCPtr(pVARIABLE) );
      if( cValue ){
         const char * pValue = cValue;
         int iWidth, iDec, iLen = ( int ) hb_itemGetCLen( pVARIABLE );
         HB_BOOL fDbl;
         HB_MAXINT lValue;
         double dValue;

         fDbl = hb_valStrnToNum( pValue, iLen, &lValue, &dValue , &iDec, &iWidth );

         if( !fDbl ){
               hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_MAXINT) lValue );
         }else{
               hb_arraySetND( pSTK_ADDR, ++CADDR, (double) dValue );
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "GETENV VARIABLE ERROR",103);
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "GETENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "GETENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_getenv(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      char * cValue = getenv( hb_itemGetCPtr(pVARIABLE) );
      if( cValue ){
         const char * pValue = cValue;
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
      }else{
         sw=put_error((PHB_ITEM) pRET, "GETENV VARIABLE ERROR",103);
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "GETENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "GETENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_setenv(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pVALOR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( !HB_IS_STRING( pVALOR ) ){
      sw=put_error((PHB_ITEM) pRET, "SETENV TYPE MISMATCH VALUE ERROR",104);
   }else{
      if( HB_IS_STRING( pVARIABLE ) ){
         int status = setenv(hb_itemGetCPtr(pVARIABLE), hb_itemGetCPtr(pVALOR), 1); 
         if( status ){
            sw=put_error((PHB_ITEM) pRET, "SETENV VARIABLE ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SETENV ARGUMENT ERROR",103);
      }
   }
   hb_itemRelease( pVARIABLE );
   hb_itemRelease( pVALOR );
}else{
   sw=put_error((PHB_ITEM) pRET, "SETENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_unsetenv(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      int status = unsetenv( hb_itemGetCPtr(pVARIABLE) );
      if( status ){
         sw=put_error((PHB_ITEM) pRET, "UNSETENV VARIABLE ERROR",103);
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "UNSETENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "UNSETENV INNER-STACK OVERFLOW",101);
}
return sw;
}
/*
#define BLACK        0
#define BLUE         1
#define GREEN        2
#define CYAN         3
#define RED          4
#define MAGENTA      5
#define BROWN        6
#define LIGHTGRAY    7
#define DARKGRAY     8
#define LIGHTBLUE    9
#define LIGHTGREEN   10
#define LIGHTCYAN    11
#define LIGHTRED     12
#define LIGHTMAGENTA 13
#define YELLOW       14
#define WHITE        15
// Special attributes 
#define UNDERLINE    64
#define BLINK        128

// Special font attributes 
#define UNDERLINE_ATTR 4
#define BLINK_ATTR     5
#define BRILLO_ATTR    1

// Bright colors start in color number 9 
#define BRILLO_MIN     9
*/



/*int fun_colortext(PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pCOLOR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if( HB_IS_NUMERIC( pCOLOR ) ) {
      //static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};
     HB_INT color = (HB_INT) hb_itemGetNInt( pCOLOR );
     int atrval=0;
     if (color & UNDERLINE)
       atrval=UNDERLINE_ATTR;
     else if (color & BLINK)
       atrval=BLINK_ATTR;
     else if (color>=BRILLO_MIN)
       atrval=BRILLO_ATTR;

     color=ansicolors[color & 15];
  
     printf("\033[%d;%dm", atrval, color);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COLOR ARGUMENT ERROR",103);
   }
   hb_itemRelease( pCOLOR );
}else{
   sw=put_error((PHB_ITEM) pRET, "COLOR INNER-STACK OVERFLOW",101);
}
return sw;  
}

int fun_background(PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pCOLOR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if( HB_IS_NUMERIC( pCOLOR ) ) {
      //static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};
     HB_INT color = (HB_INT) hb_itemGetNInt( pCOLOR );
  
     if (color<BRILLO_MIN){				   
        color=ansicolors[color & 15]+10;
  
        printf("\033[%dm", color);
     }
   }else{
     sw=put_error((PHB_ITEM) pRET, "BACKGROUND ARGUMENT ERROR",103);
   }
   hb_itemRelease( pCOLOR );
}else{
   sw=put_error((PHB_ITEM) pRET, "BACKGROUND INNER-STACK OVERFLOW",101);
}
return sw;
}
*/

/*
    PROTOTIPOS
*/

int fun_char_pos(){
int sw=1;
if (CADDR>=3){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pCHAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pTIPO = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   
   const char * cCar    = hb_itemGetCPtr( pCHAR );
   const char * cString = hb_itemGetCPtr( pTEXT );
   int tipo = hb_itemGetNI( pTIPO );
   int pos = 0,i;
   
   i=strlen(cString)-1;
   
   const char * b = cString;
   if (tipo){  // desde principio
      while (*cCar == *b) ++b;
      pos = (b - cString) + 1;
   }else{      // desde final
      while( *cCar == cString[i] ) --i;
      pos = i+1;
   }
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) pos );
   hb_itemRelease( pTEXT );
   hb_itemRelease( pCHAR );
   hb_itemRelease( pTIPO );
}else{
   sw=put_error((PHB_ITEM) pRET, "POS CHAR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_cut_single( /*int tipo*/ ){
int sw=1;
int tipo = nPCP;
if( CADDR>=2 ){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pCHAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pTEXT ) && HB_IS_STRING( pCHAR ) ){
      const char *pText = hb_itemGetCPtr( pTEXT );
      const char *pChar = hb_itemGetCPtr( pCHAR );
      char *base;
      if(tipo==59){
         base = index (pText, pChar[0]);
      }else{
         base = rindex (pText, pChar[0]);
      }
      const char * buff = base;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) base ? ++buff : pText );
     // free(base);
   }else{
      sw=put_error((PHB_ITEM) pRET, "CUT ARGUMENT ERROR",103);
   }
   hb_itemRelease( pTEXT );
   hb_itemRelease( pCHAR );
}else{
   sw=put_error((PHB_ITEM) pRET, "CUT INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_char_one(){
int sw=1;
if (CADDR>=2){
   const char *pcString;
   HB_SIZE sStrLen;
   const char *pcDeleteSet;
   HB_SIZE sDeleteSetLen;

   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDELSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   
   pcString = hb_itemGetCPtr( pSTRING );
   sStrLen = hb_itemGetCLen( pSTRING );
   pcDeleteSet = hb_itemGetCPtr( pDELSET );
   sDeleteSetLen = hb_itemGetCLen( pDELSET );
   
   if( sStrLen > 1 )
   {
      const char *pcSub;
      char *pcRet;
      HB_SIZE sRetStrLen = 0;
      char cCurrent = *pcString;

      pcRet = ( char * ) calloc( sStrLen + 1, 1 );//hb_xgrab( sStrLen );
      /* copy first char */
      pcRet[sRetStrLen++] = cCurrent;
      for( pcSub = pcString + 1; pcSub < pcString + sStrLen; pcSub++ )
      {
         if( *pcSub != cCurrent )
         {
            cCurrent = *pcSub;
            pcRet[sRetStrLen++] = cCurrent;
         }
         else if( pcDeleteSet != NULL &&
                           !ct_at_exact_forward( pcDeleteSet, sDeleteSetLen,
                                                 pcSub, 1, NULL ) )
         {
            pcRet[sRetStrLen++] = cCurrent;
         }
      }

      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pcRet );
      free(pcRet);

   }
   else                /* if( sStrLen > 1 ) */
   {
      /* algorithm does nothing to 1-char-strings */
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pcString );
   }
   hb_itemRelease( pSTRING );
   hb_itemRelease( pDELSET );
   
}else{
   sw=put_error((PHB_ITEM) pRET, "ONECHAR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_onlychar(){
int sw=1;
if (CADDR>=2){
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDELSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   const char *pcString = hb_itemGetCPtr( pSTRING );
   HB_SIZE sStrLen = hb_itemGetCLen( pSTRING );
   const char *pcOnlySet = hb_itemGetCPtr( pDELSET );
   HB_SIZE sOnlySetLen = hb_itemGetCLen( pDELSET );
   char *pcRet;
   HB_SIZE sRetStrLen = 0;
   int iShift, iBool;
   const char *pcSub, *pc;

   if( HB_IS_STRING( pSTRING ) && HB_IS_STRING( pDELSET ) ){
      if( sStrLen == 0 || sOnlySetLen == 0 ){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "" );
         hb_itemRelease( pSTRING );
         hb_itemRelease( pDELSET );
         return sw;
      }

      iShift = 1;
      
      pcRet = ( char * ) calloc( sStrLen + 1, 1 );//hb_xgrab( sStrLen );

      for( pcSub = pcString; pcSub < pcString + sStrLen + 1 - iShift; pcSub += iShift )
      {
         pc = ct_at_exact_forward( pcOnlySet, sOnlySetLen, pcSub, iShift, NULL );
         iBool = ( ( pc != NULL ) && ( ( ( pc - pcOnlySet ) % iShift ) == 0 ) );

         if( iBool )
         {
            for( pc = pcSub; pc < pcSub + iShift; pc++ )
               pcRet[sRetStrLen++] = *pc;
         }
      }
      /* copy last character if string len is odd */
      if( iShift == 2 && sStrLen % 2 == 1 )
      {
         pcRet[sRetStrLen++] = pcString[sStrLen - 1];
      }
      const char * buff = pcRet;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) buff );
      free( pcRet );
   }else{
      sw=put_error((PHB_ITEM) pRET, "ONLYCHAR ARGUMENT ERROR",103);
   }
   hb_itemRelease(pSTRING);
   hb_itemRelease(pDELSET);
}else{
   sw=put_error((PHB_ITEM) pRET, "ONLYCHAR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_char_rem(){
int sw=1;
if (CADDR>=2){
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDELSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   const char *pcString = hb_itemGetCPtr( pSTRING );
   HB_SIZE sStrLen = hb_itemGetCLen( pSTRING );
   const char *pcOnlySet = hb_itemGetCPtr( pDELSET );
   HB_SIZE sOnlySetLen = hb_itemGetCLen( pDELSET );
   char *pcRet;
   HB_SIZE sRetStrLen = 0;
   int iShift, iBool;
   const char *pcSub, *pc;

   if( HB_IS_STRING( pSTRING ) && HB_IS_STRING( pDELSET ) ){
      if( sStrLen == 0 ){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "" );
         hb_itemRelease( pSTRING );
         hb_itemRelease( pDELSET );
         return sw;
      }
      if( sOnlySetLen == 0 ){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pcString );
         hb_itemRelease( pSTRING );
         hb_itemRelease( pDELSET );
         return sw;
      }
      iShift = 1;

      pcRet = ( char * ) calloc( sStrLen + 1, 1 );//hb_xgrab( sStrLen );

      for( pcSub = pcString; pcSub < pcString + sStrLen + 1 - iShift; pcSub += iShift )
      {
         pc = ct_at_exact_forward( pcOnlySet, sOnlySetLen, pcSub, iShift, NULL );
         iBool = ( ( pc != NULL ) && ( ( ( pc - pcOnlySet ) % iShift ) == 0 ) );

         if( !iBool )
         {
            for( pc = pcSub; pc < pcSub + iShift; pc++ )
               pcRet[sRetStrLen++] = *pc;
         }
      }
      /* copy last character if string len is odd */
      if( iShift == 2 && sStrLen % 2 == 1 )
      {
         pcRet[sRetStrLen++] = pcString[sStrLen - 1];
      }
      const char * buff = pcRet;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) buff );
      free( pcRet );
   }else{
      sw=put_error((PHB_ITEM) pRET, "DELETECHAR ARGUMENT ERROR",103);
   }
   hb_itemRelease(pSTRING);
   hb_itemRelease(pDELSET);
}else{
   sw=put_error((PHB_ITEM) pRET, "DELETECHAR INNER-STACK OVERFLOW",101);
}
return sw;
}



/***************************************************
     FUNCIONES DE ARCHIVOS Y CARGA DE MATRICES
 ***************************************************/
 
#define MAXREADBUFFER   2048

void strtoutf8_item(PHB_ITEM pSTRING, PHB_ITEM pSTK, int NDX){
      HB_SIZE nLen = hb_itemGetCLen ( pSTRING ), nDest = 0;
      const char * szString;
      char * szDest = NULL;

      if( nLen )
      {
         PHB_CODEPAGE cdp = hb_vmCDP();

         if( cdp )
         {
            szString = hb_itemGetCPtr( pSTRING );
            nDest = hb_cdpStrAsUTF8Len( cdp, szString, nLen, 0 );
            szDest = ( char * ) calloc( nDest + 1, 1 );
            hb_cdpStrToUTF8( cdp, szString, nLen, szDest, nDest + 1 );
         }
      }
      if( szDest ){
         const char *buff = szDest;
         hb_arraySetC( pSTK, NDX, (const char*) buff );
         free(szDest);
      }else{
         //hb_arraySetC( pSTK, NDX, (const char*) "" );
         hb_arraySet( pSTK, NDX, pSTRING );
      }

}

void strtoutf8_matrix(PHB_ITEM pMATRIX){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pMATRIX, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            strtoutf8_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               strtoutf8_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  strtoutf8_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }
   }
}

int fun_str2utf8(){
int sw=1;
if( CADDR>=1 ){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pSTRING)){
      ++CADDR;
      strtoutf8_item( (PHB_ITEM) pSTRING, (PHB_ITEM) pSTK_ADDR, (int) CADDR);

   }else if(HB_IS_ARRAY(pSTRING)){
      ++CADDR;
      strtoutf8_matrix((PHB_ITEM) pSTRING);
   }else{  // no es string: pasa tal cual.
      hb_arraySet( pSTK_ADDR, ++CADDR, pSTRING );
   }
   hb_itemRelease( pSTRING );
}else{
   sw=put_error((PHB_ITEM) pRET, "STRTOUTF8 INNER-STACK OVERFLOW",101);
}
return sw;
}

void utf8tostr_item(PHB_ITEM pSTRING, PHB_ITEM pSTK, int NDX){
      const char * szString = hb_itemGetCPtr( pSTRING );

      if( szString )
      {
         HB_SIZE nLen = hb_itemGetCLen( pSTRING ), nDest = 0;
         char * szDest = NULL;

         if( nLen )
         {
            PHB_CODEPAGE cdp = hb_vmCDP(); 

            if( cdp )
            {
               nDest = hb_cdpUTF8AsStrLen( cdp, szString, nLen, 0 );
               szDest = ( char * ) calloc( nDest + 1, 1);
               hb_cdpUTF8ToStr( cdp, szString, nLen, szDest, nDest + 1 );
            }
         }

         if( szDest ){
            const char *buff = szDest;
            hb_arraySetC( pSTK, NDX, (const char*) buff );
            free(szDest);
         }else{
            hb_arraySet( pSTK, NDX, pSTRING );
         }
      }else{
         hb_arraySet( pSTK, NDX, pSTRING );
      }
}

void utf8tostr_matrix(PHB_ITEM pMATRIX){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pMATRIX, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            utf8tostr_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               utf8tostr_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  utf8tostr_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }
   }
}

int fun_utf82str(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pSTRING)){
      ++CADDR;
      utf8tostr_item( (PHB_ITEM) pSTRING, (PHB_ITEM) pSTK_ADDR, (int) CADDR);

   }else if(HB_IS_ARRAY(pSTRING)){
      ++CADDR;
      utf8tostr_matrix((PHB_ITEM) pSTRING);
   }else{  // no es string: pasa tal cual.
      hb_arraySet( pSTK_ADDR, ++CADDR, pSTRING );
   }
   hb_itemRelease( pSTRING );
}else{
   sw=put_error((PHB_ITEM) pRET, "UTF8TOSTR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_seek( /*int nItem*/ ){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pPOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // posicion
   PHB_ITEM pSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // SET
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   
   int Retorno;
   FILE_ERROR=0;
   if( HB_IS_NUMERIC( pPOS ) && HB_IS_NUMERIC( pSET ) )
   {
      Retorno = hb_fsSeekLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), 
                                hb_itemGetNInt( pPOS ), ( HB_USHORT ) hb_itemGetNInt( pSET ) ) ;
      FILE_ERROR = hb_fsError();
   }
   else
      Retorno = 0;

   hb_fsSetFError( FILE_ERROR );
   hb_arraySetNInt( pSTK_ADDR, ++CADDR, Retorno );
   hb_itemRelease( pFD );
   hb_itemRelease( pPOS );
   hb_itemRelease( pSET );
}else{
   sw=put_error((PHB_ITEM) pRET, "SEEK INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_count_lines(){
int sw=1;
if( CADDR<=nSizeStack-3 ){    // porque dejará 3 datos en el stack.
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_STRING( pFILE ) ){  //&& HB_IS_STRING( pTOKEN ) ){
      
      const char * pFile = hb_itemGetCPtr( pFILE );
      const char * pSep = TOKENIZER;
      
      char cSep = pSep[0];
      FILE *fp;
      long nLin=0,nTotCar=0,nLong=0,noldLong=0;
      int sw_Enter=0,sw_Car=0, nTokens=0, maxTokens=0, antChar=0; //, swFirstLine=1;
      char ch;
   
      fp=fopen(pFile,"r");
      if (fp!=NULL){
         nLin = 0;
         while ((ch = fgetc(fp)) != EOF){
            if (ch == '\n'){
               sw_Enter=1;
               sw_Car=0;
               //swFirstLine=0;
               nLin++;
               if (noldLong < nLong) { // longitud máxima de la línea
                  noldLong = nLong;
               }
               if( antChar != cSep )
                   ++nTokens;
              // printf(" nTokens = %d, maxTokens = %d\n",nTokens, maxTokens);
               if(nTokens > maxTokens ){
                  maxTokens = nTokens;
               }
               nTokens=0;
              // printf(" ---> NEW maxTokens = %d\n",maxTokens);
               nLong=0;
            }else{
              // if( swFirstLine ) 
               antChar=ch;
               if( cSep == ch ){
                   ++nTokens;
                   if ((ch = fgetc(fp)) != EOF){
                       if( ch == '\n' ){
                           --nTokens;
                       }
                   }
                   ungetc( ch, fp );
               }
               sw_Enter=0;
               sw_Car=1;
               nLong++;
            }
            nTotCar++;
         }
         fclose(fp);
         // suma 1 a nToken, por el último que no leyó:
         //nTokens++;
         ++maxTokens;
         if(sw_Enter==0 && sw_Car==1)
           ++nLin;
         if(nLong > noldLong) noldLong = nLong;
      }else{
         sw=put_error((PHB_ITEM) pRET, "COUNTFILE FILE OPEN TO READ ERROR",114);
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, (long) nLin );
      hb_arraySetNL( pSTK_ADDR, ++CADDR, (long) nTotCar );
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  noldLong );
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  maxTokens /*nTokens*/ );
      hb_itemRelease(pFILE);
    //  hb_itemRelease(pTOKEN);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COUNTFILE ARGUMENT ERROR",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "COUNTFILE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_error(){
int sw=1;
if( CADDR<nSizeStack ){   // analizar el tipo de error, entregar el mensaje correspondiente.
   HB_MAXINT nTypeErr = (HB_MAXINT) hb_fsGetFError();
   switch( nTypeErr ){
      case 0:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Successful" ); break; }
      case 2:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "File not found" ); break; }
      case 3:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Path not found" ); break; }
      case 4:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Too many files open" ); break; }
      case 5:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Access denied" ); break; }
      case 6:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Invalid handle" ); break; }
      case 8:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Insufficient memory" ); break; }
      case 15:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Invalid drive specified" ); break; }
      case 19:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Attempted to write to a write-protected disk" ); break; }
      case 21:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Drive not ready" ); break; }
      case 23:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Data CRC error" ); break; }
      case 29:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Write fault" ); break; }
      case 30:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Read fault" ); break; }
      case 32:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Sharing violation" ); break; }
      case 33:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Lock Violation" ); break; }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "FILEERROR INNER-STACK OVERFLOW",101);
}
return sw;
}

short int fun_isNumber(const char * AX){
  int DX;
  short int SW_M=0,SW_N=0,SW_P=0;
  short int retorne;
  
  retorne = AX[0]!='\0' ? 1 : 0;
  
  while( (DX=*AX)!='\0'){
    if(DX=='-'){
       if (SW_N || SW_P || SW_M) {retorne=0;break;}
       SW_M=1;
    }else if (DX=='.'){
       if (!SW_N || SW_P) {retorne=0;break;}
       SW_P=1;
    }else if (isdigit(DX)) {SW_N=1;
    }else {retorne=0;break;}
    ++AX;
  }
  if (retorne==0) { SW_P = SW_N = SW_M = 0;}
  retorne=retorne<<1;
  retorne|=SW_P;     // 1=es decimal; 0=entero
  return (retorne);
}

void echo_matrix_token( PHB_ITEM pSource, unsigned PRECISION, HB_MAXINT nDim, 
                        HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, char * TOKENIZER, FILE *fhnd ){
   const char * cSep = TOKENIZER;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pDato = hb_itemArrayGet( pSource, i);
            echo_single( (PHB_ITEM) pDato, PRECISION, fhnd );
            if( d1-i ) fwrite( cSep, 1,1, fhnd );
            hb_itemRelease(pDato);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               echo_single( (PHB_ITEM) pPrint, PRECISION, fhnd );
               hb_itemRelease(pPrint);
               if( d2-j ) fwrite( cSep, 1,1,fhnd );
            }
            fwrite( "\n", 1,1,fhnd );
            hb_itemRelease(pDato2D);
         }
         break;
      }case 3:{
         int i;
         int k;
         for( k=1; k<=d3; k++){
            for( i=1; i<=d1; i++){
               PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
                  PHB_ITEM pPrint2 = hb_itemArrayGet( pPrint, k);
                  echo_single( (PHB_ITEM) pPrint2, PRECISION, fhnd );
                  hb_itemRelease(pPrint2);
                  if( d2-j ) fwrite( cSep, 1,1, fhnd );
                  hb_itemRelease(pPrint);
               }
               hb_itemRelease(pDato2D);
               fwrite( "\n", 1,1, fhnd );
            }
            fwrite( "\n", 1,1,fhnd );
         }
         break;     
      }
   }
}

int fun_savemat(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pFILE   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  nombre de archivo a guardar
   PHB_ITEM pMATRIX = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  matriz
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING( pFILE ) && HB_IS_ARRAY( pMATRIX ) ){
      const char * szFile = hb_itemGetCPtr( pFILE );
      int nPrecision = SW_PRECISION ? PRECISION : 13;
      
      FILE *fp;         
      fp=fopen(szFile,"w");
      if( fp!=NULL ){
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pMATRIX, &nDim, &d1, &d2, &d3, &type);
         echo_matrix_token( pMATRIX, nPrecision, nDim, d1, d2, d3, (char *)TOKENIZER, (FILE*) fp );
         fclose(fp);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SAVE OPEN ERROR",115);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SAVE ARGUMENT (FILENAME|MATRIX) ERROR",103);
   }
   hb_itemRelease( pFILE );
   hb_itemRelease( pMATRIX );   
   
}else{
   sw=put_error((PHB_ITEM) pRET, "SAVE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_loadmat(){
int sw=1;
if( CADDR>=5 ){
   PHB_ITEM pFILE   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  archivo a leer
   PHB_ITEM pTOTTOK = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  total de tokens encontrados en primera linea.
   PHB_ITEM pMAXLIN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  maxima longitud de linea --> importante
   PHB_ITEM pTOTCAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  total caracteres
   PHB_ITEM pTOTLIN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  total lineas --> este es importante aqui
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING( pFILE ) ){ //&& HB_IS_STRING( pTOKEN ) ){
      const char * szFile = hb_itemGetCPtr( pFILE );
      const char * szSeparator = TOKENIZER; //hb_itemGetCPtr( pTOKEN );
   
      char cSep = szSeparator[0];  // tommo primer caracter como separador.
   
      if( HB_IS_NUMERIC( pMAXLIN ) && HB_IS_NUMERIC( pTOTCAR ) && HB_IS_NUMERIC( pTOTLIN ) &&
          HB_IS_NUMERIC( pTOTTOK ) ){
         // aqui empieza todo!
         FILE *fp;         
         fp=fopen(szFile,"r");
         if (fp!=NULL){
            long nCurrLine=0, ctaLines=0, nTotLines = hb_itemGetNInt( pTOTLIN );
           // int  nMaxLine = hb_itemGetNI( pMAXLIN );
            unsigned int ctaToken=0, relaToken=0; 
            unsigned int nTokens = (unsigned)hb_itemGetNI( pTOTTOK );
          //  HB_MAXINT nTotCar = hb_itemGetNInt( pTOTCAR );
            char ch, buffer[MAXREADBUFFER]; 
            int i=0;
            
            // verificar si hay filas y columnas prestablecidas:
            unsigned int nIniR=1, nFinR=nTotLines;
            unsigned int nIniC=1, nFinC=nTokens;
            if( MARK_ROW ) {
               if( MARK_ROW == 999999999 ) MARK_ROW=nTotLines;
               if( MARK_ROW>nTotLines ){
                  sw=put_error((PHB_ITEM) pRET, "LOAD ROW'MARK OVERFLOW",113);
               }
               nIniR=MARK_ROW;nFinR=MARK_ROW;
               if( OFFSET_ROW ){
                  if( OFFSET_ROW == 999999999 ) OFFSET_ROW=nTotLines;
                  if( OFFSET_ROW<=nTotLines ){
                     nFinR=OFFSET_ROW;
                  }else{   // es mayor! ERROR
                     sw=put_error((PHB_ITEM) pRET, "LOAD ROW'OFFSET OVERFLOW",113);
                  }
               }
            }else{  // asume todas las filas
               OFFSET_ROW=nFinR;
            }
            if( MARK_COL ) {
               if( MARK_COL == 999999999 ) MARK_COL=nTokens;
               if( MARK_COL>nTokens ){
                  sw=put_error((PHB_ITEM) pRET, "LOAD COL'MARK OVERFLOW",113);
               }
               nIniC=MARK_COL;nFinC=MARK_COL;
               if( OFFSET_COL ){
                  if( OFFSET_COL == 999999999 ) OFFSET_COL=nTokens;
                  if( OFFSET_COL<=nTokens ){
                     nFinC=OFFSET_COL;
                  }else{   // es mayor! ERROR
                     sw=put_error((PHB_ITEM) pRET, "LOAD COL'OFFSET OVERFLOW",113);
                  }
               }
            }else{  // asume todas las columnas
               OFFSET_COL=nFinC;
            }
          /*****/
          if (sw){
            //PHB_ITEM pRow = hb_itemArrayNew( nTotLines );
            PHB_ITEM pRow = hb_itemArrayNew( nFinR - nIniR + 1 );
            /* avanzo el puntero hasta la línea donde empiezo a leer */
            if( nIniR>1 ){
               while ((ch = fgetc(fp)) != EOF){
                  if ( ch == '\n' ){
                     nCurrLine++;
                     if(nCurrLine == nIniR-1) break;
                  }
               }
            }
            if( feof(fp) ){
               sw=put_error((PHB_ITEM) pRET, "LOAD FILE IS NOT MATRIX COMPATIBLE",116);
            }else{
               /***/
               //PHB_CODEPAGE cdp = hb_vmCDP();
               while( nCurrLine <= nFinR && sw){  //nTotLines ){

                  //PHB_ITEM pCol = hb_itemArrayNew( nTokens );
                  PHB_ITEM pCol = hb_itemArrayNew( nFinC - nIniC + 1 );
                  ctaToken=0;
                  relaToken=0;
                  i=0;
                  while ((ch = fgetc(fp)) != EOF){
                     if ( ch == '\n' ){
                        ++ctaToken;
                        if( ctaToken > nTokens ){   // error!
                           sw=put_error((PHB_ITEM) pRET, "LOAD FILE IS NOT MATRIX COMPATIBLE (TOKENS)",116);
                        }else if( ctaToken>=nIniC && ctaToken<=nFinC ){
                           // verificar el tipo y guardar en pCol:
                          if( i ){
                              buffer[i] = '\0';
                              const char *cBuffer = buffer;
                              double nDbl;
                             // int nInt;
                              long nLong;
                              int nRet = fun_isNumber( cBuffer );
                              relaToken++; 
                              if( nRet ){  // es numero normal?
                                 if( nRet == 2 ){  // entero o long?
                                    sscanf(cBuffer, "%ld", &nLong);
                                    if( nLong >= INT_MIN && nLong <= INT_MAX )
                                       hb_arraySetNI( pCol, relaToken, (int)nLong );
                                    else
                                       hb_arraySetNL( pCol, relaToken, (long)nLong );
                                 }else{    // decimal: double!
                                    sscanf(cBuffer, "%lf", &nDbl);
                                    hb_arraySetND( pCol, relaToken, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                                 }
                              }else if( xu_funIsnotation( cBuffer ) ){  // es un numero con notación cientifica?
                                 nDbl = xu_funE2D( cBuffer );
                                 hb_arraySetND( pCol, relaToken, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                              }else{   // debe ser string, por default la hueá.

                                 hb_arraySetC( pCol, relaToken, (const char*)cBuffer );
                              }
                              //i=0;
                           }else{
                              sw=put_error((PHB_ITEM) pRET, "LOAD FILE IS NOT MATRIX COMPATIBLE (BLANK LINE)",116);
                           }
                         //  break;
                        }
                        i=0;
                        relaToken=0;
                        break;
                     }else if( ch == cSep ){  // encontró un separador?
                        ++ctaToken;
                        if( ctaToken > nTokens ){   // error!
                           sw=put_error((PHB_ITEM) pRET, "LOAD(2) FILE IS NOT MATRIX COMPATIBLE (TOKENS)",116);
                           break;
                        }else if( ctaToken>=nIniC && ctaToken<=nFinC ){
                           // verificar el tipo y guardar en pCol:
                           if( i ){
                              buffer[i] = '\0';
                              const char *cBuffer = buffer;
                              double nDbl;
                            //  int nInt;
                              long nLong;
                        
                              int nRet = fun_isNumber( cBuffer );
                              relaToken++;
                              if( nRet ){  // es numero normal?
                                 if( nRet == 2 ){  // entero o long?
                                    sscanf(cBuffer, "%ld", &nLong);
                                    if( nLong >= INT_MIN && nLong <= INT_MAX )
                                       hb_arraySetNI( pCol, relaToken, (int)nLong );
                                    else
                                       hb_arraySetNL( pCol, relaToken, (long)nLong );

                                 }else{    // decimal: double!
                                    sscanf(cBuffer, "%lf", &nDbl);
                                    hb_arraySetND( pCol, relaToken, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                                 }
                              }else if( xu_funIsnotation( cBuffer ) ){  // es un numero con notación cientifica?
                                 nDbl = xu_funE2D( cBuffer );
                                 hb_arraySetND( pCol, relaToken, (double) SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl );
                              }else{   // debe ser string, por default la hueá.
                                 hb_arraySetC( pCol, relaToken, (const char*)cBuffer );
                              }
                            //  i=0;
                           }else{
                              sw=put_error((PHB_ITEM) pRET, "LOAD(2) FILE IS NOT MATRIX COMPATIBLE (BLANK LINE)",116);
                              break;
                           }
                        }
                        i=0;
                     }else{
                        buffer[i++] = ch;
                     }
                  }
                  if( sw ){
                     hb_arraySet( pRow, ++ctaLines, pCol );
                     ++nCurrLine;
                  }
                  hb_itemRelease( pCol );
               }
               hb_arraySet( pSTK_ADDR, ++CADDR, pRow );
               hb_itemRelease( pRow );
               MARK_ROW = MARK_COL = OFFSET_ROW = OFFSET_COL = 0;
            }
            fclose(fp);
          }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOAD FILE OPEN TO READ ERROR",114);
         }
         
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOAD ARGUMENT (COUNT FILE) ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "LOAD ARGUMENT (FILENAME|SEPARATOR) ERROR",103);
   }
   hb_itemRelease( pFILE );
//   hb_itemRelease( pTOKEN );
   hb_itemRelease( pTOTLIN );
   hb_itemRelease( pMAXLIN );
   hb_itemRelease( pTOTCAR );
   hb_itemRelease( pTOTTOK );
}else{
   sw=put_error((PHB_ITEM) pRET, "LOAD INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_writeline( /*int nItem,int TypeRead */)
{
int sw=1;
int TypeRead = nPCP == 236 ? 1 : 0;
if( CADDR>=1 ){
   PHB_ITEM pTOWRITE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // string a escribir
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );

   int nWriteS;
   FILE_ERROR=0;
   
   if( HB_IS_NUMERIC( pFD ) ){
      if( TypeRead ){   // write line string
         if( HB_IS_STRING( pTOWRITE ) ){
            HB_SIZE nLen = hb_itemGetCLen( pTOWRITE );
            nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), hb_itemGetCPtr( pTOWRITE ), nLen ) ;
            FILE_ERROR = hb_fsError();
            if(nWriteS<=0)
              sw=put_error((PHB_ITEM) pRET, "WRITELINE WRITE FAILED",103);
         }else{
            sw=put_error((PHB_ITEM) pRET, "WRITELINE ARGUMENT ERROR",103);
         }
      }else{   // write row. graba cada token.
         if( HB_IS_ARRAY( pTOWRITE ) ){
            HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
            get_size( (PHB_ITEM) pTOWRITE, &nDim, &d1, &d2, &d3, &type);
            
            if( nDim == 1 ){
               int i;
               int nPrec = SW_PRECISION ? PRECISION : 13;
               for( i=1; i<=d1; i++ ){
                  PHB_ITEM pSource = hb_itemArrayGet( pTOWRITE, i );
                  if( HB_IS_STRING( pSource ) ){
                     const char * pString = hb_itemGetCPtr( pSource );
                     long nText = hb_itemGetCLen( pSource );
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, nText ) ;
                  }else if ( HB_IS_INTEGER ( pSource ) ){
                     int pNum = hb_itemGetNI( pSource );
                     char * buf = (char *)calloc(32,1);
                     int size = sprintf(buf,"%d", pNum);
                     const char * pString = buf;
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, size ) ;
                     free(buf);
                  }else if( HB_IS_DOUBLE( pSource ) ) {
                     double pDbl = hb_itemGetND( pSource );
                     char * buf = (char *)calloc(64,1);
                     int size = sprintf(buf,"%'.*lf", nPrec, pDbl);
                     const char * pString = buf;
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, size ) ;
                     free(buf);
                  }else if( HB_IS_LONG( pSource ) ) {
                     long pLong = hb_itemGetNL( pSource );
                     char * buf = (char *)calloc(64,1);
                     int size = sprintf(buf,"%ld", pLong);
                     const char * pString = buf;
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, size ) ;
                     free(buf);
                /*  }else if( HB_IS_LOGICAL( pSource ) ){
                     HB_BOOL pBool = hb_itemGetL( pSource );
                     if (pBool) hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), "1", 1 ) ;
                     else hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), "0", 1 ) ;*/
                  }
                  if ( d1-i ) nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), TOKENIZER, 1 ) ;
                  else nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), "\n", 1 ) ;
                  FILE_ERROR = hb_fsError();
                  hb_itemRelease( pSource );
                  if(nWriteS<=0)
                     sw=put_error((PHB_ITEM) pRET, "WRITELINE WRITE FAILED",103);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "WRITEROW DIMENSION ERROR",106);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "WRITEROW ARGUMENT ERROR",103);
         }
      }
   }else
      if( TypeRead )
         sw=put_error((PHB_ITEM) pRET, "WRITELINE FILE DESCRIPTOR ERROR",117);
      else
         sw=put_error((PHB_ITEM) pRET, "WRITEROW FILE DESCRIPTOR ERROR",117);

   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pTOWRITE );
   hb_itemRelease( pFD );
}else{
   sw=put_error((PHB_ITEM) pRET, "WRITELINE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_writestring()
{
int sw=1;

if( CADDR>=1 ){
   PHB_ITEM pTOWRITE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // string a escribir
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );

   int nWriteS;
   FILE_ERROR=0;
   
   if( HB_IS_NUMERIC( pFD ) ){
      
      if( HB_IS_STRING( pTOWRITE ) ){
          HB_SIZE nLen = hb_itemGetCLen( pTOWRITE );
          nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), hb_itemGetCPtr( pTOWRITE ), nLen ) ;
          FILE_ERROR = hb_fsError();
          if(nWriteS<=0)
             sw=put_error((PHB_ITEM) pRET, "WRITESTRING WRITE FAILED",103);
      }else{
          sw=put_error((PHB_ITEM) pRET, "WRITESTRING ARGUMENT ERROR",103);
      }
      
   }else

      sw=put_error((PHB_ITEM) pRET, "WRITESTRING FILE DESCRIPTOR ERROR",117);

   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pTOWRITE );
   hb_itemRelease( pFD );
}else{
   sw=put_error((PHB_ITEM) pRET, "WRITESTRING INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_readstring()
{
int sw=1;

if( CADDR>=1 ){
   PHB_ITEM pNTOREAD = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // n a leer
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   
   HB_FHANDLE fhnd = ( HB_FHANDLE ) hb_itemGetNInt( pFD );
   HB_SIZE nToRead = ( HB_SIZE ) hb_itemGetNInt( pNTOREAD );  // numero de chars a leer
   
   char * buffer = ( char * ) calloc( nToRead + 1, 1 ); 
   HB_SIZE nRead;
//   HB_SIZE cbuf = 0;
   /* primer intento */
   /* obtener total de caracteres del archivo */
   HB_SIZE nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 1 ) ;
   HB_SIZE nFinalPos  = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 2 ) ;
           nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos, 0 ) ;

   if( nToRead + nSavePos > nFinalPos ) 
      nToRead -= ( nToRead + nSavePos ) - nFinalPos; 
   
   if(nSavePos>nFinalPos){
      FILE_ERROR=30;
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   nRead = hb_fsReadLarge( fhnd, buffer, nToRead );
   FILE_ERROR = hb_fsError();

   if(FILE_ERROR!=0){
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   long nLen;
   buffer[ nToRead ] = '\0';
   const char * pValue = buffer;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
   nLen = strlen( pValue );

   // calcula nueva posición.
   nLen++;
   nSavePos = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos + nLen, 0 ) ;

   free(buffer);
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pNTOREAD );
   hb_itemRelease( pFD );
   if(nRead<=0)
       sw=put_error((PHB_ITEM) pRET, "READSTRING READ FAILED",103);

}else{
   sw=put_error((PHB_ITEM) pRET, "READSTRING INNER-STACK OVERFLOW",101);
}
return sw;
}


int fun_readline( /*int nItem, int TypeRead*/ )
{
int sw=1;
int TypeRead = nPCP == 213 ? 0 : 1;
if( CADDR>=1 ){
   PHB_ITEM pNTOREAD = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // n a leer
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   
   HB_FHANDLE fhnd = ( HB_FHANDLE ) hb_itemGetNInt( pFD );
   HB_SIZE nToRead = ( HB_SIZE ) hb_itemGetNInt( pNTOREAD );
   
   /* obtener total de caracteres del archivo */
   HB_SIZE nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 1 ) ;
   HB_SIZE nFinalPos  = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 2 ) ;
           nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos, 0 ) ;

   if( nToRead + nSavePos > nFinalPos ) 
      nToRead -= ( nToRead + nSavePos ) - nFinalPos; 
   
   if(nSavePos>nFinalPos){
      FILE_ERROR=30;
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   char * buffer = ( char * ) calloc( nToRead + 1, 1 ); 
   HB_SIZE nRead;
   HB_SIZE cbuf = 0;
   /* primer intento */

   nRead = hb_fsReadLarge( fhnd, buffer, nToRead );
   FILE_ERROR = hb_fsError();
   
   if(FILE_ERROR!=0){
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   while( cbuf<=nToRead ){
      if(buffer[cbuf]!='\n') ++cbuf;
      else break;
   }
   long nLen;
   if( cbuf<=nToRead ){  // encontró un '\n'
      buffer[ cbuf ] = '\0';
      const char * pValue = buffer;
      if( TypeRead ){  // lee string
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
      }else{    // lee row
         const char * tokenizer = TOKENIZER;
         char *cTexto = (char *)calloc( cbuf + 1, 1 );
         memcpy( cTexto, buffer, cbuf );
         char *cBuffer = strtok(cTexto, tokenizer);

         int size=0;
         long nLong;
         double nDbl;
         PHB_ITEM pCol = hb_itemArrayNew( 0 );
         while( cBuffer ){
            hb_arraySize( pCol, ++size );
            const char * pBuffer = cBuffer;
            int nRet = fun_isNumber( pBuffer );
            if( nRet ){  // es numero normal?
               if( nRet == 2 ){  // entero o long?
                  sscanf(pBuffer, "%ld", &nLong);
                  if( nLong >= INT_MIN && nLong <= INT_MAX )
                     hb_arraySetNI( pCol, size, (int)nLong );
                  else
                     hb_arraySetNL( pCol, size, (long)nLong );
               }else{    // decimal: double!
                  sscanf(pBuffer, "%lf", &nDbl);
                  //hb_arraySetND( pCol, size, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                  hb_arraySetND( pCol, size, (double) nDbl  );
               }
            }else if( xu_funIsnotation( pBuffer ) ){  // es un numero con notación cientifica?
               nDbl = xu_funE2D( pBuffer );
               //hb_arraySetND( pCol, size, (double) SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl );
               hb_arraySetND( pCol, size, (double) nDbl );
            }else{   // debe ser string, por default la hueá.
               hb_arraySetC( pCol, size, (const char*)pBuffer );
            }
            
            cBuffer = strtok(0, tokenizer);
         }
         free(cTexto);
         // guardo array en STK_ADDR
         if( pCol ){
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pCol );
         }
         hb_itemRelease( pCol );
      }
      nLen = strlen( pValue );
   }else{     // no encontró '\n'
      buffer[ nToRead ] = '\0';
      const char * pValue = buffer;
      if( TypeRead ){  // lee string
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
      }else{    // lee row
         const char * tokenizer = TOKENIZER;
         char *cTexto = (char *)calloc( nToRead + 1, 1 );
         memcpy( cTexto, buffer, nToRead );
         char *cBuffer = strtok(cTexto, tokenizer);
         
         int size=0;
         long nLong;
         double nDbl;
         PHB_ITEM pCol = hb_itemArrayNew( 0 );
         while( cBuffer ){
            hb_arraySize( pCol, ++size );
            const char * pBuffer = cBuffer;
            int nRet = fun_isNumber( pBuffer );
            if( nRet ){  // es numero normal?
               if( nRet == 2 ){  // entero o long?
                  sscanf(pBuffer, "%ld", &nLong);
                  if( nLong >= INT_MIN && nLong <= INT_MAX )
                     hb_arraySetNI( pCol, size, (int)nLong );
                  else
                     hb_arraySetNL( pCol, size, (long)nLong );
               }else{    // decimal: double!
                  sscanf(pBuffer, "%lf", &nDbl);
                  //hb_arraySetND( pCol, size, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                  hb_arraySetND( pCol, size, (double) nDbl  );
               }
            }else if( xu_funIsnotation( pBuffer ) ){  // es un numero con notación cientifica?
               nDbl = xu_funE2D( pBuffer );
               //hb_arraySetND( pCol, size, (double) SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl );
               hb_arraySetND( pCol, size, (double) nDbl );
            }else{   // debe ser string, por default la hueá.
               hb_arraySetC( pCol, size, (const char*) pBuffer );
            }
            
            cBuffer = strtok(0, tokenizer);
         }
         free(cTexto);
         // guardo array en STK_ADDR
         if( pCol ){
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pCol );
         }
         hb_itemRelease( pCol );
      }
      nLen = strlen( pValue );
   }
   // calcula nueva posición.
   nLen++;
   nSavePos = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos + nLen, 0 ) ;
         
   free(buffer);
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pNTOREAD );
   hb_itemRelease( pFD );
   if(nRead<=0)
       sw=put_error((PHB_ITEM) pRET, "READXXX READ FAILED",103);
}else{
   if( TypeRead )
      sw=put_error((PHB_ITEM) pRET, "READLINE INNER-STACK OVERFLOW",101);
   else
      sw=put_error((PHB_ITEM) pRET, "READROW INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_eof(/* int nItem */){
int sw=1;
if( CADDR < nSizeStack ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
   if( HB_IS_NUMERIC( pFD ) )
   {
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) hb_fsEof( hb_numToHandle( hb_itemGetNInt( pFD ) ) ) );
      FILE_ERROR=hb_fsError();
   }
   else
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );

   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFD );
}else{
  sw=put_error((PHB_ITEM) pRET, "EOF INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_ferror(){
int sw=1;
if( CADDR < nSizeStack ){
  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) FILE_ERROR ? 1 : 0 );
  FILE_ERROR=0;
}else{
  sw=put_error((PHB_ITEM) pRET, "ERROR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_fclose(/* int nItem*/ ){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
//   HB_ERRCODE uiError = 0;
   if( HB_IS_NUMERIC( pFD ) )
   {
      hb_fsClose( hb_numToHandle( hb_itemGetNInt( pFD ) ) );
      FILE_ERROR = hb_fsError();
   }
   else{
      sw=put_error((PHB_ITEM) pRET, "CLOSE INVALID FILE DESCRIPTOR",117);
   }
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFD );
return sw;
}

int fun_create(/* int nItem */){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   PHB_ITEM pMODE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // modo
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
   const char * szFile = hb_itemGetCPtr( pFILE );  //hb_parc( 1 );
   if( szFile ){
      hb_arraySetNInt( pSTK_REG, nItem, ( HB_NHANDLE ) hb_fsCreate( szFile,
                                        ( HB_USHORT ) hb_itemGetNInt( pMODE ) ) );
      FILE_ERROR = hb_fsError();
   }else{
      sw=put_error((PHB_ITEM) pRET, "CREATE INVALID FILENAME",107);
   }
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFILE );
   hb_itemRelease( pFD );
   hb_itemRelease( pMODE );
}else{
   sw=put_error((PHB_ITEM) pRET, "CREATE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_fopen( /*int nItem */){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   PHB_ITEM pMODE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // modo
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
   const char * szFile = hb_itemGetCPtr( pFILE );  //hb_parc( 1 );
   if( szFile ){
      hb_arraySetNInt( pSTK_REG, nItem, ( HB_NHANDLE ) hb_fsOpen( szFile,
                  ( HB_USHORT ) hb_itemGetNInt( pMODE ) ) );
      
      FILE_ERROR = hb_fsError();
   }else{
      sw=put_error((PHB_ITEM) pRET, "OPEN INVALID FILENAME",114);
   }
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFILE );
   hb_itemRelease( pFD );
   hb_itemRelease( pMODE );
}else{
   sw=put_error((PHB_ITEM) pRET, "OPEN INNER-STACK OVERFLOW",101);
}
return sw;
}

/***************************************
    SWITCH  -  CASE
 ***************************************/
//int jumpCase( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET, PHB_ITEM SWITCH_VAR ){
int jumpCase(/* int nJump */){
int sw=1;
if( CADDR>=1 ){
   int nJump = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pDATO = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_NUMERIC( pDATO ) ){  
      PHB_ITEM pSWVAR = hb_itemArrayGet( SWITCH_VAR, 1 );
      if( hb_itemGetND( pSWVAR ) != hb_itemGetND( pDATO ) ){
         CP = nJump;// - 1;
      }
      hb_itemRelease( pSWVAR );
   }else if( HB_IS_STRING( pDATO ) ){
      PHB_ITEM pSWVAR = hb_itemArrayGet( SWITCH_VAR, 2 );
      if( strcmp( hb_itemGetCPtr( pSWVAR ), hb_itemGetCPtr( pDATO ) ) != 0 ){
         CP = nJump;// - 1;
      }
      hb_itemRelease( pSWVAR );
   }else{
      sw=put_error((PHB_ITEM) pRET, "CASE ARGUMENT ERROR",103);
   }
   hb_itemRelease( pDATO );
}else{
   sw=put_error((PHB_ITEM) pRET, "CASE INNER-STACK OVERFLOW",101);
}
return sw;
}

int put_switch( /*int nItem*/ ){

   int nItem = STK_PRG[++CP];
   PHB_ITEM pSWITCH = hb_itemArrayGet( pSTK_REG, nItem );

   if ( HB_IS_NUMERIC( pSWITCH) )
      hb_arraySetND( SWITCH_VAR, 1, (double) hb_itemGetND( pSWITCH ) );

   else if( HB_IS_STRING( pSWITCH ) )
      hb_arraySetC( SWITCH_VAR, 2, (const char*) hb_itemGetCPtr( pSWITCH ) );

   hb_itemRelease( pSWITCH );

return 1;
}

/*  TRUE y FALSE */
int fun_bool( /*int nItem, HB_BOOL lBool */){
int sw=1;
   int nItem = STK_PRG[++CP];
   hb_arraySetNI( pSTK_REG, nItem, (int) nPCP == 247 ? 1 : 0 );
return sw;
}

/**********************************************
         FUNCIONES ESPECIALES ARRAY 
 **********************************************/
int fun_array_especial(/* int nItem */){
int sw=1;

int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int tCompare = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

switch(tCompare){
   case 0:{   // SORT
      if(CADDR>=1){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pSTART = NULL;
         PHB_ITEM pCOUNT = NULL;
         HB_SIZE nStart = 0;
         HB_SIZE nCount = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            if(CADDR>=1){
               pSTART = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               nStart = hb_itemGetNInt( pSTART );
               if(CADDR>=1){
                  pCOUNT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                  nCount = hb_itemGetNInt( pCOUNT );
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySort( pARRAY,
                    pSTART ? &nStart : NULL,
                    pCOUNT ? &nCount : NULL,
                    NULL );  //hb_param( 4, HB_IT_BLOCK ) );
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SORT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         if(pSTART) hb_itemRelease(pSTART);
         if(pCOUNT) hb_itemRelease(pCOUNT);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SORT INNER-STACK OVERFLOW",101);
      }
      break;
   }case 1:{   // SCAN
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pVALUE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pSTART = NULL;
         PHB_ITEM pCOUNT = NULL;
         HB_SIZE nStart = 0;
         HB_SIZE nCount = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            if(CADDR>=1){
               pSTART = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               nStart = hb_itemGetNInt( pSTART );
               if(CADDR>=1){
                  pCOUNT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                  nCount = hb_itemGetNInt( pCOUNT );
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            HB_SIZE nPos = ( hb_arrayScan( pARRAY, pVALUE,
                              pSTART ? &nStart : NULL,
                              pCOUNT ? &nCount : NULL,
                              HB_TRUE ) );
            hb_arraySetNInt( pSTK_ADDR, ++CADDR, nPos );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pVALUE);
         if(pSTART) hb_itemRelease(pSTART);
         if(pCOUNT) hb_itemRelease(pCOUNT);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN INNER-STACK OVERFLOW",101);
      }
      break;
   }case 2:{   // REV SCAN
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pVALUE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pSTART = NULL;
         PHB_ITEM pCOUNT = NULL;
         HB_SIZE nStart = 0;
         HB_SIZE nCount = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            if(CADDR>=1){
               pSTART = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               nStart = hb_itemGetNInt( pSTART );
               if(CADDR>=1){
                  pCOUNT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                  nCount = hb_itemGetNInt( pCOUNT );
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            HB_SIZE nPos = ( hb_arrayRevScan( pARRAY, pVALUE,
                              pSTART ? &nStart : NULL,
                              pCOUNT ? &nCount : NULL,
                              HB_TRUE ) );
            hb_arraySetNInt( pSTK_ADDR, ++CADDR, nPos );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY REVERSE SCAN ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pVALUE);
         if(pSTART) hb_itemRelease(pSTART);
         if(pCOUNT) hb_itemRelease(pCOUNT);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY REVERSE SCAN INNER-STACK OVERFLOW",101);
      }
      break;
   }case 3:{   // INSERT
      if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pVALUE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOS) ){
            HB_ISIZ nPos = hb_itemGetNInt( pPOS );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            if( nPos == 0 )
               nPos = 1;
            
            if(!HB_IS_ARRAY(pVALUE)){
               hb_arraySize( pARRAY, nLen + 1 );

               hb_arrayIns( pARRAY, nPos );
               put_value( pARRAY, pVALUE, nPos, PRECISION);
            }else{  // es un array: lo inserta en la posición
               HB_SIZE nLenS=hb_arrayLen( pVALUE );
               
               hb_arraySize(pARRAY,  nLen + nLenS);
               HB_SIZE i;
               for(i=nLenS;i>=1;i--){
                  hb_arrayIns( pARRAY, nPos );
                  PHB_ITEM pELEM = hb_itemArrayGet(pVALUE,i);
                  hb_arraySet(pARRAY, nPos, pELEM);
                  hb_itemRelease(pELEM);
               }
            }
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY INSERT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pVALUE);
         hb_itemRelease(pPOS);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY INSERT INNER-STACK OVERFLOW",101);
      }
      break;
   }case 4:{  // DELETE
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOS) ){
            
            HB_ISIZ nPos = hb_itemGetNInt( pPOS );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            
            if( nPos == 0 )
               nPos = 1;

            hb_arrayDel( pARRAY, nPos );
            hb_arraySize( pARRAY, nLen - 1 );
            
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pPOS);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 5:{  // SIZE
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pNEWLEN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pNEWLEN) ){
            
            HB_ISIZ nNewLen = hb_itemGetNInt( pNEWLEN );
            ///HB_SIZE nLen = hb_arrayLen( pARRAY );
            
            hb_arraySize( pARRAY, HB_MAX( nNewLen, 0 ) );
             
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pNEWLEN);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 6:{  // ADD: une un array al principio del array target.
      if(CADDR>=2){
         PHB_ITEM pARRAYT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // objetivo
         PHB_ITEM pARRAYS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // lo que une a objetivo
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAYS) && HB_IS_ARRAY(pARRAYT) ){
            HB_SIZE nLenT=hb_arrayLen( pARRAYT );
            HB_SIZE nLenS=hb_arrayLen( pARRAYS );
            
            hb_arraySize(pARRAYT,  nLenT + nLenS);
            HB_SIZE i;
            for(i=1;i<=nLenS;i++){
               PHB_ITEM pELEM = hb_itemArrayGet(pARRAYS,i);
               hb_arraySet(pARRAYT, i+nLenT, pELEM);
               hb_itemRelease(pELEM);
            }
             
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAYT );

         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY ADD ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAYT);
         hb_itemRelease(pARRAYS);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY ADD INNER-STACK OVERFLOW",101);
      }
      break;
   }case 7:{ // ZAPRANGE
      if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOSF = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOSI = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOSI) && HB_IS_NUMERIC(pPOSF) ){
            
            HB_ISIZ nPosI = hb_itemGetNInt( pPOSI );
            HB_ISIZ nPosF = hb_itemGetNInt( pPOSF );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            
            if( nPosI <= 0 )
               nPosI = 1;
            if( nPosF <= 0 )
               nPosF = 1;
            if( nPosI>nPosF ){
               int nTmp = nPosI;nPosI=nPosF;nPosF=nTmp;
            }
            HB_SIZE nPorcion = nPosF-nPosI+1;
            HB_SIZE i;
            for(i=1; i<=nPorcion; i++)
               hb_arrayDel( pARRAY, nPosI );
            hb_arraySize( pARRAY, nLen - nPorcion );
            
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE RANGE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pPOSI);
         hb_itemRelease(pPOSF);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE RANGE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 8: {   // SCAN2D ==> para buscar un dato en un array 2D
      if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pELEM = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pCOL = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pCOL) ){
            double nElemento=0; // deben ser distintos
            const char* cElemento;
            int nCol = hb_itemGetNInt( pCOL );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            int swOk=0;
            if(HB_IS_NUMERIC(pELEM)){
               nElemento = hb_itemGetND( pELEM );
               HB_SIZE i;
               for (i=1; i<=nLen; i++){
                  PHB_ITEM pROW = hb_itemArrayGet( pARRAY, i );
                  PHB_ITEM pFIND = hb_itemArrayGet( pROW, nCol );
                  if(HB_IS_NUMERIC(pFIND)){  // solo si es numérico
                     double nDato = hb_itemGetND( pFIND );
                     if(nElemento == nDato){
                        hb_itemRelease(pFIND); hb_itemRelease(pROW);
                        swOk=1;
                        break;
                     }
                  }
                  hb_itemRelease(pFIND);
                  hb_itemRelease(pROW);
               }
               if (swOk){
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) i);
               }else{
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) -1);
               }
            }else if(HB_IS_STRING(pELEM)){
               cElemento = hb_itemGetCPtr( pELEM );
               HB_SIZE i;
               for (i=1; i<=nLen; i++){
                  PHB_ITEM pROW = hb_itemArrayGet( pARRAY, i );
                  PHB_ITEM pFIND = hb_itemArrayGet( pROW, nCol );
                  if(HB_IS_STRING(pFIND)){  // solo si es numérico
                     const char* cDato = hb_itemGetCPtr( pFIND );
                     if(strcmp(cElemento, cDato)==0){
                        hb_itemRelease(pFIND); hb_itemRelease(pROW);
                        swOk=1;
                        break;
                     }
                  }
                  hb_itemRelease(pFIND);
                  hb_itemRelease(pROW);
               }
               if (swOk){
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) i) ;
               }else{
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) -1) ;
               }
               
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN2D TYPE ARGUMENT ERROR",103);   
            }

         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN2D TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pELEM);
         hb_itemRelease(pCOL);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN2D INNER-STACK OVERFLOW",101);
      }
      break;
   }case 9:{    // distribution array
      if(CADDR>=2){
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY1) && HB_IS_ARRAY(pARRAY2) ){
            HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nLen2 = hb_arrayLen( pARRAY2 );
            HB_SIZE i;
            if( nLen1>0 && nLen2>0 ){
            PHB_ITEM NEWARRAY = hb_itemArrayNew( nLen1 * nLen2 * 2 );
            HB_SIZE nSize=0;
            for (i=1; i<=nLen1; i++){
               PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
               ///const char* cDato = hb_itemGetCPtr( pELEM1 );
               ///if(HB_IS_STRING(pELEM1)){
                  HB_SIZE j;
                  for (j=1; j<=nLen2; j++){
                     PHB_ITEM pELEM2 = hb_itemArrayGet( pARRAY2, j );
                     ++nSize;
                     hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM1 );
                     ++nSize;
                     hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM2 );
                     //if(HB_IS_STRING(pELEM2)){
                     /*   const char* cDato2 = hb_itemGetCPtr( pELEM2 );
                        int len1=strlen(cDato);
                        int len2=strlen(cDato2);
                        char * cString = (char*)calloc(len1 + len2 + 1,1);
                        memcpy(cString,cDato,len1);
                        memcpy(cString+len1,cDato2,len2);
                        cString[len1 + len2] = '\0';
                        const char * cBuffer = cString;
                        hb_arraySize(NEWARRAY,++nSize);
                        hb_arraySetC( NEWARRAY, nSize, (const char*) cBuffer );
                        free(cString); */
                     //}
                     hb_itemRelease(pELEM2);
                  }
              /// }
               hb_itemRelease(pELEM1);
            }
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) NEWARRAY) ;
            hb_itemRelease(NEWARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY DISTRIB LENGTH ZERO ERROR",103);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY DISTRIB TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY DISTRIB INNER-STACK OVERFLOW",101);
      }
      break;
   }case 10: case 11: case 12: case 13: case 14: case 15:{    // MAX=10, MIN=11
      if(CADDR>=1 && CADDR<nSizeStack-1){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            HB_SIZE i, nPosition = 1;
            // escoge elemento pivote
            PHB_ITEM pPIVOTE = hb_itemArrayGet( pARRAY, 1 );
            double nPivote = hb_itemGetND( pPIVOTE );
            hb_itemRelease( pPIVOTE );
            if (tCompare >= 10 && tCompare <=12){
               // busca el maximo:
               for (i=2; i<=nLen; i++){
                  PHB_ITEM pELEM = hb_itemArrayGet( pARRAY, i );
                  if ( HB_IS_NUMERIC(pELEM) ){
                     double nElemento = hb_itemGetND( pELEM );
                     if ( nPivote < nElemento ) {
                        nPivote = nElemento;
                        nPosition = i;
                     }
                  }  // si no es numérico, no hace nada.
                  hb_itemRelease(pELEM);
               }
            }else{
               // busca el minimo:
               for (i=2; i<=nLen; i++){
                  PHB_ITEM pELEM = hb_itemArrayGet( pARRAY, i );
                  if ( HB_IS_NUMERIC(pELEM) ){
                     double nElemento = hb_itemGetND( pELEM );
                     if ( nPivote > nElemento ) {
                        nPivote = nElemento;
                        nPosition = i;
                     }
                  }  // si no es numérico, no hace nada.
                  hb_itemRelease(pELEM);
               }
            }
            if ( tCompare == 10 || tCompare == 13 ){
               hb_arraySetND( pSTK_ADDR, ++CADDR, (double) nPivote ) ;
            }else if ( tCompare == 11 || tCompare == 14 ){
               hb_arraySetNInt( pSTK_ADDR, ++CADDR, (HB_SIZE) nPosition ) ;
            }else{
               hb_arraySetND( pSTK_ADDR, ++CADDR, (double) nPivote ) ;
               hb_arraySetNInt( pSTK_ADDR, ++CADDR, (HB_SIZE) nPosition ) ;
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY MAX|MIN TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY MAX|MIN INNER-STACK OVER OR UNDERFLOW",101);
      }
      break;
   }case (16):{   // array mix: {a,b,c} {1,2,3} => {a,1,b,2,c,3}
       if(CADDR>=2){
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY1) && HB_IS_ARRAY(pARRAY2) ){
            HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nLen2 = hb_arrayLen( pARRAY2 );
            if( nLen1 == nLen2 ){
               HB_SIZE i;
               PHB_ITEM NEWARRAY = hb_itemArrayNew( nLen1 + nLen2 );
               HB_SIZE nSize=0;
               for (i=1; i<=nLen1; i++){
                  PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
                  PHB_ITEM pELEM2 = hb_itemArrayGet( pARRAY2, i );
                  ++nSize;
                  hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM1 );
                  ++nSize;
                  hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM2 );
                  hb_itemRelease(pELEM1);
                  hb_itemRelease(pELEM2);
               }
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) NEWARRAY) ;
               hb_itemRelease(NEWARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY MIX LENGTH ERROR",103);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY MIX TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY MIX INNER-STACK OVERFLOW",101);
      }
  
      
      break;
   }case (17): case (18): { // array rotate R y L
       if(CADDR>=3){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // array
         PHB_ITEM pHASTA  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // desde
         PHB_ITEM pDESDE  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // hasta
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY1) && HB_IS_NUMERIC(pDESDE) && HB_IS_NUMERIC(pHASTA)){
           // HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nDesde = hb_itemGetNI( pDESDE );
            HB_SIZE nHasta = hb_itemGetNI( pHASTA );
            HB_SIZE i;
            if(tCompare==17){
               PHB_ITEM pELEMi = hb_itemArrayGet( pARRAY1, nDesde );
               for (i=nDesde+1; i<=nHasta; i++){
                  PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
                  hb_arraySet( pARRAY1, i-1, (PHB_ITEM) pELEM1 );
                  hb_itemRelease(pELEM1);
               }
               hb_arraySet( pARRAY1, nHasta, (PHB_ITEM) pELEMi );
               hb_itemRelease(pELEMi);
            }else{
               PHB_ITEM pELEMi = hb_itemArrayGet( pARRAY1, nHasta );
               for (i=nHasta-1; i>=nDesde; i--){
                  PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
                  hb_arraySet( pARRAY1, i+1, (PHB_ITEM) pELEM1 );
                  hb_itemRelease(pELEM1);
               }
               hb_arraySet( pARRAY1, nDesde, (PHB_ITEM) pELEMi );
               hb_itemRelease(pELEMi);               
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY ROTATE TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pDESDE);
         hb_itemRelease(pHASTA);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY ROTATE INNER-STACK OVERFLOW",101);
      }
      break;
   }case(19): { // swap element (range puede ser hecho con hopper rápidamente!
       if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // array
         PHB_ITEM pPOS2  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // posicion
         PHB_ITEM pPOS1  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // posicion
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOS1) && HB_IS_NUMERIC(pPOS2)){
            //HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nPos1 = hb_itemGetNI( pPOS1 );
            HB_SIZE nPos2 = hb_itemGetNI( pPOS2 );
           // HB_SIZE i;
            PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY, nPos1 );
            PHB_ITEM pELEM2 = hb_itemArrayGet( pARRAY, nPos2 );
            PHB_ITEM pTEMP = pELEM1;
            hb_arraySet( pARRAY, nPos1, (PHB_ITEM)pELEM2 );
            hb_arraySet( pARRAY, nPos2, (PHB_ITEM)pTEMP );
            hb_itemRelease(pELEM1);
            hb_itemRelease(pELEM2);
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SWAP-ELEMENTS TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pPOS2);
         hb_itemRelease(pPOS1);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SWAP-ELEMENTS INNER-STACK OVERFLOW",101);
      }
      break;
   }
}
return sw;
}


/***************************************************
         FUNCIONES DE CONJUNTOS
 ***************************************************/

PHB_ITEM fun_set_unique( PHB_ITEM pSTACK ){
    
    // Creo el array, después ajusto. Siempre será menor o igual a tamaño original.
    HB_SIZE nLen = hb_arrayLen( pSTACK );
    PHB_ITEM pUNIQUE = hb_itemArrayNew( nLen );
    unsigned int n;
    
    HB_MAXINT type=0;
    PHB_ITEM pItem = hb_itemArrayGet( pSTACK, 1);
    get_item_type( (PHB_ITEM) pItem, &type );
    hb_itemRelease( pItem );

    // EL ARRAY DEBE ESTAR ORDENADO.
    if ( type>=11 && type<=13 ){   // number
       HB_MAXINT nSize=1;

       PHB_ITEM pAA = hb_itemArrayGet( pSTACK, 1); 
       double npA = hb_itemGetND(pAA);
       hb_itemRelease( pAA );
       hb_arraySetND( pUNIQUE, 1, (double) npA );

       for(n=2;n<=nLen;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK, n);
          double npAA = hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          if( npAA != npA ){
             hb_arraySetND( pUNIQUE, ++nSize, (double) npAA );
          }
          npA = npAA;
       }
       hb_arraySize( pUNIQUE, nSize ); // ajusto array final

    }else if( type==10 ){  // string
       HB_MAXINT nSize=1;

       PHB_ITEM pAA = hb_itemArrayGet( pSTACK, 1);
       const char * npA = hb_itemGetCPtr(pAA);
       hb_itemRelease( pAA );
       hb_arraySetC( pUNIQUE, 1, (const char *) npA );

       for(n=2;n<=nLen;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK, n);
          const char * npAA = hb_itemGetCPtr(pAA);
          if( strcmp ( npA, npAA ) != 0 ){
             hb_arraySetC( pUNIQUE, ++nSize, (const char *) npAA );
          }
          npA = hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
       }
       hb_arraySize( pUNIQUE, nSize ); // ajusto array final
    }

    return pUNIQUE;
}

PHB_ITEM fun_set_union( PHB_ITEM pSTACK1, PHB_ITEM pSTACK2 ){

    HB_SIZE nRowA = hb_arrayLen( pSTACK1 );
    HB_SIZE nRowB = hb_arrayLen( pSTACK2 );
    
    PHB_ITEM pUNION = hb_itemArrayNew( nRowA + nRowB );
    unsigned int n;
    
    HB_MAXINT type1=0;
    PHB_ITEM pItem1 = hb_itemArrayGet( pSTACK1, 1);
    get_item_type( (PHB_ITEM) pItem1, &type1 );
    hb_itemRelease( pItem1 );
    HB_MAXINT type2=0;
    PHB_ITEM pItem2 = hb_itemArrayGet( pSTACK2, 1);
    get_item_type( (PHB_ITEM) pItem2, &type2 );
    hb_itemRelease( pItem2 );
    
    if( (type1>=11 && type1<=13) || (type2>=11 && type2<=13) ){
    
          HB_MAXINT nSize=0;
          // RELLENO EL ARRAY INICIAL
          for(n=1;n<=nRowA;n++){
             PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
             hb_arraySetND( pUNION, ++nSize, (double) hb_itemGetND(pAA) );
             hb_itemRelease( pAA );
          }
          for(n=1;n<=nRowB;n++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, n);
             hb_arraySetND( pUNION, ++nSize, (double) hb_itemGetND(pBB) );
             hb_itemRelease( pBB );
          }    
    }else if( (type1==10 && type2==10) ){  // sting
          HB_MAXINT nSize=0;
          for(n=1;n<=nRowA;n++){
             PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
             hb_arraySetC( pUNION, ++nSize, (const char*) hb_itemGetCPtr(pAA) );
             hb_itemRelease( pAA );
          }
          for(n=1;n<=nRowB;n++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, n);
             hb_arraySetC( pUNION, ++nSize, (const char*) hb_itemGetCPtr(pBB) );
             hb_itemRelease( pBB );
          }
    }
    return pUNION;
}

PHB_ITEM fun_set_intersection( PHB_ITEM pSTACK1, PHB_ITEM pSTACK2 ){

    HB_SIZE nRowA = hb_arrayLen( pSTACK1 );
    HB_SIZE nRowB = hb_arrayLen( pSTACK2 );
    
    PHB_ITEM pINTER = hb_itemArrayNew( nRowA > nRowB ? nRowA : nRowB );
    
    HB_MAXINT type1=0;
    PHB_ITEM pItem1 = hb_itemArrayGet( pSTACK1, 1);
    get_item_type( (PHB_ITEM) pItem1, &type1 );
    hb_itemRelease( pItem1 );
    HB_MAXINT type2=0;
    PHB_ITEM pItem2 = hb_itemArrayGet( pSTACK2, 1);
    get_item_type( (PHB_ITEM) pItem2, &type2 );
    hb_itemRelease( pItem2 );
    
    unsigned m,n,piv;
    
    if( (type1>=11 && type1<=13) || (type2>=11 && type2<=13) ){
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=nRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          double npA=hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             double npB=hb_itemGetND(pBB);
             hb_itemRelease( pBB );
             if( npA == npB ){
                hb_arraySetND( pINTER, ++nSize, (double) npA );
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if ( npA < npB ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
       }
       hb_arraySize( pINTER, nSize ); // ajusto array final
    }else if( (type1==10 && type2==10) ){  // sting

       HB_MAXINT nSize=0;
       for(n=1;n<=nRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          const char * npA=hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
          for(m=1;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             const char * npB=hb_itemGetCPtr(pBB);
             hb_itemRelease( pBB );
             if( strcmp ( npA, npB ) == 0 ){
                hb_arraySetC( pINTER, ++nSize, (const char*) npA );
                break;
             }
          }
       }
       hb_arraySize( pINTER, nSize ); // ajusto array final
    }
    return pINTER;
}

PHB_ITEM fun_set_difference( PHB_ITEM pSTACK1, PHB_ITEM pSTACK2 ){

    HB_SIZE nRowA = hb_arrayLen( pSTACK1 );
    HB_SIZE nRowB = hb_arrayLen( pSTACK2 );
    
    PHB_ITEM pDIFF = hb_itemArrayNew( nRowA > nRowB ? nRowA : nRowB );
    
    HB_MAXINT type1=0;
    PHB_ITEM pItem1 = hb_itemArrayGet( pSTACK1, 1);
    get_item_type( (PHB_ITEM) pItem1, &type1 );
    hb_itemRelease( pItem1 );
    HB_MAXINT type2=0;
    PHB_ITEM pItem2 = hb_itemArrayGet( pSTACK2, 1);
    get_item_type( (PHB_ITEM) pItem2, &type2 );
    hb_itemRelease( pItem2 );

    unsigned n,m,sw,piv;
    
    if( (type1>=11 && type1<=13) || (type2>=11 && type2<=13) ){
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=nRowA;n++){
          sw = 1;
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          double npA=hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             double npB=hb_itemGetND(pBB);
             hb_itemRelease( pBB );
             if( npA == npB ){
                sw = 0;
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if ( npA < npB ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
          if( sw ){
             hb_arraySetND( pDIFF, ++nSize, (double) npA );
          }
       }
       hb_arraySize( pDIFF, nSize ); // ajusto array final
    }else if( (type1==10 && type2==10) ){  // sting
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=nRowA;n++){
          sw = 1;

          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          const char * npA = hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             const char * npB = hb_itemGetCPtr(pBB);
             hb_itemRelease( pBB );
             if( strcmp ( npA, npB ) == 0 ){
                sw = 0;
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if( strcmp( npA, npB ) < 0 ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
          if( sw ){
             hb_arraySetC( pDIFF, ++nSize, (const char *) npA );
          }
       }
       hb_arraySize( pDIFF, nSize ); // ajusto array final    
    }
    return pDIFF;
}

// "setunique"=>52, "setunion"=>53,"setintersec"=>54,"setdiff"=>55,"setsimmetricdiff"=>56,;
int fun_set_especial( /*int nItem*/ ){
int sw=1;
int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int tCompare = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

switch(tCompare){
   case 0:{  // UNIQUE
      if(CADDR>=1){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pARRAY );
         hb_arraySet( pSTK_ADDR, ++CADDR, pUNIQUE );
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAY);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET UNIQUE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 1:{   // UNION
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pUNIQUE );
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET UNION INNER-STACK OVERFLOW",101);
      }   
      break;
   }case 2:{  //INTERSECTION
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pINTER = fun_set_intersection( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pINTER );
         hb_itemRelease(pINTER);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET INTERSEC INNER-STACK OVERFLOW",101);
      }
      break;
   }case 3:{   // SETDIFF
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pINTER = fun_set_intersection( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         PHB_ITEM pDIFF = fun_set_difference( (PHB_ITEM) pARRAY1, (PHB_ITEM) pINTER );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pDIFF );
         hb_itemRelease(pINTER);
         hb_itemRelease(pDIFF);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET DIFF INNER-STACK OVERFLOW",101);
      }
      break;
   }case 4:{   // SIMMETRIC DIFF
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         PHB_ITEM pINTER = fun_set_intersection( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         PHB_ITEM pTEMPORAL = fun_set_intersection( (PHB_ITEM) pUNIQUE, (PHB_ITEM) pINTER );
         
         PHB_ITEM pDIFF = fun_set_difference( (PHB_ITEM) pUNIQUE, (PHB_ITEM) pTEMPORAL );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pDIFF );
         hb_itemRelease(pINTER);
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pDIFF);
         hb_itemRelease(pTEMPORAL);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET SIMMETRIC DIFF INNER-STACK OVERFLOW",101);
      }
      break;
   }case 5: {   // DISJOINT
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         if( hb_arrayLen( pARRAY1 ) + hb_arrayLen( pARRAY2 ) == hb_arrayLen( pUNIQUE )){
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
         }else{
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
         }
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET DISJOINT INNER-STACK OVERFLOW",101);
      }
      break;
   }case 6: {   //  SUBSET
      if(CADDR>=2){
         PHB_ITEM pARRAYB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // B
         PHB_ITEM pARRAYA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // A es subconjunto de B
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAYA, (PHB_ITEM) pARRAYB );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         if( hb_arrayLen( pARRAYB ) == hb_arrayLen( pUNIQUE )){
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
         }else{
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
         }
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAYA);
         hb_itemRelease(pARRAYB);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET SUBSET INNER-STACK OVERFLOW",101);
      }
      break;
   }case 7: {   //  SUPERSET
      if(CADDR>=2){
         PHB_ITEM pARRAYB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // B
         PHB_ITEM pARRAYA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // A es superconjunto de B
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAYA, (PHB_ITEM) pARRAYB );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         if( hb_arrayLen( pARRAYA ) == hb_arrayLen( pUNIQUE )){
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
         }else{
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
         }
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAYA);
         hb_itemRelease(pARRAYB);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET SUPERSET INNER-STACK OVERFLOW",101);
      }
      break;
   }
}
return sw;
}


/*********************************************
         FUNCIONES DE CLASE STRING
 *********************************************/

int fun_getstringarray(/* long nItem */){
int sw=1;
if( CADDR>=1 ){
   long nItem = STK_PRG[++CP];
   
   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if ( HB_IS_ARRAY(pARRAY) ){
      
      long nLen = hb_arrayLen( pARRAY );
      CADDR += SWKEEP; SWKEEP = 0;
      // size total
      int i,sw_error=0;
      long size=0, acumulado=0;
      for(i=1; i<=nLen; i++){
         PHB_ITEM pString = hb_itemArrayGet( pARRAY, i );
         if( HB_IS_STRING(pString))
            size += hb_itemGetCLen( pString );
         else{
            sw_error=1;
         }
         hb_itemRelease(pString);
         if(sw_error) break;
      }
      if(sw_error || !size || !nLen){
         sw=put_error((PHB_ITEM) pRET, "PACK STRING ARGUMENT ARRAY ERROR : VOID",103);   
      }else{
         //printf("NLEN=%ld, SIZE=%ld\n",nLen,size);
         char *separator = TOKENIZER;
         char * line = (char *)calloc( (size * nLen * 2) + size, 1 );
         for(i=1; i<=nLen; i++){
            PHB_ITEM pString = hb_itemArrayGet( pARRAY, i );
            size = hb_itemGetCLen( pString );
            const char * cString = hb_itemGetCPtr( pString );
            strcat(line, cString);
            if( i<nLen )
                line[acumulado + size]=separator[0];
   
         //memcpy(line, cString, size);
            acumulado += size+1;
            hb_itemRelease(pString);
         }
         line[acumulado]='\0';
         const char * cbuffer = line;
         hb_arraySetC( pSTK_REG, nItem, cbuffer );
         free(line);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PACK STRING ARGUMENT ARRAY ERROR",103);   
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "PACK STRING INNER-STACK OVERFLOW",101);
}
return sw;
}

unsigned char * revisa_caracter_especial(const char * pTexto){

  unsigned char * cChar = (unsigned char *) calloc(10,1);
  cChar[0] = *pTexto;
  if (cChar[0]==194 || cChar[0]==195 || cChar[0]==207 || cChar[0]==198 || cChar[0]==197
      || cChar[0]==234 || cChar[0]==180 ){
      ++pTexto;
      cChar[1] = *pTexto;
      cChar[2] = '\0';
  }else if (cChar[0]==226 || cChar[0]==239 ){
      ++pTexto;cChar[1] = *pTexto;
      ++pTexto;cChar[2] = *pTexto;
      cChar[3] = '\0';
  }else if(cChar[0]==206 ){
      ++pTexto;cChar[1] = *pTexto;
      ++pTexto;cChar[2] = *pTexto;
      ++pTexto;cChar[3] = *pTexto;
      cChar[4] = '\0';
  }else{ 
      cChar[1] = '\0';
  }
  return cChar;
}

int fun_getarraystring( /*long nItem */){
int sw=1;
if( CADDR>=1 ){
   
   long nItem = STK_PRG[++CP];
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * pText = hb_itemGetCPtr( pSTRING );
   long nLen = hb_itemGetCLen( pSTRING );
   hb_itemRelease(pSTRING);
   
   const char *separator = TOKENIZER;
   char * cTexto = (char*) calloc(nLen+1,1);
   memcpy(cTexto,pText,nLen);
   PHB_ITEM pCWM = hb_itemArrayNew(0); // CWM
   int cnt=0;
   
  //// printf("token=[%s]\n",separator);
   if(*separator!='\0'){
      char * token = strtok(cTexto, separator);

      while (token){
         //char * cToken = (char *)calloc(strlen(token)+1,1);
         //memcpy(cToken, token, strlen(token));
         const char * pBuffer = token; //cToken
         //printf("TOKEN = [%s]\n",token);
         hb_arraySize( pCWM, ++cnt);
         if(strlen(token)>0){
         
            hb_arraySetC( pCWM,   cnt, (const char *) pBuffer);
         }else{
            hb_arraySetC( pCWM,   cnt, (const char *) "");
         }
         token = strtok(0, separator);
         //free(cToken);
      }
   }else{
      const char * pTexto = cTexto;
      while(*pTexto){
         unsigned char * cChar = (unsigned char *) calloc(10,1);
         cChar[0] = *pTexto;
         if (cChar[0]==194 || cChar[0]==195 || cChar[0]==207 || cChar[0]==198 || cChar[0]==197
             || cChar[0]==234 || cChar[0]==180 ){
             ++pTexto;
             cChar[1] = *pTexto;
             cChar[2] = '\0';
         }else if (cChar[0]==226 || cChar[0]==239 ){
             ++pTexto;cChar[1] = *pTexto;
             ++pTexto;cChar[2] = *pTexto;
             cChar[3] = '\0';
         }else if(cChar[0]==206 ){
             ++pTexto;cChar[1] = *pTexto;
             ++pTexto;cChar[2] = *pTexto;
             ++pTexto;cChar[3] = *pTexto;
             cChar[4] = '\0';
         }else{ 
             cChar[1] = '\0';
         }
         const char * pChar=cChar;
         hb_arraySize( pCWM, ++cnt);
         hb_arraySetC( pCWM,   cnt, (const char *) pChar); 
         free(cChar);
         ++pTexto;
      }
   }
   free(cTexto);
   
  // hb_arraySize(pCWM,cnt);
   hb_arraySet( pSTK_REG, nItem, (PHB_ITEM)pCWM );
//   int i;
//   for(i=1; i<=cnt;i++){
//      PHB_ITEM f=hb_itemArrayGet(pCWM,i);
//      printf("LEN = %ld LINEA %d = %s\n", hb_itemGetCLen( f ), i, hb_itemGetCPtr(f));
//      hb_itemRelease(f);
//   }

   hb_itemRelease(pCWM);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "PACK ARRAY INNER-STACK OVERFLOW",101);
}
return sw;
}
/*
int fun_especialstring(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET, char *TOKENIZER){
int sw=1;
int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int tCompare = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

switch(tCompare){
   case 0:{    // load string
      sw=fun_loadstring((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET);
      break;
   }case 1:{   // get array from string
      sw=fun_getarraystring((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET);
      break;
   }case 2:{   // get string from array
      sw=fun_getstringarray((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET, (char *)TOKENIZER);
      break;
   } 
}

return sw;
} */

int fun_countstring(/*int nItem*/){
int sw=1;
if( CADDR<=nSizeStack ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, nItem);  // string
   const char * cString = hb_itemGetCPtr( pREG );
   hb_itemRelease( pREG );

   const char * tb=cString;
   long nLine=0;
   while(*tb!='\0'){
      if(*tb=='\n' || *tb=='\0'){
         ++nLine;
      }
      ++tb;
   }
   //if(*tb=='\0') ++nLine;
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (long)nLine );
}else{
   sw=put_error((PHB_ITEM) pRET, "STRING - COUNT INNER-STACK OVERFLOW",101);
}
return sw;
}



int fun_linestring(/*int nItem*/){
int sw=1;

int nItem = STK_PRG[++CP];
PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, nItem);  // string
const char * cString = hb_itemGetCPtr( pREG );
hb_itemRelease( pREG );
   
long nLine=1,cLine=0;
if( MARK_POS ){
   cLine = MARK_POS;
}else{
   if( CADDR>=1 ){
      PHB_ITEM pLINE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // linea
      CADDR += SWKEEP; SWKEEP = 0;
      cLine = hb_itemGetNL( pLINE );
      hb_itemRelease( pLINE );
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET LINE INNER-STACK OVERFLOW",101);
   }
}
   
if(sw){
   const char * tb=cString;

   if(cLine==1){  // primera linea
      char *line = (char *)calloc(MAXREADBUFFER,1);
      int i=0;
      while(*tb!='\n' && *tb!='\0'){
         line[i++] = *tb; ++tb;
      }
      line[i]='\0';
      const char *buffer = line;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)buffer );
      free(line);
   }else{
      while(*tb!='\0'){
         if(*tb=='\n'){
            ++nLine;
            if(nLine == cLine){
               char *line = (char *)calloc(MAXREADBUFFER,1);
               int i=0;
               ++tb;  // saltar último '\n'
               while(*tb!='\n' && *tb!='\0'){
                  line[i++] = *tb; ++tb;
               }
               line[i]='\0';
               const char *buffer = line;
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)buffer );
               free(line);
               break;
            }
         }
         ++tb;
      }
      if(*tb=='\0'){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)"" );
      }
   }
 //  }
}else{
   sw=put_error((PHB_ITEM) pRET, "GET LINE INNER-STACK OVERFLOW",101);
}
return sw;
}
   

int fun_savestring(/*int nItem*/){
int sw=1;
if( CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   
   if( HB_IS_STRING(pREG) ){
      const char * cString = hb_itemGetCPtr( pREG );
      PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
      CADDR += SWKEEP; SWKEEP = 0;
      const char * szFile = hb_itemGetCPtr( pFILE );
      hb_itemRelease( pFILE );
      FILE *fp;
      if( (fp = fopen(szFile,"w"))!=NULL ){
         const char * tb = cString;
         while(*tb){
            if(*tb!='\0') fputc(*tb,fp);
            tb++;
         }
      }
      fclose(fp);
      
   }else{
      sw=put_error((PHB_ITEM) pRET, "STRING - SAVE ARGUMENT ERROR",103);
   }
   hb_itemRelease( pREG );
}else{
   sw=put_error((PHB_ITEM) pRET, "STRING - SAVE INNER-STACK OVERFLOW",101);
}
return sw;
}
   
int fun_loadstring(/*int nItem*/ ){
int sw=1;
if( CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * szFile = hb_itemGetCPtr( pFILE );
   hb_itemRelease( pFILE );

   FILE *fp;
   if( (fp=fopen(szFile,"rb") ) != NULL ){
      
      fseek(fp, 0L, SEEK_END);
      long int nFinalPos  = ftell( fp ) ;
      
      rewind( fp );
      fseek( fp, 0L, SEEK_CUR) ;

      char * output = (char *)calloc(nFinalPos + 2, 1);
      if( output ){
         long int i=0;
         char ch;
         while ((ch = fgetc(fp)) != EOF){
            output[i++] = ch;
         }
         output[i] = '\0';
         const char * cbuffer = output;
         //hb_arraySetC( pSTK_ADDR, ++CADDR, cbuffer );
         hb_arraySetC( pSTK_REG, nItem, cbuffer );
         free(output);
      }else{
         sw=put_error((PHB_ITEM) pRET, "STRING - LOAD NOT ENOUGH MEMORY",100);
      }
      fclose(fp);

   }else{
      sw=put_error((PHB_ITEM) pRET, "STRING - LOAD FILE NOT EXIST OR BAD FILENAME",114);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "STRING - LOAD INNER-STACK OVERFLOW",101);
}
return sw;
}

/**************************************************
     FUNCIONES ESTADISTICAS
 ***************************************************/

int fun_get_multiplicatory( PHB_ITEM pARRAY, double *MULTI, long *NUMELEMENTS){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
if (type>=11){
   switch( nDim ){
      case 1:{
         *NUMELEMENTS = d1;
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            *MULTI *= hb_itemGetND( pARG22);
            hb_itemRelease(pARG22);
         }
         break;
      }case 2:{
         *NUMELEMENTS = d1 * d2;
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               *MULTI *= hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_itemRelease(pARG22);
         }
         break;
      }case 3:{
         *NUMELEMENTS = d1 * d2 * d3;
         int i;
         for(i=1; i<=d1; i++){
            PHB_ITEM pARGF = hb_itemArrayGet( pARRAY, i);
            int j;
            for(j=1; j<=d2; j++){
               PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
               int k;
               for(k=1; k<=d3; k++){
                  PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                  *MULTI *= hb_itemGetND( pARGP);
                  hb_itemRelease(pARGP);
               }
               hb_itemRelease(pARGC);
            }
            hb_itemRelease(pARGF);
         }
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_get_summatory( PHB_ITEM pARRAY, double *SUMMA, long *NUMELEMENTS, int TYPE){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
if (type>=11){
   switch( nDim ){
      case 1:{
         *NUMELEMENTS = d1;
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            if(TYPE)   // 1=suma simple; 0=suma reciprocos
                *SUMMA += hb_itemGetND( pARG22);
            else
                *SUMMA += 1 / hb_itemGetND( pARG22);
            hb_itemRelease(pARG22);
         }
         break;
      }case 2:{
         *NUMELEMENTS = d1 * d2;
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               if(TYPE)   // 1=suma simple; 0=suma reciprocos
                  *SUMMA += hb_itemGetND( pARG222);
               else
                  *SUMMA += 1 / hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_itemRelease(pARG22);
         }
         break;
      }case 3:{
         *NUMELEMENTS = d1 * d2 * d3;
         int i;
         for(i=1; i<=d1; i++){
            PHB_ITEM pARGF = hb_itemArrayGet( pARRAY, i);
            int j;
            for(j=1; j<=d2; j++){
               PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
               int k;
               for(k=1; k<=d3; k++){
                  PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                  if(TYPE)   // 1=suma simple; 0=suma reciprocos
                     *SUMMA += hb_itemGetND( pARGP);
                  else
                     *SUMMA += 1 / hb_itemGetND( pARGP);
                  hb_itemRelease(pARGP);
               }
               hb_itemRelease(pARGC);
            }
            hb_itemRelease(pARGF);
         }
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_get_sumespecial(PHB_ITEM pARRAY, int d1, int d2, int type){
int sw=1;
if(CADDR<nSizeStack){
   switch(type){
      case 6:{  // suma columnas
         int j;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d2 );
         for( j=1; j<=d2; j++){
            int i;
            double SUMMA=0;
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA += hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG22);
            }
            hb_arraySetND( pNEWARRAY, j, (double) SUMMA );
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;
      }
      case 7:{   // suma filas
         int i;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d1 );
         for( i=1; i<=d1; i++){  // fila
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            double SUMMA=0;
            for( j=1; j<=d2; j++){  // columna
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA += hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_arraySetND( pNEWARRAY, i, (double) SUMMA );
            hb_itemRelease(pARG22);
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;
      }
      case 8:{   // multiplica columnas
         int j;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d2 );
         for( j=1; j<=d2; j++){
            int i;
            double SUMMA=1;
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA *= hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG22);
            }
            hb_arraySetND( pNEWARRAY, j, (double) SUMMA );
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;
      }
      case 9:{  // multiplica filas
         int i;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d1 );
         for( i=1; i<=d1; i++){  // fila
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            double SUMMA=1;
            for( j=1; j<=d2; j++){  // columna
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA *= hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_arraySetND( pNEWARRAY, i, (double) SUMMA );
            hb_itemRelease(pARG22);
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;

      }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INNER-STACK UNDERFLOW",102);
}
return sw;
}

PHB_ITEM fun_get_class( PHB_ITEM pARRAY, PHB_ITEM pUNIQUE ){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);

   HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
   get_size( (PHB_ITEM) pUNIQUE, &nDim1, &d11, &d12, &d13, &type1);
      
   int i;
   long Ni = 0;
   double Fi = 0;
   PHB_ITEM pNEWARRAY = hb_itemArrayNew( d11 );  // resultado
   for (i=1; i<=d11; i++ ){
      PHB_ITEM pARG2 = hb_itemArrayGet( pUNIQUE, i);
      PHB_ITEM pRows = hb_itemArrayNew( 5 );  // elemento, ocurrencias
      if( HB_IS_NUMERIC(pARG2) ){
         double nDato = hb_itemGetND( pARG2);
         int j;
         long SUMMA = 0;

         for (j=1; j<=d1; j++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, j);
            if( HB_IS_NUMERIC( pARG22 )){
               if( nDato == hb_itemGetND( pARG22) )
                  SUMMA++;
            }
            hb_itemRelease(pARG22);
         }
         double mean =  (double)SUMMA / (double)d1;
         Ni += SUMMA;
         Fi += mean;

         hb_arraySetND( pRows, 1, (double) nDato );
         hb_arraySetNL( pRows, 2, (long) SUMMA );
         hb_arraySetND( pRows, 3, (double) mean );
         hb_arraySetNL( pRows, 4, (long) Ni );
         hb_arraySetND( pRows, 5, (double) Fi );

      }else if( HB_IS_STRING(pARG2)){
         const char * cDato = hb_itemGetCPtr( pARG2);
         int j;
         long SUMMA = 0;
         for (j=1; j<=d1; j++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, j);
            if( HB_IS_STRING( pARG22 )){
                if( strcmp( cDato, hb_itemGetCPtr( pARG22)) == 0 )
                   SUMMA++;
            }
            hb_itemRelease(pARG22);
         }
         double mean =  (double)SUMMA / (double)d1;
         Ni += SUMMA;
         Fi += mean;
         
         hb_arraySetC( pRows, 1, (const char *) cDato );
         hb_arraySetNL( pRows, 2, (long) SUMMA );
         hb_arraySetND( pRows, 3, (double) mean );
         hb_arraySetNL( pRows, 4, (long) Ni );
         hb_arraySetND( pRows, 5, (double) Fi );
      }
      hb_arraySet( pNEWARRAY, i, pRows );
      hb_itemRelease(pRows);
      hb_itemRelease(pARG2);
   }

return pNEWARRAY;
}

PHB_ITEM fun_get_sturgesbin( PHB_ITEM pARRAY, int K ){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
   
   PHB_ITEM pELEMI = hb_itemArrayGet( pARRAY, 1);
   PHB_ITEM pELEMF = hb_itemArrayGet( pARRAY, d1);
   double nEi = floor(hb_itemGetND( pELEMI ));
   double nEf = ceil(hb_itemGetND( pELEMF ));
   double nFinal = nEf;
   hb_itemRelease(pELEMI);
   hb_itemRelease(pELEMF);
   double R = nEf - nEi;        // rango
   int C = ceil((double)R / K);   // amplitud intervalo de clase
   double P=0;               // ajuste para clases inicio y fin 
   if( (double)C*K > R)
      P = ceil( ( (double)C*K - R ) / 2.0 );
   nEi -= P;
   nFinal += P;
   if( nEi<0 ){
      nEf += fabs(nEi);
      nEi = 0; 
   }
   int i;
   long Ni = 0;
   double Fi = 0;
   // llenado de clases:
   PHB_ITEM pNEWARRAY = hb_itemArrayNew( K );  // resultado
   nEf = nEi + C;
   for( i=1; i<=K; i++){   // para cada clase

      PHB_ITEM pRows = hb_itemArrayNew( 7 );  // elemento, ocurrencias
      hb_arraySetNI( pRows, 1, (int) nEi );
      hb_arraySetNI( pRows, 2, (int) nEf );
      hb_arraySetND( pRows, 3, (double) (nEf + fabs(nEi))/2 );
      int j;
      long SUMMA=0;
      
      for(j=1; j<=d1; j++){
         PHB_ITEM pARG = hb_itemArrayGet( pARRAY, j);
         if( HB_IS_NUMERIC( pARG )){
            double nDato = hb_itemGetND( pARG );
            if( nDato >= nEi && nDato < nEf )   // cuenta para [a, b[
               SUMMA++;
         }
         hb_itemRelease(pARG);
      }
      double mean =  (double)SUMMA / (double)d1;
      Ni += SUMMA;
      Fi += mean;

      hb_arraySetNI( pRows, 4, (int) SUMMA );
      hb_arraySetND( pRows, 5, (double) mean );
      hb_arraySetNI( pRows, 6, (int) Ni );
      hb_arraySetND( pRows, 7, (double) Fi );
      hb_arraySet( pNEWARRAY, i, pRows );
      hb_itemRelease(pRows);
      nEi = nEf;
     // if( i==K-1){
     //    nEf = nFinal;//C+nEf > nFinal ? C+nEf : nFinal;
     //    if( nEf-nEi != C )
            
     // }else 
         nEf += C;
         //nEf = nEf + C + ((i==K-1) ? ( -C + nFinal ): 0.0);  // para incluir el último dato de la lista [a, B]
   }
   // recopilacion de datos y llenado de tabla
   //printf("\nK = %d\n",K);
return pNEWARRAY;
}


int fun_stat_especial(/*int nItem */){
int sw=1;

if( CADDR >= 1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int tCompare = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   
   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );   // array

   if( HB_IS_ARRAY(pARRAY) ){
      if( tCompare < 3 ){
         // esta es fundamental, sobre esta se construye la estadística descriptiva con MACROS. 
         long NUMELEMENTS=0;
         double SUMMA=0;
         CADDR += SWKEEP; SWKEEP = 0;
         if(!(int)fun_get_summatory(pARRAY, &SUMMA, &NUMELEMENTS, 1)){
            sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (SUMMATORY BASED) ARGUMENT ERROR",103);
         }else{
            switch( tCompare ){
               case 0:{   // suma
                  hb_arraySetND( pSTK_ADDR, ++CADDR, (double) SUMMA ); break; 
               }case 1: {   // busca promedio
                  hb_arraySetND( pSTK_ADDR, ++CADDR, (double) ( SUMMA / NUMELEMENTS ) ); break;
               }case 2: {  // suma y promedio
                  if( CADDR<=nSizeStack){
                     hb_arraySetND( pSTK_ADDR, ++CADDR, (double) SUMMA );
                     hb_arraySetND( pSTK_ADDR, ++CADDR, (double) ( SUMMA / NUMELEMENTS ) );
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (SUM OR MEAN) INNER-STACK UNDERFLOW",102);
                  }
                  break;
               }default:{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INVALID FUNC - ARGUMENT ERROR",103);break;
               }
            }
         }
      }else{   // otras cosas. por ahora: error
         switch( tCompare ){
            case 3: case 4:{   // sturges class  // variable continua
               // el array debe ser 1D. si no es, usar reshape afuera.
               long N = hb_arrayLen(pARRAY);
               hb_arraySort( pARRAY, NULL, NULL, NULL );
               int K=0;
               // calcular K según strges o bindado.
               if( tCompare == 4 ){  // sacar desde el Stack el bin dado
                  if(CADDR>=1){
                     PHB_ITEM pBIN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                     CADDR += SWKEEP; SWKEEP = 0;
                     K = hb_itemGetNI(pBIN);
                     hb_itemRelease(pBIN);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (STURGESS) INVALID BIN - ARGUMENT ERROR",103);break;
                  }
               }else{
                  K = ceil(1+3.3*log10(N));
               }
               
               PHB_ITEM pNEWARRAY = fun_get_sturgesbin( (PHB_ITEM) pARRAY, (int) K );
               hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
               hb_itemRelease(pNEWARRAY);
               
               break;
            }case 5: {   // ocurrencias de cada elemento. un elemento es una clase en sí misma.
               // el array debe ser 1D. si no es, usar reshape afuera.
              
               hb_arraySort( pARRAY, NULL, NULL, NULL );
               PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pARRAY );
               PHB_ITEM pNEWARRAY = fun_get_class( (PHB_ITEM) pARRAY, (PHB_ITEM) pUNIQUE );
               hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
               hb_itemRelease(pUNIQUE);
               hb_itemRelease(pNEWARRAY);
               break;
            }case 6:{   // suma columnas => vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,6);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (COLUMN SUM) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 7:{   // suma filas ==> vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,7);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (ROW SUM) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 8: case 9:{   // multiplica todo, como la suma
               long NUMELEMENTS=0;
               double MULTI=1;
               CADDR += SWKEEP; SWKEEP = 0;
               if(!(int)fun_get_multiplicatory(pARRAY, &MULTI, &NUMELEMENTS)){
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (MULTIPLICATORY BASED) ARGUMENT ERROR",103);
               }else{
                  switch( tCompare ){
                     case 8:{   // multiplicatoria
                        hb_arraySetND( pSTK_ADDR, ++CADDR, (double) MULTI ); break; 
                     }case 9: {   // media geométrica
                       //printf("\nMULTI= %lf, NUMELE=%ld, 1/NUM=%lf, PRUEBA: %lf\n",(double)MULTI,(long)NUMELEMENTS,(double)(1/NUMELEMENTS),(double) pow( (double)MULTI, (double)(1.0 / NUMELEMENTS) ));
                        hb_arraySetND( pSTK_ADDR, ++CADDR, (double) pow( (double)MULTI, (double)(1.0 / NUMELEMENTS) ) ); break;
                     }default:{
                        sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INVALID FUNC - ARGUMENT ERROR",103);break;
                     }
                  }
               }
               break;
            }case 10:{  // media harmónica: suma reciprocos
               long NUMELEMENTS=0;
               double SUMMA=0;
               CADDR += SWKEEP; SWKEEP = 0;
               if(!(int)fun_get_summatory(pARRAY, &SUMMA, &NUMELEMENTS, 0)){
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (HARMONIC MEAN) ARGUMENT ERROR",103);
               }else{
                  hb_arraySetND( pSTK_ADDR, ++CADDR, (double) (NUMELEMENTS / SUMMA) );
               }
               break;
            }case 11:{   // multiplica columnas => vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,8);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (COLUMN MULT) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 12:{   // multiplica filas ==> vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,9);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (ROW MULT) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 13: case 14:{  // ADDSUB | SUBADD
                  CADDR += SWKEEP; SWKEEP = 0;
                  HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
                  get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
                  if(type==11 && nDim==1 && d1>0){
                     HB_SIZE nLenT=hb_arrayLen( pARRAY );
            
                     HB_SIZE i;
                     int swAlter;
                     if (tCompare==13) swAlter=1; else swAlter=0;
                     PHB_ITEM pELEM = hb_itemArrayGet(pARRAY,1);
                     double nResul=(double)hb_itemGetND(pELEM);
                     hb_itemRelease(pELEM);
                     for(i=2;i<=nLenT;i++){
                        PHB_ITEM pELEM = hb_itemArrayGet(pARRAY,i);
                        if(swAlter){
                           nResul += (double)hb_itemGetND(pELEM); swAlter=0;
                        }else{
                           nResul -= (double)hb_itemGetND(pELEM); swAlter=1;
                        }
                        hb_itemRelease(pELEM);
                     }
                     hb_arraySetND( pSTK_ADDR, ++CADDR, (double) (nResul) );
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "ARRAY ADDSUB|SUBADD ARGUMENT ERROR: I NEED AN NUMBER'S UNIDIM ARRAY",103);
                  }
               break;

            }default:{
               sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INVALID FUNC - ARGUMENT ERROR",103);break;
            }
         }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "STATS-FUNC ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INNER-STACK OVERFLOW",101);
}
return sw;
}

/***********************************************
     FUNCIONES TRY CATCH, RAISE ATRAPAN
     ERRORES
 ************************************************/
// "poptry"=>71, "gettry"=>264, "swtrap"=>265, "throw"=>266
int fun_trycatch( /*int nItem,*//* int tCompare*/){
int sw=1;

int tCompare = nPCP==71 ? 3 : nPCP-264;
switch( tCompare){
   case /*264*/0:{  // GETTRY
      int nItem = STK_PRG[++CP]; // para colocar el codigo del error
      PHB_ITEM pERRCOD = hb_itemArrayGet( pRET, 7 );
      if( HB_IS_NUMERIC(pERRCOD)){
         hb_arraySetNI( pSTK_REG, nItem, (int) hb_itemGetNI(pERRCOD) );
      }else{
         sw=put_error((PHB_ITEM) pRET, "TRY BAD FORMED",118);
      }
      hb_itemRelease(pERRCOD);
      break;
   }case /*265*/1:{  // SWTRAP
      unsigned int nItem = STK_PRG[ ++CP ];
      sw= (int) push_try( (unsigned int) nItem ) ;
      break;
   }case /*266*/ 2:{   // RAISE
      int nItem = STK_PRG[++CP];
      PHB_ITEM pERRCOD = hb_itemArrayGet( pSTK_REG, nItem );
      int nErrCode=hb_itemGetNI(pERRCOD);
      hb_itemRelease(pERRCOD);
      if(CADDR>=1){
         PHB_ITEM pSTRERR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         const char * cMsgErr = hb_itemGetCPtr(pSTRERR);
         sw=put_error((PHB_ITEM) pRET, (const char *) cMsgErr,nErrCode);
         hb_itemRelease(pSTRERR);
      }else{
         sw=put_error((PHB_ITEM) pRET, "USER RAISED ERROR ",nErrCode);
      }
      break;
   }case /*71*/ 3:{   // POPTRY
      int tCP = CP;
      sw=(int) pop_try();  // esto obtiene nueva direccion. Aquí no sirve.
      CP = tCP;
      break;
   }
}
return sw;
}


/*
 * Additional date functions
 *
 * Copyright 1999 Jose Lalin <dezac@corevia.com>
 */

static int hb_isleapyear( int iYear )
{
   return ( iYear % 4 == 0 && iYear % 100 != 0 ) || ( iYear % 400 == 0 );
}

void fun_get_time(const char * szTime, int nLen, int *iHour, int *iMinute, int *iSeconds, int *iMillisec){
   if( nLen >= 8 ){
      *iHour    = 10 * ( szTime[ 0 ] - '0' ) + ( szTime[ 1 ] - '0' );
      *iMinute  = 10 * ( szTime[ 3 ] - '0' ) + ( szTime[ 4 ] - '0' );
      *iSeconds = 10 * ( szTime[ 6 ] - '0' ) + ( szTime[ 7 ] - '0' );
      if( nLen == 11 ){
         *iMillisec = 10 * ( szTime[ 9 ] - '0' ) + ( szTime[ 10 ] - '0' );
      }else{
         *iMillisec = 0;
      }
   }else{
      *iHour = *iMinute = *iSeconds = *iMillisec = 0;
   }
}
static int _hb_timeValid( const char * szTime, HB_SIZE nLen, int * piDecode )
{
   int fValid = 0;

   if( nLen == 2 || nLen == 5 || nLen == 8 || nLen == 11 )
   {
      static const int sc_iMax[] = { 23, 59, 59, 99 };
      int     i, iVal;
      HB_SIZE ul;

      fValid = 1;
      for( ul = 0; fValid && ul < nLen; ++ul )
      {
         fValid = ul % 3 == 2 ? szTime[ ul ] == ':' :
                  ( szTime[ ul ] >= '0' && szTime[ ul ] <= '9' );
      }
      for( ul = 0, i = 0; fValid && ul < nLen; ul += 3, ++i )
      {
         iVal   = 10 * ( szTime[ ul ] - '0' ) + ( szTime[ ul + 1 ] - '0' );
         fValid = iVal <= sc_iMax[ i ];
         if( piDecode )
            piDecode[ i ] = iVal;
      }
   }

   return fValid;
}

int _hb_dateValid( const char * cDate, HB_SIZE nLen ){
   const char * pDate = cDate;
   
   int fecha_correcta = 0;

   char *fecha = (char *)calloc( nLen+10, 1 );
   memcpy(fecha,pDate,nLen);
   char * cDia = strtok(fecha, "/");
   if(cDia){
      char * cMes = strtok(0, "/");
      if(cMes){
         char * cAnio = strtok(0, "/");
         if(cAnio){
            const char *pDia = cDia;
            const char *pMes = cMes;
            const char *pAnio = cAnio;
            int nDia = atoi( pDia );
            int nMes = atoi( pMes );
            int nAnio = atoi( pAnio );
            int dia_maximo=0;

            if ( nMes >= 1 && nMes <= 12 ){
               switch ( nMes ){
                  case  1 : case  3 : case  5 : case  7 : case  8 : case 10 :
                  case 12 : dia_maximo = 31;
                            break;
                  case  4 : case  6 : case  9 :
                  case 11 : dia_maximo = 30;
                            break;
                  case  2 : if ( nAnio % 4 == 0 && nAnio % 100 != 0 || nAnio % 400 == 0 )
                               dia_maximo = 29;
                            else
                                dia_maximo = 28;
               }

               if ( nDia >= 1 && nDia <= dia_maximo )
                  fecha_correcta = 1;
            }
         }
      }
   }
   free(fecha); //free(cDia);free(cMes);free(cAnio);
   return fecha_correcta;
}

static int ct_doy( long lDate )
{
   int iYear, iMonth, iDay;
   long lFirst;

   hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
   lFirst = hb_dateEncode( iYear, 1, 1 );
   return ( int ) ( lDate - lFirst + 1 );
}

static int ct_daysinmonth( int iMonth, int bLeap )
{
   if( iMonth == 2 )
      return bLeap ? 29 : 28;
   else if( iMonth == 4 || iMonth == 6 || iMonth == 9 || iMonth == 11 )
      return 30;
   else
      return 31;
}


static char * hb_SecToTimeStr( char * pszTime, long lTime )
{
   int iValue;

   HB_TRACE(HB_TR_DEBUG, ("hb_SecToTimeStr(%p, %ld)", pszTime, lTime));

   iValue = ( int ) ( ( lTime / 3600 ) % 24 );
   pszTime[ 0 ] = ( char ) ( iValue / 10 ) + '0';
   pszTime[ 1 ] = ( char ) ( iValue % 10 ) + '0';
   pszTime[ 2 ] = ':';
   iValue = ( int ) ( ( lTime / 60 ) % 60 );
   pszTime[ 3 ] = ( char ) ( iValue / 10 ) + '0';
   pszTime[ 4 ] = ( char ) ( iValue % 10 ) + '0';
   pszTime[ 5 ] = ':';
   iValue = ( int ) ( lTime % 60 );
   pszTime[ 6 ] = ( char ) ( iValue / 10 ) + '0';
   pszTime[ 7 ] = ( char ) ( iValue % 10 ) + '0';
   pszTime[ 8 ] = '\0';

   return pszTime;
}

static long hb_TimeStrToSec( const char * pszTime )
{
   HB_SIZE nLen;
   long lTime = 0;

   HB_TRACE(HB_TR_DEBUG, ("hb_TimeStrToSec(%s)", pszTime));

   nLen = strlen( pszTime );

   if( nLen >= 1 )
      lTime += ( long ) hb_strVal( pszTime, nLen ) * 3600;

   if( nLen >= 4 )
      lTime += ( long ) hb_strVal( pszTime + 3, nLen - 3 ) * 60;

   if( nLen >= 7 )
      lTime += ( long ) hb_strVal( pszTime + 6, nLen - 6 );

   return lTime;
}

int fun_get_dateadd_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pA, PHB_ITEM pB) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pB, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            long lStart = hb_dateUnformat( hb_itemGetCPtr( pARG11 ), hb_setGetDateFormat() );
            long lEnd = hb_itemGetNI( pA );
            char szDate[ 9 ];
            char szFormatted[ 11 ];
            hb_arraySetC( pRows, i, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                                szFormatted, hb_setGetDateFormat() ) );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               long lStart = hb_dateUnformat( hb_itemGetCPtr( pARG111 ), hb_setGetDateFormat() );
               long lEnd = hb_itemGetNI( pA );
               char szDate[ 9 ];
               char szFormatted[ 11 ];
               hb_arraySetC( pCols, j, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                                szFormatted, hb_setGetDateFormat() ) );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  long lStart = hb_dateUnformat( hb_itemGetCPtr( pARG1111 ), hb_setGetDateFormat() );
                  long lEnd = hb_itemGetNI( pA );
                  char szDate[ 9 ];
                  char szFormatted[ 11 ];
                  hb_arraySetC( pPag, k, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                                   szFormatted, hb_setGetDateFormat() ) );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int get_dateadd(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING( pB ) && HB_IS_NUMERIC( pA )){
      long lStart = hb_dateUnformat( hb_itemGetCPtr( pB ), hb_setGetDateFormat() );
      long lEnd = hb_itemGetNI( pA );
      char szDate[ 9 ];
      char szFormatted[ 11 ];
      hb_arraySetC( pSTK_ADDR, ++CADDR, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                    szFormatted, hb_setGetDateFormat() ) );
   }else if(HB_IS_ARRAY( pB ) && HB_IS_NUMERIC( pA )){
      ++CADDR;
      sw=fun_get_dateadd_matrix( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM)pA, (PHB_ITEM)pB );
   }else{
      sw=put_error((PHB_ITEM) pRET, "DATE ADD ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
   hb_itemRelease(pB);
}else{
   sw=put_error((PHB_ITEM) pRET, "DATE ADD INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_daysdiff_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pA, PHB_ITEM pB) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pB, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
            long lEnd = hb_dateUnformat( hb_itemGetCPtr( pARG11 ), hb_setGetDateFormat() );      
            hb_arraySetNI( pRows, i, lStart - lEnd );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
               long lEnd = hb_dateUnformat( hb_itemGetCPtr( pARG111 ), hb_setGetDateFormat() );      
               hb_arraySetNI( pCols, j, lStart - lEnd );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
                  long lEnd = hb_dateUnformat( hb_itemGetCPtr( pARG1111 ), hb_setGetDateFormat() );      
                  hb_arraySetNI( pPag, k, lStart - lEnd );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int get_daysdiff(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING( pA ) && HB_IS_STRING( pB )){
      long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
      long lEnd = hb_dateUnformat( hb_itemGetCPtr( pB ), hb_setGetDateFormat() );      
      hb_arraySetNI( pSTK_ADDR, ++CADDR, lStart - lEnd );
   }else if(HB_IS_STRING( pA ) && HB_IS_ARRAY( pB )){
      ++CADDR;
      sw=fun_get_daysdiff_matrix( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM)pA, (PHB_ITEM)pB );
   }else{
      sw=put_error((PHB_ITEM) pRET, "DAYS DIFF ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
   hb_itemRelease(pB);
}else{
   sw=put_error((PHB_ITEM) pRET, "DAYS DIFF INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_elaptime_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pA, PHB_ITEM pB) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pB, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pARG11 ) );
            long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
            char szTime[ 9 ];
            hb_arraySetC( pRows, i, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pARG111 ) );
               long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
               char szTime[ 9 ];
               hb_arraySetC( pCols, j, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pARG1111 ) );
                  long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
                  char szTime[ 9 ];
                  hb_arraySetC( pPag, k, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int get_elaptime(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING( pA ) && HB_IS_STRING( pB )){
      long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pB ) );
      long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
      char szTime[ 9 ];
      hb_arraySetC( pSTK_ADDR, ++CADDR, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
   }else if(HB_IS_STRING( pA ) && HB_IS_ARRAY( pB )){
      ++CADDR;
      sw=fun_get_elaptime_matrix( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM)pA, (PHB_ITEM)pB );
   }else{
      sw=put_error((PHB_ITEM) pRET, "ELAPTIME ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
   hb_itemRelease(pB);
}else{
   sw=put_error((PHB_ITEM) pRET, "ELAPTIME INNER-STACK OVERFLOW",101);
}
return sw;
}

int get_seconds(){
int sw=1;

if( CADDR<nSizeStack ){
   if(CADDR>=1){
      PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if(HB_IS_STRING( pA )){
         hb_arraySetND( pSTK_ADDR, ++CADDR, hb_TimeStrToSec( hb_itemGetCPtr( pA ) ) );
      }
      hb_itemRelease(pA);
   }else{   // segundos transcurridos desde la medianoche-
      hb_arraySetND( pSTK_ADDR, ++CADDR, (double) hb_dateSeconds() );
      ///hb_arraySetND( pSTK_ADDR, ++CADDR, clock() );
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SECONDS INNER-STACK OVERFLOW",101);
}   
return sw;
}

int get_sectotime(/* PHB_ITEM pSTK_ADDR, PHB_ITEM pRET */){
int sw=1;

if(CADDR>=1){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_NUMERIC( pA )){
      char pszTime[ 9 ];
      hb_arraySetC( pSTK_ADDR, ++CADDR, hb_SecToTimeStr( pszTime, hb_itemGetNInt( pA ) ) );
   }else{
      sw=put_error((PHB_ITEM) pRET, "SECONDS TO TIME ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
}else{
   sw=put_error((PHB_ITEM) pRET, "SECONDS TO TIME INNER-STACK OVERFLOW",101);
}
return sw;
}

int put_sleep(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   hb_idleSleep( hb_itemGetND( pA ) );
   //sleep( hb_itemGetNInt( pA ) );
   hb_itemRelease(pA);
}else{
   sw=put_error((PHB_ITEM) pRET, "SLEEP INNER-STACK OVERFLOW",101);
}   
return sw;
}

int put_microseconds(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   // hb_idleSleep( hb_itemGetNInt( pA ) / 1000 );
   usleep( hb_itemGetNInt( pA ) );// * 1000 );
   hb_itemRelease(pA);
}else{
   sw=put_error((PHB_ITEM) pRET, "MICROSECONDS INNER-STACK OVERFLOW",101);
}   
return sw;
}

int fun_timecpu(){  // milisegundos desde iniciado el proceso.
int sw=1;
int nItem = STK_PRG[++CP];
clock_t tiempo = clock();
hb_arraySetNI( pSTK_REG, nItem, (int) tiempo );
return sw;
}

int fun_timer(){   // trabaja con TIMECPU.
int sw=1;
if(CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pVARTIMER = hb_itemArrayGet( pSTK_REG, nItem);
   double nVarTimer = hb_itemGetND(pVARTIMER);
   hb_itemRelease(pVARTIMER);
   
   PHB_ITEM pTIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   double nTimeMillisec = hb_itemGetND(pTIME);
   hb_itemRelease(pTIME);
   clock_t tiempo = clock();
  // if( ( (double) hb_dateSeconds() - nVarTimer ) * 1000 >= nTimeMillisec ){
  if( ( tiempo - nVarTimer ) * 1000 / CLOCKS_PER_SEC >= nTimeMillisec ){
      hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
      //hb_arraySetND(pSTK_REG, nItem, (double) hb_dateSeconds());
      //tiempo = clock();
      hb_arraySetND(pSTK_REG, nItem, tiempo);
   }else{
      hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "TIMER INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_clock_per_sec(){
int sw=1;
if(CADDR<nSizeStack){
   hb_arraySetND(pSTK_ADDR, ++CADDR, CLOCKS_PER_SEC);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLOCKPERSEC INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_notation(){
int sw=1;
if(CADDR){
   PHB_ITEM pNUMBER = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING(pNUMBER)){
      const char * AX = hb_itemGetCPtr(pNUMBER);
      hb_itemRelease(pNUMBER);
      if( xu_funIsnotation((const char *) AX) ){
         double nDbl = xu_funE2D( (const char *) AX );
         hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nDbl);
         hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
      }else{
         hb_arraySetC(pSTK_ADDR, ++CADDR, (const char * ) AX);
         hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GETNOTATION? ARGUMENT ERROR",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "GETNOTATION? INNER-STACK UNDERFLOW",104);
}
return sw;
}

int fun_get_datetime_item(PHB_ITEM pDATETIME, PHB_ITEM pSTK, int ndx,/* PHB_ITEM pRET,*/ int nCode, int single){
int sw=1;
   const char * cDate = hb_itemGetCPtr(pDATETIME);
   long nLen = hb_itemGetCLen(pDATETIME);
   
   switch( nCode ){
      case 1:{
         char pszTime[24];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 24, "%02d de %s de %4d", iDay,XU_ANO[iMonth], iYear);
         hb_arraySetC( pSTK, ndx, (const char * )pszTime );
         break;
      // 2 y 3 no aplican, porque ya son strings
      }case 4: case 5:{  // fecha en stack, hora
         if( single ){
            if( nCode==4 ){
               if( CADDR<=nSizeStack-3 ){
                  int iYear, iMonth, iDay;
                  hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                     &iYear, &iMonth, &iDay );
                  hb_arraySetNI( pSTK, CADDR, iYear);
                  hb_arraySetNI( pSTK, ++CADDR, iMonth);
                  hb_arraySetNI( pSTK, ++CADDR, iDay);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "DATE INNER-STACK OVERFLOW",101);
               }
            }else{
               if( CADDR<=nSizeStack-4 ){
                  int iHour, iMinute, iSeconds, iMillisec;
                  fun_get_time( cDate, nLen, &iHour, &iMinute, &iSeconds, &iMillisec );
                  hb_arraySetNI( pSTK, CADDR, iMillisec);
                  hb_arraySetNI( pSTK, ++CADDR, iSeconds);
                  hb_arraySetNI( pSTK, ++CADDR, iMinute);
                  hb_arraySetNI( pSTK, ++CADDR, iHour);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "DATE INNER-STACK OVERFLOW",101);
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "DATE INNER-STACK OUT OF CONTEXT",108);
         }
         break;
      }case 6:case 7: case 8:{   //año, mes, dia, 
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         switch( nCode ){
            case 6: {hb_arraySetNI( pSTK, ndx, iYear); break;}
            case 7: {hb_arraySetNI( pSTK, ndx, iMonth); break;}
            case 8: {hb_arraySetNI( pSTK, ndx, iDay); break;}
         }
         break;
      }case 9:case 10: case 11:{    //hora, minuto, segundos
         int iHour, iMinute, iSeconds, iMillisec;
         fun_get_time( cDate, nLen, &iHour, &iMinute, &iSeconds, &iMillisec );
         switch( nCode ){
            case 9: {hb_arraySetNI( pSTK, ndx, iHour); break;}
            case 10: {hb_arraySetNI( pSTK, ndx, iMinute); break;}
            case 11: {hb_arraySetNI( pSTK, ndx, iSeconds); break;}
         }
         break;
      }case 12:{  // dia de la semana en palabras
         char pszTime[ 11 ];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         if( nDow > 0){
            const char * semana = XU_SEMANA[ nDow ];
            hb_arraySetC( pSTK, ndx, semana);
         }else{
            hb_arraySetC( pSTK, ndx, cDate );
         }
         break;
      }case 13:{   // mes en palabras
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         const char * mes = XU_ANO[ iMonth ];
         hb_arraySetC( pSTK, ndx, mes);
         break;
      }case 14:{    // es año bisiesto?
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_arraySetNI( pSTK, ndx, (int) hb_isleapyear( iYear ) );
         break;
      }case 15:{    // días en el mes
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         int bLeap = hb_isleapyear( iYear );
         hb_arraySetNI( pSTK, ndx, ct_daysinmonth( iMonth, bLeap ) );
         break;
      }case 16:{   // dia de la semana en indice.
         char pszTime[ 11 ];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK, ndx, nDow );
         break;
      }case 17:{   // semana del año
         long lDate2;
         char pszTime[ 11 ];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         long lDate = hb_dateUnformat( cDate, hb_setGetDateFormat() );
         if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
             lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
         else
             lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
         hb_arraySetNI( pSTK, ndx, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
         break;
      }case 18:{   // día del año
         int ndiadelYear = ct_doy( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK, ndx, ndiadelYear );
         break;
      }case 19:{  // hora valida?
         hb_arraySetNI( pSTK, ndx, (int) _hb_timeValid( cDate, nLen, NULL ));
         break;
      }case 20:{   // fecha valida?
         hb_arraySetNI( pSTK, ndx, (int) _hb_dateValid( cDate, nLen));
         break;
      }default: sw=put_error((PHB_ITEM) pRET, "DATE ARGUMENT ERROR",103); break;
   
   }
return sw;
}

int fun_get_datetime_matrix(PHB_ITEM pDATETIME, PHB_ITEM pSTK_ADDR, int CADDR,/* PHB_ITEM pRET,*/int nCode){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pDATETIME, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
            sw=fun_get_datetime_item( (PHB_ITEM) pARG11, (PHB_ITEM) pRows, i, /*(PHB_ITEM) pRET,*/ (int) nCode, 0);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=fun_get_datetime_item( (PHB_ITEM) pARG111, (PHB_ITEM) pCols, j,/* (PHB_ITEM) pRET,*/ (int) nCode, 0);
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=fun_get_datetime_item( (PHB_ITEM) pARG1111, (PHB_ITEM) pPag, k,/* (PHB_ITEM) pRET,*/ (int) nCode, 0);
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int fun_date_time( /*int nItem */){
int sw=1;
if(CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int nCode = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   PHB_ITEM pDATETIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pDATETIME)){
      ++CADDR;
      sw=fun_get_datetime_item( (PHB_ITEM) pDATETIME, (PHB_ITEM) pSTK_ADDR, CADDR,/* (PHB_ITEM) pRET,*/ (int) nCode, 1);
      
   }else if( HB_IS_ARRAY(pDATETIME)){
      ++CADDR;
      sw=fun_get_datetime_matrix( (PHB_ITEM) pDATETIME, (PHB_ITEM) pSTK_ADDR, CADDR,/* (PHB_ITEM) pRET,*/ (int) nCode);
//   long lDate = hb_dateUnformat( cDate, hb_setGetDateFormat() );
   }
   hb_itemRelease(pDATETIME);

}else{
   sw=put_error((PHB_ITEM) pRET, "DATE & TIME INNER-STACK OVERFLOW",101);
}
return sw;
}

void fun_put_names(PHB_ITEM pDATETIME, int tCompare){

       HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
       get_size( (PHB_ITEM) pDATETIME, &nDim, &d1, &d2, &d3, &type);

       switch( nDim ){
          case 1:{
             PHB_ITEM pRows  = hb_itemArrayNew( d1 );
             long i;
             for (i=1; i<=d1; i++ ){
                PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
                switch(tCompare){
                    case 0:{
                       int nCode = hb_itemGetNInt(pARG11);
                       if(nCode>=1 && nCode<=7){
                           const char * pszTime = XU_SEMANA[nCode];
                           hb_arraySetC( pRows, i, (const char * )pszTime );
                       }else{
                           hb_arraySetC( pRows, i, (const char * )"***" );
                       }
                       break;
                   }case 1:{
                       int nCode = hb_itemGetNInt(pARG11);
                       if(nCode>=1 && nCode<=12){
                           const char * pszTime = XU_ANO[nCode];
                           hb_arraySetC( pRows, i, (const char * )pszTime );
                       }else{
                           hb_arraySetC( pRows, i, (const char * )"***" );
                       }
                       break;
                   }
                }
                hb_itemRelease(pARG11);
             }
             hb_arraySet(pSTK_ADDR, CADDR, pRows);
             hb_itemRelease(pRows);
             break;
         }case 2:{
             PHB_ITEM pRows = hb_itemArrayNew( d1 );
             long i;
             for( i=1; i<=d1; i++){
                PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
                PHB_ITEM pCols = hb_itemArrayNew( d2 );
                long j;
                for( j=1; j<=d2; j++){
                   PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
                   switch(tCompare){
                      case 0:{
                         int nCode = hb_itemGetNInt(pARG111);
                         if(nCode>=1 && nCode<=7){
                             const char * pszTime = XU_SEMANA[nCode];
                             hb_arraySetC( pCols, j, (const char * )pszTime );
                         }else{
                             hb_arraySetC( pCols, j, (const char * )"***" );
                         }
                         break;
                      }case 1:{
                         int nCode = hb_itemGetNInt(pARG111);
                         if(nCode>=1 && nCode<=12){
                             const char * pszTime = XU_ANO[nCode];
                             hb_arraySetC( pCols, j, (const char * )pszTime );
                         }else{
                             hb_arraySetC( pCols, j, (const char * )"***" );
                         }
                         break;
                      }
                   } 
                   hb_itemRelease(pARG111);
                }
                hb_arraySet( pRows, i, pCols );
                hb_itemRelease(pARG11);
                hb_itemRelease(pCols);
             }
             hb_arraySet(pSTK_ADDR, CADDR, pRows);
             hb_itemRelease(pRows);
             break;
         }case 3:{
             PHB_ITEM pRows = hb_itemArrayNew( d1 );
             long i;
             for( i=1; i<=d1; i++){
                PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
                PHB_ITEM pCols = hb_itemArrayNew( d2 );
                long j;
                for( j=1; j<=d2; j++){
                   PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
                   PHB_ITEM pPag = hb_itemArrayNew( d3 );
                   long k;
                   for( k=1; k<=d3; k++){
                      PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                      switch(tCompare){
                         case 0:{
                            int nCode = hb_itemGetNInt(pARG1111);
                            if(nCode>=1 && nCode<=7){
                                const char * pszTime = XU_SEMANA[nCode];
                                hb_arraySetC( pPag, k, (const char * )pszTime );
                            }else{
                                hb_arraySetC( pPag, k, (const char * )"***" );
                            }
                            break;
                         }case 1:{
                            int nCode = hb_itemGetNInt(pARG1111);
                            if(nCode>=1 && nCode<=12){
                                const char * pszTime = XU_ANO[nCode];
                                hb_arraySetC( pPag, k, (const char * )pszTime );
                            }else{
                                hb_arraySetC( pPag, k, (const char * )"***" );
                            }
                            break;
                         }
                      }
                      hb_itemRelease(pARG1111);
                   }
                   hb_arraySet( pCols, j, pPag );
                   hb_itemRelease(pARG111);
                   hb_itemRelease(pPag);
                }
                hb_arraySet( pRows, i, pCols );
                hb_itemRelease(pARG11);
                hb_itemRelease(pCols);
             }
             hb_arraySet(pSTK_ADDR, CADDR, pRows);
             hb_itemRelease(pRows);
             break;
         }
      }

}

int fun_dayname(){
int sw=1;
if(CADDR){
   int tCompare=0;
   PHB_ITEM pDATETIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(!HB_IS_ARRAY(pDATETIME)){
       int nCode = hb_itemGetNInt(pDATETIME);
       if(nCode>=1 && nCode<=7){
           const char * pszTime = XU_SEMANA[nCode];
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
       }else{
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )"***" );
       }
   }else{  // array de enteros.
       ++CADDR;
       fun_put_names( (PHB_ITEM) pDATETIME, (int) tCompare );
   }
   hb_itemRelease(pDATETIME);
}else{
   sw=put_error((PHB_ITEM) pRET, "DAYNAME INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_monthname(){
int sw=1;
if(CADDR){
   int tCompare=1;
   PHB_ITEM pDATETIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(!HB_IS_ARRAY(pDATETIME)){
       int nCode = hb_itemGetNInt(pDATETIME);
       if(nCode>=1 && nCode<=12){
           const char * pszTime = XU_ANO[nCode];
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
       }else{
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )"***" );
       }
   }else{
       ++CADDR;
       fun_put_names( (PHB_ITEM) pDATETIME, (int) tCompare );
   }
   hb_itemRelease(pDATETIME);
}else{
   sw=put_error((PHB_ITEM) pRET, "MONTHNAME INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_datenow( /*int nItem */){
int sw=1;
if( CADDR<nSizeStack ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int nCode = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   
   int iYear, iMonth, iDay, iHour, iMinute, iSeconds, iMillisec;
   hb_timeStampGetLocal( &iYear, &iMonth, &iDay,
                         &iHour, &iMinute, &iSeconds, &iMillisec );

   switch(nCode){
      case 0: case 1:{   // fecha y hora completa, codificada como dd/mm/aaaa,hh:mm:ss.mss
         char pszTime[ nCode ? 37 : 25];
         
         if( nCode )   //1 = natural
            hb_snprintf( pszTime, 37, "%02d de %s de %4d,%02d:%02d:%02d:%02d", iDay,XU_ANO[iMonth], iYear, iHour, 
                                                                               iMinute, iSeconds, iMillisec/10 );
         else          // formato ///
            hb_snprintf( pszTime, 25, "%02d/%02d/%4d,%02d:%02d:%02d:%02d", iDay,iMonth,iYear, iHour,iMinute,iSeconds, iMillisec/10 );
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
         break;
      }case 2:{  //  fecha string
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
         break;
      }case 3:{  //  hora string
         char pszTime[ 13 ];
         hb_snprintf( pszTime, 13, "%02d:%02d:%02d:%02d", iHour, iMinute, iSeconds, iMillisec/10 );
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
         break;
      }case 4: case 5:{   // fecha en stack, hora en stack, formato numero
         if( nCode==4 ){
            if( CADDR<=nSizeStack-3 ){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iYear);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iMonth);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iDay);
            }else{
               sw=put_error((PHB_ITEM) pRET, "DATENOW INNER-STACK OVERFLOW",101);
            }
         }else{
            if( CADDR<=nSizeStack-4 ){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)iMillisec/10);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iSeconds);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iMinute);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iHour);
            }else{
               sw=put_error((PHB_ITEM) pRET, "DATENOW INNER-STACK OVERFLOW",101);
            }
         }
         break;
      }case 6:case 7: case 8: case 9:case 10: case 11:{   //año, mes, dia, hora, minuto, segundos
         switch( nCode ){
            case 6: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iYear); break;}
            case 7: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iMonth); break;}
            case 8: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iDay); break;}
            case 9: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iHour); break;}
            case 10: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iMinute); break;}
            case 11: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iSeconds); break;}
         }
         break;
      }case 12:{  // dia de la semana en palabras
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         if( nDow > 0){
            const char * semana = XU_SEMANA[ nDow ];
            hb_arraySetC( pSTK_ADDR, ++CADDR, semana);
         }else{
            hb_arraySetC( pSTK_ADDR, ++CADDR, cDate );
         }
         break;
      }case 13:{   // mes en palabras
         const char * mes = XU_ANO[ iMonth ];
         hb_arraySetC( pSTK_ADDR, ++CADDR, mes);
         break;
      }case 14:{    // es año bisiesto?
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) hb_isleapyear( iYear ) );
         break;
      }case 15:{    // días en el mes
         int bLeap = hb_isleapyear( iYear );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, ct_daysinmonth( iMonth, bLeap ) );
         break;
      }case 16:{   // dia de la semana en indice.
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, nDow );
         break;
      }case 17:{   // semana del año
         long lDate2;
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         long lDate = hb_dateUnformat( cDate, hb_setGetDateFormat() );
         if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
             lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
         else
             lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
         break;
      }case 18:{   // día del año
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int ndiadelYear = ct_doy( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, ndiadelYear );
         break;
      }case 19:{  // hora valida?
         char pszTime[ 12 ];
         hb_snprintf( pszTime, 12, "%02d:%02d:%02d:%02d", iHour, iMinute, iSeconds, iMillisec/10 );
         const char *cDate = pszTime;
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) _hb_timeValid( cDate, 11, NULL ));
         break;
      }default: sw=put_error((PHB_ITEM) pRET, "DATENOW ARGUMENT ERROR",103); break;
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "DATENOW INNER-STACK OVERFLOW",101);
}
return sw;
}


/**************************************************
     FUNCIONES DE MANEJO DE BITS, CONVERSION
     DE BASE
 ************************************************/

/**************************************************************************************/ 
/*
 * CT3 Number and bit manipulation functions:
 *       NumAnd(), NumOr(), NumXor(), NUMNOT()
 *       ClearBit(), SetBit()
 *
 * Copyright 2007 Przemyslaw Czerpak <druzus / at / priv.onet.pl>
 * Adapted by Daniel Stuardo by Hooper 2020.
 */

int bintodec(PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nLen = hb_itemGetCLen( pSource );
   const char * bin = hb_itemGetCPtr( pSource );
   hb_itemRelease(pSource);

   HB_MAXINT decimal;
   int i = 0;

    decimal = 0;
    nLen--;

    while(nLen>=0) //for(i=nLen; i>=0/*bin[i]!='\0'*/; i--)
    {
        if(bin[nLen] == '0' || bin[nLen] == '1')
           decimal += pow(2, i) * ( bin[nLen] - 48 );
        else
        {
            decimal=0;
            sw=put_error((PHB_ITEM) pRET, "BINTODEC - ARGUMENT ERROR",103);
            break;
        }
        nLen--; i++;
    }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_LONGLONG) decimal ); 
   return sw;

}
int octtodec(PHB_ITEM pSTK_ADDR ){
int sw=1;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   HB_MAXINT octal = hb_itemGetNL( pSource );
   hb_itemRelease(pSource);
   
   HB_MAXINT decimal=0;
   int i=0;
   while (octal != 0){

        decimal =  decimal +(octal % 10)* pow(8, i++);

        octal = octal / 10;

   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_LONGLONG) decimal );
   
return sw;
}

int hextodec( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nLen = hb_itemGetCLen( pSource );
   const char * hex = hb_itemGetCPtr( pSource );
   hb_itemRelease(pSource);

   HB_MAXINT decimal;
    int i = 0, val;

    decimal = 0;
    nLen--;

    for(i=0; hex[i]!='\0'; i++)
    {
        /* Find the decimal representation of hex[i] */
        if(hex[i]>='0' && hex[i]<='9')
        {
            val = hex[i] - 48;
        }
        else if(hex[i]>='a' && hex[i]<='f')
        {
            val = hex[i] - 97 + 10;
        }
        else if(hex[i]>='A' && hex[i]<='F')
        {
            val = hex[i] - 65 + 10;
        }
        else
        {
            decimal=0;
            sw=put_error((PHB_ITEM) pRET, "HEXTODEC - ARGUMENT ERROR",103);
            break;
        }

        decimal += val * pow(16, nLen);
        nLen--;
    }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_LONGLONG) decimal ); 
   return sw;
}

int ConvertParam( PHB_ITEM Param, HB_MAXINT * plNum )
{

   const char * szHex=NULL;// = hb_parc( iParam );
   if( HB_IS_STRING( Param )){
      szHex = hb_itemGetCPtr( Param );
   }
   if( szHex ){
      *plNum = 0;
      while( *szHex == ' ' )
         szHex++;
      while( *szHex ){
         char c = *szHex++;

         if( c >= '0' && c <= '9' )
            c -= '0';
         else if( c >= 'A' && c <= 'F' )
            c -= 'A' - 10;
         else if( c >= 'a' && c <= 'f' )
            c -= 'a' - 10;
         else
            break;
         *plNum = ( *plNum << 4 ) | c;
      }
      return 1;
   }else if( HB_IS_NUMERIC( Param ) ){
      *plNum = hb_itemGetNL( Param );//hb_parnint( iParam );
      return 1;
   }

   *plNum = -1;
   return 0;
}

int fun_andbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
// lValue es el número sobre el cual se aplicará AND
HB_MAXINT lValue = -1, lNext = 0;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
//   printf("\nLVALUE = %ld",lValue);
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;

      if( ConvertParam( pSource, &lNext ) ){
         lValue &= lNext;
  //       printf("\n\tlNEXT = %ld ==> LVALUE = %ld",lNext,lValue);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ANDBIT - OPERAND ARGUMENT ERROR",103);
         hb_itemRelease(pSource);
         break;
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
  // printf("\nLVALUE = %ld",lValue);
}else{
   sw=put_error((PHB_ITEM) pRET, "ANDBIT - FIRST ARGUMENT ERROR",103);
   hb_itemRelease(pSource);
}
return sw;
}

int fun_orbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
// lValue es el número sobre el cual se aplicará AND
HB_MAXINT lValue = -1, lNext = 0;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;

      if( ConvertParam( pSource, &lNext ) ){
         lValue |= lNext;
      }else{
         sw=put_error((PHB_ITEM) pRET, "ORBIT - OPERAND ARGUMENT ERROR",103);
         hb_itemRelease(pSource);
         break;
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}else{
   sw=put_error((PHB_ITEM) pRET, "ORBIT - FIRST ARGUMENT ERROR",103);
   hb_itemRelease(pSource);
}
return sw;
}

int fun_xorbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
// lValue es el número sobre el cual se aplicará AND
HB_MAXINT lValue = -1, lNext = 0;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;

      if( ConvertParam( pSource, &lNext ) ){
         lValue ^= lNext;
      }else{
         sw=put_error((PHB_ITEM) pRET, "XORBIT - OPERAND ARGUMENT ERROR",103);
         hb_itemRelease(pSource);
         break;
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}else{
   sw=put_error((PHB_ITEM) pRET, "XORBIT - FIRST ARGUMENT ERROR",103);
   hb_itemRelease(pSource);
}
return sw;
}

int fun_notbits( PHB_ITEM pSTK_ADDR ){
int sw=1;
   HB_MAXINT lValue;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( ConvertParam( pSource, &lValue ) )
      lValue = ( ~lValue ) & 0xffffffff;//ffffffff;
   hb_itemRelease(pSource);
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
return sw;
}

int fun_clearbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;

HB_MAXINT lValue = 0, iBit;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      
      if( ConvertParam( pSource, &iBit ) ){
         if( iBit < 1 || iBit > 64 ){
            sw=put_error((PHB_ITEM) pRET, "CLEARBIT - OPERAND ARGUMENT ERROR",103);
            break;
         }
         lValue &= ~( ( ( HB_MAXINT ) 1 ) << ( iBit - 1 ) );
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}
return sw;
}

int fun_setbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;

HB_MAXINT lValue = 0, iBit;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &iBit ) ){
         if( iBit < 1 || iBit > 64 ){
            sw=put_error((PHB_ITEM) pRET, "SETBIT - OPERAND ARGUMENT ERROR",103);
            break;
         }
         lValue |= ( ( HB_MAXINT ) 1 ) << ( iBit - 1 );
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}
return sw;
}
int fun_isbit( PHB_ITEM pSTK_ADDR, int iBit  ){
int sw=1;
   HB_MAXINT lValue;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( ConvertParam( pSource, &lValue ) )
   {
      if( iBit )
         --iBit;
      lValue &= ( ( HB_MAXINT ) 1 ) << iBit;
   }
   else
      lValue = 0;
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)(lValue != 0) );
   hb_itemRelease(pSource);

return sw;
}

int fun_mirrorbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   HB_MAXINT lValue;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   
   if(CADDR){
      PHB_ITEM pTipo = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &lValue ) && lValue == ( lValue & 0xffff ) )
      {
         HB_USHORT usBits = hb_itemGetNI( pTipo )==0 ? 8 : 16;
         HB_USHORT usResult = ( HB_USHORT ) ( lValue >> usBits );

         do
         {
            usResult <<= 1;
            if( lValue & 1 )
               usResult |= 1;
            lValue >>= 1;
         }
         while( --usBits );

         lValue = usResult;
      }
      else{
         lValue = 0;
         sw=put_error((PHB_ITEM) pRET, "MIRROR BIT ARGUMENT ERROR",103); 
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
      hb_itemRelease(pTipo);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MIRROR BIT INNER-STACK OVERFLOW",101); 
   }
   
   hb_itemRelease(pSource);
return sw;
}

int fun_rotabits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   HB_MAXINT lValue, lShift;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

   if(CADDR){
      PHB_ITEM pBit = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( ConvertParam( pSource, &lValue ) && lValue == ( lValue & 0xffff ) && ConvertParam( pBit, &lShift )
          && lShift == ( lShift & 0xffff ) )
      {
         if(CADDR){
            PHB_ITEM pTypeRot = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
            CADDR += SWKEEP; SWKEEP = 0;
            if( hb_itemGetNI( pTypeRot ) == 0 )
            {
               HB_USHORT us = ( HB_USHORT ) ( ( lValue & 0xff ) << ( lShift & 0x07 ) );

               lValue = ( lValue & 0xff00 ) | ( us & 0xff ) | ( us >> 8 );
            }
            else
            {
               lValue <<= ( lShift & 0x0f );
               lValue = ( lValue & 0xffff ) | ( lValue >> 16 );
            }
            hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
            hb_itemRelease(pTypeRot);
         }else{
            lValue = 0;
            sw=put_error((PHB_ITEM) pRET, "ROTATION BIT -ROT TYPE ARGUMENT ERROR",103); 
         }
      }
      else{
         lValue = 0;
         sw=put_error((PHB_ITEM) pRET, "ROTATION BIT - ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pBit);
   }else{
      sw=put_error((PHB_ITEM) pRET, "ROTATION BIT INNER-STACK OVERFLOW",101); 
   }
   
   hb_itemRelease(pSource);
return sw;
}

int fun_shfrbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;
   HB_MAXINT lValue, lBits;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if(CADDR){
      PHB_ITEM pBits = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &lValue ) && ConvertParam( pBits, &lBits ) )
      {
         lValue = lValue >> lBits;
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
      hb_itemRelease(pBits);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SHIFTR BIT INNER-STACK OVERFLOW",101); 
   }
   hb_itemRelease(pSource);
return sw;
}

int fun_shflbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;
   HB_MAXINT lValue, lBits;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if(CADDR){
      PHB_ITEM pBits = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &lValue ) && ConvertParam( pBits, &lBits ) )
      {
         lValue = lValue << lBits;
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
      hb_itemRelease(pBits);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SHIFTL BIT INNER-STACK OVERFLOW",101); 
   }
   hb_itemRelease(pSource);
return sw;
}

int fun_bit_counter(/*int nItem*/ ){
int sw=1;
// al menos deben hacer 2 elementos en el stack
if(CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int nCode = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   switch( nCode ){
         case 100: sw=(int)fun_andbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 101: sw=(int)fun_orbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 102: sw=(int)fun_xorbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 103: sw=(int)fun_notbits( (PHB_ITEM) pSTK_ADDR ); break;
         case 104: sw=(int)fun_clearbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 105: sw=(int)fun_setbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 106: sw=(int)fun_mirrorbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 107: sw=(int)fun_rotabits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 108: sw=(int)fun_shfrbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 109: sw=(int)fun_shflbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 110: sw=(int)hextodec( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 111: sw=(int)octtodec( (PHB_ITEM) pSTK_ADDR ); break;
         case 112: sw=(int)bintodec( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         default: {
            if( nCode>=1 && nCode<=64 )
               sw=(int)fun_isbit( (PHB_ITEM) pSTK_ADDR, (int)nCode );
            else
               sw=put_error((PHB_ITEM) pRET, "BIT FUNCTION ARGUMENT ERROR",103); 
            break;
         }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "BIT FUNCTION INNER-STACK OVERFLOW",101);
}
return sw;
}

/* JOINSTR: unir elementos del stack en un string */
int fun_jointostr(/* int nItem */){
int sw=1;
char * cJoin = (char *)calloc( 4096, 1 );
int Index = 1;
long nLen=0,tLen=strlen(TOKENIZER);
int tCompare = nPCP == 256 ? 1 : 0;
if(CADDR){
while(CADDR){
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, Index );
   if( HB_IS_STRING( pSource ) ){
       const char * pString = hb_itemGetCPtr( pSource );
       long nText = hb_itemGetCLen( pSource );
       strcat( cJoin, pString );
       nLen+=nText;
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNI( pSource );
       char * buf = (char *)calloc(32,1);
       int size = sprintf(buf,"%d", pNum);
       const char * pString = buf;
       strncat( cJoin, pString, size );
       free(buf);
       nLen+=size;
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       char * buf = (char *)calloc(64,1);
       int size;
       if( SW_PRECISION )
          size = sprintf(buf,"%.*lf", PRECISION, pDbl);
       else
          size = sprintf(buf,"%g", pDbl);
       
       //int size = sprintf(buf,"%f", pDbl);
       const char * pString = buf;
       strncat( cJoin, pString, size );
       free(buf);
       nLen+=size;
   }else if( HB_IS_LONG( pSource ) ) {
       long pLong = hb_itemGetNL( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%ld", pLong);
       const char * pString = buf;
       strncat( cJoin, pString, size );
       free(buf);
       nLen+=size;
 /*  }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) strcat( cJoin, "1" );
       else strcat( cJoin, "0" );
       nLen++;*/
   }else{
       sw=put_error((PHB_ITEM) pRET, "JOIN ARRAY DETECTED - ARGUMENT ERROR",103);
   }
   if(CADDR>1)
      strcat( cJoin, TOKENIZER ); nLen+=tLen;
      
   hb_itemRelease(pSource);
   ++Index;
   --CADDR;
}

CADDR += SWKEEP; SWKEEP = 0;

cJoin[ nLen ] = '\0';
const char * cBuffer = cJoin;
if (tCompare){
   int nItem = STK_PRG[++CP];
   hb_arraySetC( pSTK_REG, nItem, (const char*) cBuffer );
}else{
//   PHB_ITEM pBuff = hb_itemPutC( NULL, (const char*) cBuffer );
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) cBuffer );
//   hb_arraySetC( pSTK_ADDR, ++CADDR, (PHB_ITEM) pBuff );
//   hb_itemRelease(pBuff);
}

free(cJoin);
}else{
   sw=put_error((PHB_ITEM) pRET, "JOIN INNER-STACK OVERFLOW",101);
}
return sw;
}

/* CALENDAR */
#define ISO_CAL 0

int days[12]    = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static char *month[12] = {"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
                   "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"};

static char *amonth[12] = {"ENE", "FEB", "MAR", "ABR", "MAY", "JUN",
                   "JUL", "AGO", "SEP", "OCT", "NOV", "DIC"};
                   
static char *daynames[8] = {"Dom", "Lun", "Mar", "Mie", "Jue", "Vie", "Sab", "Dom"};

const char *line = "";

int isleap (unsigned yr)
{
   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);
}

static unsigned months_to_days (unsigned month)
{
   return (month * 3057 - 3007) / 100;
}

static long years_to_days (unsigned yr)
{
   return yr * 365L + yr / 4 - yr / 100 + yr / 400;
}

long ymd_to_scalar (unsigned yr, unsigned mo, unsigned day)
{
   long scalar;
   scalar = day + months_to_days(mo);
   if ( mo > 2 )                         /* adjust if past February */
      scalar -= isleap(yr) ? 1 : 2;
   yr--;
   scalar += years_to_days(yr);
   return scalar;
}

/*void pone_tabs( int nTab){
int i;
for(i=1; i<=nTab; i++)
   printf("\t");
}*/

int fun_calendar(/*int nItem*/ ){
int sw=1;

int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int nCode = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

   
   int day, day_1, numdays, i, j;
 //  int desde=1,hasta=3;

   int yr, mo;
   
 /*
   int xml=0;
   if( (int)(nCode-1000) >= 0 ){  // pide resultado en XML
      xml=1;
      nCode = (int)(nCode-1000);
   }*/

   if( nCode == 0 ){  // today! no pide nada a stack    calendar(TODAY)
      int iDay, iHour, iMinute, iSeconds, iMillisec;  // no usado.
      hb_timeStampGetLocal( &yr, &mo, &iDay,
                            &iHour, &iMinute, &iSeconds, &iMillisec );
      
   }else if( nCode >0 && nCode <=99 ){   // +/- meses antes y después de fecha indicada en stack. calendar(BETWEEN+n)
      if(CADDR>=2){
         PHB_ITEM pYear = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pMonth = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         yr = hb_itemGetNI( pYear );
         mo = hb_itemGetNI( pMonth );
         hb_itemRelease(pYear);
         hb_itemRelease(pMonth);
         for (i = nCode; i > 0; --i){  // ajusto el mes de inicio, aplicando time machine.
            --mo;
            if (!mo){
                  mo = 12;
                  --yr;
            }
         }
         
         nCode *= 2 ;  // duplica los meses, para incluir el segundo bloque después de la fecha indicada.
         if( fmod(nCode,2) == 0) ++nCode;
      }else{
         sw=put_error((PHB_ITEM) pRET, "CALENDAR INNER-STACK OVERFLOW",101);
         return sw;
      }
   }else if( nCode>=100 && nCode<200){   // añade meses a la fecha del stack.  calendar(ADDMONTH+n)
      nCode = (int)(nCode-100);   // ajuste para los meses a incluir después de la fecha.
      if(CADDR>=2){
         PHB_ITEM pYear = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pMonth = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         yr = hb_itemGetNI( pYear );
         mo = hb_itemGetNI( pMonth );
         hb_itemRelease(pYear);
         hb_itemRelease(pMonth);
      }else{
         sw=put_error((PHB_ITEM) pRET, "CALENDAR INNER-STACK OVERFLOW",101);
         return sw;
      }
      
   }else{   // meses después de la fecha indicada en stack
      sw=put_error((PHB_ITEM) pRET, "CALENDAR CONSTANT ARGUMENT ERROR",103);
      return sw;
   }

   // 
   // Quiere solo despliegue (0 o nada) o array (1)?
   int print=0;
   if(CADDR){
      PHB_ITEM pItem = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if(HB_IS_NUMERIC( pItem )){  // asume columnas
         print = hb_itemGetNI( pItem );  // asume 4 tabs por columna
         print = print != 0 ? 1 : 0;   // ajusta seleccion
      }
      hb_itemRelease(pItem);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
      if (!mo || 12 < mo){
         sw=put_error((PHB_ITEM) pRET, "CALENDAR MONTH ARGUMENT ERROR",103);
         return sw;
      }

      if (100 > yr)
            yr += 1900;

      if (3000 < yr || 1800 > yr){
         sw=put_error((PHB_ITEM) pRET, "CALENDAR YEAR:]1800-3000[ ARGUMENT ERROR",103);
         return sw;
      }

      if(nCode==0) nCode=1;
      
      
      PHB_ITEM pRows = hb_itemArrayNew( nCode * 8 );   // n-meses
      int nPos = 1;
      //_____________________
      for( i = 0;i<nCode*8; i++){
         PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
         hb_arraySetC( pCols, 1, (const char*) "   " );
         hb_arraySetC( pCols, 2, (const char*) "   " );
         hb_arraySetC( pCols, 3, (const char*) "   " );
         hb_arraySetC( pCols, 4, (const char*) "   " );
         hb_arraySetC( pCols, 5, (const char*) "   " );
         hb_arraySetC( pCols, 6, (const char*) "   " );
         hb_arraySetC( pCols, 7, (const char*) "   " );
         hb_arraySet(pRows,nPos++, pCols);
         hb_itemRelease(pCols);
      }
      //_____________________
      nPos = 1;

      for(i = 0; i < nCode; i++, mo++){
            /*if (!mo){
                  mo = 12;
                  --yr;
            }*/
            
            if(hb_inkey(0,0,128)==3){
               sw=put_error((PHB_ITEM) pRET, "BREAK EXECUTION BY USER (CTRL-C)",200);
               break;
            }
        
            if (12 < mo){
                  mo = 1;
                  ++yr;
            }
            numdays = days[mo - 1];
            if (2 == mo && isleap(yr))
                  ++numdays;
            day_1 = (int)((ymd_to_scalar(yr, mo, 1) - (long)ISO_CAL) % 7L);
            
            if(!print)
               printf("%s, %d\n", month[mo - 1], yr);
            else{
               PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
               hb_arraySetC( pCols, 1, (const char*) amonth[mo - 1] );
               hb_arraySetC( pCols, 2, (const char*) "   " );
               hb_arraySetC( pCols, 3, (const char*) "   " );
               hb_arraySetC( pCols, 4, (const char*) "   " );
               hb_arraySetC( pCols, 5, (const char*) "   " );
               hb_arraySetC( pCols, 6, (const char*) "   " );
               char *cAnio = (char *)calloc(11,1);
               sprintf(cAnio,"%4d",yr);
               hb_arraySetC( pCols, 7, (const char*) cAnio );
               free(cAnio);
               hb_arraySet(pRows,nPos++, pCols);
               hb_itemRelease(pCols);
            }
            
            if(!print){
               for (j = 0; j < 7; ){
                  fputs(daynames[ISO_CAL + j], stdout);
                  if (7 != ++j)
                     fputc(' ', stdout);
               }
            }else{
               PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
               int nCol=1;
               for (j = 0; j < 7; ++j){
                  hb_arraySetC( pCols, nCol++, (const char*) daynames[ISO_CAL + j] );
               }
               hb_arraySet(pRows,nPos++, pCols);
               hb_itemRelease(pCols);
            }
            if(!print) printf("\n");
            
            if(!print){
               for (day = 0; day < day_1; ++day)
                  fputs("    ", stdout);
               for (day = 1; day <= numdays; ++day, ++day_1, day_1 %= 7){
                  if (!day_1 && 1 != day)
                     printf("\n");
                  printf("%3d ", day);
               }
               for ( ; day_1; ++day_1, day_1 %= 7)
                  fputs("    ", stdout);
               fputc('\n', stdout);

            }else{
               PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
                  hb_arraySetC( pCols, 1, (const char*) "   " );
                  hb_arraySetC( pCols, 2, (const char*) "   " );
                  hb_arraySetC( pCols, 3, (const char*) "   " );
                  hb_arraySetC( pCols, 4, (const char*) "   " );
                  hb_arraySetC( pCols, 5, (const char*) "   " );
                  hb_arraySetC( pCols, 6, (const char*) "   " );
                  hb_arraySetC( pCols, 7, (const char*) "   " );

               int nCol=1;
               
               int nday=1;
               for (day = 0; /*day < 7*/; ++day){
                  if(day < day_1)
                     hb_arraySetC( pCols, nCol++, (const char*) "   " );
                  else{
                     char *cDia = (char *)calloc(11,1);
                     sprintf(cDia,"%3d",nday);
                     hb_arraySetC( pCols, nCol++, (const char*) cDia );
                     free(cDia);
                     nday++;
                     ++day_1; day_1 %= 7;
                     if(!day_1 && 1 != day) break;
                  }
               }
               hb_arraySet(pRows,nPos++, pCols);
               hb_itemRelease(pCols);
               
               //day = nday;
               int iniDay = nday;
               //day = 1;
               ++day_1;
              //________________________ 
             /* if ( day > numdays ){
                 PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
                  hb_arraySetC( pCols, 1, (const char*) "   " );
                  hb_arraySetC( pCols, 2, (const char*) "   " );
                  hb_arraySetC( pCols, 3, (const char*) "   " );
                  hb_arraySetC( pCols, 4, (const char*) "   " );
                  hb_arraySetC( pCols, 5, (const char*) "   " );
                  hb_arraySetC( pCols, 6, (const char*) "   " );
                  hb_arraySetC( pCols, 7, (const char*) "   " );
                  hb_arraySet(pRows,nPos++, pCols);
                  hb_itemRelease(pCols);
              }*/
              //________________________
               while (day <= numdays){
                  
                  if(hb_inkey(0,0,128)==3){
                     sw=put_error((PHB_ITEM) pRET, "CALENDAR BREAK EXECUTION BY USER (CTRL-C)",200);
                     return sw;
                  }
                //  printf("INIDAY = %d; DAY = %d\n",iniDay,day);
                  PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
                  hb_arraySetC( pCols, 1, (const char*) "   " );
                  hb_arraySetC( pCols, 2, (const char*) "   " );
                  hb_arraySetC( pCols, 3, (const char*) "   " );
                  hb_arraySetC( pCols, 4, (const char*) "   " );
                  hb_arraySetC( pCols, 5, (const char*) "   " );
                  hb_arraySetC( pCols, 6, (const char*) "   " );
                  hb_arraySetC( pCols, 7, (const char*) "   " );
                  int nCol=1;

                  for (day = iniDay; day <= numdays; ++day, ++day_1, day_1 %= 7){
                     if (!day_1 && 1 != day){
                        char *cTerminal = (char *)calloc(11,1);

                        sprintf(cTerminal,"%3d",day);
                        hb_arraySetC( pCols, nCol++, (const char*) cTerminal );
                        free(cTerminal);
                        ++day;
                        iniDay=day;
                        
                        ++day_1;
                        day_1 %= 7;
                        break;
                     }
                     char *cDiaI = (char *)calloc(11,1);
                     sprintf(cDiaI,"%3d",day);
                     hb_arraySetC( pCols, nCol++, (const char*) cDiaI );
                     free(cDiaI);
                  }
                  hb_arraySet(pRows,nPos++, pCols);
                  hb_itemRelease(pCols);
               }
              /* PHB_ITEM pColsf = hb_itemArrayNew( 7 );  // 7 días de la semana
               nCol = 1;
               if(!day_1) day_1=1;
               for ( ; day_1; ++day_1, day_1 %= 7)
                  hb_arraySetC( pColsf, nCol++, (const char*) "   " );
                  
               hb_arraySet(pRows,nPos++, pColsf);
               hb_itemRelease(pColsf);
              */
            }
            if( fmod(nPos,8)==0 ) ++nPos;
      }
      if(print)
         hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
      
      hb_itemRelease(pRows);
return sw;
}

int fun_reverse_string( /*int nItem */){
int sw=1;
if(CADDR<nSizeStack){
   long nItem = STK_PRG[++CP];
   PHB_ITEM pSTRING = hb_itemArrayGet(pSTK_REG,nItem);
   const char* cString = hb_itemGetCPtr(pSTRING);
   long nLen = hb_itemGetCLen(pSTRING);
   char *str = (char*)calloc( nLen+1,1);
   
   memcpy(str, cString, nLen);
   
      char *p1, *p2;

      if (! str || ! *str){
         hb_arraySetC( pSTK_ADDR, ++CADDR, cString );
      }else{
         for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2)
         {
            *p1 ^= *p2;
            *p2 ^= *p1;
            *p1 ^= *p2;
         }
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) str );
      }
   hb_itemRelease(pSTRING);
   free(str);
}else{
   sw=put_error((PHB_ITEM) pRET, "REVERSE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_grep(/*int nItem*/){
int sw=1;
int nItem = STK_PRG[++CP];

if(CADDR>=2){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

   CADDR += SWKEEP; SWKEEP = 0;

   const char * cFile = hb_itemGetCPtr(pFILE);
   const char * cSearch = hb_itemGetCPtr(pTEXT);
   long nLenFile = hb_itemGetCLen(pFILE);
   long nLenSear = hb_itemGetCLen(pTEXT);

   hb_itemRelease(pFILE);
   hb_itemRelease(pTEXT);

  // generar nombre de archivo temporal:
   srand(time(NULL));
   long numrand = 10000 + rand() % (100000001 - 10000);
   char tmpFile[100];
   int ltmpf = sprintf(tmpFile," > /tmp/tmpmSeaMurrfile%ld.tmp",numrand);
   tmpFile[ltmpf]='\0';
      
   char * cLine = (char *) calloc(nLenFile + nLenSear + 100, 1);
   memcpy(cLine, "grep -h -n -b ",14);
/*   if(strstr(cSearch,"-E")==NULL){
      memset(cLine + 14, '"', 1 );
      memcpy(cLine + 15, cSearch, nLenSear);
      memset(cLine + 15 + nLenSear, '"', 1 );
      memset(cLine + 16 + nLenSear, ' ', 1 );
      memcpy(cLine + 17 + nLenSear, cFile, nLenFile);
   }else{   // tiene expresiones regulares
   */
      memcpy(cLine + 14, cSearch, nLenSear);
      memset(cLine + 14 + nLenSear, ' ', 1 );
      memcpy(cLine + 15 + nLenSear, cFile, nLenFile);
 //  }
    memcpy(cLine + 15 + nLenSear + nLenFile, tmpFile, ltmpf); 
   //memcpy(cLine + 17 + nLenSear + nLenFile, " > /tmp/tmpmSeaMurrfile000000000000.tmp", 39); 
   //memcpy(cLine + 17 + nLenSear + nLenFile, tmpFile, ltmpf); 


  // printf("\nLINEA: %s\n",cLine);

   const char * t=cLine;
 //  printf("\nGREP: %s\n",t);

   int ret = system(t);
   if (WIFSIGNALED(ret) &&
      (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
      sw=put_error((PHB_ITEM) pRET, "SEARCH-SYSTEM CHILD TERMINATED",102);
   }

   free(cLine);
   
   if( sw ){
      FILE *fp;
   //   char ch;
      PHB_ITEM pCWM = hb_itemArrayNew( 0 ); // CWM

      ltmpf = sprintf(tmpFile,"/tmp/tmpmSeaMurrfile%ld.tmp",numrand);
      tmpFile[ltmpf]='\0';
      if( (fp=fopen(tmpFile,"r"))!=NULL ){
    ///  if( (fp=fopen("/tmp/tmpmSeaMurrfile000000000000.tmp","r"))!=NULL ){

         unsigned long linea=0,noffset=0;

         char ch;

         while ((ch = fgetc(fp)) != EOF){
            // busca numero de linea
            linea=0; noffset=0;
            while(ch!=':'){
               linea = (linea * 10) + (ch - '0');
               ch = fgetc(fp);    // avanzo un caracter.
            }
            ch = fgetc(fp);  // omite ':'
            // busca desplazamiento
            while(ch!=':'){
               noffset = (noffset * 10) + (ch - '0');
               ch = fgetc(fp);    // avanzo un caracter.
            }
            ch = fgetc(fp);  // omite ':'

            PHB_ITEM pC = hb_itemArrayNew( 2 );
            hb_arraySetNL( pC, 1, linea );
            hb_arraySetNL( pC, 2, noffset );
            hb_arrayAdd( pCWM, pC );
            hb_itemRelease(pC);
            // resto de línea hasta '\n'
            while(ch!='\n') ch = fgetc(fp);
         }

         fclose(fp);
        // rm file:
         int ltmpf = sprintf(tmpFile,"rm /tmp/tmpmSeaMurrfile%ld.tmp",numrand);
         tmpFile[ltmpf]='\0';
         int ret = system(tmpFile);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "SEARCH-SYSTEM CHILD TERMINATED",102);
         } 
         ///system("rm /tmp/tmpmSeaMurrfile000000000000.tmp");
      }else{
         sw=put_error((PHB_ITEM) pRET, "SEARCH TEMPFILE CREATION ERROR",107);
      }
      hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pCWM );
      hb_itemRelease(pCWM);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SEARCH INNER-STACK OVERFLOW",101);
}
return sw;
}

/* El siguiente código pertenece a:
 * Copyright 2001 IntTec GmbH, Neunlindenstr 32, 79106 Freiburg, Germany
 *        Author: Martin Vogel <vogel@inttec.de>
 */
/* defines */
#define DO_REPLACE_REPLALL      56 //0
#define DO_REPLACE_REPLLEFT     54 //1
#define DO_REPLACE_REPLRIGHT    55 //2

int fun_repl_lateral( /*int iSwitch*/ ){
int sw=1;
int iSwitch = nPCP;
if(CADDR>=3){
   PHB_ITEM pSTRING  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pREPLACE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pSEARCH   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

   CADDR += SWKEEP; SWKEEP = 0;

   const char * pcString = hb_itemGetCPtr(pSTRING);
   const char * pcReplace = hb_itemGetCPtr(pREPLACE);
   const char * pcSearch = hb_itemGetCPtr(pSEARCH);

   HB_SIZE sStrLen = hb_itemGetCLen( pSTRING );
   hb_itemRelease(pSTRING);
   hb_itemRelease(pREPLACE);
   hb_itemRelease(pSEARCH);

   char *pcRet, *pc;
   char cSearch = *pcSearch, cReplace = *pcReplace;
   
   pcRet = ( char * ) calloc( sStrLen + 1, 1 );
   memcpy( pcRet, pcString, sStrLen );

   if( iSwitch != DO_REPLACE_REPLRIGHT )
   {
      pc = pcRet;
      while( *pc == cSearch && pc < pcRet + sStrLen )
      {
         *pc = cReplace;
         pc++;
      }
   }

   if( iSwitch != DO_REPLACE_REPLLEFT )
   {
      pc = pcRet + sStrLen - 1;
      while( *pc == cSearch && pc >= pcRet )
      {
         *pc = cReplace;
         pc--;
      }
   }
   const char* buffer = pcRet;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) buffer );
   free(pcRet);
   
}else{
   if( iSwitch == DO_REPLACE_REPLALL )
      sw=put_error((PHB_ITEM) pRET, "RALL INNER-STACK OVERFLOW",101);
   else if( iSwitch == DO_REPLACE_REPLLEFT )
      sw=put_error((PHB_ITEM) pRET, "RLEFT INNER-STACK OVERFLOW",101);
   else
      sw=put_error((PHB_ITEM) pRET, "RRIGHT INNER-STACK OVERFLOW",101);
}
return sw;
}

/*
  FUNCIONES DE SATURACION DE LINEAS, POR CAMPOS Y
  POR LARGO POSICIÓN.
*/
uint16_t ftokens(const char *linea, const char *buscar, uint16_t lb) {
   const char *t,*r; // son solo punteros apuntando a la cadena s.

   uint16_t n=0;
   //printf(" OBTUVE: [%s] [%s]\n",linea,buscar);
   r = linea;  // rescato primera posición
   t = strstr(r,buscar);
   while (t!=NULL) {
      r = t + lb;
      ++n;
      t = strstr(r,buscar);
   }
   if(strlen(linea)>0 && n==0) n=1;
   return n;
}

char* strpad( const char * cText, HB_MAXINT nLen, HB_MAXINT nSize, int tCompare ){

 //  const char * cText = hb_itemGetCPtr( pARG );
 //  const char * cRelleno = hb_itemGetCPtr( pRELL );
 //  HB_MAXINT nSize = hb_itemGetCLen( pARG );
 //  HB_MAXINT nLen = hb_itemGetNL( pPAD );
   char * szResult=NULL;
   if( nLen <= nSize ){
      char * Ret = (char *)calloc( nSize+1,1);
      memcpy(Ret,cText,nSize);
      return ( (char *) Ret );
   }else{

      switch( tCompare){
         case 0: {   // PADC 
            /*char * */szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = ' ';
            HB_ISIZ nPad = ( ( HB_SIZE ) nLen - nSize ) >> 1;
            memset( szResult, cPad, nPad );
            memcpy( szResult + nPad, cText, nSize );
            memset( szResult + nPad + nSize, cPad, ( HB_SIZE ) nLen - nSize - nPad );
            //const char * milenka = szResult;
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            //return (szResult);
            //free( szResult );
            break;
         }case 1: {  // PADR
            /*char * */szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = ' ';
            memcpy( szResult, cText, nSize );
            memset( szResult + nSize, cPad, ( HB_SIZE ) nLen - nSize );
            //const char * milenka = szResult;
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            //return (szResult);
           // free( szResult );
            break;
         }case 2: {  // PADL
            /*char * */szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = ' ';
            memset( szResult, cPad, ( HB_SIZE ) nLen - nSize );
            memcpy( szResult + ( HB_SIZE ) nLen - nSize, cText, nSize );
            //const char * milenka = szResult;
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            //return (szResult);
           // free( szResult );
            break;
         }
      }
      return (szResult);
   }
}

      
#define MAXBUFFER 4096

char *fsaturate( const char *tokens, const char *tok, const char *linea, int tipo){
   char *buffer;
   const char *t, *s;
   char **ltoken;     // lista de tokens
   uint16_t lentok = strlen(tok);
   uint16_t i=0,l, sizei;

   if (lentok==0) {return NULL;}

   // cuántos tokens tengo?
   
   uint16_t ntok = ftokens(tokens,tok,lentok);
   if (ntok==0) {return NULL;}   // no hay tokens
   //ltoken = (char**)malloc( sizeof(char *)*(ntok+2) );
   ltoken = (char**)calloc( ntok+1, sizeof(char *) );
   // a ntok se suma 1, pues acá necesito los tokens, no los separadores, como en strtran. 

   if (ltoken==NULL) return NULL;   // no hay memoria

   // obtengo tokens y los guardo en un arreglo para reemplazar después.
   t = tokens;
   char *temp;
   while ((s = strstr(t,tok))!=NULL) {
       l = s - t;
       
       ltoken[i] = (char*)calloc( (l+1), 1);//sizeof(char *) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           //free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           
           return NULL;     // no hay memoria para el arreglo
       }
       //strncpy(ltoken[i], t, l);
       strncpy(temp, t, l);
       t = ++s;
     //  printf("\nTOken... [%s]\n",ltoken[i]);  // OK.
       ++i;
   }

   if (t!=NULL) {           // queda un token más: lo capturo.
       ltoken[i] = (char*)calloc( (strlen(t)+1), 1);// sizeof(char *) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           ///free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           
           return NULL;     // no hay memoria para el arreglo
       }
       
       //strcpy(ltoken[i], t);
       strcpy(temp, t);
       sizei = i;
   } else sizei = i-1;

   // asigno espacio a la línea objetiva
   ///buf = (char *) malloc (sizeof(char *)*MAXBUFFER); // MAXBUFFER lo asgno por flag "512"
   buffer = (char *) calloc (MAXBUFFER,1);//sizeof(char *));
   char *buf = buffer;
   if (buf==NULL) {         // limpiar la memoria que ya fue asignada
       //free(ltoken);
       for (l=0;l<=i;++l) free(ltoken[l]);
       free(ltoken);
       free(buffer);
       
       return NULL;         // no hay memoria para el arreglo
   }
   // Reemplazo los tokens en la línea objetiva
   uint16_t ncampo=0;
   uint16_t lc=0;
   const char *c, *cc;

  // strcpy(buf,"");
   t = linea;
   while ((s = strstr(t,"$"))!=NULL) {
       l = s - t;
       strncat(buf,t,l);         // rescato porción de linea sin tocar, antes del token
       c = s+1;                  // desde el supuesto dígito en adelante
       while (isdigit(*c)) c++;  // obtengo el número del campo
       lc = c - s;               // longitud del número
       if (lc>1) {               // es un campo. 1= no es un campo
          char *cindice,*cind;        // para guardar los índices
          cindice = (char *) calloc(lc+1*10,1);//malloc (10*(lc+1));
          cind = cindice;
          if (cind==NULL) {     // limpiar la memoria que ya fue asignada
              ///free(ltoken);
              for (l=0;l<=i;++l) free(ltoken[l]);
              free(ltoken);
              free(buffer);
              
              return NULL;         // no hay memoria para el arreglo
          }
          
          strncpy(cind,s+1,lc);   // preparo el indice del arreglo para obtener token
          ncampo = atoi(cind);
          if (ncampo<=sizei) {     // es un campo válido??
             // aniadir aqui el pad, si lo hay
             const char * campo = ltoken[ncampo];
             if(*c==':'){  // aqui hay un pad
                cc = c;
                c++;  // me lo salto
                if(!isdigit(*c)){  // construcción errada
                   free(cindice);
                   for (l=0;l<=i;++l) free(ltoken[l]);
                   free(ltoken);
                   free(buffer);
                   
                   return NULL;
                }
                char *cPad/*ding*/;
                char *cPadToken;        // para guardar los índices
                int w=0;
                
                while(isdigit(*c)) {/*printf("DIG=%c, ",*c);*/c++;++w;/*printf("W=%d",w);*/}
                lc = w;// c - ( cc+w);
                cPad/*ding*/ = (char *) calloc (lc+1,1);//sizeof(char *));
                //cPadToken = (char * ) calloc (128,1);
                //char * cPad = cPadding;
          	//strncpy(cPad,(cc+w),lc);
          	strncpy(cPad,cc+1,lc);

                int nPad = atoi(cPad);
                int sizeCampo = strlen(campo);
          	//printf("\nLC = %d, CIND=%d CPAD = %s, NPAD = %d sizeCampo=%d Campo=%s",lc,ncampo,cPad,nPad,sizeCampo,campo);
                if(toupper(*c) == 'C'){  //0
                   cPadToken=strpad(campo,nPad,sizeCampo,0);
                }else if(toupper(*c) == 'L'){  //1
                   cPadToken=strpad(campo,nPad,sizeCampo,1);
                }else if(toupper(*c) == 'R'){  //2
                   cPadToken=strpad(campo,nPad,sizeCampo,2);
                }else{   // error
                   free(cindice);free(cPad);
                   for (l=0;l<=i;++l) free(ltoken[l]);
                   free(ltoken);
                   free(buffer);
                   
                   return NULL;
                }
                //printf("\nENTRA AQUI con %s\n",cPadToken);
                if (cPadToken!=NULL) 
                   strcat(buf,cPadToken);
                else
                   strcat(buf,"");

                // printf("\nESTA OK\n");
                c++;
                free(cPad/*ding*/);
                free(cPadToken);
                //printf("\nFREE OK\n");
             }else{
                //strcat(buf,campo);
                if(tipo){
                   char * cCampo = fun_alltrim( (const char*)campo, (HB_SIZE)strlen(campo));
                   if (cCampo == NULL){
                      char * cCampo = (char * )calloc(1,1);
                      cCampo[0]='\0';
                   }
                   const char * pCampo = cCampo;
              //  printf("\nENTRA AQUI con %s\n",cCampo);
                   strcat(buf, pCampo);
              //  printf("\nESTA OK\n");
                   free(cCampo);
                }else{
                   strcat(buf, campo);
                }
             }
          }
          t = c;              // siempre: por si o por no, el campo será eliminado igual
          free(cindice);
       } else {
          strncat(buf,s,1);   // rescato "$" que no es un campo
          t = ++s;            // avanzo un espacio y continúo el proceso
       }
   }
   // rescato lo último que no ha sido rescatado
   strcat (buf,t);
   int nLen = strlen(buf);
//   buf[nLen+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
   free(ltoken);
   
   char * Retorno = (char *) calloc (nLen+1,1);//sizeof(char));
   char * Ret = Retorno;
   strcpy(Ret,buf);
   
   // deguerbo resultado
   free(buffer);
   return Retorno;
/*
//   buf[strlen(buf)+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
   free(ltoken);
   
   // deguerbo resultado
   return buffer; */
}

char *fLPsaturate( const char *tokens, int *pos, int nPos, const char *linea){
   char *buffer;
   const char *t, *s;
   //char **ltoken;     // lista de tokens
   char *ltoken[nPos];
   uint16_t i=0,j=0,k=0,l=0, sizei=0;

//   ltoken = (char**)malloc((nPos+1) * sizeof(char **) );
   // a ntok se suma 1, pues acá necesito los tokens, no los separadores, como en strtran. 

//   if (ltoken==NULL) return NULL;   // no hay memoria

   // obtengo tokens y los guardo en un arreglo para reemplazar después.
   t = tokens;
   j = 0;
   const char *c,*cc;
   c = t;
//   char *temp;
   while (j<nPos){   //((s = strstr(t,tok))!=NULL) {
       k=0;
       while (k++<pos[j]) c++;
       l = c - t;
       
       //ltoken[i] = (char*)calloc( (l+1), 1);//sizeof(char) );
       char* temp = (char *)calloc( l+1,1);
       strncpy(temp, t, l);
       char* tmp2 = fun_alltrim( (const char*)temp, l);
       ltoken[i] = (char*)calloc(strlen(tmp2)+1,1);
       strcpy(ltoken[i], tmp2);
       free(temp);
       free(tmp2);

       t = c;
       ++i;
       ++j;
   }

   if (t!=NULL) {           // queda un token más: lo capturo.
       char* temp = (char *)calloc( l+1,1);
       strncpy(temp, t, l);
       char* tmp2 = fun_alltrim( (const char*)temp, l);
       ltoken[i] = (char*)calloc(strlen(tmp2)+1,1);
       strcpy(ltoken[i], tmp2);
       free(temp);
       free(tmp2);
       
       sizei = i-1;
   } else sizei = i-1;

   // asigno espacio a la línea objetiva
   buffer = (char *) calloc (MAXBUFFER,1);//sizeof(char));
   char *buf = buffer;
   if (buf==NULL) {         // limpiar la memoria que ya fue asignada
       //free(ltoken);
       for (l=0;l<=i;++l) free(ltoken[l]);
       //free(ltoken);
       free(buffer);
       return NULL;         // no hay memoria para el arreglo
   }
   
   // Reemplazo los tokens en la línea objetiva
   uint16_t ncampo=0;
   uint16_t lc=0;
   
  // strcpy(buf,"");
   t = linea;
   
   while ((s = strstr(t,"$"))!=NULL) {
       l = s - t;
       strncat(buf,t,l);         // rescato porción de linea sin tocar, antes del token
       c = s+1;                  // desde el supuesto dígito en adelante
       while (isdigit(*c)) c++;  // obtengo el número del campo
       lc = c - s;               // longitud del número
       if (lc>1) {               // es un campo. 1= no es un campo
          char *cindice, *cind;        // para guardar los índices
          cindice = (char *) malloc (1*(lc+1));
          cind = cindice;
          //cindice = (char *) calloc (3,sizeof(char *));
          if (cind==NULL) {     // limpiar la memoria que ya fue asignada
             //free(ltoken);
             for (l=0;l<=i;++l) free(ltoken[l]);
             //free(ltoken);
             free(buffer);
             return NULL;         // no hay memoria para el arreglo
          }
          
          strncpy(cind,s+1,lc);   // preparo el indice del arreglo para obtener token
          ncampo = atoi(cind);
          
          if (ncampo<=sizei) {     // es un campo válido??
             const char * campo = ltoken[ncampo];
          	 // aniadir aqui el pad, si lo hay
             if(*c==':'){  // aqui hay un pad
                 cc = c;
          	    c++;  // me lo salto
          	    char *cPad;
          	    char *cPadding;
          	    
          	    int w=0;

          	    while(isdigit(*c)) {c++;++w;}
          	    lc = w; //c - ( cc+w);
          	    cPadding = (char *) calloc (lc+1,1);//sizeof(char));
          	    cPad = cPadding;
          	    //strncpy(cPad,(cc+w),lc);
          	    strncpy(cPad,cc+1,lc);
          	    int nPad = atoi(cPad);
          	    int sizeCampo = strlen(campo);
          	    
                    //printf("\nLC = %d, CIND=%d CPAD = %s, NPAD = %d sizeCampo=%d Campo=%s",lc,ncampo,cPad,nPad,sizeCampo,campo);
          	    char *cPadToken;        // para guardar los índices
          	    if(toupper(*c) == 'C'){  //0
          	       cPadToken=strpad(campo,nPad,sizeCampo,0);
          	    }else if(toupper(*c) == 'L'){  //1
          	       cPadToken=strpad(campo,nPad,sizeCampo,1);
          	    }else if(toupper(*c) == 'R'){  //2
          	       cPadToken=strpad(campo,nPad,sizeCampo,2);
          	    }else{   // error
          	       return NULL;
          	    }
          	    if (cPadToken!=NULL) 
                        strcat(buf,cPadToken);
                    else
                        strcat(buf,"");
                   /// printf("\nCampo=[%s]\n",cPadToken);
          	    c++;
          	    free(cPadding);
          	    free(cPadToken);
             }else{
                HB_SIZE nLenC = strlen(campo);
                char * cCampo = fun_alltrim( (const char*)campo, nLenC);
                if (cCampo == NULL){
                   char * cCampo = (char * )calloc(1,1);
                   cCampo[0]='\0';
                }
                const char * pCampo = cCampo;
                strcat(buf, (const char*)pCampo);  // aqui el problema
                free(cCampo);
             }
          }
          t = c;              // siempre: por si o por no, el campo será eliminado igual
          free(cindice);
       } else {
          strncat(buf,s,1);   // rescato "$" que no es un campo
          t = ++s;            // avanzo un espacio y continúo el proceso
       }
   }
   // rescato lo último que no ha sido rescatado
   strcat (buf,t);
   int nLen = strlen(buf);
//   buf[nLen+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
//   free(ltoken);
   
   char * Retorno = (char *) calloc (nLen+1,1);//sizeof(char));
   char * Ret = Retorno;
   strcpy(Ret,buf);
   
   // deguerbo resultado
   free(buffer);
   return Retorno;
}

/* FUN_SATURATE
   Depende de la lectura de líneas desde un archivo. Cada línea leída, será
   usada para saturar otra línea, pasada como argumento a satura.
   */
int fun_saturate(){
int sw=1;
if(CADDR>=2){   // necesita 2 argumentos del stack; 1 de stackReg
   long nItem = STK_PRG[++CP];
   PHB_ITEM pSTRING = hb_itemArrayGet(pSTK_REG,nItem);  // línea a saturar
   if(!HB_IS_STRING(pSTRING)){
      hb_itemRelease(pSTRING);
      sw=put_error((PHB_ITEM) pRET, "SATURATE LINE TO SATURE ARGUMENT ERROR - MUST BE STRING",103);
      return sw;
   }
   const char * cLinea = hb_itemGetCPtr(pSTRING);
   hb_itemRelease(pSTRING);
   PHB_ITEM pSEP    = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // separador o array de posiciones
   PHB_ITEM pTOKENS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // línea con tokens
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(HB_IS_STRING(pSEP)){
      if( HB_IS_STRING(pTOKENS) ){  // debe ser un separador
         const char * cSep = hb_itemGetCPtr(pSEP);
         const char * cTokens = hb_itemGetCPtr(pTOKENS);

         if (cSep[0]==':'){
            sw=put_error((PHB_ITEM) pRET, "SATURATE ARGUMENT ERROR - TOKEN SEP ':' NOT VALID",103);
         }else{
            char * pBuffer;
      
            pBuffer = (char *)fsaturate( cTokens, cSep, cLinea, 1 );
         
            if (pBuffer==NULL){
               sw=put_error((PHB_ITEM) pRET, "SATURATE MASK ARGUMENT ERROR - BAD FORMED",103);
               pBuffer = (char * ) calloc(1,1);
               pBuffer[0]='\0';
            }
            const char * pRet = pBuffer;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pRet );
            free(pBuffer);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SATURATE SECOND ARGUMENT ERROR - MUST BE STRING",103);
      }    
   }else if(HB_IS_ARRAY(pSEP)){
      if( HB_IS_STRING(pTOKENS) ){
         const char * cTokens = hb_itemGetCPtr(pTOKENS);
         HB_SIZE nSepLen = hb_arrayLen( pSEP );
         if(nSepLen<=0){
            sw=put_error((PHB_ITEM) pRET, "SATURATE SECOND ARGUMENT ERROR - ARRAY NULL",103);
         }else{
            int pos[nSepLen];
            HB_SIZE q;
            // obtengo los elementos del array y lo llevo a array de int.
            for (q=0;q<nSepLen;q++){
               PHB_ITEM pQ = hb_itemArrayGet( pSEP, q+1);
               pos[q] = hb_itemGetNInt(pQ);
               hb_itemRelease( pQ );
            }
            char * pBuffer;
         
            pBuffer = (char *)fLPsaturate( cTokens, pos, nSepLen, cLinea);

            if (pBuffer==NULL){
               sw=put_error((PHB_ITEM) pRET, "SATURATE MASK ARGUMENT ERROR - BAD FORMED",103);
               pBuffer = (char * ) calloc(1,1);
               pBuffer[0]='\0';
            }
            const char * pRet = pBuffer;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pRet );
            free(pBuffer);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SATURATE SECOND ARGUMENT ERROR - MUST BE STRING",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SATURATE FIRST ARGUMENT ERROR - MUST BE NUM ARRAY OR STRING",103);
   }
   hb_itemRelease(pSEP);
   hb_itemRelease(pTOKENS);

}else{
   sw=put_error((PHB_ITEM) pRET, "SATURATE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_format(){
int sw=1;
if(CADDR>=2){   // necesita 2 argumentos del stack; 1 de stackReg
   long nItem = STK_PRG[++CP];
   PHB_ITEM pSTRING = hb_itemArrayGet(pSTK_REG,nItem);  // línea a saturar
   if(!HB_IS_STRING(pSTRING)){
      hb_itemRelease(pSTRING);
      sw=put_error((PHB_ITEM) pRET, "FORMAT LINE TO FORMAT ARGUMENT ERROR - MUST BE STRING",103);
      return sw;
   }
   const char * cLinea = hb_itemGetCPtr(pSTRING);
   hb_itemRelease(pSTRING);
   PHB_ITEM pSEP    = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // separador o array de posiciones
   PHB_ITEM pTOKENS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // línea con tokens
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(HB_IS_STRING(pSEP)){
      if( HB_IS_STRING(pTOKENS) ){  // debe ser un separador
         const char * cSep = hb_itemGetCPtr(pSEP);
         const char * cTokens = hb_itemGetCPtr(pTOKENS);

         if (cSep[0]==':'){
            sw=put_error((PHB_ITEM) pRET, "FORMAT ARGUMENT ERROR - TOKEN SEP ':' NOT VALID",103);
         }else{
            char * pBuffer;
            
            pBuffer = (char *)fsaturate( cTokens, cSep, cLinea, 0 );
         
            if (pBuffer==NULL){
               sw=put_error((PHB_ITEM) pRET, "FORMAT MASK ARGUMENT ERROR - BAD FORMED",103);
               pBuffer = (char * ) calloc(1,1);
               pBuffer[0]='\0';
            }
            const char * pRet = pBuffer;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pRet );
            free(pBuffer);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "FORMAT SECOND ARGUMENT ERROR - MUST BE STRING",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "FORMAT FIRST ARGUMENT ERROR - MUST BE NUM ARRAY OR STRING",103);
   }
   hb_itemRelease(pSEP);
   hb_itemRelease(pTOKENS);

}else{
   sw=put_error((PHB_ITEM) pRET, "FORMAT INNER-STACK OVERFLOW",101);
}
return sw;
}

/*
   FUNCIONES DE SOCKET TCP.
   */
// structuras y otras definiciones generales
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
//#include <errno.h>      /* for errno and EINTR */
//#define TIMEOUT_SECS  2    /* TIMEOUT SECONDS WAIT */
/////#include <signal.h>     /* for sigaction() YA ESTA DEFINIDO */
//Se necesitan dos estructuras del tipo sockaddr
// SERVER TCP
struct sockaddr_in server;  //La primera guarda info del server
struct sockaddr_in client;  //La segunda del cliente
// CLIENT TCP
struct hostent *he;         /* estructura que recibirá información sobre el nodo remoto */
//struct sockaddr_in server_cl;  /* información sobre la dirección del servidor */

//struct sigaction myAction;       /* For setting signal handler */
//int tries = 0;    /* para intentos de TIMEOUT UDP */

////int TCP_longitud_cliente=0; //no es necesario.

/* Funciones */
int fun_socketTCP_Accept(){
int sw=1;
int fd2;   // descriptor de la conexión con el cliente, diferente del descriptor del socket.
unsigned int TCP_longitud_cliente;
TCP_longitud_cliente= sizeof(struct sockaddr_in);

long nItem = STK_PRG[++CP];
PHB_ITEM pFD = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR
int fd = hb_itemGetNI(pFD);
hb_itemRelease(pFD);

if(fd>0){
   /* A continuación la llamada a accept() */
   if ((fd2 = accept(fd,(struct sockaddr *)&client,&TCP_longitud_cliente))!=-1) {
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd2 );  // devuelve el identificador del socket del cliente TCP conectado
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - ACCEPT ERROR",120);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - DESCRIPTOR ERROR",117);
}
return sw;
}

int fun_socketTCP_Connect(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR
int fd = hb_itemGetNI(pFD);
hb_itemRelease(pFD);
if(fd>0){
   if(connect(fd, (struct sockaddr *)&server, sizeof(struct sockaddr))==-1){
      sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT TCP - CONNECT ERROR",121);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT TCP - CONNECT DESCRIPTOR ERROR",117);
}

return sw;
}

int fun_socketTCP_Recv(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(fd2>0){
   if(CADDR>=1){
      int numBytes;
      PHB_ITEM pSIZEBUFF = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // NUMERO DE BYTES QUE ESPERA RECIBIR
      unsigned int sizeBuffer=hb_itemGetNI(pSIZEBUFF);
      hb_itemRelease(pSIZEBUFF);
      
      CADDR += SWKEEP; SWKEEP = 0;
      
      if(sizeBuffer>0){
         char buffer[sizeBuffer];
         if ((numBytes=recv(fd2,buffer,sizeBuffer,0)) != -1){
            buffer[numBytes]='\0';
            if(CADDR<nSizeStack-3){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)numBytes );        // tercero: numero de bytes recibidos
               
               const char* cSource = inet_ntoa(server.sin_addr);
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cSource );  // segundo: la IP fuente

               const char* cBuffer = buffer;
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cBuffer );  // primero: el mensaje recivido

            }else{
               sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV ERROR",121);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV ARGUMENT ERROR - BYTES TO READ",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV INNER-STACK UNDERFLOW : #BYTES TO READ?",102);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV DESCRIPTOR ERROR",117);
}

return sw;
}

int fun_socketTCP_Send(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(CADDR>=1){
   PHB_ITEM pMESSAGE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MENSAJE A ENVIAR
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING(pMESSAGE)){
      const char* cBuffer=hb_itemGetCPtr(pMESSAGE);
      hb_itemRelease(pMESSAGE);
      send(fd2,cBuffer,strlen(cBuffer),0);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - SEND ARGUMENT ERROR : TYPE MISMATCH",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - SEND INNER-STACK UNDERFLOW : MSG TO SEND?",102);
}
return sw;
}


/*void CatchAlarm(int ignored)     // Handler for SIGALRM 
{
    tries += 1;
}*/

int fun_socketUDP_Recvfrom(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(fd2>0){
   if(CADDR>=1){
      int numBytes;
      PHB_ITEM pSIZEBUFF = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // NUMERO DE BYTES QUE ESPERA RECIBIR
      unsigned int sizeBuffer=hb_itemGetNI(pSIZEBUFF);
      hb_itemRelease(pSIZEBUFF);
      
      CADDR += SWKEEP; SWKEEP = 0;
      
      if(sizeBuffer>0){
         char buffer[sizeBuffer];
         int addr_len = sizeof(struct sockaddr);
         if ((numBytes=recvfrom(fd2, buffer, sizeBuffer, 0, (struct sockaddr *)&client, (socklen_t *)&addr_len)) != -1){
            buffer[numBytes]='\0';
            if(CADDR<nSizeStack-3){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)numBytes );        // tercero: numero de bytes recibidos
               
               const char* cSource = inet_ntoa(client.sin_addr);
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cSource );  // segundo: la IP fuente

               const char* cBuffer = buffer;
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cBuffer );  // primero: el mensaje recivido

            }else{
               sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM ERROR",121);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM ARGUMENT ERROR - BYTES TO READ",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM INNER-STACK UNDERFLOW : #BYTES TO READ?",102);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM DESCRIPTOR ERROR",117);
}

return sw;
}

int fun_socketUDP_Sendto(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(CADDR>=1){
   PHB_ITEM pMESSAGE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MENSAJE A ENVIAR
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING(pMESSAGE)){
      const char* cBuffer=hb_itemGetCPtr(pMESSAGE);
      hb_itemRelease(pMESSAGE);
      int numBytes;
      
     /* Set signal handler for alarm signal */
 /*     myAction.sa_handler = CatchAlarm;
      if (sigfillset(&myAction.sa_mask) < 0){ // block everything in handler 
         sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO SIGFILLSET ERROR",122);
         return sw;
      }
      myAction.sa_flags = 0;

      if (sigaction(SIGALRM, &myAction, 0) < 0){
         sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO SIGACTION ERROR",123);
         return sw;
      }
      alarm(TIMEOUT_SECS);       // Set the timeout
      struct timeval tv;
tv.tv_sec = 3;
tv.tv_usec = 0;
if (setsockopt(fd2, SOL_SOCKET, SO_SNDTIMEO,&tv,sizeof(tv)) < 0) {
    perror("Error");
}*/

      numBytes=sendto(fd2,cBuffer,strlen(cBuffer),MSG_DONTWAIT,(struct sockaddr *)&client, sizeof(struct sockaddr));

         if(numBytes!=-1){
            if(CADDR<nSizeStack){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)numBytes );  // numero de bytes enviados
            }else{
               sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO ERROR",121);
         }

   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO ARGUMENT ERROR : TYPE MISMATCH",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO INNER-STACK UNDERFLOW : MSG TO SEND?",102);
}
return sw;
}


// función de apertura de SOCKET: CLIENTE(1) o SERVIDOR(0), CLOSE(2)
int fun_socket(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pTYPE = hb_itemArrayGet(pSTK_REG,nItem);  // tipo de socket: Server, o Client
int nType = hb_itemGetNI(pTYPE);
hb_itemRelease(pTYPE);

if(nType==0){  // TCP server
   if(CADDR>=2){
      //Primer paso, definir variables
      int fd;   // descriptor de socket

      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      if(puerto>0){
         PHB_ITEM pBACKLOG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // NUMERO MAXIMO DE CONEXIONES ENCOLADAS.
         int backLog=hb_itemGetNI(pBACKLOG);
         hb_itemRelease(pBACKLOG);
         
         CADDR += SWKEEP; SWKEEP = 0;
         
         if(backLog<=0) backLog=5;   // 5 conexiones por default
      
         //Configuracion del servidor
         server.sin_family= AF_INET;          //Familia TCP/IP
         server.sin_port = htons(puerto);     //Puerto
         server.sin_addr.s_addr = INADDR_ANY; //Cualquier cliente puede conectarse
         bzero(&(server.sin_zero),8);         //Funcion que rellena con 0's
 
         //Paso 2, definicion de socket
         if (( fd=socket(AF_INET,SOCK_STREAM,0) )<0){
            sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - OPEN SOCKET ERROR",118);
         }else{
           //Paso 3, avisar al sistema que se creo un socket. Solicita un nombre para el socket y número de puerto local
            if(bind(fd,(struct sockaddr*)&server, sizeof(struct sockaddr))==-1) {
               sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - BIND ERROR",119);
            }else{
              //Paso 4, establecer el socket en modo escucha
               if(listen(fd,backLog) == -1) {
                  sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - LISTEN ERROR",120);
               }else{  // todo ok! comienza el webeo...
                  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket TCP
               }
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - INNER-STACK UNDERFLOW : NEED A PORT",102);
   }
}else if(nType==1){  // TCP client
   if(CADDR>=2){
      int fd;
       
      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      if(puerto>0){
         PHB_ITEM pADDRESS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // DIRECCION IP TIPO "127.0.0.1"
         CADDR += SWKEEP; SWKEEP = 0;
         if(HB_IS_STRING(pADDRESS)){
            const char* ip=hb_itemGetCPtr(pADDRESS);
            hb_itemRelease(pADDRESS);
            if ((he=gethostbyname(ip))==NULL){
               sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - HOST NAME ERROR",121);
            }else{
               if ((fd=socket(AF_INET, SOCK_STREAM, 0))==-1){        //Paso 2, definicion de socket
                  sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT TCP - OPEN SOCKET ERROR",118);
               }else{
                 //Datos del servidor
                  server.sin_family = AF_INET;
                  server.sin_port = htons(puerto);
                  server.sin_addr = *((struct in_addr *)he->h_addr);
                 /*he->h_addr pasa la información de ``*he'' a "h_addr" */
                  bzero(&(server.sin_zero),8);   // rellena con 0
                  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket TCP
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT TCP - ARGUMENT ERROR : IP BAD TYPE",103);
         }            
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT TCP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
   
   }
}else if(nType==3){  // UDP server
   if(CADDR>=1){
      //Primer paso, definir variables
      int fd;   // descriptor de socket

      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      CADDR += SWKEEP; SWKEEP = 0;
      if(puerto>0){
 
         //Paso 2, definicion de socket
         if (( fd=socket(AF_INET,SOCK_DGRAM,0) )<0){
            sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - OPEN SOCKET ERROR",118);
         }else{

            //Configuracion del servidor
            server.sin_family= AF_INET;          //Familia TCP/IP
            server.sin_port = htons(puerto);     //Puerto
            server.sin_addr.s_addr = INADDR_ANY; //Cualquier cliente puede conectarse
            bzero(&(server.sin_zero),8);         //Funcion que rellena con 0's
           //Paso 3, avisar al sistema que se creo un socket. Solicita un nombre para el socket y número de puerto local
            if(bind(fd,(struct sockaddr*)&server, sizeof(struct sockaddr))==-1) {
               sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - BIND ERROR",119);
            }else{
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - INNER-STACK UNDERFLOW : NEED A PORT",102);
   }
}else if(nType==4){   // UDP cliente
   if(CADDR>=2){
      int fd;
       
      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      if(puerto>0){
         PHB_ITEM pADDRESS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // DIRECCION IP TIPO "127.0.0.1"
         CADDR += SWKEEP; SWKEEP = 0;
         if(HB_IS_STRING(pADDRESS)){
            const char* ip=hb_itemGetCPtr(pADDRESS);
            hb_itemRelease(pADDRESS);
            if ((he=gethostbyname(ip))==NULL){
               sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT UDP - HOST NAME ERROR",121);
            }else{
               if ((fd=socket(AF_INET, SOCK_DGRAM, 0))==-1){        //Paso 2, definicion de socket
                  sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT UDP - OPEN SOCKET ERROR",118);
               }else{
                 //Datos del servidor
                  client.sin_family = AF_INET;
                  client.sin_port = htons(puerto);
                  client.sin_addr = *((struct in_addr *)he->h_addr);
                 /*he->h_addr pasa la información de ``*he'' a "h_addr" */
                  bzero(&(client.sin_zero),8);   // rellena con 0
                  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket TCP
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT UDP - ARGUMENT ERROR : IP BAD TYPE",103);
         }
                 
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT UDP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT UDP - INNER-STACK UNDERFLOW",102);
   }
}else if(nType==2){  //  TCP close
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // DECRIPTOR A CERRAR
   int fd=hb_itemGetNI(pFD);
   hb_itemRelease(pFD);
   CADDR += SWKEEP; SWKEEP = 0;
   if(fd>0)
      close(fd);
   else
      sw=put_error((PHB_ITEM) pRET, "SOCKET TCP CLOSE - DESCRIPTOR ERROR",117);
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET TCP TYPE ARGUMENT ERROR - MUST BE 0|1",103);
}

return sw;
}

/************************/

/****************************
   MESSSAGE QUEUE SYSTEM V
 ****************************/
///#include <sys/types.h>   // ya existe
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/stat.h>
 
int fun_qcreate(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int key = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int flags=0,permisos;
if(key==0){   // crea clave privada
   key = IPC_PRIVATE;
   flags |= IPC_CREAT;
}else{
   flags |= IPC_CREAT; // | IPC_EXCL;
}
if(CADDR){ // busca por permisos.
   PHB_ITEM pPERMISOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PERMISOS
   permisos=hb_itemGetNI(pPERMISOS);
   hb_itemRelease(pPERMISOS);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   permisos=(S_IRUSR | S_IWUSR); //0666;
}
if(permisos>0){
   int msqid = msgget(key, flags | permisos);
   if (msqid == -1){
      sw=put_error((PHB_ITEM) pRET, "QCREATE - CAN'T CREATE QUEUE",122);
   }else{
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)msqid );  // devuelve key.
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "QCREATE - PERMS ARGUMENT ERROR",103);
}
return sw;
}

int fun_qset(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int msg_qbytes;

if(CADDR>=1){   // debe haber: {__msg_cbytes,msg_qbytes}
   PHB_ITEM pMSG_QBYTES = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MSG_QBYTES: total de bytes de la cola
   msg_qbytes=hb_itemGetNI(pMSG_QBYTES);
   hb_itemRelease(pMSG_QBYTES);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   msg_qbytes=16384;
}
if(sw){

 /*     if(CADDR){ // busca por permisos.
         PHB_ITEM pPERMISOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PERMISOS
         permisos=hb_itemGetNI(pPERMISOS);
         hb_itemRelease(pPERMISOS);
      }else{
         permisos=(S_IRUSR | S_IWUSR); //600 // mejor si 0666;
      }*/
      struct msqid_ds ds;
      if (msgctl(msqid, IPC_STAT, &ds) == -1){
            sw=put_error((PHB_ITEM) pRET, "QSET - RETRIEVE QUEUE INFO ERROR",123);
      }else{
         ds.msg_qbytes = msg_qbytes;
      
          /* Actualiza la estructura de datos en el kernel */
   
         if (msgctl(msqid, IPC_SET, &ds) == -1)
            sw=put_error((PHB_ITEM) pRET, "QSET - UPDATE DATA KERNEL ERROR",123);
      }
}
return sw;
}

int fun_qsend(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int maxLong,mType=1;
int flags=0;
const char* message;
if(CADDR>=3){   // {msgType, maxlong,message}
   PHB_ITEM pMSG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MESSAGE
   message=hb_itemGetCPtr(pMSG);
   hb_itemRelease(pMSG);
   PHB_ITEM pMAXLONG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MAXLONG
   maxLong = hb_itemGetNI(pMAXLONG);
   hb_itemRelease(pMAXLONG);
   PHB_ITEM pMTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MSGTYPE
   mType = hb_itemGetNI(pMTYPE);
   hb_itemRelease(pMTYPE);
}else if(CADDR==2){  // {maxlong,message}
   PHB_ITEM pMSG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MESSAGE
   message=hb_itemGetCPtr(pMSG);
   hb_itemRelease(pMSG);
   PHB_ITEM pMAXLONG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MAXLONG
   maxLong = hb_itemGetNI(pMAXLONG);
   hb_itemRelease(pMAXLONG);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "QSEND - INNER-STACK UNDERFLOW",102);
}
CADDR += SWKEEP; SWKEEP = 0;
if(sw){
   struct mbuf {
      long mtype;                       /* Message type */
      char mtext[maxLong];              /* Message body */
   };
   struct mbuf msg;
   
   flags |= IPC_NOWAIT ;
   int msgLen = strlen(message) + 1;
   if(msgLen > maxLong)
      sw=put_error((PHB_ITEM) pRET, "QSEND - MESSAGE TOO LONG",124);
   else{
      memcpy(msg.mtext, message, msgLen);
      msg.mtype = mType;
      if (msgsnd(msqid, &msg, msgLen, flags) == -1)
         sw=put_error((PHB_ITEM) pRET, "QSEND - CAN'T SEND TO QUEUE",122);
   }
}
return sw;
}

int fun_qrecv(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int maxLong,msgLen,mType=1,flags=0;
if(CADDR>=2){   // {maxlong}
   PHB_ITEM pMAXLONG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MAXLONG
   maxLong = hb_itemGetNI(pMAXLONG);
   hb_itemRelease(pMAXLONG);
   PHB_ITEM pMTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MSGTYPE
   mType = hb_itemGetNI(pMTYPE);
   hb_itemRelease(pMTYPE);
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   flags |= IPC_NOWAIT;
   struct mbuf {
      long mtype;                       /* Message type */
      char mtext[maxLong];              /* Message body */
   };
   struct mbuf msg;


///   permisos=(S_IRUSR | S_IWUSR); //0666;

   msg.mtype=mType;
   msgLen = msgrcv(msqid, &msg, maxLong, mType,flags);
   if (msgLen == -1)
      sw=put_error((PHB_ITEM) pRET, "QRECV - CAN'T RECEIVE FROM QUEUE",122);
   else{
      const char* cBuffer = msg.mtext;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cBuffer );  // 
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "QRECV - INNER-STACK UNDERFLOW",102);
}
return sw;
}

int fun_qremove(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);

if (msgctl(msqid, IPC_RMID, NULL) == -1)
   sw=put_error((PHB_ITEM) pRET, "QREMOVE - CAN'T REMOVE QUEUE",122);

return sw;
}

/* existe archivo y drectorio*/

int fun_exist_file(){
int sw=1;
if( CADDR < nSizeStack ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * szFile = hb_itemGetCPtr( pFILE );
   hb_arraySetNI( pSTK_ADDR, ++CADDR, szFile ? hb_spFile( szFile, NULL ) : 0 );
   hb_itemRelease( pFILE );
}else{
   sw=put_error((PHB_ITEM) pRET, "EXIST INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_exist_dir(){
int sw=1;
if( CADDR < nSizeStack ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * szFile = hb_itemGetCPtr( pFILE );
   struct stat sb;

   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (stat(szFile, &sb) == 0 && S_ISDIR(sb.st_mode) ));
   hb_itemRelease( pFILE );
}else{
   sw=put_error((PHB_ITEM) pRET, "EXISTDIR INNER-STACK OVERFLOW",101);
}

return sw;
}

/* PARSER Y UNPARSER DE EXPRESIONES HTML */
                              
int fun_doParser(){
int sw=1;
if(CADDR>=4){
   PHB_ITEM pUNICO   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // indica 0=ONLYTAG tag; 1=NORMALTAG
   PHB_ITEM pCONTENT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // contenido del tag. Acepta ""
   PHB_ITEM pATTRIBS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // contenido de atributos. Acepta ""
   PHB_ITEM pNAME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // nombre del tag
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pCONTENT) && HB_IS_STRING(pATTRIBS) && HB_IS_STRING(pNAME) ){
      const char* cName    = hb_itemGetCPtr(pNAME);
      const char* cContent = hb_itemGetCPtr(pCONTENT);
      const char* cAttribs = hb_itemGetCPtr(pATTRIBS);
      int nUnicoTag = hb_itemGetNI(pUNICO);

      long nLenAttr = hb_itemGetCLen(pATTRIBS);
      long nLen = hb_itemGetCLen(pCONTENT);
      long nLenName = hb_itemGetCLen(pNAME);
      char* cTemp = (char*)calloc( nLenAttr + nLenName + nLenName + nLen + 50, 1);
      memset(cTemp,0,nLenAttr + nLenName + nLenName + nLen + 50);  // relleno con 0.
      memcpy(cTemp,"<",1);

      memcpy(cTemp + 1,cName,nLenName);
      
      int spc = 1;
      if( nLenAttr > 0 ){  // hay atributos
         memcpy(cTemp + 1 + nLenName," ",1);
         spc=2;
      }
      memcpy(cTemp + nLenName + spc,cAttribs,nLenAttr);
      int lcTemp = 0;
      
     // verificar si es un unico tag y añadieron contenido:
      if(nLen && nUnicoTag) nLen=0;  // anula el contenido
       
      if(!nLen){      // es etiqueta vacía, sin contenido?
         if(nUnicoTag){        // del tipo <nombre [attrib]/>
            memcpy(cTemp + nLenName + spc + nLenAttr,"/>",2);
            cTemp[nLenName + spc + 2 + nLenAttr]='\0';
         }else{           // del tipo <nombre [attrib]>
            memcpy(cTemp + nLenName + spc + nLenAttr,">",1);
         }
      }else{                                // tiene contenidos
         memcpy(cTemp + nLenName + spc + nLenAttr,">",1);
         memcpy(cTemp + nLenName + spc + 1 + nLenAttr,cContent,nLen);
      }
      if(!nUnicoTag){  // añado cierre de tag
         memcpy(cTemp + nLenName + spc + 1 + nLenAttr + nLen,"</",2);
         memcpy(cTemp + nLenName + spc + 3 + nLenAttr + nLen,cName,nLenName);
         memcpy(cTemp + nLenName + spc + 3 + nLenAttr + nLen + nLenName,">",1);
         cTemp[nLenName + spc + 4 + nLenAttr + nLen + nLenName]='\0';
      }

      long nItem = STK_PRG[++CP];
      PHB_ITEM pVARS = hb_itemArrayGet(pSTK_REG,nItem);  // VAR STRING DE PARSEO
      long nLenVar = hb_itemGetCLen(pVARS);
      const char* cVarStr = hb_itemGetCPtr(pVARS);
      hb_itemRelease(pVARS);
      
      lcTemp = strlen( cTemp );
      char* cStrFinal=(char*)calloc( lcTemp + nLenVar + 1, 1 );
      memset(cStrFinal,0,lcTemp + nLenVar + 1);
      memcpy(cStrFinal, cVarStr, nLenVar );        // concateno nuevo registro a var existente.
      memcpy(cStrFinal + nLenVar, cTemp, lcTemp);
      cStrFinal[nLenVar+lcTemp]='\0';
      const char* cBuffer = cStrFinal;
      hb_arraySetC( pSTK_REG, nItem, (const char *)  cBuffer );
      free(cStrFinal);
      free(cTemp);

   }else{
      sw=put_error((PHB_ITEM) pRET, "PARSER - ARGUMENT ERROR",103);
   }
   hb_itemRelease(pCONTENT);
   hb_itemRelease(pATTRIBS);
   hb_itemRelease(pNAME);
   hb_itemRelease(pUNICO);
}else{
   sw=put_error((PHB_ITEM) pRET, "PARSER - INNER-STACK UNDERFLOW",102);
}
return sw;
}

/* UNPARSER 
   Requisitos: debe ser un campo con o sin atributos, y puede o no tener contenidos.
   Asimismo, puede ser un campo del tipo <field/> o <field attr=valor...>
   Además, no deben existir campos anidados con el mismo nombre.
   */
int fun_unparser(){
int sw=1;
if(CADDR)
{
   PHB_ITEM pNAME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // nombre del campo. Debe ser simple, sin atributos.
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pNAME) )
   {
      const char* cName    = hb_itemGetCPtr(pNAME);
      long nLenName = hb_itemGetCLen(pNAME);
     // obtengo variable que contiene HTML 
      long nItem = STK_PRG[++CP];
      PHB_ITEM pVARS = hb_itemArrayGet(pSTK_REG,nItem);  // VAR STRING DE PARSEO
      long nLenVar = hb_itemGetCLen(pVARS);
      const char* cVarStr = hb_itemGetCPtr(pVARS);
      hb_itemRelease(pVARS);
     //
      char* cField = (char*)calloc(nLenName + 100,1); // campo a buscar. Podría incluir lista de atributos
      memset(cField,0,nLenName + 100);
      memcpy(cField,"<",1);                // armamos el campo a buscar en cVarStr
      memcpy(cField + 1,cName,nLenName);
      memcpy(cField + 1 + nLenName,">",1);
      cField[nLenName + 2]='\0';       // "<field>"
      int es_vacio=0;
      int tieneAtrib=0;
      char* iniF = strstr(cVarStr,cField);  // primera ocurrencia del campo
      char* atributos=(char*)calloc(100,1);   // por si encuentra atributos más adelante.
      int ctaAtrib=0;        // para saber cuántos atributos hay en el campo, de existir.
      if (iniF==NULL)
      {  // no lo encontró. Puede ser un campo solitario.
         cField[nLenName + 1]='/';cField[nLenName + 2]='>';cField[nLenName + 3]='\0';  // "<field/>"
         iniF = strstr(cVarStr,cField);   // busco otra vez.
         if(iniF==NULL)
         {  // no lo encontró. Podría ser un tag con atributos...
            cField[nLenName + 1]=' ';cField[nLenName + 2]='\0';  // "<field "
            iniF = strstr(cVarStr,cField);   // busco otra vez.
            if(iniF==NULL)
            {
               sw=put_error((PHB_ITEM) pRET, "UNPARSER - MISSING FIELD",124);
            }
            else
            {  // tiene atributos
               tieneAtrib=1;
               // debo completar el campo, para incluir los atributos, y luego, obtenerlos afuera
               char* tiniF = iniF + strlen(cField);
               int i = nLenName + 2;
               int j=0;
               do
               {  // busca por el final del tag
                  cField[i] = *tiniF;
                  if(*tiniF!='/' && *tiniF!='>')   // solo necesito el contenido, no el campo completo.
                  {
                     atributos[j] = *tiniF; j++;
                  }
                  if(*tiniF=='=') ctaAtrib++;
                  tiniF++; i++;
               }
               while(*tiniF!='>');

               atributos[j]='\0';  // aqui solo debería tener la lista de atributos.

               if(*tiniF=='>') {cField[i] = *tiniF; i++;} // el rezagado.
               cField[i]='\0';
             //  printf("\nCFIELD = %s, i=%d,cfield[i-2]=%c\n",cField,i,cField[i-2]);
               if(cField[i-2]=='/')
               {  // es un tag unico.
                  es_vacio=1;
                  hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "" ); // devuelve al stack un string nulo
               }
            }
         }
         else
         {
            es_vacio=1;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "" ); // devuelve al stack un string nulo
         }
      }
      // procesar la salida.
      if(sw)
      {
         if(!es_vacio)
         {  // obtengo el contenido
            char* tiniF = iniF;   // rescato posicion original del campo.
            tiniF += strlen(cField); // ubico en el inicio del contenido
            // armo el final del campo:
            char* cFieldEnd = (char*)calloc(nLenName + 100,1); // campo a buscar
            memset(cFieldEnd,0,nLenName + 100);
            memcpy(cFieldEnd,"</",2);
            memcpy(cFieldEnd + 2,cName,nLenName);
            memcpy(cFieldEnd + 2 + nLenName,">",1);
            cFieldEnd[nLenName + 3]='\0';
            //busco campo final! Primera ocurrencia.
            char* iniFE = strstr(cVarStr,cFieldEnd);
            int porcion = iniFE - tiniF;
            //armo string de contenido y guardo en Stack
          //  printf("\nPORCION=%d\n",porcion);
            if(porcion>0){
               char* cFieldContent = (char*)calloc(porcion + 1,1);
               memset(cFieldContent,0,porcion + 1);
               memcpy(cFieldContent,tiniF,porcion);
               cFieldContent[porcion]='\0';
               const char* cBuffer = cFieldContent;
             //  printf("\nBUFFER=%s\n",cBuffer);
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  cBuffer ); // devuelve al stack
               free(cFieldContent);
            }else{
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "" ); // devuelve al stack un string nulo
            }
            //borro "porcion" de la variable cVarStr:
         //   printf("\nPASO!\nENTRA A PREPARAR VARIABLE");
            char* cNewVar = (char*)calloc(nLenVar + 10, 1); // preparo nueva variable
            memset(cNewVar,0,nLenVar+10);
            porcion = iniF-cVarStr;
            int i=0;
            while(porcion--)
            {
               cNewVar[i] = cVarStr[i];i++;
            }
            char* final = iniFE + strlen(cFieldEnd);
            while(*final)
            {
               cNewVar[i] = *final; final++;i++;
            }
            cNewVar[i]='\0';
            const char* cBufferNew = cNewVar;
            hb_arraySetC( pSTK_REG, nItem, (const char *)  cBufferNew );
            free(cNewVar);
            
            free(cFieldEnd);
         //   printf("\nPASO!\nSALE!");
         }
         else
         {
            //borro "porcion" de la variable cVarStr:
            char* cNewVar = (char*)calloc(nLenVar + 10, 1);
            memset(cNewVar,0,nLenVar+10);
            int porcion = iniF-cVarStr;
            int tp = porcion;
            int i=0;
            while(porcion--)
            {
               cNewVar[i] = cVarStr[i];i++;
            }
            const char* final = cVarStr + ( tp + strlen(cField));
            while(*final)
            {
               cNewVar[i] = *final; final++;i++;
            }
            cNewVar[i]='\0';
            
            const char* cBufferNew = cNewVar;
            hb_arraySetC( pSTK_REG, nItem, (const char *)  cBufferNew );
            free(cNewVar);
         }
      }
      free(cField);
      // procesar lista de atributos.
      if(tieneAtrib)
      {  // obtiene los atributos y guardo en array, y el resto del proceso queda igual
         if(ctaAtrib)
         {  // puede que se escribió: <field >, o <field />: debe dejar pasar como campo normal.
            PHB_ITEM pARRATR = hb_itemArrayNew(ctaAtrib);
            int i=0;
            int indArray=0;
          //  printf("\nENTRA A ATRIBUTOS DESDE: %s",atributos);
            while(atributos[i]!='\0')
            {
               if(atributos[i]==' ') {i++;continue;}  // salte los espacios en blanco.
               if(atributos[i]=='=')  // encontré un valor.
               {
                  i++;  // avanzo, y veo qué tiene: numero, string, u otra cosa.
               //   printf("\nENTRA A GUARDAR VALOR");
                  while(atributos[i]!='\0' && atributos[i]==' ') i++;   // quita espacios en blanco.
                  int j=0;
                  char* cValor = (char*)calloc(100, 1);
                  if(atributos[i]==34)  // hay un string.
                  {
                     i++;    // no guarda comillas.
                     do{
                        cValor[j] = atributos[i];  // guardo todo lo que hay dentro de la cadena.
                        i++; j++;
                     }while(atributos[i]!='\0' && atributos[i]!=34);
                  }else{   // es otra cosa. Termina con espacio en blanco.
                     do{
                        cValor[j] = atributos[i];  // guardo todo lo que hay hasta espacio en blanco.
                        i++; j++;
                     }while(atributos[i]!='\0' && atributos[i]!=' ');
                  }
                  cValor[j]='\0';
              //    printf("\nVALOR OBTENIDO: %s",cValor);
                  // guarda en array:
                  ++indArray;
                  const char* cBuffer = cValor;
                  hb_arraySetC(pARRATR, indArray, (const char*) cBuffer);
                  free(cValor);
               }
               i++;
            }
          //  printf("\nSALE DE ATRIBUTOS");
            // guardo en stack, a continuación del contenido.
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM)pARRATR );
            hb_itemRelease(pARRATR);
         }
      }
      free(atributos);
   }
   else
   {
      sw=put_error((PHB_ITEM) pRET, "UNPARSER - ARGUMENT ERROR",103);
   }
   hb_itemRelease(pNAME);
}
else
{
   sw=put_error((PHB_ITEM) pRET, "UNPARSER - INNER-STACK UNDERFLOW",102);
}
return sw;
}

/* REGEX */

#define MAX_ERROR_MSG  0x1000
#define TOPE_REGEX     15
#include <regex.h>

int aIndexREGEX=-1;
static regex_t aREGEX[TOPE_REGEX];
int validREGEX[TOPE_REGEX];

int fun_regcompile(){
int sw=1;
if(CADDR>=2){
  int error;
  ///char pattern[1024];
  //regex_t compiled_pattern;
//  PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
  PHB_ITEM pPATTERN = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PATRON
  PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
  CADDR += SWKEEP; SWKEEP = 0;
  if( HB_IS_STRING(pPATTERN) && HB_IS_NUMERIC(pFLAGS)){
     long nLenPat = hb_itemGetCLen(pPATTERN);
     ///long nLenStr = hb_itemGetCLen(pSTRING);
     if (nLenPat){
        const char* cPattern = hb_itemGetCPtr(pPATTERN);
        int nFlags = hb_itemGetNI(pFLAGS);
        ++aIndexREGEX;
        if(aIndexREGEX>=TOPE_REGEX){  // buscar alguno que haya sido eliminado
           int i;
           for(i=0;i<TOPE_REGEX;i++){
              if(!validREGEX[i]){
                 aIndexREGEX=i;
                 break;
              }
           }
        }
        if(aIndexREGEX>=0 && aIndexREGEX<TOPE_REGEX){
           //aREGEX[aIndexREGEX]=malloc(sizeof(regex_t));
           validREGEX[aIndexREGEX]=1;
           error = regcomp(&(aREGEX[aIndexREGEX]), cPattern, nFlags);
         //  printf("\nERROR= %d\n",error);
           if (error==0) {  // compiló bien. Ahora, a validar!
           //   printf("\nQUE HAY = %d\n",aREGEX[aIndexREGEX].re_nsub);
              long nItem = STK_PRG[++CP];
              //aREGEX[aIndexREGEX] = //(regex_t)malloc(sizeof(regex_t));
              ///aREGEX[aIndexREGEX] = compiled_pattern;
              hb_arraySetNI( pSTK_REG, nItem, (int)  aIndexREGEX );
           }else{
              validREGEX[aIndexREGEX]=0;
              char error_message[MAX_ERROR_MSG];
              char* ERROR = (char*)calloc(MAX_ERROR_MSG,1); 
              regerror (error, &aREGEX[aIndexREGEX], error_message, MAX_ERROR_MSG);
	      memcpy(ERROR,"REGCOMPILE COMPILATION ERROR: ",30);
	      memcpy(ERROR + 30,error_message,strlen(error_message));
              sw=put_error((PHB_ITEM) pRET, ERROR,error);
              free(ERROR);
           }
        }else{
           sw=put_error((PHB_ITEM) pRET, "REGCOMPILE #PATTERN OVERFLOW",129);
        }
     }else{
        sw=put_error((PHB_ITEM) pRET, "REGCOMPILE PATTERN MUST BE NOT NULL|0",127);
     } 
  }else{
     sw=put_error((PHB_ITEM) pRET, "REGCOMPILE ARGUMENT TYPE ERROR",103);
  }
  hb_itemRelease(pPATTERN);
//  hb_itemRelease(pSTRING);
  hb_itemRelease(pFLAGS);
}else{
  sw=put_error((PHB_ITEM) pRET, "REGCOMPILE STACK UNDERFLOW",102); 
}
return sw;
}

int fun_regfree(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pVARS = hb_itemArrayGet(pSTK_REG,nItem);  // VAR INDICE REGEX
int nIndex = hb_itemGetNI(pVARS);
hb_itemRelease(pVARS);
if( (nIndex >= 0 && nIndex < TOPE_REGEX) ){
   if(validREGEX[nIndex]){
      regfree(&aREGEX[nIndex]);
      validREGEX[nIndex]=0;
   }  // no hace nada.
}else{
   sw=put_error((PHB_ITEM) pRET, "REGFREE INDEX REGEX ERROR",130);
}
return sw;
}

int fun_regvalid(){
int sw=1;
if(CADDR>=3){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
   PHB_ITEM pINDEX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // INDICE
   PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
   CADDR += SWKEEP; SWKEEP = 0;
   int swREGEX=0;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   if(HB_IS_STRING(pSTRING)) {
      swREGEX=1;
   }else if(HB_IS_ARRAY(pSTRING)){
      get_size( (PHB_ITEM) pSTRING, &nDim, &d1, &d2, &d3, &type);
      if (type==10 && nDim==1){
         swREGEX=2;
      }
   }
   if( (HB_IS_STRING(pSTRING) || HB_IS_ARRAY(pSTRING)) && HB_IS_NUMERIC(pINDEX) && HB_IS_NUMERIC(pFLAGS)){
      int nIndex = hb_itemGetNI(pINDEX);
      if( nIndex>=0 && nIndex<=aIndexREGEX ){
      /// verificar indice
         if(validREGEX[nIndex]){
            int nFlags = hb_itemGetNI(pFLAGS);
            
            if(swREGEX==1){
               const char* test_pattern = hb_itemGetCPtr(pSTRING);
               int   error = regexec(&aREGEX[nIndex], test_pattern, (size_t) 0, NULL, nFlags);
               if (error == 0) {
                  hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
               } else if (error == REG_NOMATCH) {
                  hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
               } else {
                  hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
               }
            }else if(swREGEX==2){
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               PHB_ITEM retArray = hb_itemArrayNew(0);
               int i;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pITEMSTR = hb_itemArrayGet( pSTRING, i);
                  const char* test_pattern = hb_itemGetCPtr(pITEMSTR);
                  int   error = regexec(&aREGEX[nIndex], test_pattern, (size_t) 0, NULL, nFlags);
                  if (error == 0) {
                     hb_arrayAdd(retArray,pITEMSTR);
                     hb_arraySetNI(pRows, i, (int) 1);
                  } else if (error == REG_NOMATCH) {
                     hb_arraySetNI(pRows, i, (int) 0);
                  } else {
                     hb_arraySetNI(pRows, i, (int) 0);
                  }
                  hb_itemRelease(pITEMSTR);
               }
               hb_arraySet(pSTK_ADDR, ++CADDR, retArray);
               hb_arraySet(pSTK_ADDR, ++CADDR, pRows);
               hb_itemRelease(pRows);
               hb_itemRelease(retArray);
            }else{
               sw=put_error((PHB_ITEM) pRET, "REGVALID STRING|ARRAY 1D STRING EXPECTED",103);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REGVALID COMPILATION NOT EXIST",131);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "REGVALID #PATTERN OVERFLOW",129);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "REGVALID ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pINDEX);
   hb_itemRelease(pSTRING);
   hb_itemRelease(pFLAGS);
}else{
   sw=put_error((PHB_ITEM) pRET, "REGVALID STACK UNDERFLOW",102); 
}
return sw;
}

int fun_regmatch(){
int sw=1;
if(CADDR>=4){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
   PHB_ITEM pINDEX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // INDICE
   PHB_ITEM pNMATCHES = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // N-MATCHES
   PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pSTRING) && HB_IS_NUMERIC(pNMATCHES) && HB_IS_NUMERIC(pINDEX) && HB_IS_NUMERIC(pFLAGS)){
      int nIndex = hb_itemGetNI(pINDEX);
      if( nIndex>=0 && nIndex<=aIndexREGEX ){
      /// verificar indice
         if(validREGEX[nIndex]){
            int nFlags = hb_itemGetNI(pFLAGS);
            int n_matches = hb_itemGetNI(pNMATCHES);
            regmatch_t m[n_matches];
            
            const char* to_match = hb_itemGetCPtr(pSTRING);
            const char * p = to_match;
            PHB_ITEM retArray = hb_itemArrayNew(0);
            int swBucle=1;
            while (swBucle) {
               int i = 0;
               int nomatch = regexec (&aREGEX[nIndex], p, n_matches, m, nFlags);
               //printf("pasa por aqui: %d\n",nomatch);
               if (nomatch) {
                  hb_arraySet(pSTK_ADDR, ++CADDR, retArray);
                  hb_itemRelease(retArray);
                  break;
               }else{
                  for (i = 0; i < n_matches; i++) {
                     //printf("---FOR---pasa por aqui: %d\n",i);
                     
                     int start;
                     int finish;
                     if (m[i].rm_so == -1) {
                        //if(i==0) swBucle=0;
                        break;
                     }
                     start = m[i].rm_so + (p - to_match);
                     finish = m[i].rm_eo + (p - to_match);
                     ///printf("start=%d, finish=%d\n",start,finish);
                     if(finish && start){
                        PHB_ITEM pRows = hb_itemArrayNew(3);
                        hb_arraySetNI(pRows,1,start+1);
                        hb_arraySetNI(pRows,2,finish);
                        char* buffer = (char*)calloc((finish - start) + 1, 1);
                        sprintf(buffer, "%.*s",(finish - start),to_match + start);
                        const char* cBuffer = buffer;
                        hb_arraySetC(pRows,3,cBuffer);
                        free(buffer);
                        hb_arrayAdd(retArray,pRows);
                        hb_itemRelease(pRows);
                     }else{
                        hb_arraySet(pSTK_ADDR, ++CADDR, retArray);
                        hb_itemRelease(retArray);
                        swBucle=0;
                        break;
                     }
                  }
               }
               p += m[0].rm_eo;
               //if(++swBucle==3) break;
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REGMATCH COMPILATION NOT EXIST",131);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "REGMATCH #PATTERN OVERFLOW",129);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "REGMATCH ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pINDEX);
   hb_itemRelease(pSTRING);
   hb_itemRelease(pNMATCHES);
   hb_itemRelease(pFLAGS);
}else{
   sw=put_error((PHB_ITEM) pRET, "REGMATCH STACK UNDERFLOW",102); 
}
return sw;
}

/*int fun_regmatch(){
int sw=1;
if(CADDR>=3){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
   PHB_ITEM pPATTERN = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PATRON
   PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
   if( HB_IS_STRING(pSTRING) && HB_IS_STRING(pPATTERN) && HB_IS_NUMERIC(pFLAGS)){
      //int nIndex = hb_itemGetNI(pINDEX);
      //if( nIndex>=0 && nIndex<=aIndexREGEX ){
      regex_t patron_compilado[5];   
      //int nFlags = REG_NOSUB;
      int nFlags = hb_itemGetNI(pFLAGS);
         
         const char* cPatron = hb_itemGetCPtr(pPATTERN);
         //char* test_pattern = (char*)calloc(1024,1);
         //memset(test_pattern,0,1024);
         const char* test_pattern = hb_itemGetCPtr(pSTRING);
//         char txt[strlen(test_pattern)+1];
//         memcpy(txt,test_pattern,strlen(test_pattern));
//         txt[strlen(test_pattern)]='\0';
//         printf("\n%s, -- HAY = %d\n",test_pattern,aREGEX[nIndex].re_nsub);
         int error = regcomp(&patron_compilado[0], cPatron, nFlags);
         if(error!=0){
              char error_message[MAX_ERROR_MSG];
              char* ERROR = (char*)calloc(MAX_ERROR_MSG+100,1); 
              regerror (error, &patron_compilado[0], error_message, MAX_ERROR_MSG);
	      memcpy(ERROR,"REGVALID COMPILATION ERROR: ",28);
	      memcpy(ERROR + 28,error_message,strlen(error_message));
              sw=put_error((PHB_ITEM) pRET, ERROR,error);
              free(ERROR);
         }else{
            error = regexec(&patron_compilado[0], test_pattern, (size_t) 0, NULL, 0);
            if (error == 0) {
               hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
            } else if (error == REG_NOMATCH) {
               hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
            } else {
               hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) -1);
            }
         }
         regfree(&patron_compilado[0]);
      //}else{
      //   sw=put_error((PHB_ITEM) pRET, "REGVALID #PATTERN OVERFLOW",129);
      //}
   }else{
      sw=put_error((PHB_ITEM) pRET, "REGVALID ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pPATTERN);
   hb_itemRelease(pSTRING);
   hb_itemRelease(pFLAGS);
}else{
   sw=put_error((PHB_ITEM) pRET, "REGVALID STACK UNDERFLOW",102); 
}
return sw;
}*/


/************************/

int returnProgram(){
int sw=1;
              HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
              if (CADDR>0){
                 PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                 PHB_ITEM pTemp = pSource;
                 
                 // evaluacion de resultado escalar. Después: arrays
                 
                 if( HB_IS_ARRAY( pSource ) ){   // es un ARRAY
                     get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
                     hb_arraySet( pRET, 1, (PHB_ITEM) pTemp );//pTemp );   // asigna puntero a pRET.
                     switch(type){
                        case 10: hb_arraySetC( pRET, 2, (const char *)  "AC"  ); break;
                        case 11: hb_arraySetC( pRET, 2, (const char *)  "AN"  ); break;
                        case 12: hb_arraySetC( pRET, 2, (const char *)  "AL"  ); break;
                     }
                 }else{
                      get_item_type( (PHB_ITEM) pSource, &type);
                      switch( type ){
                          case 10: {   // string
                              const char * pString = hb_itemGetCPtr( pSource );
                              hb_arraySetC( pRET, 1, (const char *)  pString  );
                              hb_arraySetC( pRET, 2, (const char *)  "C"  );
                              break;
                          }case 11: {  // numint
                              HB_MAXINT pNum = hb_itemGetNInt( pSource );
                              hb_arraySetNInt( pRET, 1, (HB_MAXINT)  pNum  );
                              hb_arraySetC( pRET, 2, (const char *)  "N"  );
                              break;
                          }case 12: {  // double
                              double pDbl = hb_itemGetND( pSource );
                              hb_arraySetND( pRET, 1, (double) pDbl );
                              hb_arraySetC( pRET, 2, (const char *)  "N"  );
                              break;
                          }case 13: {  // long
                              long pLong = hb_itemGetNL( pSource );
                              hb_arraySetNL( pRET, 1, (long) pLong );
                              hb_arraySetC( pRET, 2, (const char *)  "N"  ); 
                              break;
                        /*  }case 14: {   // logical
                              HB_BOOL pBool = hb_itemGetL( pSource );
                              hb_arraySetL( pRET, 1, (HB_BOOL) pBool ) ;
                              hb_arraySetC( pRET, 2, (const char *)  "L"  );
                              break;*/
                          }
                      }
                 }
                 hb_arraySetNInt( pRET, 3, (HB_MAXINT)  nDim  );
                 hb_arraySetNInt( pRET, 4, (HB_MAXINT)  d1  );
                 hb_arraySetNInt( pRET, 5, (HB_MAXINT)  d2  );
                 hb_arraySetNInt( pRET, 6, (HB_MAXINT)  d3  );
                 //hb_arraySetNInt( pRET, 7, (HB_MAXINT)  0  );
                 sw = 0;
                 hb_itemRelease(pSource);
              }else{    // ERROR!!!
                 sw=put_error((PHB_ITEM) pRET, "RET STACK UNDERFLOW",102); 
              }
return sw;
}

int fun_assert(){
int sw=1;
if(CADDR){
   PHB_ITEM pASSERT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   CADDR += SWKEEP; SWKEEP = 0;
   int bAssert = hb_itemGetNI( pASSERT );
   hb_itemRelease(pASSERT);
   int nItem = STK_PRG[++CP];
   PHB_ITEM pMESS=hb_itemArrayGet( pSTK_REG, nItem);
   const char * pString = hb_itemGetCPtr( pMESS );
   int cLen = hb_itemGetCLen(pMESS);
   hb_itemRelease(pMESS);
   char mensajeErr[150];
   memset(mensajeErr,0,150);
   memcpy(mensajeErr,"ASSERT: ",8);
   memcpy(mensajeErr+8,pString,cLen);
   mensajeErr[cLen+8+1]='\0';
   
   if( !bAssert )
      sw=put_error((PHB_ITEM) pRET, mensajeErr,300); 
   
}else{
   sw=put_error((PHB_ITEM) pRET, "ASSERT STACK UNDERFLOW",102); 
}

return sw;
}

int fun_getserror(){
int sw=1;
if(CADDR<=nSizeStack){
   PHB_ITEM pSTRERR = hb_itemArrayGet( pRET, 2);
   const char* strError = hb_itemGetCPtr(pSTRERR);
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  strError  );
   hb_itemRelease(pSTRERR);
}else{
   sw=put_error((PHB_ITEM) pRET, "GETESTRRROR STACK UNDERFLOW",102);
}   
return sw;
}

int put_argcnt(){
int sw=1;
if(CADDR<nSizeStack)
   hb_arraySetNInt( pSTK_ADDR, ++CADDR, (unsigned int) LENDS );
else
   sw=put_error((PHB_ITEM) pRET, "TOTALARG STACK UNDERFLOW",102); 
return sw;
}

int fun_clamp_matrix( PHB_ITEM pINICIAL, PHB_ITEM pFINAL, PHB_ITEM pVAR ) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pVAR, &nDim, &d1, &d2, &d3, &type);
   if (type==11){
   switch( nDim ){
      case 1:{
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG1 = hb_itemArrayGet( pVAR, i);
            double nVar = hb_itemGetND(pARG1);
            hb_itemRelease(pARG1);
            if( nVar>nFinal )
               hb_arraySetNL( pVAR, i, (HB_LONGLONG) nFinal );
            else if( nVar<nInicial)
               hb_arraySetNL( pVAR, i, (HB_LONGLONG) nInicial );
         }
         break;
      }case 2:{
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pVAR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               double nVar = hb_itemGetND(pARG11);
               hb_itemRelease(pARG11);
               if( nVar>nFinal )
                  hb_arraySetNL( pARG1, j, (HB_LONGLONG) nFinal );
               else if( nVar<nInicial)
                  hb_arraySetNL( pARG1, j, (HB_LONGLONG) nInicial );
               
            }
            hb_itemRelease(pARG1);
         }
         break;
      }case 3:{
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pVAR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, k);
                  double nVar = hb_itemGetND(pARG111);
                  hb_itemRelease(pARG111);
                  if( nVar>nFinal )
                     hb_arraySetNL( pARG11, k, (HB_LONGLONG) nFinal );
                  else if( nVar<nInicial)
                     hb_arraySetNL( pARG11, k, (HB_LONGLONG) nInicial );

               }
               hb_itemRelease(pARG11);
            }
            hb_itemRelease(pARG1);
         }
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int fun_clamp(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pFINAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // final
   PHB_ITEM pINICIAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // inicial
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pVAR=hb_itemArrayGet( pSTK_REG, nItem);
   
   if( HB_IS_NUMERIC(pFINAL) && HB_IS_NUMERIC(pINICIAL) ){
      if( HB_IS_NUMERIC(pVAR) ){
         double nVar = hb_itemGetND( pVAR );
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         if( nVar>nFinal )
            hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pFINAL );
         else if( nVar<nInicial)
            hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pINICIAL );
      }else if(HB_IS_ARRAY(pVAR)){
         sw=fun_clamp_matrix( (PHB_ITEM) pINICIAL, (PHB_ITEM) pFINAL, (PHB_ITEM)pVAR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "CLAMP TARGET ARGUMENT TYPE ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "CLAMP RANGE ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pVAR);
   hb_itemRelease(pFINAL);
   hb_itemRelease(pINICIAL);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLAMP STACK UNDERFLOW",102); 
}
return sw;
}

/*int fun_clamp(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pFINAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // final
   PHB_ITEM pINICIAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // inicial
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pVAR=hb_itemArrayGet( pSTK_REG, nItem);
   if( HB_IS_NUMERIC(pVAR) && HB_IS_NUMERIC(pFINAL) && HB_IS_NUMERIC(pINICIAL) ){
      double nVar = hb_itemGetND( pVAR );
      double nFinal = hb_itemGetND( pFINAL );
      double nInicial = hb_itemGetND( pINICIAL );
      if( nVar>nFinal )
         hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pFINAL );
      else if( nVar<nInicial)
         hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pINICIAL );
         
   }else{
      sw=put_error((PHB_ITEM) pRET, "CLAMP ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pVAR);
   hb_itemRelease(pFINAL);
   hb_itemRelease(pINICIAL);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLAMP STACK UNDERFLOW",102); 
}
return sw;
}*/
int fun_fill_box(){
int sw=1;
if(CADDR>=3){
   PHB_ITEM pANCHO = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pALTO = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pCHAR = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   HB_SIZE nAncho = hb_itemGetNI( pANCHO );
   HB_SIZE nAlto = hb_itemGetNI( pALTO );
   
   const char * cChar = hb_itemGetCPtr(pCHAR);
   char * space = (char *)calloc(nAncho*3+1,1);
   HB_SIZE i=0;
   for (i = 0; i<nAncho; ++i){
      //space[i]=cChar[0];
      strcat(space,cChar);
   }
   //space[nAncho]='\0';
   int nRow = SCREEN_ROW;
   
   for (i=1; i<=nAlto; ++i){
      printf("\033[%d;%dH%s",nRow++,SCREEN_COL,space);
   }
   SCREEN_ROW = nRow;
   free(space);
   hb_itemRelease(pCHAR);
   hb_itemRelease(pANCHO);
   hb_itemRelease(pALTO);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLRBOX STACK UNDERFLOW",102); 
}
return sw;
}

int fun_cposx(){
  int nItem = STK_PRG[++CP];
  PHB_ITEM pSCRROW = hb_itemPutNInt( NULL, (int) SCREEN_ROW );
  hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSCRROW );
  hb_itemRelease(pSCRROW);
return 1;
}
int fun_cposy(){
  int nItem = STK_PRG[++CP];
  PHB_ITEM pSCRCOL = hb_itemPutNInt( NULL, (int) SCREEN_COL );
  hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSCRCOL );
  hb_itemRelease(pSCRCOL);
return 1;
}

int fun_updateCol(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor a sumar-restar columna
   int nPosy = hb_itemGetNI( pPOSY );
   hb_itemRelease(pPOSY);
   SCREEN_COL = SCREEN_COL + nPosy;
   printf("\033[%d;%dH",SCREEN_ROW,SCREEN_COL);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "UPDATE COL STACK UNDERFLOW",102); 
}
return sw;
}

int fun_updateRow(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor a sumar-restar fila
   int nPosx = hb_itemGetNI( pPOSX );
   hb_itemRelease(pPOSX);
   SCREEN_ROW = SCREEN_ROW + nPosx;
   printf("\033[%d;%dH",SCREEN_ROW,SCREEN_COL);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "UPDATE ROW STACK UNDERFLOW",102); 
}
return sw;
}

int fun_goCol(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosy = hb_itemGetNI( pPOSY );
   hb_itemRelease(pPOSY);
   printf("\033[%d;%dH",SCREEN_ROW,nPosy);
   SCREEN_COL = nPosy;
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "GOY STACK UNDERFLOW",102); 
}
return sw;
}
int fun_goRow(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosx = hb_itemGetNI( pPOSX );
   hb_itemRelease(pPOSX);
   printf("\033[%d;%dH",nPosx,SCREEN_COL);
   SCREEN_ROW = nPosx;
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "GOX STACK UNDERFLOW",102); 
}
return sw;
}

int fun_goxy(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pPOSY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosy = hb_itemGetNI( pPOSY );
   hb_itemRelease(pPOSY);
   PHB_ITEM pPOSX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosx = hb_itemGetNI( pPOSX );
   hb_itemRelease(pPOSX);
   printf("\033[%d;%dH",nPosx,nPosy);
   SCREEN_ROW = nPosx;
   SCREEN_COL = nPosy;
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "GOXY STACK UNDERFLOW",102); 
}
return sw;
}

int empty_stack(){
              if( CADDR ){
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
              }else{
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
              }
return 1;
}

/*int put_PI( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){ //, int PRECISION ){
int sw=1;
if( CADDR<nSizeStack ){
//   PHB_ITEM pSEC = hb_itemPutND( NULL, (double) 3.14159265358979323846 );
   hb_arraySetND( pSTK_ADDR, ++CADDR, (double) SW_PRECISION ? xu_funprecision(3.14159265358979323846,PRECISION) : 3.14159265358979323846 );
//   hb_itemRelease(pSEC);
}else{
   sw=put_error((PHB_ITEM) pRET, "PI INNER-STACK OVERFLOW");
}   
return sw;
}
*/
int dspush(){
int sw=1;
   int nItem = STK_PRG[++CP];
   pSTK_OBJ[++nINDEXOBJ]=hb_itemArrayGet( pSTK_REG, nItem);
/*   if(STK_PRG[CP+1]==289){
      ++CP;
      sw=dspush();
   }*/

return sw;
}
int dspop(){
int sw=1;
   int nItem = STK_PRG[++CP];
   hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSTK_OBJ[nINDEXOBJ] );
   hb_itemRelease(pSTK_OBJ[nINDEXOBJ]);
   --nINDEXOBJ;
/*   if(STK_PRG[CP+1]==290){
      ++CP;
      sw=dspop();
   }*/
//              sw=STK_PRG[CP+1]==290? dspop() : 1 ;
return sw;
}

int dstop(){
int sw=1;
if(nINDEXOBJ>=0){
   int nItem = STK_PRG[++CP];
   hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSTK_OBJ[nINDEXOBJ] );
}else{
   sw=put_error((PHB_ITEM) pRET, "ITOP(INNER-STACK-NOT-USER) STACK UNDERFLOW",102); 
}
return sw;
}

int replicate_by(){
int sw=1;
              if ( CADDR>=1 ){
                 sw=(int)fun_replicate(/*STK_PRG[ ++CP ]*/); // TODO: DEBO ASIGNAR A VAR GLOBAL, SEGUN nPNP
              }else{
                 sw=put_error((PHB_ITEM) pRET, "REPLICATE STACK UNDERFLOW",102); 
              }
return sw;
}
int replicate(){
int sw=1;
              if ( CADDR>=2 ){
                 sw=(int)fun_replicate(/*0*/);
              }else{
                 sw=put_error((PHB_ITEM) pRET, "REPLICATE STACK UNDERFLOW",102); 
              }
return sw;
}

int fun_minusplus(){
int sw=1;
if(CADDR<nSizeStack){
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nReg );
   int tIncDec = nPCP == 384? -1 : nPCP == 385? 1 : nPCP == 386? -2: 2;
   if( HB_IS_LONG(pSTACK)) {
      hb_arraySetNL(pSTK_ADDR, ++CADDR, (long)hb_itemGetNL(pSTACK)+tIncDec);
   }else if(HB_IS_INTEGER(pSTACK)){
      hb_arraySetNInt(pSTK_ADDR, ++CADDR, (int)hb_itemGetNInt(pSTACK)+tIncDec);
   }else if(HB_IS_DOUBLE(pSTACK)){
      hb_arraySetND(pSTK_ADDR, ++CADDR, (double)hb_itemGetND(pSTACK)+tIncDec);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MINUS|PLUS ONE|TWO TYPE MISMATCH",104);
   }
   hb_itemRelease(pSTACK);
}else{
   sw=put_error((PHB_ITEM) pRET, "MINUS|PLUS ONE|TWO STACK OVERFLOW",103);
}
return sw;
}

int fun_isnumeric(){
int sw=1;
if(CADDR){
   int tCompare=nPCP==150?1:0;
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(!HB_IS_ARRAY(pKEY)){
      if(tCompare)
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (HB_IS_NUMERIC(pKEY) ? 1 : 0) );
      else
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (HB_IS_STRING(pKEY) ? 1 : 0) );
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pKEY, &nDim, &d1, &d2, &d3, &type);
      //if (type>10){
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pKEY, i);
                  if(tCompare)
                     hb_arraySetNI( pRows, i, (int) (HB_IS_NUMERIC(pARG22) ? 1 : 0) );
                  else
                     hb_arraySetNI( pRows, i, (int) (HB_IS_STRING(pARG22) ? 1 : 0) );
                  hb_itemRelease(pARG22);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pKEY, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     if(tCompare)
                        hb_arraySetNI( pCols, j, (int) (HB_IS_NUMERIC(pARG222) ? 1 : 0) );
                     else
                        hb_arraySetNI( pCols, j, (int) (HB_IS_STRING(pARG222) ? 1 : 0) );
                     hb_itemRelease(pARG222);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pKEY, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     PHB_ITEM pPag = hb_itemArrayNew( d3 );
                     int k;
                     for( k=1; k<=d3; k++){
                        PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                        if(tCompare)
                           hb_arraySetNI( pPag, k, (int) (HB_IS_NUMERIC(pARG2222) ? 1 : 0) );
                        else
                           hb_arraySetNI( pPag, k, (int) (HB_IS_STRING(pARG2222) ? 1 : 0) );
                        hb_itemRelease(pARG2222);
                     }
                     hb_arraySet( pCols, j, pPag );
                     hb_itemRelease(pARG222);
                     hb_itemRelease(pPag);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=0;
            }
         }
     // }else{
     //    sw=put_error((PHB_ITEM) pRET, "ISNUMERIC|STRING? TYPE MISMATCH",104);
     // }
   }
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "ISNUMERIC|STRING? STACK UNDERFLOW",102); 
}
return sw;
}

/*int fun_isstring(){
int sw=1;
if(CADDR){
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   hb_arraySetL( pSTK_ADDR, ++CADDR, (HB_BOOL) (HB_IS_STRING(pKEY) ? 1 : 0) );
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "ISSTRING? STACK UNDERFLOW",102); 
}
return sw;
}*/
int fun_isarray(){
int sw=1;
if(CADDR){
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (HB_IS_ARRAY(pKEY) ? 1 : 0) );
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "ISARRAY? STACK UNDERFLOW",102); 
}
return sw;
}
int fun_length(){
int sw=1;
if(CADDR){
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   int nLen=1;
   if(HB_IS_ARRAY(pKEY)){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pKEY, &nDim, &d1, &d2, &d3, &type);
      nLen *= nDim==1 ? d1 : nDim==2 ? d1*d2 : d1*d2*d3;
   }
   // si pKEY no es array, longitud=1.
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) nLen );
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "LENGTH STACK UNDERFLOW",102); 
}
return sw;
}

int fun_seed(){
int sw=1;
   if(CADDR){
      PHB_ITEM pSEED = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      unsigned int nSeed = hb_itemGetNI( pSEED );
      srand( nSeed ? ( unsigned ) nSeed : ( unsigned ) hb_dateMilliSeconds() );
      s_fInit = 1;
      hb_itemRelease(pSEED);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SEED STACK UNDERFLOW",102);
   }
return sw;
}

int keyboard_free(){
     //fflush(stdin);
     //
     hb_inkeyReset();
     hb_inkeySetLast( 0 );  // elimina teclas presionadas
   /*  int k=1;
     while( !k ){
        k = hb_inkeyNext( hb_setGetEventMask() );
     }*/
return 1;
}
int keyboard_put(){
              if(CADDR){
                 PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                 CADDR += SWKEEP; SWKEEP = 0;
                 hb_inkeyPut(hb_itemGetNI(pKEY));
                 hb_itemRelease(pKEY);
              }
return 1;
}
int keyboard_hit(){
              hb_inkey(0,0,128);
              if(CADDR<nSizeStack)
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (hb_inkeyLast(128)!=0) );
return 1;
}
int keyboard_ctrlc(){
              hb_inkey(0,0,128);
              if(CADDR<nSizeStack)
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (hb_inkeyLast(128)==3) );
              hb_inkeySetLast( 0 );  // borro, porque sé que es ctrl-c.
return 1;
}
int keyboard_esc(){
              hb_inkey(0,0,128);
              if(CADDR<nSizeStack)
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (hb_inkeyLast(128)==27) );
              hb_inkeySetLast( 0 );  // borro, porque sé que es escape.
return 1;
}

int fun_lastkey(){
              //hb_inkey(0,0,128);
              //hb_arraySetNL( pSTK_REG, STK_PRG[ ++CP ], hb_inkey( 0,0,hb_setGetEventMask() ) );
              hb_arraySetNL( pSTK_REG, STK_PRG[ ++CP ], hb_inkeyLast( hb_setGetEventMask() ) );
              //hb_arraySetNL( pSTK_REG, STK_PRG[ ++CP ], getc(stdin) );
return 1;
}

int put_pausa(){
              //hb_idleState();
              hb_inkey((HB_BOOL) HB_TRUE,0,128);
return 1;
}

#define HB_MAX_UTF8        3

int fun_get_char_utf8(){
int sw=1;
if(CADDR){
   PHB_ITEM pCHAR=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   HB_WCHAR c = hb_itemGetNI( pCHAR );
   hb_itemRelease(pCHAR);

/*   int iLen;
   char utf8Char[ HB_MAX_UTF8 ];
   iLen = hb_cdpU16CharToUTF8( utf8Char, ( HB_WCHAR ) c );
   //hb_retclen( utf8Char, iLen );
   const char * chrutf8 = utf8Char;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) chrutf8 );
  */ 
   switch(c){
      case 126: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "~" );
            break;

      }case 129: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "A" );
            break;

      }case 137: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "E" );
            break;

      }case 141: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "I" );
            break;

      }case 145: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "Ñ" );
            break;

      }case 147: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "O" );
            break;

      }case 154: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "U" );
            break;

      }case 160: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "à" );
            break;

      }case 161: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "á" );
            break;

      }case 164: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ä" );
            break;

      }case 168: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "è" );
            break;

      }case 169: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "é" );
            break;

      }case 171: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ë" );
            break;

      }case 172: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ì" );
            break;

      }case 173: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "í" );
            break;

      }case 175: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ï" );
            break;

      }case 176: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ù" );
            break;

      }case 177: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ñ" );
            break;

      }case 178: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ò" );
            break;

      }case 179: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ó" );
            break;

      }case 182: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ö" );
            break;

      }case 186: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ú" );
            break;

      }case 188: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ü" );
            break;

      }case 191: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "¿" );
            break;

      }default:{
         char * cChar = (char *) calloc(10,1);
         cChar[0] = c;
         cChar[1] = '\0';
         const char *buff = cChar;
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) buff );
         free(cChar);
      }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "CHRUTF8 STACK UNDERFLOW",102);
}
return sw;
}

int true_instruccion(){
              if( CADDR<nSizeStack )
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, 1 );
return 1;
}
int false_instruccion(){
              if( CADDR<nSizeStack )
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, 0 );
return 1;
}
int multipass_on(){
              MULTIPASS=1;
return 1;
}
int multipass_off(){
              MULTIPASS=0;
return 1;
}

/* la variable estará en STACK; luego, sólo debo retener la direccion
   de la misma en el stack antes de la ejecucion de la orden */
int fun_pushvar(){

   PUSH_VAR = STK_PRG[++CP];

return 1;
}

int declara_puntero(){
              SW_PUNTERO=1;
return 1;
}

int clear_stack(){
int sw=1;
   CADDR=0;
   int i;
//   hb_itemRelease(pSTK_ADDR);
//   pSTK_ADDR = hb_itemArrayNew( nSizeStack );
   for(i=1; i<=nSizeStack; i++) hb_arrayDel(pSTK_ADDR,1);

   hb_itemRelease(pSTK_ADDR);
   pSTK_ADDR = hb_itemArrayNew( nSizeStack );

   hb_ret();   
   hb_gcCollect();   
   hb_idleState();
return sw;
}

int kpop(){  // kill
int sw=1;
if( CADDR>0 ){
   hb_arrayDel(pSTK_ADDR,CADDR);
 //  hb_ret();
   
 //  hb_gcCollect();
 //  hb_idleState();
   CADDR--;
}// aquí no hay "else", dado que si no hay datos, no pasa ná.
return sw;
}
int clear_var(){
int sw=1;
              int nReg = STK_PRG[ ++CP ];
             // hb_arrayDel(pSTK_REG, nReg);
             // hb_arrayIns(pSTK_REG, nReg);
             // hb_arraySetNI( pSTK_REG, nReg, (int)0 );
              if(hb_arrayDel(pSTK_REG, nReg)){
                 hb_arrayIns(pSTK_REG, nReg);
                 hb_arraySetNL( pSTK_REG, nReg, (long)0 );
              }else{
                 sw=put_error((PHB_ITEM) pRET, "CLEAR VAR NOT DELETE",104);
              }
              hb_ret();

              hb_gcCollect();
              hb_idleState();
return sw;
}

int fun_keep(){
int sw=1;
   ++SWKEEP;
/*   if(STK_PRG[CP+1]==194){
      ++CP;
      sw=fun_keep();
   }*/
return sw;
}

int fun_keeparg(){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
   SWKEEP+=hb_itemGetNI(pSTACK);
   hb_itemRelease(pSTACK);
/*   if(STK_PRG[CP+1]==317){
      ++CP;
      sw=fun_keeparg();
   } */
return sw;
}

int fun_sizestack(){
int sw=1;
int SIZE=CADDR;
if(CADDR+1<nSizeStack){
   hb_arraySetNI( pSTK_ADDR, ++CADDR, SIZE );
   hb_arraySetNI( pSTK_ADDR, ++CADDR, nINDEXOBJ+1 );
}else
   sw=put_error((PHB_ITEM) pRET, "SIZESTACK INNER-STACK OVERFLOW",102); 
return sw;
}

int funDuplicateStack(){
int sw=1;
if(CADDR>0){
   PHB_ITEM pLASTITEM = hb_itemArrayGet( pSTK_ADDR, CADDR );
   hb_arraySet( pSTK_ADDR, ++CADDR, pLASTITEM );
   hb_itemRelease(pLASTITEM);
}else{
   sw=put_error((PHB_ITEM) pRET, "DUP INNER-STACK OVERFLOW",102); 
}
return sw;
}

/*int set_video(){
int sw=1;
int iRows, iCols;
hb_gtScrDim( &iRows, &iCols );
if(CADDR>=1){
   PHB_ITEM pROWS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   iRows = hb_itemGetNInt(pROWS);
}
if(CADDR>=1){   
   PHB_ITEM pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   iCols = hb_itemGetNInt(pCOLS);
}
   //hb_retl( hb_gtSetMode( iRows, iCols ) == HB_SUCCESS );
hb_gtSetMode( iRows, iCols );

return sw;
}*/
/*int fun_setmode()
{
int sw=0;
if(CADDR>=2){
   PHB_ITEM pNEWCOL=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pNEWROW=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   unsigned int iRows = hb_itemGetNInt(pNEWROW);
   unsigned int iCols = hb_itemGetNInt(pNEWCOL);
   hb_itemRelease(pNEWCOL);
   hb_itemRelease(pNEWROW);
   
   PHB_GT pGT;
   pGT = hb_gt_Base();
   if( pGT )
   {
      if( HB_GTSELF_SETMODE( pGT, iRows, iCols ) )
         sw = HB_SUCCESS;
      hb_gt_BaseFree( pGT );
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "VIDEO INNER-STACK OVERFLOW",102);
}
return sw;
}*/



int fun_push(){
              int nItem = STK_PRG[++CP];
              if(CADDR){
                 PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
                 PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, CADDR--);
                 CADDR += SWKEEP; SWKEEP = 0;
                 hb_arrayAdd( pSTACK, pDATO );
               //  hb_arraySet( pSTK_REG, nItem, pSTACK );
                 hb_itemRelease(pSTACK);
                 hb_itemRelease(pDATO);
              }
return 1;
}
int fun_pop(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              long ulLen = hb_arrayLen( pSTACK );
              PHB_ITEM pLast = hb_itemNew( NULL );
              if(CADDR<nSizeStack){
                 if( ulLen ){
                    hb_arrayLast( pSTACK, pLast );
                    hb_arrayDel( pSTACK, ulLen );
                    --ulLen;
                    hb_arraySize( pSTACK, HB_MAX( ulLen, 0 ) );
                    hb_arraySet( pSTK_ADDR, ++CADDR, pLast );
                 }else{
                    sw=put_error((PHB_ITEM) pRET, "DEQUE-POP STACK OVERFLOW",103); 
                 }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "DEQUE-POP INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pLast);
              hb_itemRelease(pSTACK);
return sw;
}
int fun_qpop(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              long ulLen = hb_arrayLen( pSTACK );
              if(CADDR<nSizeStack){
                 if( ulLen ){
                    PHB_ITEM pFirst = hb_itemArrayGet( pSTACK, 1);
                    hb_arrayDel( pSTACK, 1 );
                    --ulLen;
                    hb_arraySize( pSTACK, HB_MAX( ulLen, 0 ) );
                    hb_arraySet( pSTK_ADDR, ++CADDR, pFirst );
                    hb_itemRelease(pFirst);
                 }else{
                    sw=put_error((PHB_ITEM) pRET, "QUEUE-POP STACK OVERFLOW",103); 
                 }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "QUEUE-POP INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pSTACK);
return sw;
}
int print_matrix2D( PHB_ITEM pSource, unsigned PRECISION, const char *tokenizer, unsigned int ROW, unsigned int COL, unsigned int d1, unsigned int d2 ){

int sw=1;
int swOffset=0;
   int i, NR=ROW;
  /* Verifica rangos de impresion */
   int nIniR=1, nFinR=d1;
   int nIniC=1, nFinC=d2;
   // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
   if( MARK_ROW ) {
      if( MARK_ROW == 999999999 ) MARK_ROW=d1;
      if( MARK_ROW>d1 ){
         sw=put_error((PHB_ITEM) pRET, "PRINT TABLE ROW'MARK OVERFLOW",101);
         hb_itemRelease(pSource);
         return sw;               
      }
      nIniR=MARK_ROW;nFinR=MARK_ROW;
      if( OFFSET_ROW ){
         if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
         if( OFFSET_ROW<=d1 ){
            nFinR=OFFSET_ROW;
         }else{   // es mayor! ERROR
            sw=put_error((PHB_ITEM) pRET, "PRINT TABLE ROW'OFFSET OVERFLOW",101);
            hb_itemRelease(pSource);
            return sw;
         }
      }
   }else{  // asume todas las filas
      swOffset=1;
      OFFSET_ROW=nFinR;
   }
   if( MARK_COL ) {
      if( MARK_COL == 999999999 ) MARK_COL=d2;
      if( MARK_COL>d2 ){
         sw=put_error((PHB_ITEM) pRET, "PRINT TABLE COL'MARK OVERFLOW",101);
         hb_itemRelease(pSource);
         return sw;               
      }
      nIniC=MARK_COL;nFinC=MARK_COL;
      if( OFFSET_COL ){
         if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
         if( OFFSET_COL<=d2 ){
            nFinC=OFFSET_COL;
         }else{   // es mayor! ERROR
            sw=put_error((PHB_ITEM) pRET, "PRINT TABLE COL'OFFSET OVERFLOW",101);
            hb_itemRelease(pSource);
            return sw;
         }
      }
   }else{  // asume todas las columnas
      swOffset=1;
      OFFSET_COL=nFinC;
   }
   /* verifica incremento por intervalo seteado */
   int nIncR=SET_INTERVAL_ROW;
   int nIncC=SET_INTERVAL_COL;
   for( i=nIniR; i<=nFinR; i+=nIncR ){
      PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
      int j, NC=COL;
      printf("\033[%d;%dH",NR,NC);
      for( j=nIniC; j<=nFinC; j+=nIncC ){
         PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
         
         print_single( (PHB_ITEM) pPrint, PRECISION );
         
         hb_itemRelease(pPrint);
         //++NC;
         if( d2-j ) printf( "%s",tokenizer );
      }
      ++NR;
      hb_itemRelease(pDato2D);
   }
   if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
   printf( "\n" );
return sw;
}

int fun_print_array(){
int sw=1;

if(CADDR>=1 ){
//   PHB_ITEM pCOL=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // columna
//   PHB_ITEM pROW=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fila
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // array
   int nCol = SCREEN_COL;//hb_itemGetNInt(pCOL);
   int nRow = SCREEN_ROW;//hb_itemGetNInt(pROW);

   if( HB_IS_ARRAY(pARRAY) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      if( nDim == 2 ){
         int nPrecision = SW_PRECISION ? PRECISION : 13;
         const char * tokenizer=TOKENIZER;
         sw = print_matrix2D( pARRAY, nPrecision, tokenizer, nRow, nCol, d1, d2 );
      }else{
         sw=put_error((PHB_ITEM) pRET, "PRINT 2D DIMENSION ERROR",104);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PRINT 2D TYPE MISMATCH",104);
   }
 //  hb_itemRelease(pCOL);
 //  hb_itemRelease(pROW);
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "PRINT 2D INNER-STACK OVERFLOW",102); 
}
return sw;
}

int fun_draw_table(){
int sw=1;

if(CADDR>=1 ){
//   PHB_ITEM pCOL=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // columna
//   PHB_ITEM pROW=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fila
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // array
   //int nCol = SCREEN_COL;//hb_itemGetNInt(pCOL);
   //int nRow = SCREEN_ROW;//hb_itemGetNInt(pROW);

   if( HB_IS_ARRAY(pARRAY) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      switch(nDim){
      case 2:{
         
         int nIniR=1, nFinR=d1;
         int nIniC=1, nFinC=d2;
         int i,NR = SCREEN_ROW;
         for( i=nIniR; i<=nFinR; i++ ){
            PHB_ITEM pDato2D = hb_itemArrayGet( pARRAY, i);
            int j, NC=SCREEN_COL;
            printf("\033[%d;%dH",NR,NC);
            for( j=nIniC; j<=nFinC; j++ ){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               //int pixel = hb_itemGetNI(pPrint);
               //print_single( (PHB_ITEM) pPrint, PRECISION );
               printf("\033[48;5;%dm ",hb_itemGetNI(pPrint));
               
               hb_itemRelease(pPrint);
               //++NC;
               //if( d2-j ) printf( "%s",tokenizer );
            }
            ++NR;
            hb_itemRelease(pDato2D);
         }
         fflush(stdout);
         break;
      }case 1:{
         //sw=put_error((PHB_ITEM) pRET, "DRWTBL DIMENSION ERROR",104);
         int nIniR=1, nFinR=d1;
         int i;
         printf("\033[%d;%dH",SCREEN_ROW,SCREEN_COL);
         for( i=nIniR; i<=nFinR; i++ ){
            PHB_ITEM pDato2D = hb_itemArrayGet( pARRAY, i);
            printf("\033[48;5;%dm ",hb_itemGetNI(pDato2D));
            hb_itemRelease(pDato2D);
         }
         fflush(stdout);
         break;
      }default:{
         sw=put_error((PHB_ITEM) pRET, "DRWTBL DIMENSION ERROR",104);
      }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "DRWTBL TYPE MISMATCH",104);
   }
 //  hb_itemRelease(pCOL);
 //  hb_itemRelease(pROW);
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "DRWTBL INNER-STACK OVERFLOW",102); 
}
return sw;
}


int fun_look(){
int sw=1;

if(CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
   long ulLen = hb_arrayLen( pSTACK );
   PHB_ITEM pLast = NULL;

   PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   long nDato = hb_itemGetNL(pDATO);
   hb_itemRelease(pDATO);
   if( CADDR<nSizeStack){
      if( nDato > 0 && nDato <= ulLen ){
          pLast = hb_itemArrayGet( pSTACK, nDato );
          hb_arraySet( pSTK_ADDR, ++CADDR, pLast );
      }else{
          sw=put_error((PHB_ITEM) pRET, "LOOK ARGUMENT ERROR - INDEX OVERFLOW",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "LOOK INNER-STACK OVERFLOW",102); 
   }
   hb_itemRelease(pLast);              
   hb_itemRelease(pSTACK);
}else{
   sw=put_error((PHB_ITEM) pRET, "LOOK INNER-STACK UNDERFLOW",102); 
}
return sw;
}

int fun_tail(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              long ulLen = hb_arrayLen( pSTACK );
              PHB_ITEM pLast = hb_itemNew( NULL );
              if(CADDR<nSizeStack){
                 if( ulLen )  hb_arrayLast( pSTACK, pLast );
                 hb_arraySet( pSTK_ADDR, ++CADDR, pLast );
              }else{
                 sw=put_error((PHB_ITEM) pRET, "TAIL INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pLast);              
              hb_itemRelease(pSTACK);
return sw;
}
int fun_head(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              //long ulLen = hb_arrayLen( pSTACK );
              if(CADDR<nSizeStack){
                 PHB_ITEM pFirst = hb_itemArrayGet( pSTACK, 1);
                 hb_arraySet( pSTK_ADDR, ++CADDR, pFirst );
                 hb_itemRelease(pFirst);
              }else{
                 sw=put_error((PHB_ITEM) pRET, "HEAD INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pSTACK);
return sw;
}

int fun_swap(){
int sw=1;
  int nItem1 = STK_PRG[++CP];
  int nItem2 = STK_PRG[++CP];
  PHB_ITEM pREG1=hb_itemArrayGet( pSTK_REG, nItem1);
  PHB_ITEM pREG2=hb_itemArrayGet( pSTK_REG, nItem2);
  PHB_ITEM SWAP_REG=pREG1;
  hb_arraySet( pSTK_REG, nItem1, (PHB_ITEM)pREG2 );
  hb_arraySet( pSTK_REG, nItem2, (PHB_ITEM)SWAP_REG );

 // hb_itemRelease(SWAP_REG);
  hb_itemRelease(pREG1);
  hb_itemRelease(pREG2);
  
return sw;
}

int fun_get_size_terminal(){
int sw=1;
if(CADDR<nSizeStack-2){
   struct winsize w;
   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);

   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) w.ws_row);
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) w.ws_col);
    //printf ("lines %d\n", w.ws_row);
    //printf ("columns %d\n", w.ws_col);
}else{
   sw=put_error((PHB_ITEM) pRET, "GETSIZSCR INNER-STACK OVERFLOW",102); 
}
return sw;
}

int fun_nothing(){return 1;}

/*  GRAFICAS SIMPLES EN MODO TEXTO */


void plotPoints(int xc, int yc, int x1, int y1) {    
    printf("\033[%d;%dH ",(int)floorf(xc+x1),(int)floorf(yc+y1));
    printf("\033[%d;%dH ",(int)floorf(xc-x1),(int)floorf(yc+y1));
    printf("\033[%d;%dH ",(int)floorf(xc+x1),(int)floorf(yc-y1));
    printf("\033[%d;%dH ",(int)floorf(xc-x1),(int)floorf(yc-y1));
    printf("\033[%d;%dH ",(int)floorf(xc+y1),(int)floorf(yc+x1));
    printf("\033[%d;%dH ",(int)floorf(xc-y1),(int)floorf(yc+x1));
    printf("\033[%d;%dH ",(int)floorf(xc+y1),(int)floorf(yc-x1));
    printf("\033[%d;%dH ",(int)floorf(xc-y1),(int)floorf(yc-x1));
}
  
int  fun_txt_circle (){

int sw=1;
if( CADDR>=3 ){
    PHB_ITEM pRAD=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pYC=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pXC=hb_itemArrayGet( pSTK_ADDR, CADDR--);

    int xc = hb_itemGetNI(pXC);
    int yc = hb_itemGetNI(pYC);
    int r = hb_itemGetNI(pRAD);

    hb_itemRelease(pXC);
    hb_itemRelease(pYC);
    hb_itemRelease(pRAD);
    
    int x=0,y=r,p;

    plotPoints(xc, yc, x, y);
    p = 1-r;
    while (x<y){
       if (p<0){
          ++x;
          p = p+2*x+1;
       }else{
          ++x;
          --y;
          p=p+2*(x-y)+1;
       }
       plotPoints(xc, yc, x, y);
    }
    fflush(stdout);
}else{
   sw=put_error((PHB_ITEM) pRET, "CIRCLE INNER-STACK OVERFLOW",102); 
}
return sw;
}

void inner_draw_line(float x1, float y1, float x2, float y2){
    int  i=0;
    float dx=0, dy=0, luz=0, DX=0, DY=0;
    
    dx = x2-x1; dy = y2-y1; //Sub(x2, x1), Sub (y2, y1), Move to ' dx, dy '
    DX = fabs(dx); DY = fabs(dy);
    luz = fabs(dx) >= fabs(dy) ? DX : DY; // Greater equal ( Abs(dx) » (DX), Abs(dy)»(DY) ), DX, DY ) )

  // incremento:
    dx = dx/luz; dy = dy/luz;
    //Div(dx, paso), Div(dy, paso), Move to ( dx, dy )

  //  Color back (13)
  // dibuja línea:
    for ( i=0; i < (int)luz ; ++i){
     //Loop if ( Less equal (i, paso) )
        printf("\033[%d;%dH ",(int)floorf(x1),(int)floorf(y1));
        x1 = x1+dx; y1=y1+dy;
    }
    fflush(stdout);
}

int fun_txt_line()
{
int sw=1;
if( CADDR>=4 ){
    PHB_ITEM pDY=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pDX=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pOY=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pOX=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    
    float x1 = (float) hb_itemGetND(pOX);
    float y1 = (float) hb_itemGetND(pOY);
    float x2 = (float) hb_itemGetND(pDX);
    float y2 = (float) hb_itemGetND(pDY);
    
    hb_itemRelease(pOX);
    hb_itemRelease(pOY);
    hb_itemRelease(pDX);
    hb_itemRelease(pDY);
    
    inner_draw_line(x1,y1,x2,y2);

}else{
    sw=put_error((PHB_ITEM) pRET, "LINE INNER-STACK OVERFLOW",102); 
}
return sw;
}

// entrego un array bidimensional, no dos arrays
//  draw(array)
int fun_nbr(){
int sw=1;
   int count=0;
   int nItem1 = STK_PRG[++CP];
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_REG, nItem1);

   PHB_ITEM pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW-1);
   PHB_ITEM pVERTC = hb_itemArrayGet( pVERTR, MARK_COL-1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);
   
   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW-1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW-1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL+1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);
   
   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL-1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);
   
   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL+1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW+1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL-1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW+1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW+1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL+1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   hb_itemRelease(pARRAY);
   hb_arraySetNI( pSTK_ADDR, ++CADDR, count );

return sw;
}

int fun_txt_drawPoligon(){
int sw=1;

   int nItem1 = STK_PRG[++CP];
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_REG, nItem1);

   if( HB_IS_ARRAY(pARRAY) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      if( nDim == 2 ){
    
         int i;

         for (i = 2; i<=d1; ++i) {
             PHB_ITEM pVERT1 = hb_itemArrayGet( pARRAY, i-1);
             PHB_ITEM pVX1 = hb_itemArrayGet( pVERT1, 1);
             PHB_ITEM pVY1 = hb_itemArrayGet( pVERT1, 2);
             
             PHB_ITEM pVERT = hb_itemArrayGet( pARRAY, i);
             PHB_ITEM pVX = hb_itemArrayGet( pVERT, 1);
             PHB_ITEM pVY = hb_itemArrayGet( pVERT, 2);
                          
             inner_draw_line( hb_itemGetNI(pVX1), hb_itemGetNI(pVY1), hb_itemGetNI(pVX), hb_itemGetNI(pVY) );
             hb_itemRelease(pVX);hb_itemRelease(pVY);hb_itemRelease(pVERT);
             hb_itemRelease(pVX1);hb_itemRelease(pVY1);hb_itemRelease(pVERT1);
         }
         PHB_ITEM pVERT1 = hb_itemArrayGet( pARRAY, d1);
         PHB_ITEM pVX1 = hb_itemArrayGet( pVERT1, 1);
         PHB_ITEM pVY1 = hb_itemArrayGet( pVERT1, 2);
             
         PHB_ITEM pVERT = hb_itemArrayGet( pARRAY, 1);
         PHB_ITEM pVX = hb_itemArrayGet( pVERT, 1);
         PHB_ITEM pVY = hb_itemArrayGet( pVERT, 2);
                          
         inner_draw_line( hb_itemGetNI(pVX1), hb_itemGetNI(pVY1), hb_itemGetNI(pVX), hb_itemGetNI(pVY) );
         hb_itemRelease(pVX);hb_itemRelease(pVY);hb_itemRelease(pVERT);
         hb_itemRelease(pVX1);hb_itemRelease(pVY1);hb_itemRelease(pVERT1);

      }else{
          sw=put_error((PHB_ITEM) pRET, "DRAW DIMENSION ERROR",104);
      }
   }else{
       sw=put_error((PHB_ITEM) pRET, "DRAW ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pARRAY);
   return sw;
}

void inner_draw_poligon( float verticesx[], float verticesy[], int N ){


  int  i;
    for (i = 1; i<N; ++i){
        inner_draw_line( verticesx[ (i-1)], verticesy [(i-1)], verticesx [i], verticesy [i] );
    }
    inner_draw_line( verticesx [N-1], verticesy [N-1], verticesx [0], verticesy [0] );

}

int fun_txt_poligon(){
int sw=1;
if( CADDR>=4 ){
    PHB_ITEM pRAD=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pNVERT=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pCY=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pCX=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    
    
    int N = hb_itemGetNI(pNVERT);
    int radio = hb_itemGetNI(pRAD);
    int cx = hb_itemGetNI(pCX);
    int cy = hb_itemGetNI(pCY);
    
    hb_itemRelease(pCY);hb_itemRelease(pCX);hb_itemRelease(pNVERT);hb_itemRelease(pRAD);

    float alfa;
    int i;

    alfa = (2* 3.141592) / N;
    float verticesx[N];
    float verticesy[N];
    for (i= 0; i<N ; ++i){
       verticesx[ i] = cx + radio * cos( i*alfa );
       verticesy[ i] = cy + radio * sin( i*alfa );
    }
    inner_draw_poligon( verticesx, verticesy,  N );

}else{
    sw=put_error((PHB_ITEM) pRET, "POLIGON INNER-STACK OVERFLOW",102);
}
return sw;
}


/*
static volatile sig_atomic_t keep_running = 1;
//int keep_running = 1;

//static void sig_handler(int _){
//    (void)_;
//    keep_running = 0;
//}
void sig_handler(int signo)
{
  if (signo == SIGINT){
     printf("\nreceived SIGINT\n");
     keep_running = 0;
  }
} */

 // estructuras para punteros a función:


    struct {
        int (*p)();
    }funCall[405] = { /*    0: */{PushReg},          
                      /*    1: */{PushCopyReg},      
                      /*    2: */{PushDS},           
                      /*    3: */{LetReg},           
                      /*    4: */{LetMacro},         
                      /*    5: */{LetDS},            
                      /*    6: */{jumpSingle},       
                      /*    7: */{jumpEQ},           
                      /*    8: */{jumpNEQ},          
                      /*    9: */{jumpLT},           
                      /*   10: */{jumpLTE},          
                      /*   11: */{jumpGT},
                      /*   12: */{jumpGTE}, 
                      /*   13: */{jumpT},
                      /*   14: */{jumpNT},
                      /*   15: */{jumpV},           
                      /*   16: */{jumpNV},
                      /*   17: */{jumpZ},
                      /*   18: */{jumpNZ},
                      /*   19: */{jumpNEG},
                      /*   20: */{jumpPOS},         
                      /*   21: */{jumpGOSUB},
                      /*   22: */{jumpJSUB},
                      /*   23: */{logicalCompare},
                      /*   24: */{logicalCompare},
                      /*   25: */{logicalCompare},
                      /*   26: */{logicalCompare},
                      /*   27: */{logicalCompare},
                      /*   28: */{logicalCompare},
                      /*   29: */{logicalCompare},
                      /*   30: */{logicalCompare},
                      /*   31: */{logicalCompare},
                      /*   32: */{logicalCompare}, 
                      /*   33: */{logicalCompare},
                      /*   34: */{logicalEmpty},
                      /*   35: */{between},
                      /*   36: */{empty_stack},
                      /*   37: */{fun_ifenv},
                      /*   38: */{fun_exist_file},
                      /*   39: */{fun_getserror},
                      /*   40: */{computo},
                      /*   41: */{computo},
                      /*   42: */{computo},
                      /*   43: */{computo},
                      /*   44: */{computo},
                      /*   45: */{computo},
                      /*   46: */{computo},
                      /*   47: */{computo},
                      /*   48: */{computo}, 
                      /*   49: */{computo},
                      /*   50: */{jumpCase},
                      /*   51: */{logicalCompare},
                      /*   52: */{keyboard_free},
                      /*   53: */{keyboard_put},
                      /*   54: */{fun_repl_lateral},
                      /*   55: */{fun_repl_lateral},
                      /*   56: */{fun_repl_lateral},
                      /*   57: */{fun_isnaninf},
                      /*   58: */{fun_isnaninf},
                      /*   59: */{fun_cut_single},
                      /*   60: */{funStrOneArg},
                      /*   61: */{funStrOneArg},
                      /*   62: */{funStrOneArg},
                      /*   63: */{funStrOneArg},
                      /*   64: */{funStrOneArg},
                      /*   65: */{funStrOneArg},
                      /*   66: */{funStrOneArg},
                      /*   67: */{funStrOneArg},
                      /*   68: */{fun_isanyall},
                      /*   69: */{fun_isanyall},
                      /*   70: */{NULL}, //{fun_clear_marks},
                      /*   71: */{fun_trycatch},
                      /*   72: */{get_elaptime},
                      /*   73: */{get_daysdiff},
                      /*   74: */{get_dateadd},
                      /*   75: */{stack_gettoken},
                      /*   76: */{stack_modtoken},
                      /*   77: */{fun_cut_single},
                      /*   78: */{fun_regvalid},
                      /*   79: */{fun_regmatch},
                      /*   80: */{funNumOneArg},
                      /*   81: */{funNumOneArg},
                      /*   82: */{funNumOneArg},
                      /*   83: */{funNumOneArg},
                      /*   84: */{funNumOneArg},
                      /*   85: */{funNumOneArg},
                      /*   86: */{funNumOneArg},
                      /*   87: */{funNumOneArg},
                      /*   88: */{funNumOneArg},
                      /*   89: */{funNumOneArg},
                      /*   90: */{funNumOneArg},
                      /*   91: */{funNumOneArg},
                      /*   92: */{funNumOneArg},
                      /*   93: */{funNumOneArg},
                      /*   94: */{funNumOneArg},
                      /*   95: */{funNumOneArg},
                      /*   96: */{funNumOneArg},
                      /*   97: */{funNumOneArg},
                      /*   98: */{funNumOneArg},
                      /*   99: */{funNumOneArg},
                      /*  100: */{funNumOneArg},
                      /*  101: */{funNumOneArg},
                      /*  102: */{funNumOneArg},
                      /*  103: */{funNumOneArg},
                      /*  104: */{funNumOneArg},
                      /*  105: */{funNumOneArg},
                      /*  106: */{funNumOneArg},
                      /*  107: */{funNumOneArg},
                      /*  108: */{funNumOneArg},
                      /*  109: */{funNumOneArg},
                      /*  110: */{funNumOneArg},
                      /*  111: */{funNumOneArg},
                      /*  112: */{funNumOneArg},
                      /*  113: */{fun_nothing},  // no tocar: usado por NOP
                      /*  114: */{funDuplicateStack},
                      /*  115: */{type_item_char},
                      /*  116: */{fun_sizestack},
                      /*  117: */{fun_clear_range},
                      /*  118: */{fun_cartesian},
                      /*  119: */{put_coordinates_2D},
                      /*  120: */{put_coordinates_1D},
                      /*  121: */{fun_interval},       
                      /*  122: */{fun_interval},
                      /*  123: */{fun_interval},
                      /*  124: */{fun_show},
                      /*  125: */{boolean_compare},
                      /*  126: */{boolean_compare},
                      /*  127: */{boolean_compare},    
                      /*  128: */{boolean_compare},
                      /*  129: */{boolean_compare},
                      /*  130: */{boolean_not},
                      /*  131: */{put_argcnt},
                      /*  132: */{type_item},               
                      /*  133: */{fun_ferror},
                      /*  134: */{put_pausa},
                      /*  135: */{put_microseconds},
                      /*  136: */{returnProgram},
                      /*  137: */{fun_transform},      
                      /*  138: */{fun_getenv},
                      /*  139: */{pop_label},
                      /*  140: */{keyboard_hit},
                      /*  141: */{keyboard_esc},
                      /*  142: */{fun_echo},
                      /*  143: */{fun_replace},
                      /*  144: */{fun_print},     
                      /*  145: */{funSubstr},
                      /*  146: */{put_offset},
                      /*  147: */{true_instruccion},
                      /*  148: */{get_sectotime},
                      /*  149: */{keyboard_ctrlc},     
                      /*  150: */{fun_isnumeric},
                      /*  151: */{fun_isnumeric},  // isstring
                      /*  152: */{fun_isarray},
                      /*  153: */{fun_length},
                      /*  154: */{kpop},
                      /*  155: */{clear_stack},
                      /*  156: */{funCountAt}, 
                      /*  157: */{funIndexAt},
                      /*  158: */{funAt},
                      /*  159: */{fun_mask},
                      /*  160: */{fun_money},
                      /*  161: */{multipass_on},
                      /*  162: */{multipass_off},
                      /*  163: */{settokenizer},
                      /*  164: */{get_seconds},
                      /*  165: */{false_instruccion},
                      /*  166: */{fun_matrix_mul},
                      /*  167: */{fun_pad},
                      /*  168: */{fun_pad},
                      /*  169: */{fun_pad},
                      /*  170: */{fun_cat},
                      /*  171: */{replicate},
                      /*  172: */{fun_setenv},
                      /*  173: */{fun_unsetenv},
                      /*  174: */{fun_dayname},
                      /*  175: */{fun_onlychar},   
                      /*  176: */{fun_compact},
                      /*  177: */{put_offset2D},
                      /*  178: */{declara_puntero},
                      /*  179: */{fun_insert},
                      /*  180: */{fun_delete},
                      /*  181: */{fun_count_lines}, 
                      /*  182: */{fun_str2utf8},
                      /*  183: */{fun_utf82str},
                      /*  184: */{fun_char_rem},
                      /*  185: */{fun_get_error},
                      /*  186: */{fun_loadmat},
                      /*  187: */{fun_savemat}, 
                      /*  188: */{fun_exec},
                      /*  189: */{put_sleep},
                      /*  190: */{fun_draw_table},
                      /*  191: */{fun_char_one},
                      /*  192: */{fun_char_pos},
                      /*  193: */{fun_printusingtoken},
                      /*  194: */{fun_keep},      
                      /*  195: */{fun_putstack},
                      /*  196: */{fun_goxy},
                      /*  197: */{fun_clock_per_sec},
                      /*  198: */{fun_exec},
                      /*  199: */{fun_clear_interval},
                      /*  200: */{fun_size_binary},
                      /*  201: */{move_stack_reg},
                      /*  202: */{funInc_one},
                      /*  203: */{funDec_one},
                      /*  204: */{put_precision},
                      /*  205: */{fun_create_array},
                      /*  206: */{tottoken}, 
                      /*  207: */{funInc_much},
                      /*  208: */{put_coordinates_2D},
                      /*  209: */{funDec_much},
                      /*  210: */{fun_create_fun_array},
                      /*  211: */{fun_reverse_string}, 
                      /*  212: */{put_coordinates_1D},
                      /*  213: */{fun_readline},
                      /*  214: */{fun_lastkey},
                      /*  215: */{put_precision},
                      /*  216: */{add_item_row},
                      /*  217: */{put_array},
                      /*  218: */{get_array},
                      /*  219: */{getrow},
                      /*  220: */{getcol},
                      /*  221: */{catrow},
                      /*  222: */{catcol},
                      /*  223: */{getpage},
                      /*  224: */{putpage},  
                      /*  225: */{size_array},
                      /*  226: */{type_item},
                      /*  227: */{gettoken},
                      /*  228: */{modtoken},
                      /*  229: */{fun_fopen},
                      /*  230: */{fun_emptyarray},   
                      /*  231: */{fun_create_fun_array},
                      /*  232: */{fun_create_fun_array},
                      /*  233: */{fun_create_fun_array},
                      /*  234: */{fun_create_fun_array},
                      /*  235: */{fun_fclose},
                      /*  236: */{fun_writeline},
                      /*  237: */{fun_readline},
                      /*  238: */{fun_seek},
                      /*  239: */{fun_eof},
                      /*  240: */{fun_create},
                      /*  241: */{put_switch}, 
                      /*  242: */{fun_writeline},
                      /*  243: */{put_sequenceSpaced},
                      /*  244: */{put_sequence},
                      /*  245: */{move_stack_reg},
                      /*  246: */{fun_reshape},       
                      /*  247: */{fun_bool},
                      /*  248: */{fun_bool},
                      /*  249: */{fun_datenow},
                      /*  250: */{fun_stat_especial},
                      /*  251: */{fun_set_especial},
                      /*  252: */{fun_array_especial},
                      /*  253: */{fun_date_time},
                      /*  254: */{fun_socket},
                      /*  255: */{NULL},  // no tocar!
                      /*  256: */{fun_jointostr},
                      /*  257: */{computo_especial},
                      /*  258: */{computo_especial},
                      /*  259: */{computo_especial},
                      /*  260: */{computo_especial},
                      /*  261: */{computo_especial},
                      /*  262: */{computo_especial},
                      /*  263: */{computo_especial},
                      /*  264: */{fun_trycatch},    
                      /*  265: */{fun_trycatch},
                      /*  266: */{fun_trycatch},
                      /*  267: */{logical_espCompare},
                      /*  268: */{logical_espCompare},
                      /*  269: */{logical_espCompare}, 
                      /*  270: */{logical_espCompare},
                      /*  271: */{logical_espCompare},
                      /*  272: */{logical_espCompare},
                      /*  273: */{clear_var},
                      /*  274: */{fun_push},   
                      /*  275: */{logical_espCompare},
                      /*  276: */{logical_espCompare},
                      /*  277: */{computo_especial},
                      /*  278: */{fun_bit_counter},
                      /*  279: */{fun_calendar},  
                      /*  280: */{fun_loadstring},
                      /*  281: */{fun_getarraystring},
                      /*  282: */{fun_getstringarray},
                      /*  283: */{fun_savestring},
                      /*  284: */{fun_linestring},
                      /*  285: */{fun_countstring},
                      /*  286: */{fun_grep},
                      /*  287: */{fun_timer},
                      /*  288: */{fun_putstr},
                      /*  289: */{dspush},
                      /*  290: */{dspop},
                      /*  291: */{fun_pop},
                      /*  292: */{fun_qpop},  
                      /*  293: */{fun_tail},
                      /*  294: */{fun_head},
                      /*  295: */{replicate_by},
                      /*  296: */{fun_writestring},
                      /*  297: */{fun_readstring},
                      /*  298: */{fun_saturate},
                      /*  299: */{fun_socketTCP_Accept},
                      /*  300: */{fun_socketTCP_Recv},
                      /*  301: */{fun_socketTCP_Send},
                      /*  302: */{fun_socketTCP_Connect},
                      /*  303: */{fun_socketUDP_Recvfrom},
                      /*  304: */{fun_socketUDP_Sendto},
                      /*  305: */{fun_opeCode},
                      /*  306: */{fun_qcreate},
                      /*  307: */{fun_qset},
                      /*  308: */{fun_qsend},
                      /*  309: */{fun_qrecv},
                      /*  310: */{fun_qremove},
                      /*  311: */{fun_assert},
                      /*  312: */{fun_doParser},
                      /*  313: */{fun_unparser},
                      /*  314: */{fun_regcompile},
                      /*  315: */{fun_regfree},
                      /*  316: */{fun_clamp},
                      /*  317: */{fun_keeparg},
                      /*  318: */{fun_timecpu},
                      /*  319: */{fun_range},
                      /*  320: */{fun_voidarray},
                      /*  321: */{fun_create_fun_array},
                      /*  322: */{funNumOneArg},
                      /*  323: */{funNumOneArg},
                      /*  324: */{funNumOneArg},
                      /*  325: */{funNumOneArg},
                      /*  326: */{funNumOneArg},
                      /*  327: */{funNumOneArg},
                      /*  328: */{fun_emptyarray},
                      /*  329: */{fun_goRow},
                      /*  330: */{fun_goCol},
                      /*  331: */{fun_monthname}, //{fun_clrmarksall},  // retoma acceso a stack unicamente
                      /*  332: */{fun_seed},
                      /*  333: */{fun_getseptok},
                      /*  334: */{fun_sqrcompute},
                      /*  335: */{fun_sqrcompute},
                      /*  336: */{fun_sqrcompute},
                      /*  337: */{fun_sqrcompute},
                      /*  338: */{fun_sqrcompute},
                      /*  339: */{fun_eqarr}, // eqarr
                      /*  340: */{fun_eqarr}, // neqarr
                      /*  341: */{fun_swap},  // analizar para cambiar el stack de trabajo
                      /*  342: */{fun_print_array},
                      /*  343: */{computo},
                      /*  344: */{computo},
                      /*  345: */{fun_get_size_terminal},
                      /*  346: */{type_item_string},  // revisa hasta que no concuerde con lo esperado
                      /*  347: */{type_item_string},  // revisa hasta que encuentre algo que espera
                      /*  348: */{fun_get_char_utf8},  // obtiene version utf8 de caracter especial  
                      /*  349: */{fun_get_notation},  // verifica si un string es notacion cientifica, y convierte.
                      /*  350: */{fun_jointostr},   // JOIN pero deja en stack
                      /*  351: */{fun_updateRow},
                      /*  352: */{fun_updateCol},
                      /*  353: */{fun_fill_box},
                      /*  354: */{fun_dump_array}, //{fun_clearall},
                      /*  355: */{fun_exist_dir},
                      /*  356: */{fun_getenv_num},
                      /*  357: */{fun_outbetween},
                      /*  358: */{fun_txt_line},
                      /*  359: */{fun_txt_circle},
                      /*  360: */{fun_txt_poligon},
                      /*  361: */{funNumOneArg},   // nneg
                      /*  362: */{funNumOneArg},    // npos
                      /*  363: */{fun_mklist},
                      /*  364: */{NULL},
                      /*  365: */{NULL},
                      /*  366: */{NULL},
                      /*  367: */{NULL},
                      /*  368: */{NULL},
                      /*  369: */{NULL},
                      /*  370: */{dstop},
                      /*  371: */{fun_format},  // retoma modo acceso a memoria (funcion)
                      /*  372: */{fun_pushall},
                      /*  373: */{get_ewarray},
                      /*  374: */{put_ewarray},
                      /*  375: */{fun_eqarr}, // eqarrto
                      /*  376: */{fun_eqarr},  // neqarrto
                      /*  377: */{jumpSpecialNT},
                      /*  378: */{jumpSpecialT},
                      /*  379: */{fun_look},
                      /*  380: */{fun_get_dims},
                      /*  381: */{fun_get_rows},
                      /*  382: */{fun_get_cols},
                      /*  383: */{fun_get_pages},
                      /*  384: */{fun_minusplus},   // minus one
                      /*  385: */{fun_minusplus},   // plus one
                      /*  386: */{fun_minusplus},   // minus two
                      /*  387: */{fun_minusplus},   // plus two
                      /*  388: */{fun_cposx},
                      /*  389: */{fun_cposy},
                      /*  390: */{fun_txt_drawPoligon},
                      /*  391: */{jumpNNeg},
                      /*  392: */{jumpNPos},
                      /*  393: */{fun_nbr},
                      /*  394: */{fun_getsomething}, // get positives
                      /*  395: */{fun_getsomething}, // get negatives
                      /*  396: */{fun_getsomething}, // get non zeros
                      /*  397: */{fun_getsomething}, // get non void
                      /*  398: */{fun_pushvar},
                      /*  399: */{fun_delcols},
                      /*  400: */{fun_delrows},
                      /*  401: */{fun_delpags},
                      /*  402: */{fun_inscols},
                      /*  403: */{fun_insrows},
                      /*  404: */{fun_inspags}
                      } ;



HB_FUNC ( XFUNCALL ){
/*  declarar punteros a funcion que devuelvan INT: que será el numero de error, o 0 si sale bien
    enumerar todo desde el 1. Los registros jamás serán colocados en el área de una funcion
    Con esto, me evito el switch 
    DEJAR ESTE LENGUAJE INDPENDIENTE. NOMBRE CLAVE: XI
    
    OBSERVACIONES:
    - Solo se permite asignar datos sobre matrices 3D, y sobre porciones de estas, pero los computos son sobre matrices
      2D, y completas.
    - Computos sobre matrices 3D, usar getpage, putpage, y computar sbre una matriz 2D.  
    - Para calcular sobre una porción de una matriz 2D, usar [],offset y get/put. Y que hueá.
*/


 // programa principal. Main Loop:

    pSTK_DS  = hb_param( 1, HB_IT_ARRAY ); // dataseg
    pSTK_PRG = hb_param( 2, HB_IT_ARRAY ); // program
    pSTK_DBG = hb_param( 3, HB_IT_ARRAY ); // lineas del programa
    
 //   long uiArrayLenDS = ( long ) hb_arrayLen( pSTK_DS );
    long uiArrayLenPRG = ( long ) hb_arrayLen( pSTK_PRG );    
    
    CP=0;
    CADDR=0;
    swErr=0;
    SW_PRECISION=0;   // por defecto, no hay precisión
    int sw=1;      // ciclo principal
    CTE_NAN = asin(90);
    
//    char *TOKENIZER;
    TOKENIZER = (char*)calloc(2,1);
    TOKENIZER[0]=',';
    TOKENIZER[1]='\0';

    //PHB_ITEM pRET = hb_itemArrayNew( 7 );   // respuesta: 5 elementos. Si aumento dimensiones de arrays, deben ser 7
    pRET = hb_itemArrayNew( 7 );   // respuesta: 5 elementos. Si aumento dimensiones de arrays, deben ser 7
//    PHB_ITEM pSTK_REG = hb_itemArrayNew( nNumVar );   // stack de registros ax=1, bx=2,... zx=26

   //verificacion de total de argumentos pasados por pSTK_DS
    LENDS = ( unsigned int ) hb_arrayLen( pSTK_DS );

 // Carga el programa en un array int: ¿cambiará la velocidad?
 // ATENCION!!!
 // --- Los datos constantes de otro tipo distinto a int, son mal transformados: no cambiar parámetro pSTK_PRG
 //     en esos casos, solo en los casos donde SE SABE que se obtendrá un ENTERO INDICE.
//    int STK_DBG[ uiArrayLenPRG + 1 ];

   // defino a -1 el vector que permite controlar
    int i;
    for(i=0;i<TOPE_REGEX;i++)
       validREGEX[i]=0;
 
    
   // int STK_PRG[ uiArrayLenPRG + 1 ];
    STK_PRG = (int *)realloc(STK_PRG, (uiArrayLenPRG + 1)*sizeof(int));
     
    for(CP=1; CP<=uiArrayLenPRG; CP++){
       PHB_ITEM pCP = hb_itemArrayGet( pSTK_PRG, CP);
       STK_PRG[ CP ] = (int) hb_itemGetNInt( pCP );
       hb_itemRelease(pCP);
    }
    
    CP=1;
    // busco metadata: numero de variables declaradas, y otras cosas que necesite
    unsigned int nNumVar=STK_PRG[ CP ];
    
  //  PHB_ITEM pSTK_vREG[1];
  //  pSTK_vREG[0] = hb_itemArrayNew( nNumVar );   // stack de registros
    
///    PHB_ITEM pSTK_REG = hb_itemArrayNew( nNumVar );   // stack de registrosNULL;
    pSTK_REG = hb_itemArrayNew( nNumVar );   // stack de registrosNULL;
    
    // busco tamaño del stack de trabajo:
    nSizeStack=STK_PRG[ ++CP ]; 
//    PHB_ITEM pSTK_ADDR = hb_itemArrayNew( nSizeStack );   // stack de direcciones
    pSTK_ADDR = hb_itemArrayNew( nSizeStack );   // stack de direcciones

    // DATO RESERVADO PARA FUTUROS USOS. Contemplar otras posiciones.
    iLOCAL_INI = STK_PRG[ ++CP ];
    
    // Habilita CTRL+C
    short SW_CTRL_C = STK_PRG[ ++CP ];
    
   // con esto, guardaré los datos que se deseen guardar antes de un salto a otra función, y serán recuperados
   // con el regreso. Se usa con DSPUSH y DSPOP (Data Stack). Implementado en 289 y 290
   // PHB_ITEM pSTK_OBJ[nSizeStack*2]; // original: hecho global
    nINDEXOBJ=-1;
//    printf("\nSIZE pSTK_OBJ = %ld\n",sizeof(pSTK_OBJ));
   // for(nINDEXOBJ=0;nINDEXOBJ<nSizeStack;nINDEXOBJ++) pSTK_OBJ[nINDEXOBJ]=hb_itemNew( NULL );
   // nINDEXOBJ=-1;
    
//    PHB_ITEM SWITCH_VAR=hb_itemArrayNew( 2 );  // dato de switch: 1=number, 2=string
    SWITCH_VAR=hb_itemArrayNew( 2 );  // dato de switch: 1=number, 2=string
    hb_arraySetND( SWITCH_VAR, 1, (double) 0 );
    hb_arraySetC( SWITCH_VAR, 2, (const char*) "" );

    // busca constantes y variables; las guarda en STK_REG:

    while(CP<=uiArrayLenPRG){
       if(STK_PRG[ ++CP ]==0){ //(-2)){   // es una constante
          PHB_ITEM pCP = hb_itemArrayGet( pSTK_PRG, ++CP);   // indice
          int index = (int) hb_itemGetNInt( pCP );
          hb_itemRelease(pCP);
          PHB_ITEM pCP2 = hb_itemArrayGet( pSTK_PRG, ++CP);   // dato:
          if( HB_IS_INTEGER( pCP2 ) ){
             hb_arraySetNInt( pSTK_REG, index, hb_itemGetNInt( pCP2 ) );
          }else if( HB_IS_LONG( pCP2 ) ){
             hb_arraySetNL( pSTK_REG, index, hb_itemGetNL( pCP2 ) );
          }else if( HB_IS_NUMERIC( pCP2 ) ){
             hb_arraySetND( pSTK_REG, index, hb_itemGetND( pCP2 ) );
          }else if( HB_IS_STRING( pCP2 ) ){
             hb_arraySetC( pSTK_REG, index, hb_itemGetCPtr( pCP2 ) );
          }
          hb_itemRelease(pCP2);
       }else if(STK_PRG[ CP ] == 255){
          ++CP;  // para no contabilizarlo más.
          break;
       }
    }
    
   // INICIO DE EJECUCION VIENE INMEDIATAMENTE LUEGO DE CONSTANTES.
    if (STK_PRG[ CP ]!=255){
       sw=put_error((PHB_ITEM) pRET, "-MAIN- MUST BE FIRST LABEL",120);
    }


    //int nPCP=0; // dejarlo global
    nPCP = 0;

    if(SW_CTRL_C){
       // para empezar, solo trabajará con valores atómicos, no arrays
       for ( ;; ) {    // ciclo principal

         /* CTRL-C.  solo para debug */
          if(hb_inkey(0,0,128)==3){
             sw=put_error((PHB_ITEM) pRET, "BREAK EXECUTION BY USER (CTRL-C)",200);
             break;
          }

          nPCP = STK_PRG[ ++CP ];
          sw=(int)(*funCall[nPCP].p)();
        
          // atrapar error con try catch.
          if(!sw) {
             if( cabezaTry )
                sw=(int) read_try();
             else
                break;
          }
       } // while
    }else{
       // para empezar, solo trabajará con valores atómicos, no arrays
       for ( ;; ) {    // ciclo principal

          nPCP = STK_PRG[ ++CP ];
          ///nPCPNext = STK_PRG[ CP + 1];
          sw=(int)(*funCall[nPCP].p)();
        
          // atrapar error con try catch.
          if(!sw) {
             if( cabezaTry )
                sw=(int) read_try();
             else
                break;
          }
       } // while
    }
    
    if ( swErr ){   // defino array resultado con error:
       PHB_ITEM pSource = hb_itemArrayGet( pSTK_DBG, CP);
       int LineaError = hb_itemGetNI( pSource );
       hb_itemRelease(pSource);

       hb_arraySetNInt( pRET, 1, (int)  LineaError );
       hb_arraySetNInt( pRET, 3, (HB_MAXINT)  0  );
       hb_arraySetNInt( pRET, 4, (HB_MAXINT)  0  );
       hb_arraySetNInt( pRET, 5, (HB_MAXINT)  0  );
       hb_arraySetNInt( pRET, 6, (HB_MAXINT)  0  );
       //hb_arraySetNInt( pRET, 7, (HB_MAXINT)  0  );
    }
    hb_itemRelease(pSTK_ADDR);  // borra stack de trabajo
    hb_itemRelease(pSTK_REG);   // borra stack de registros variables y constantes
    
    //hb_itemRelease(pSTK_OBJ);   // borra stack de parametros locales.

    //   int i;
    //   for(i=0;i<nSizeStack;i++) 
    //      if(pSTK_OBJ[i]) 
    //          hb_itemRelease(pSTK_OBJ[i]);
    int ndxReg;
    for(ndxReg=0; ndxReg<TOPE_REGEX; ndxReg++){
       if(validREGEX[ndxReg]){
      //    printf("\nLIBERADO %d\n",ndxReg);
          regfree(&aREGEX[ndxReg]);
       } 
    }
    
    free(TOKENIZER);
    if( SWITCH_VAR ) hb_itemRelease( SWITCH_VAR );
    
    while(cabeza!=NULL){
       jumpLabel *nodo = cabeza;
       cabeza=nodo->siguiente;
       free(nodo);
    }
    while(cabezaTry!=NULL){
       tryLabel *nodo = cabezaTry;
       cabezaTry=nodo->siguiente;
       free(nodo);
    }
    i=0;
    while(i<=nINDEXOBJ){
       if(pSTK_OBJ[i])
           hb_itemRelease(pSTK_OBJ[i]);
       ++i;
    }
    free(STK_PRG);  // por global STK_PRG realloc.
    //printf("\033[?25h");
    hb_inkeySetLast( 0 );
    hb_itemReturnRelease( pRET );           // define retorno de puntero pRET

}


#pragma ENDDUMP

