/*

  HOPPER
  
  Es un lenguaje de programación prototipo, que presenta una propuesta de programación
  basada en la intuición del lenguaje natural.
  Posee un analizador léxico y sintáctico. No realiza análisis semántico, dado que no
  cuenta con declaración de tipos, y sus registros variables pueden cambiar de tipo en
  el transcurso de la ejecucion del programa.
  Los tipos se analizan dentro de la ejecucón. Es ahí donde existe un analizador semántico,
  en la ejecución.
  
  Esta idea está inspirada en las ideas de Grace Murray Hopper, más conocida como "Amazing
  Grace" (la sorprendente Grace): ella postuló y creó compiladores que permitiesen una
  comunicación más natural con el computador; Hopper, el lenguaje, va un poco más allá,
  centrándose en la intuición de la comunicación natural.
*/

REQUEST HB_LANG_ES
HB_LANGSELECT( "ES" )
REQUEST HB_CODEPAGE_UTF8
hb_cdpSelect( "UTF8" )

function main()

public _CR:=HB_OSNewline()           //chr(13)+chr(10)
PUBLIC _arr_par:=array(0)
//public _sw_source:=.F.
//public _file
PUBLIC NULL:=""

//PUBLIC sourceFile:=NULL
PUBLIC file

// Chequea parametros y los asigna a un array (esto queda para la ejecucion)

numParam:=PCOUNT()
if numParam==0
    _header()
    _modo_de_uso()
    release all
    quit
end

msgError:=NULL

file:=hb_utf8tostr(hb_pValue(1))    // el nombre del archivo
if !file(file)
   msgError:="file not found or bad filename: "+GenMsg(file)
   _error(msgError,0)
end

_arr_par:={}
aadd(_arr_par,file)

_q:=rand()

iParam:=2
swDebug:=.F.
if numParam>=iParam
  // _arr_par:=array(numParam-(iParam-1))
  //  rellenar array de parametros para distribuir despues de la carga de variables
   nParametro:=1
   WHILE iParam<=numParam
      if hb_pValue(iParam)=="-d"  // salida de "return" se despliega en pantalla
         swDebug:=.T.
      else
         //_arr_par[nParametro]:=hb_pValue(iParam)
         //++nParametro
         vParametro:=valtype(hb_pValue(iParam))
         if vParametro=="C"
            aadd(_arr_par,hb_pValue(iParam))
         elseif vParametro=="N"
            aadd(_arr_par,val(hb_pValue(iParam)))
         end
      end
      ++iParam
   END
//else
//   _arr_par:={}
end

set date french
set century on
////set decimals to 16

SETCANCEL(.T.)

stackPrg:={}
numLine:={}
if !GetBinary(file,@stackPrg,@numLine)
   _error("Binary has not been loaded!",0)
end

ret := XFUNCALL(_arr_par, stackPrg, numLine)

  if ret[2]==NIL
     msgError:="VM:PROGRAM RETURN NULL -- BAD KID, VERY BAD!"
     _error(msgError,0)
  
  elseif len(ret[2])>2
     _error("vm : "+lower(ret[2]+"(COD:"+hb_ntos(ret[7])+")"),ret[1])
  
  else   // devolvió un valor
     if swDebug
        if valtype(ret[1])=="A"
           print_matrix( ret[1] )
        else
           if valtype(ret[1])=="N"
              fwrite(1,hb_ntos(ret[1])+_CR)
           elseif valtype(ret[1])=="L"
              fwrite(1,iif(ret[1],"1","0")+_CR)
           else
              fwrite(1,ret[1]+_CR)
           end
        end
     end
  end
  
  release ret[1]
  release ret[2]
  release ret[3]
  release ret[4]
  release ret[5]
  release ret[6]
  release ret[7]
  release ret

release stackPrg  
release _arr_par

return nil

#define LBYTES 2
#define UBYTES 1

function GetBinary(archivoExec,stackPrg,numLine)
LOCAL fd,c,strShell,contb:=0
LOCAL _cnt_byte:=0,i,long:=0,cStr,nRegs,nLong,nResv,cntR:=0

fd:=fopen(archivoExec,0)
if ferror()!=0
   fwrite(1,"Open program "+GenMsg(archivoExec)+" error: #"+hb_ntos(ferror())+_CR)
   return .F.
else

   // lee bang line, si es que la tiene, para ejecución a la shell
   c:=" "
   fread(fd,@c,UBYTES)
   nSavePos := fseek( fd, 0, 1 )
   if c=="#"
      fread(fd,@c,UBYTES)
      nSavePos := fseek( fd, 0, 1 )
      if c=="!"
        strShell:="#!"
        
        while c!=chr(10)   // lee todo #!/usr/bin/bhopper
           fread(fd,@c,UBYTES)
           nSavePos := fseek( fd, 0, 1 )
           if c!=chr(10)
              strShell+=c
           end
        end
        if strShell!="#!/usr/bin/bhopper3"
            fwrite(1,"* "+GenMsg(archivoExec)+" is not a valid binary Hopper file! ("+strShell+")"+_CR)
            return .F.
        end
      else  // error!
         fwrite(1,"* "+GenMsg(archivoExec)+" is not a valid binary Hopper file!"+_CR)
         return .F.
      end
   else
      fseek(fd,nSavePos-1,0)
   end

   c:="    "   
   // lee resto de programa
   fread(fd,@c,LBYTES)
   if c!="B"
      fclose(fd)
      fwrite(1,"Binary "+GenMsg(archivoExec)+" is not a Hopper valid"+_CR)
      return .F.
   else
      fread(fd,@c,LBYTES)
      if c!="H"
         fclose(fd)
         fwrite(1,"Binary "+GenMsg(archivoExec)+" is not a Hopper valid"+_CR)
         return .F.
      end
   end
   
   // lee longitud del programa
   c:="    "
   fread(fd,@c,LBYTES)
   long:=bin2I(c)
   stackPrg:=array(long)
   numLine:=array(long)
   // leo encabezado:
   fread(fd,@c,LBYTES); nRegs:=bin2I(c)  // numero de registros y cotes
   stackPrg[1]:=nRegs
   fread(fd,@c,LBYTES); nLong:=bin2I(c)  // long stack
   stackPrg[2]:=nLong
   fread(fd,@c,LBYTES); nResv:=bin2I(c)  // reservado
   stackPrg[3]:=nResv
   fread(fd,@c,LBYTES); nResv:=bin2I(c)  // sw ctrl+c
   stackPrg[4]:=nResv
   // lee stack de registros y constantes:
//   ? 1," : ",stackPrg[1]
//   ? 2," : ",stackPrg[2]
//   ? 3," : ",stackPrg[3]
   i:=5
   while !hb_feof(fd)
      fread(fd,@c,LBYTES); stackPrg[i]:=bin2I(c)   // leo '0'?
    //  ? i," COD: ",stackPrg[i]
      if stackPrg[i]!=255
         fread(fd,@c,LBYTES); stackPrg[++i]:=bin2I(c)   // leo pos
    //     ? i," POS: ",stackPrg[i]
         ++i          // avanzo a tipo de dato, y dato
         fread(fd,@c,LBYTES)   // leo tipo de dato
         if bin2I(c)==0   // es un numero
            c:="    "
            cStr:=""
            while c!=chr(255)
               fread(fd,@c,LBYTES)
               if c!=chr(255)
                  cStr+=chr(bin2I(c))
               end
            end
            stackPrg[i]:=val(cStr)
    //        ? i," NUM: ",stackPrg[i]

         elseif bin2I(c)==2   // debe ser string?
            c:="    "
            cStr:=""
            while c!=chr(255)
               fread(fd,@c,LBYTES)
               if c!=chr(255)
                  cStr+=chr(bin2I(c))
               end
            end
            stackPrg[i]:=cStr//hb_UTF8tostr(cStr)
    //        ? i," STR: ",stackPrg[i]
         else
            fclose(fd)
            fwrite(1,"Binary "+GenMsg(archivoExec)+": register stack bad formed"+_CR)
            return .F.
         end
      else
         exit
      end
      ++i
   end
   cntR:=i+1
   // lee resto de programa:
   for i:=cntR to long
      fread(fd,@c,LBYTES); stackPrg[i]:=bin2I(c)
  //    ? i," PRG: ",stackPrg[i]
   end
   // lee numeros de línea
   for i:=1 to long
      fread(fd,@c,LBYTES)
      numLine[i]:=bin2I(c)
   end
end
fclose(fd)
return .T.

function GenMsg(msg)
LOCAL pLeft:="‘",pRight:="’" // no tienen un valor ascii definido, sino, un conjunto. OJO!
return pLeft+msg+pRight


Procedure _Error(bajada,linea)

//  fwrite(1,file+" : line ‘"+alltrim(str(linea))+"’ : "+bajada+_CR)
  //printmsg(_CR+file+" : line "+GenMsg(alltrim(str(linea)))+" : "+chr(27)+"[91m"+bajada+chr(27)+"[0m"+_CR+_CR)
  printmsg(_CR+file+":line "+GenMsg(alltrim(str(linea)))+" => "+chr(27)+"[38;5;202merror"+chr(27)+"[0m: "+bajada+_CR)

  _vnum:= linea //val(_numbusca) 
  if valtype(_vnum)!="N"
     _vnum:=val(_vnum)
     linea:=_vnum
  end
  if linea>0
     ActualDir:=dirname()+"/log" 
     ActualDir+="/"+substr(file,rat("/",file)+1,len(file))+".log"
     printmsg("In binary file: "+file+_CR)
     printmsg("Place of error-->[ "+ActualDir+" ]:")
     if file(ActualDir)
         // cargo programa fuente, si existe
       //  if file(_fuente) 
            _v:=Memoread(ActualDir)
            printmsg(_CR+"          :")
            for _j:=_vnum-4 to _vnum+4
               _linea:=rtrim(Memoline(_v,2048,_j))
               /*if "//" $ _linea  //AT("//",_linea)>0 
                  _linea:=substr(_linea,1,at("//",_linea)-1)
               end
               if "/*" $ _linea //AT("/*",_linea)>0 
                  _linea:=substr(_linea,1,at("/*",_linea)-1)
               end*/
               if _j==_vnum
                  //setcolor("15/2")
                  if len(_linea)>MAXCOL()-15
                     _linea:=substr(_linea,1,MAXCOL()-15)+"..."
                  end
                  printmsg(_CR+hb_UTF8tostr(strzero(linea,5)+" >> "+chr(27)+"[38;5;202m"+_linea+chr(27)+"[0m"))
                  //setcolor("")
               else
                  printmsg(_CR+hb_UTF8tostr("         "+_linea ))
               end
            end
            printmsg(_CR+"          :"+_CR)
            //break
            //printmsg("Copying [ "+fileTemp+" ] to LOG directory for your visualization"+_CR)
        // end
     else
        printmsg(_CR+"Log file "+Genmsg(ActualDir)+" not exist or missing LOG directory"+_CR)
     end 
  end

  RELEASE ALL
  
  QUIT

return

procedure _header()
LOCAL msgError
   msgError:="  "+GenMsg(chr(27)+"[1m"+"AMAZING HOPPER!"+chr(27)+"[0m")+" VM v0.1+.2020"+_CR+ ;
             "  Inspirado en las ideas de Grace Murray Hopper."+_CR+ ;
             "  Compiladores: Harbour 3.0.0 (Rev. 16951) bajo gcc (Ubuntu 9.3.0-17ubuntu1~20.04)"+_CR+;
             "  Mr.Dalien, 2020."+_CR+_CR
/*   msgError:="  AMAZING HOPPER! VM v0.1+.2020"+_CR+ ;
             "  Inspirado en las ideas de Grace Murray Hopper."+_CR+ ;
             "  Compiladores: Harbour 3.0.0 (Rev. 16951) bajo gcc (Ubuntu 9.3.0-17ubuntu1~20.04)"+_CR+;
             "  Mr.Dalien, 2020."+_CR+_CR*/
   fwrite(1,msgError)

return

procedure _modo_de_uso()
LOCAL msgError
    msgError:="  Modo de Uso:"+_CR+_CR+ ;
              "  bhopper <archivo> [parametros] [parametros de usuario]"+_CR+ ;
              "  o bien,"+_CR+;
              "  ./<archivo> [parametros] [parametros de usuario]"+_CR+;
              "--------------------------------------------------------------------------------------"+_CR+;
              "  donde:"+_CR+ ;
              "     <archivo>     Es el archivo binario a ejecutar."+_CR+ ;
              "     [parametros]  Parametros, si se requieren:"+_CR+ ;
              "                   -d        imprime el argumento de 'return' en el 'stdout'."+_CR+_CR+;
              "  Para mayor información, consulte: "+GenMsg(chr(27)+"[1m"+"man hbasic"+chr(27)+"[0m")+_CR+_CR+;
              "  Bugs, dudas y aportes: daniel.stuardo@gmail.com"+_CR+_CR
    fwrite(1,msgError)
return



/** codigo C **/
#pragma BEGINDUMP
#include "hbapi.h"
#include "hbstack.h"
#include "hbapiitm.h"
#include "hbapierr.h"
#include "hbapigt.h"
#include "hbset.h"
#include "hbdate.h"
#include <sys/ioctl.h>

//  #define _MAC64_
//  #define _LINUX32_
#define _LINUX64_


#ifdef _LINUX32_
  #include "/home/dalien/harbour-3.0.0/contrib/hbct/ct.h"
  #include "/home/dalien/harbour-3.0.0/contrib/hbct/ctmath.h"
#endif

#ifdef _MAC64_ 
  #include "ct.h"
  #include "ctmath.h"
#endif

#ifdef _LINUX64_ 

/* para pc universidad*/
//  #include "/home/xu/Lang/ct.h"
//  #include "/home/xu/Lang/ctmath.h" 
/* mi pc mac*/
  #include "/home/dalien/Lang/harbour-3.0.0/contrib/hbct/ct.h"
  #include "/home/dalien/Lang/harbour-3.0.0/contrib/hbct/ctmath.h" 

  //#include "ct.h"
  //#include "ctmath.h"
#endif

#ifdef _MAC64_
   #include <sys/time.h>
#endif
#ifdef _LINUX64_
   #include <time.h>
#endif
#ifdef _LINUX32_
   #include <time.h>
#endif

#define _GNU_SOURCE

#include "hbmather.h"
//#include "hbdate.h"
//#include "hbset.h"
#include "hbmath.h"
#include <ctype.h>
#include <extend.h>
#include <math.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <signal.h>
#include <float.h>
#include <limits.h>

/*HB_FUNC( GETFAMILIA ){
   int codfun  = hb_parni( 1 );
   long newOrden = 0;
   long familia=0;
   if( codfun >= 0 && codfun <=5 )       familia=1;
   else if( codfun >= 6 && codfun <=22 ) familia=2;
   else if( codfun >= 23 && codfun <=59 )  familia=3;
   else if( codfun >= 60 && codfun <=89 )  familia=4;
   else if( codfun >= 90 && codfun <=119 ) familia=5;
   else if( codfun >= 120 && codfun <=159 ) familia=6;
   else if( codfun >= 160 && codfun <=189 ) familia=7;
   else if( codfun >= 190 && codfun <=219 ) familia=8;
   else if( codfun >= 220 && codfun <=259 ) familia=9;
   else familia=10;
 //  printf(">>> ORDEN = %d",codfun);
   newOrden |= codfun;
   newOrden = newOrden << 4;
   newOrden |= familia;
 //  printf(">>> NEW ORDEN = %ld\n",newOrden);
   //hb_retni( newOrden );
   
   hb_retnl( codfun );
}*/

/*HB_FUNC( BUSCACOMPLETA )
{
   unsigned int pKey  = hb_parni( 1 );
   PHB_ITEM pSTRING = hb_param( 2, HB_IT_STRING );
   unsigned int pLen = hb_parni( 3 );  //len busca
   
   const char * t = hb_itemGetCPtr( pSTRING );

   if ( isalpha(*(t+pKey-2)) || isdigit(*(t+pKey-2)) || *(t+pKey-2)=='_' ||
        isalpha(*(t+pKey+pLen-1)) || isdigit(*(t+pKey+pLen-1)) || *(t+pKey+pLen-1)=='_') 
      hb_retni( 0 );
   else
      hb_retni( pKey );
   hb_itemClear( pSTRING );
} */
HB_FUNC( PRINTMSG )
{
   PHB_ITEM pSTRING  = hb_param( 1, HB_IT_STRING );
   const char * expr = hb_itemGetCPtr( pSTRING );
   printf("%s",expr);
}

HB_FUNC( LLENAPILA )
{
   PHB_ITEM pSTRING  = hb_param( 1, HB_IT_STRING );
   const char * expr = hb_itemGetCPtr( pSTRING );
   
   PHB_ITEM pCWM = hb_itemArrayNew( 100 );
   unsigned int cta_par=0,cont=0;
   char c,cc;
   int swError=0;
   
   while(*expr){
      c = *expr;
   ///   printf("%c",c);
      ++expr;
      if (c=='('){
         ++cta_par;
      }else if(c==')'){
         --cta_par;
      }
  //    if(c=='?') continue;
      if(c=='&' || c=='|' || c=='!'){
         const char * r = expr;
         cc = *r;
         ++r;
         if(cc=='&' || cc=='|' || cc=='='){
            char * s = (char *)calloc(3,1);
            s[0] = c; s[1] = cc; s[2]='\0';
            const char * t = s;
           // printf("\nSIMBOLO = %s\n",t);
            hb_arraySetC(pCWM,++cont,(const char *) t) ;
            free(s);
            expr = r;  // actualizo expr
         }else if(c=='!' && (cc==' '||cc=='(')){
            hb_arraySetC(pCWM,++cont,(const char *) "not") ;

         }else{
            hb_retni( 1 );
            swError=1;
            break;
         }
//      }else if(c=='$'){
      }else if(c=='$'){   // puede ser $$
         char * s = (char *)calloc(3,1);
         if( *expr == '$' ){  // es $$
            s[0] = c; s[1]='$'; s[2]='\0';
            ++expr;
         }else{
            s[0] = c; s[2]='\0';
         }
         const char * t = s;
         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);            

      }else if(c=='+'||c=='-'||c=='*'||c=='/'||c=='\\'||c=='%'||
               c==')'||c=='('||c=='^'||c=='$'){
         char * s = (char *)calloc(2,1);
         s[0] = c; s[1]='\0';
         const char * t = s;
         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);
      }else if(c=='='||c=='<'||c=='>'||c=='!'){
         const char * r = expr;
         cc = *r;
         ++r;
         if(cc=='='||cc=='<'||cc=='>'||cc=='!'){
            if(c=='<'){
               if (cc=='>'||cc=='='){
                  char * s = (char *)calloc(3,1);
                  s[0] = c; s[1] = cc; s[2]='\0';
                  const char * t = s;
                  hb_arraySetC(pCWM,++cont,(const char *) t) ;
                  free(s);
                  expr = r;  // actualizo expr
               }else{
                  hb_retni( 1 );
                  swError=1;
                  break;
               }
            }else if(c=='='){
               if(cc=='='){
                  char * s = (char *)calloc(3,1);
                  s[0] = c; s[1] = cc; s[2]='\0';
                  const char * t = s;
                  hb_arraySetC(pCWM,++cont,(const char *) t) ;
                  free(s);
                  expr = r;  // actualizo expr
               }else{
                  hb_retni( 1 );
                  swError=1;
                  break;
               }               
            }else if(c=='>'){
               if(cc=='='){
                  char * s = (char *)calloc(3,1);
                  s[0] = c; s[1] = cc; s[2]='\0';
                  const char * t = s;
                  hb_arraySetC(pCWM,++cont,(const char *) t) ;
                  free(s);
                  expr = r;  // actualizo expr
               }else{
                  hb_retni( 1 );
                  swError=1;
                  break;
               }
            }else{
               hb_retni( 1 );
               swError=1;
               break;
            }
         }else{
            char * s = (char *)calloc(2,1);
            s[0] = c; s[1]='\0';
            const char * t = s;
            hb_arraySetC(pCWM,++cont,(const char *) t) ;
            free(s);
         }
      }else if (c=='['){   // brakets de rangos para array
         // rescatar anterior y convertirlo:
         PHB_ITEM pVar = hb_itemArrayGet( pCWM, cont);
         long cLen = hb_itemGetCLen(pVar);
         const char * varget = hb_itemGetCPtr(pVar);
         hb_itemRelease(pVar);
         char * cGet = (char *)calloc(100,1);
         //char * fget="get(", * fpar=")";
         memcpy((char *)cGet, "get(" ,4);
         memcpy((char *)cGet+4, varget, cLen);
         memset((char *)cGet+4+cLen,')', 1);
       //  hb_arraySetC(pCWM,++cont,(const char *) cGet) ;
       //  free(cGet);
       //  cont-=2;
         int swCont=0;
         if(cont>1){
            --cont;
            swCont=1;
         }
            
         char * s = (char *)calloc(150,1);
         int i=1;
         s[0]=c;
         while (*expr && *expr!=']'){
            s[i++] = *expr;
            ++expr;
         }
         s[i++]=']'; s[i]=',';

         memcpy(s + strlen(s), cGet, cLen + 5 );
         const char * t=s;
         if(!swCont){
            hb_arraySetC(pCWM,cont,(const char *) t) ;
         }else{
            hb_arraySetC(pCWM,++cont,(const char *) t) ;
         }
         free(s);
         free(cGet);
         ++expr;
         //++cont;
         // el anterior debio ser la variable del array: swap y convertir v=>get(v):
      }else if(c==34){   // es un string
         char * s = (char *)calloc(2048,1);
         int i=1;
         s[0]=c;
         while (*expr!='\0'){
            s[i++] = *expr;
            if (*expr==34) {++expr;break;}
            ++expr;
         }
         s[i]='\0';
         const char * t=s;
         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);
      }else if (isdigit(c) || isalpha(c) || c=='-' || c=='@' || c=='_'){
         char * s = (char *)calloc(1024,1);
         int i=1;
         s[0]=c;
         while (*expr && (isdigit(*expr) || isalpha(*expr) || *expr=='.' || *expr=='@' || *expr=='_')){
            s[i++] = *expr;
            ++expr;
         }
         s[i]='\0';
         const char * t=s;
         hb_arraySetC(pCWM,++cont,(const char *) t) ;
         free(s);
      }else{
         if(c!=' '&&c!=','){
            hb_retni( 2 );
            swError=2;
            break;
         }
      }
   } 
 //  printf("\nCTAPAR = %d",cta_par);
   if(swError)
       hb_itemRelease(pCWM);
       
   else if(cta_par!=0 && !swError){
      hb_retni( 3 );
      
   }else{
     /* char * s = (char *)calloc(2,1);
      s[0] = ')'; s[1]='\0';
      const char * t = s;
      hb_arraySetC(pCWM,++cont,(const char *) t) ;
      free(s);
      */
      hb_arraySize( pCWM, cont );
      
      hb_itemReturnRelease( pCWM );
   }
}

long Factor_Precision[16] = {1,10,100,1000,10000,100000,1e+06,1e+07,1e+08,1e+09,1e+10,
                             1e+11,1e+12,1e+13,1e+14,1e+15}; //,1e+16};

double xu_funprecision(double dNum, int Dec){

/*  char *buf;
  double m;
  
  buf=(char *)calloc(1024,1);
  sprintf(buf,"%.*lf",Dec, dNum);
//
  sscanf(buf, "%lf", &m);

  free(buf);
  return(m); */
  return round(dNum * Factor_Precision[Dec])/Factor_Precision[Dec];
}

HB_FUNC( IS_NOALLNUM )
{
   int iPCount = hb_pcount();

   HB_BOOL bGood = HB_TRUE;
   if( iPCount > 0 )
   {
      PHB_ITEM pVAR = hb_param( 1, HB_IT_NUMERIC );
      int nVAR = hb_itemGetNI( pVAR );
      int iParam;
      for( iParam = 2; iParam <= iPCount; iParam++ )
      {
         PHB_ITEM pCom = hb_param( iParam, HB_IT_NUMERIC );
         //int nNum = hb_itemGetNI( pCom );
         if( nVAR == hb_itemGetNI( pCom ) )
         {
            bGood = HB_FALSE;
            break;
         }
      }
   }
   hb_retl( bGood );
}


HB_FUNC( IS_NOALL )
{
   int iPCount = hb_pcount();

   HB_BOOL bGood = HB_TRUE;
   if( iPCount > 0 )
   {
      PHB_ITEM pVAR = hb_param( 1, HB_IT_STRING );
      const char * cVAR = hb_itemGetCPtr( pVAR );
      int iParam;
      for( iParam = 2; iParam <= iPCount; iParam++ )
      {
         PHB_ITEM pCom = hb_param( iParam, HB_IT_STRING );
         const char * cCom = hb_itemGetCPtr( pCom );
         if( strcmp( cVAR, cCom ) == 0 )
         {
            bGood = HB_FALSE;
            break;
         }
      }
   }
   hb_retl( bGood );
}

//isany(vtip,"NN","CC")
HB_FUNC( IS_ANY )
{
   int iPCount = hb_pcount();

   HB_BOOL bGood = HB_FALSE;
   if( iPCount > 0 )
   {
      PHB_ITEM pVAR = hb_param( 1, HB_IT_STRING );
      const char * cVAR = hb_itemGetCPtr( pVAR );
      int iParam;
      for( iParam = 2; iParam <= iPCount; iParam++ )
      {
         PHB_ITEM pCom = hb_param( iParam, HB_IT_STRING );
         const char * cCom = hb_itemGetCPtr( pCom );
         if( strcmp( cVAR, cCom ) == 0 )
         {
            bGood = HB_TRUE;
            break;
         }
      }
   }
   hb_retl( bGood );
}

int xu_funIsnotation(const char * AX){
  //int DX;
  //short int SW_E=0,SW_P=0,SW_S=0;
  int retorne=1;
  int swE=0;
  int swP=0;
  int swS=0;
  int swD=0;
  
  const char *t=AX;
  if(isdigit(*t) || *t=='-' || *t=='+'){
     ++t;
     while(*t!='\0'){
        if(isdigit(*t)) {
           ++t;
        }else if(*t=='.'){
           if(swP){
              //printf("hay mas de un punto = %c\n",*t);
              retorne=0; break;
           } else {
              swP=1;
           }
           ++t;
        }else if(isalpha(*t)){
           if(*t!='e' && *t!='E'){ 
               //printf("debo encontrar un E aqui = %c\n",*t);
               retorne=0;
               break;
           }else{
               if(swE) {
                  //printf("se repite E = %c\n",*t);
                  retorne=0; break;
               } else { 
                  swE=1; 
               }
               ++t;
               if(*t!='\0'){
                   if(!isdigit(*t) && (*t!='-' && *t!='+')) {
                      //printf("despues de E debe ser un digito o + o - = %c\n",*t);
                      retorne=0;
                      break;
                   }else if(*t=='-' || *t=='+'){
                      if(swS){ 
                         //printf("encontre mas de un signo luego de E = %c\n",*t);
                         retorne=0;break;
                      } else {
                         swS=1;
                         ++t;
                         if(isdigit(*t)){
                            //printf("Activa swD\n");
                            swD=1;
                         }else{
                            //printf("no encontre un digito luego de E+- = %c\n",*t);
                            retorne=0;break;
                         }
                      }
                   }else if(isdigit(*t)){
                      //printf("Activa swD\n");
                      swD=1;
                   }else{
                      //printf("Algo raro detecta = %c\n",*t);
                      retorne=0;break;
                   }
                   ++t;
               }else{
                   //printf("encontre fin de cadena antes de completar E\n");
                   retorne=0;break;
               }
           }
        }else{
           //printf("encontre algo distinto a digito, E y . = %c\n",*t);
           retorne=0;
           break;
        }
     }
  }else{
     //printf("no encontre signo ni digito al empezar = %c\n",*t);
     retorne=0;
  }
  if( retorne && !swD){
//     if(!swE)
     //printf("retorne = 1 pero !swD\n");
     retorne=0;
  }
/*  DX=*AX;
  if (DX=='-') ++AX; 
  
  while( (DX=*AX)!='\0'){
    if(toupper(DX)=='E'){
       if (!SW_E) SW_E=1;
       else {retorne=0;break;}
    }else if (DX=='.'){
       if (!SW_P) SW_P=1;
       else {retorne=0;break;}
    }else if (DX=='+' || DX=='-') {
       if (!SW_S) SW_S=1;
       else {retorne=0;break;}
    }else if (!isdigit(DX)) {retorne=0;break;}
    ++AX;
  }
  if (!SW_E ) retorne=0;*/
  return retorne;
}

/*HB_FUNC( ISNOTATION )
{
   hb_retni( xu_funIsnotation( hb_parc( 1 ) ) );
}*/

double xu_funE2D( const char * linea ){
   
   const char *buf;
   char *sMant;
   double nMant;
   int nExp,mant=0,signo;
   buf=linea;
   while(*buf!='E' && *buf!='e') {
      mant++;
      ++buf;
   }
   nExp = atoi(++buf);
   sMant = (char *)calloc(mant+1,1);
   strncpy(sMant,linea,mant);
   sMant[mant]='\0';
   if (sMant[0]=='-') {
      signo=(-1); 
      //sMant++;
      sMant[0]='0';
   } else signo=1;
   nMant = atof(sMant);
   free ( sMant );
//   printf("\n--> %f, %d, %d\n%f\n",nMant,nExp,signo, nMant * pow( (double)10, (double)nExp)*signo);
   return ((double) nMant * (double)pow( (double)10, (double)nExp)*(double)signo );
}

/* HB_FUNC( FUNE2D )
{
   const char* linea = hb_parc(1);
   double retorno = (double)xu_funE2D( linea );
//   printf("\n RES = %f\n",retorno);
   hb_retnd ( retorno );
} */

short int fun_istnumber(const char * AX){
  int DX;
  short int SW_M=0,SW_N=0,SW_P=0;
  short int retorne;
  
  retorne = AX[0]!='\0' ? 1 : 0;
  
  while( (DX=*AX)!='\0'){
    if(DX=='-'){
       if (SW_N || SW_P || SW_M) {retorne=0;break;}
       SW_M=1;
    }else if (DX=='.'){
       if (!SW_N || SW_P) {retorne=0;break;}
       SW_P=1;
    }else if (isdigit(DX)) {SW_N=1;
    }else {retorne=0;break;}
    ++AX;
  }
  if( !SW_N ) return 0;
  return retorne;
}

HB_SIZE hb_striAt( const char * szSub, HB_SIZE nSubLen, const char * szText, HB_SIZE nLen )
{

   if( nSubLen > 0 && nLen >= nSubLen )
   {
      HB_SIZE nPos = 0;
      nLen -= nSubLen;
      do
      {
         if( HB_TOUPPER(szText[ nPos ]) == HB_TOUPPER(*szSub) )
         {
            HB_SIZE nSubPos = nSubLen;
            do
            {
               if( --nSubPos == 0 )
                  return nPos + 1;
            }
            while( HB_TOUPPER(szText[ nPos + nSubPos ]) == HB_TOUPPER(szSub[ nSubPos ]) );
         }
      }
      while( nPos++ < nLen );
   }

   return 0;
}

char *fun_rtrim(const char *linea, HB_SIZE size) {    

   if(size>0) size--;   // me salto el '\0'
   char * r, *buffer;
   const char * pLinea = linea;
   const char * t;
   HB_SIZE tsize;

   t = pLinea;
   t += size;
   while( /*size>=0 &&*/ HB_ISSPACE( *t ) )
   {
      t--;
      size--;
      if (size==0 && *t==' ') {--t;break;}
   }
   tsize = t - pLinea + 1;//2;

   buffer = (char *) calloc(tsize+1,1);
   if (buffer==NULL) return NULL;
   r = buffer;
   memcpy(r,pLinea,tsize);
   r[tsize]='\0';
   return buffer;
}
char * fun_ltrim(const char *linea, HB_SIZE nLen) {
   const char *t;
   t = linea;
   
   while( nLen && HB_ISSPACE( *t ) )
   {
      t++;
      nLen--;
   }
   char *r, *buffer;
   buffer = (char *) calloc(nLen+1,1);
   if (buffer==NULL) return NULL;
   r = buffer;
   memcpy(r,t,nLen); 
   r[nLen]='\0';
   return buffer;
} 

char * fun_alltrim( const char *linea, HB_SIZE size) {
   const char *t=linea;
   char *l = fun_ltrim(t,size);
   char *r = fun_rtrim(l,strlen(l));
   
   HB_SIZE nLen = strlen(r);
   char *u, *buffer;
   buffer = (char *) calloc(nLen+1,1);
   if (buffer==NULL) return NULL;
   u = buffer;
   memcpy(u,r,nLen); 
   free(r);free(l);
   u[nLen]='\0';

   return buffer;
}

double FFACTORIAL(double param){
  double f=1;
  int i,x;
  double tablaf[21]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,
                     87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,
                     121645100408832000,2432902008176640000};
  x = (long)param;

    if (x<=20){
       f=tablaf[x];
    }else{
       f=tablaf[20];
       i=21;
       do{
         f=f*i;
       }while(++i<=x);
    }
  return f;
}


// XFUNCALL(DATASEG,PROGRAM)
// TEMPORAL es un array: { var, tipo("C","N","L","AN","AC","AL"), DIM,DIMR,DIMC,DIMP,DIMB }
//      ejemplo: TEMPORAL:={ V, "AC", 2, 10, 30, 0 , 0 }
//               TEMPORAL:={ V, "N", 0,0,0,0,0}


/* Declaraciones básicas de variables globales */
/*#ifdef _LINUX32_
   unsigned int CLOCKS_PER_SEC=1000000;
#endif*/
int swErr=0;   // Error!  
int CP=0;      // contador de programa pSTK_PRG. Inicia en 1
int CADDR=0;   // contador de pSTK_ADDR
int SWKEEP=0;
int iLOCAL_INI=0;  // donde inician locales
int nINDEXOBJ=0;
// SET intervalos, y sw de rangos.
unsigned int SET_INTERVAL_ROW=1,SET_INTERVAL_COL=1,SET_INTERVAL_PAG=1;
unsigned int SW_USERANGE=0;  // indice del registro que tiene el rango
unsigned int RANGEROW=0,RANGECOL=0,RANGEDIM=0;
int SW_ORIGIN_RANGE=1;  // 1=REG, 0=ADDR
//
unsigned int MARK_ROW=0, MARK_COL=0, MARK_POS=0, OFFSET_POS=0;
//unsigned int MARK_INTERfVALO_ROW=0, MARK_INTERVALO_COL=0;
unsigned int MARK_PAGE=0;
unsigned int MULTIPASS=1;
unsigned int SW_PUNTERO=0;
int nSizeStack=0;   // tamaño del stack de trabajo.
int FILE_ERROR=0;
int SIZE_BINARY=0;   // tamaño del binario a convertir con BIN
// POSICION EN PANTALLA:
int SCREEN_ROW = 1, SCREEN_COL = 1;

//unsigned int MARK_OFFSETROW=0, MARK_OFFSETCOL=0;   // coordenadas fila, columna de arrays
unsigned int OFFSET_ROW=0, OFFSET_COL=0;  // desplazamiento en elementos detro de un array.
short int SW_PRECISION=0;  // no se hace ajuste de decimales por defecto.

//short int SW_POSTFIX=0;   // calculo en notacion polaca inversa para #MATH. inactivo por default.
int PUSH_VAR=-1; // variable de copiado directo de operaciones.

unsigned PRECISION = 0;   // precision. default: no hay precision
//double SWITCH_VAR=0;    // dato de switch.
unsigned int LENDS=0;     // total de argumentos pasados al programa
double CTE_NAN = 0;
////int SW_CLRMARKSALL = 0;  // habilita/inhabilita borrar marcas luego de GET/PUT.
static volatile int s_fInit = 0;

/* variables de ejecución, publicas.
   Con esto, es posible que no necesite pasar argumentos
   y, ademas, crear punteros a funcion */
PHB_ITEM pSTK_DS;   // dataseg
PHB_ITEM pSTK_PRG;  // program
PHB_ITEM pSTK_DBG;  // lineas del programa
PHB_ITEM pSTK_ADDR; // stack de trabajo.
PHB_ITEM pSTK_REG;  // stack de registros variables
PHB_ITEM SWITCH_VAR;  // stack para switch/case
PHB_ITEM pRET;      // stack de retorno fin de ejecucion
int *STK_PRG = NULL;  // stack de instrucciones enteras.
int nPCP=0; //,nPCPNext=0;   // codigo de funcion.
PHB_ITEM pSTK_OBJ[1024];  // 8182 bytes reservados. para guardar datos de llamadas recursivas, o desde un local a otro.

char *TOKENIZER;
    
static char * XU_SEMANA[8]={"","Domingo","Lunes","Martes","Miercoles","Jueves","Viernes","Sabado"};
static char * XU_ANO[13]={"","Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio",
                          "Agosto","Septiembre","Octubre","Noviembre","Diciembre"};

//unsigned long INFINITO=93786976294838206460L;
//static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};


void get_size( PHB_ITEM pSource, HB_MAXINT *nDim, HB_MAXINT *d1, HB_MAXINT *d2, HB_MAXINT *d3, HB_MAXINT *type){
   PHB_ITEM pType=NULL;
   //long uiArrayLen1d = ( long ) hb_arrayLen( pSource );
   
   if( ( *d1 = ( long ) hb_arrayLen( pSource ) ) ){
       ++*nDim;
       //*d1 = uiArrayLen1d;
       pType = hb_itemArrayGet( pSource, 1);
       PHB_ITEM pSource2D = hb_itemArrayGet( pSource, 1);
       
       if( HB_IS_ARRAY( pSource2D ) ){   // es un ARRAY 2D
           //long uiArrayLen2d = ( long ) hb_arrayLen( pSource2D );
           
           if( (*d2 = ( long ) hb_arrayLen( pSource2D )) ){
               ++*nDim;
               ///*d2 = uiArrayLen2d;
               hb_itemRelease(pType);
               pType = hb_itemArrayGet( pSource2D, 1);
                                    //pTemp = pSource2D;
               PHB_ITEM pSource3D = hb_itemArrayGet( pSource2D, 1);
               if( HB_IS_ARRAY( pSource3D ) ){   // es un ARRAY 3D
                  //long uiArrayLen3d = ( long ) hb_arrayLen( pSource3D );
                  
                  if( ( *d3 = ( long ) hb_arrayLen( pSource3D ) ) ){
                     ++*nDim;
                     //*d3 = uiArrayLen3d;
                     hb_itemRelease(pType);
                     pType = hb_itemArrayGet( pSource3D, 1);
                  }
               }
               
               hb_itemRelease(pSource3D);
           }
           
       }
       
       hb_itemRelease(pSource2D);
   }
   if( pType ){
      if( HB_IS_STRING( pType ) ){
       //hb_arraySetC( pRET, 2, (const char *)  "AC"  );
       *type = 10;
      }else if ( HB_IS_INTEGER ( pType ) ){
       //hb_arraySetC( pRET, 2, (const char *)  "AN"  );
       *type = 11;
      }else if( HB_IS_NUMERIC( pType ) ) {
       //hb_arraySetC( pRET, 2, (const char *)  "AN"  );
       *type = 11;
      }else if( HB_IS_LONG( pType )  ){
       //hb_arraySetC( pRET, 2, (const char *)  "AN"  );
       *type = 11;
  /*    }else if( HB_IS_LOGICAL( pType ) ){
       //hb_arraySetC( pRET, 2, (const char *)  "AL"  );
       *type = 12;*/
      }
      hb_itemRelease(pType);
   }else *nDim=0;
}

void get_item_type(PHB_ITEM pSource, HB_MAXINT *type){
   if( HB_IS_STRING( pSource ) ){
      *type = 10;
   }else if ( HB_IS_INTEGER ( pSource ) ){
      *type = 11;
   }else if( HB_IS_NUMERIC( pSource ) ) {
      *type = 12;
   }else if( HB_IS_LONG( pSource )  ){
      *type = 13;
 /*  }else if( HB_IS_LOGICAL( pSource ) ){
      *type = 14; */
   }
}

/*void put_inc_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){


    if ( HB_IS_INTEGER ( pSource ) ){
        int pNum = hb_itemGetNI( pSource );
        hb_arraySetNI( pWSTACK, ndx, (int)  (pNum + xcremento)  );
    }else if( HB_IS_DOUBLE( pSource ) ) {
        double pDbl = hb_itemGetND( pSource );
        hb_arraySetND( pWSTACK, ndx, (double) (pDbl + xcremento) );
    }else if( HB_IS_LONG( pSource )  ){
        long pLong = hb_itemGetNL( pSource );
        hb_arraySetNL( pWSTACK, ndx, (long) ( pLong+xcremento ) );
    }else{
        const char * s = hb_itemGetCPtr(pSource);
        long nLen = hb_itemGetCLen(pSource);
        char *st = (char *)calloc(nLen+1,1);
        sprintf(st,"%s",s);
        const char *t=st;
        if(xcremento>nLen) xcremento=nLen;
        t+=xcremento;
        hb_arraySetC(pWSTACK, ndx, (const char*) t);
        free(st);
    }
}*/
void put_inc_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){


    if ( HB_IS_INTEGER ( pSource ) ){
        hb_arraySetNI( pWSTACK, ndx, (int)  (hb_itemGetNI( pSource ) + xcremento)  );

    }else if( HB_IS_LONG( pSource )  ){
        hb_arraySetNL( pWSTACK, ndx, (long) ( hb_itemGetNL( pSource )+xcremento ) );

    }else if( HB_IS_DOUBLE( pSource ) ) { //ASUME DOUBLE
        hb_arraySetND( pWSTACK, ndx, (double) (hb_itemGetND( pSource ) + xcremento) );
    }else{
        const char * s = hb_itemGetCPtr(pSource);
        long nLen = hb_itemGetCLen(pSource);
        char *st = (char *)calloc(nLen+1,1);
        sprintf(st,"%s",s);
        const char *t=st;
        if(xcremento>nLen) xcremento=nLen;
        t+=xcremento;
        hb_arraySetC(pWSTACK, ndx, (const char*) t);
        free(st);
    }
}

/*void put_inc_INT_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    int pNum = hb_itemGetNI( pSource );
    hb_arraySetNI( pWSTACK, ndx, (int)  (pNum + xcremento)  );
}

void put_inc_LONG_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    long pLong = hb_itemGetNL( pSource );
    hb_arraySetNL( pWSTACK, ndx, (long) ( pLong+xcremento ) );
}
void put_inc_DOUBLE_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){
    double pDbl = hb_itemGetND( pSource );
    hb_arraySetND( pWSTACK, ndx, (double) (pDbl + xcremento) );
}*/

void put_inc_str_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    const char * s = hb_itemGetCPtr(pSource);
    long nLen = hb_itemGetCLen(pSource);
    char *st = (char *)calloc(nLen+1,1);
    sprintf(st,"%s",s);
    const char *t=st;
    if(xcremento>nLen) xcremento=nLen;
    t+=xcremento;
    hb_arraySetC(pWSTACK, ndx, (const char*) t);
    free(st);

}

void put_dec_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    if ( HB_IS_INTEGER ( pSource ) ){
        hb_arraySetNI( pWSTACK, ndx, (int)  (hb_itemGetNI( pSource ) - xcremento)  );

    }else if( HB_IS_LONG( pSource )  ){
        hb_arraySetNL( pWSTACK, ndx, (long) ( hb_itemGetNL( pSource )-xcremento ) );

    }else if( HB_IS_DOUBLE( pSource ) ) { //ASUME DOUBLE
        hb_arraySetND( pWSTACK, ndx, (double) (hb_itemGetND( pSource ) - xcremento) );
    }else{
        const char * s = hb_itemGetCPtr(pSource);
        long nLen = hb_itemGetCLen(pSource);
        char *st = (char *)calloc(nLen+1,1);
        sprintf(st,"%s",s);
        if(nLen-xcremento<=0) st[0]='\0';
        else st[nLen-xcremento]='\0';
        hb_arraySetC(pWSTACK, ndx, (const char*) st);
        free(st);
    }
}

void put_dec_str_value(PHB_ITEM pWSTACK, long ndx, PHB_ITEM pSource, int xcremento){

    const char * s = hb_itemGetCPtr(pSource);
    long nLen = hb_itemGetCLen(pSource);
    char *st = (char *)calloc(nLen+1,1);
    sprintf(st,"%s",s);
    if(nLen-xcremento<=0) st[0]='\0';
    else st[nLen-xcremento]='\0';
    hb_arraySetC(pWSTACK, ndx, (const char*) st);
    free(st);
}

void put_value(PHB_ITEM pWSTACK, PHB_ITEM pSource, int ndx, int PRECISION){

// chequea tipo de valor obtenido y guarda en STK_ADDR:
        
    if ( HB_IS_INTEGER ( pSource ) ){
        int pNum = hb_itemGetNInt( pSource );
        hb_arraySetNI( pWSTACK, ndx, (int)  pNum  );
    }else if( HB_IS_DOUBLE( pSource ) ) {
        double pDbl = hb_itemGetND( pSource );
        hb_arraySetND( pWSTACK, ndx, (double) SW_PRECISION ? xu_funprecision(pDbl,PRECISION) : pDbl );
    }else if( HB_IS_LONG( pSource )  ){
        long pLong = hb_itemGetNL( pSource );
        hb_arraySetNL( pWSTACK, ndx, (long) pLong ); 
    }else if( HB_IS_STRING( pSource ) ){
        const char * pString = hb_itemGetCPtr( pSource );
        hb_arraySetC( pWSTACK, ndx, (const char *)  pString  );

   /* }else if( HB_IS_LOGICAL( pSource ) ){
        HB_BOOL pBool = hb_itemGetL( pSource );
        hb_arraySetL( pWSTACK, ndx, (HB_BOOL) pBool ) ;*/
    }else if( HB_IS_ARRAY( pSource )){
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 ); // creo array ajustado a los rangos.
               int i;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                  put_value(pRows, pARGS, i, PRECISION);
                  hb_itemRelease(pARGS);
               }
               hb_arraySet(pWSTACK, ndx, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pCols, pARGC, j, PRECISION);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARGF);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pWSTACK, ndx, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               int i;
               for(i=1; i<=d1; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  int j;
                  for(j=1; j<=d2; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k;
                     for(k=d1; k<=d3; k++){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAYP, pARGP, k, PRECISION);
                        hb_itemRelease(pARGP);
                     }
                     hb_arraySet(pARRAYC, j, pARRAYP);
                     hb_itemRelease(pARRAYP);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet(pARRAY, i, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pWSTACK, ndx, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }
         }
    }
}

int put_error(PHB_ITEM pRET, const char *ErrString, int ErrCode){//, int *swErr){
   swErr=1;
   hb_arraySetC( pRET, 2, (const char *) ErrString );
   hb_arraySetNI(pRET, 7, (int) ErrCode );
   return 0;
}

int normaliza_indices_1d(unsigned int * nIni, unsigned int *nFin, HB_MAXINT d1,
                          unsigned int * MARK_POS ){

   if( *MARK_POS == 999999999 ) *MARK_POS = d1;
   if( *MARK_POS ) { 
       *nIni = *MARK_POS; 
       *nFin = *MARK_POS;
   }
return 1;
}

int normaliza_indices_2d( unsigned int *nIniR, unsigned int *nFinR, unsigned int *nIniC, unsigned int *nFinC, 
                          long int d1, long int d2, int *swOffset,
                          unsigned int *MARK_ROW, unsigned int *OFFSET_ROW, 
                          unsigned int *MARK_COL, unsigned int *OFFSET_COL ){

int sw=1;

//            printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL); 
  if( *MARK_ROW ) {
      if( *MARK_ROW == 999999999 ) *MARK_ROW=d1;
      if( *MARK_ROW>d1 ){
          sw=put_error((PHB_ITEM) pRET, "GET|PUT ROW'MARK OVERFLOW",101);
          //hb_itemRelease(pSource);
          return sw;               
      }
      *nIniR=*MARK_ROW;*nFinR=*MARK_ROW;
      if( *OFFSET_ROW ){
          if( *OFFSET_ROW == 999999999 ) *OFFSET_ROW=d1;
          if( *OFFSET_ROW<=d1 ){
              *nFinR=*OFFSET_ROW;
          }else{   // es mayor! ERROR
              sw=put_error((PHB_ITEM) pRET, "GET|PUT ROW'OFFSET OVERFLOW",101);
              //hb_itemRelease(pSource);
              return sw;
          }
      }
  }else{  // asume todas las filas
      *swOffset=1;
      *OFFSET_ROW=*nFinR;
  }
  if( *MARK_COL ) {
      if( *MARK_COL == 999999999 ) *MARK_COL=d2;
      if( *MARK_COL>d2 ){
          sw=put_error((PHB_ITEM) pRET, "GET|PUT COL'MARK OVERFLOW",101);
          //        hb_itemRelease(pSource);
          return sw;               
      }
      *nIniC=*MARK_COL;*nFinC=*MARK_COL;
      if( *OFFSET_COL ){
          if( *OFFSET_COL == 999999999 ) *OFFSET_COL=d2;
          if( *OFFSET_COL<=d2 ){
              *nFinC=*OFFSET_COL;
          }else{   // es mayor! ERROR
              sw=put_error((PHB_ITEM) pRET, "GET|PUT COL'OFFSET OVERFLOW",101);
              //       hb_itemRelease(pSource);
              return sw;
          }
      }
  }else{  // asume todas las columnas
      *swOffset=1;
      *OFFSET_COL=*nFinC;
  }
  return sw;
}

int normaliza_indices_3d(unsigned int *nIniR, unsigned int *nFinR, unsigned int *nIniC, unsigned int *nFinC, 
                         unsigned int *nPagIni, unsigned int * nPagFin,
                         long int d1, long int d2, long int d3, int *swOffset,
                         unsigned int *MARK_PAGE, unsigned int *OFFSET_POS,
                         unsigned int *MARK_ROW, unsigned int *OFFSET_ROW, 
                         unsigned int *MARK_COL, unsigned int *OFFSET_COL){
int sw=1;
  if( *MARK_PAGE ){
      if( *MARK_PAGE == 999999999 ) *MARK_PAGE=d3;
      if( *MARK_PAGE>d3 ){
          sw=put_error((PHB_ITEM) pRET, "GET|PUT PAGE'MARK OVERFLOW",101);
          //hb_itemRelease(pSource);
          return sw;               
      }
      *nPagIni=*MARK_PAGE; *nPagFin=*MARK_PAGE;
      if( *OFFSET_POS ){
          if( *OFFSET_POS == 999999999 ) *OFFSET_POS=d3;
          if( *OFFSET_POS<=d3 ){
              *nPagFin=*OFFSET_POS;
          }else{   // es mayor! ERROR
              // printf("\n\nOFFSET_PAGE = %ld\n\n",OFFSET_POS);
              sw=put_error((PHB_ITEM) pRET, "GET|PUT PAGE'OFFSET OVERFLOW",101);
              //hb_itemRelease(pSource);
              return sw;
          }
      } 
  }else{  // si no existe marca de página, se asume todo; luego:
      *swOffset=1;
      *OFFSET_POS=*nPagFin; 
  }
  sw=normaliza_indices_2d(nIniR, nFinR, nIniC, nFinC, d1, d2, swOffset,
                          MARK_ROW, OFFSET_ROW, MARK_COL, OFFSET_COL );

return sw;
}


int fun_clear_interval(){
              SET_INTERVAL_ROW=1;SET_INTERVAL_COL=1;SET_INTERVAL_PAG=1;
              MARK_ROW=0; MARK_COL=0; MARK_POS=0; MARK_PAGE=0;
              OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0;
return 1;
}

int fun_clear_range(){
              SW_USERANGE=0;SW_ORIGIN_RANGE=1;
              RANGEROW=0;RANGECOL=0;RANGEDIM=0;
return 1;
}
/*int fun_clear_marks(){
              MARK_ROW=0; MARK_COL=0; MARK_POS=0; MARK_PAGE=0;
              OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0;
return 1;
}*/
/*int fun_clearall(){
int sw=1; 
  sw = fun_clear_marks();
  sw = fun_clear_range();
  sw = fun_clear_interval();
return sw;
}*/
/*int fun_clrmarksall(){
   //fun_clear_marks();
   //fun_clear_interval();
   SW_CLRMARKSALL = (SW_CLRMARKSALL)? 0 : 1;
return 1;
}*/

/******************************************************
     ESTRUCTURAS LISTAS PARA SALTOS Y OTROS
     PROCESOS INTERNOS
 *******************************************************/
 
/*struct stack_inner{
   PHB_ITEM pDATA; 
   struct stack_inner *siguiente;
}; 

typedef struct stack_inner saveData;
saveData *cabezaData = NULL;
saveData *actualData = NULL;

int push_data( PHB_ITEM pDato ){
int sw=1;
    
    saveData *nodo = (struct stack_inner*)malloc(sizeof(struct stack_inner));

    if(nodo == NULL){
       sw=0; //put_error((PHB_ITEM) pRET, "INNER-DATA STACK POINTER NOT ENOUGHT MEMORY",100);
    }else{
       //PHB_ITEM pdatotmp = hb_itemGet//hb_itemNew( NULL );
       PHB_ITEM pSEC = hb_itemPutND( NULL, (double) 3.14159265358979323846 );
       
       nodo->pDATA = pDato;
       nodo->siguiente = cabezaData;
       cabezaData = nodo;
    }

return sw;
}
//= hb_itemNew( NULL );
int pop_data( PHB_ITEM * pDato ){
int sw=1;

    if(cabezaData == NULL){
        sw=0; //put_error((PHB_ITEM) pRET, "INNER-DATA STACK POINTER OVERFLOW", 101);
    }else{
        saveData *nodo = cabezaData;
        // *dirJump = nodo->id;
        *pDato = nodo->pDATA;   // -1 por ++CP del final del ciclo.

        cabezaData=nodo->siguiente;
        free(nodo);
    }
return sw;
}
*/
struct label_to_jump{
    int id;
//    char *dataText;   // por si lo necesite después
    struct label_to_jump *siguiente;
};

typedef struct label_to_jump jumpLabel;
jumpLabel *cabeza = NULL;
jumpLabel *actual = NULL;

struct label_to_try{
    int id;
//    char *dataText;   // por si lo necesite después
    struct label_to_try *siguiente;
};

typedef struct label_to_try tryLabel;
tryLabel *cabezaTry = NULL;
tryLabel *actualTry = NULL;


int push_label( int etiqueta ){
int sw=1;
    
    jumpLabel *nodo = (struct label_to_jump*)malloc(sizeof(struct label_to_jump));

    if(nodo == NULL){
       sw=put_error((PHB_ITEM) pRET, "JSUB|GOSUB STACK POINTER NOT ENOUGHT MEMORY",100);
    }else{
       nodo->id = etiqueta;
       nodo->siguiente = cabeza;
       cabeza = nodo;
    }

return sw;
}

int pop_label(){
int sw=1;
    if(cabeza == NULL){
        sw=put_error((PHB_ITEM) pRET, "BACK STACK POINTER OVERFLOW", 101);
    }else{
        jumpLabel *nodo = cabeza;
        //*dirJump = nodo->id;
        CP = nodo->id - 1;   // -1 por ++CP del final del ciclo.

        cabeza=nodo->siguiente;
        free(nodo);
    }
return sw;
}

int push_try( int etiqueta ){
int sw=1;
    
    tryLabel *nodo = (struct label_to_try*)malloc(sizeof(struct label_to_try));

    if(nodo == NULL){
       sw=put_error((PHB_ITEM) pRET, "TRY STACK POINTER NOT ENOUGHT MEMORY",100);
    }else{
       nodo->id = etiqueta;
       nodo->siguiente = cabezaTry;
       cabezaTry = nodo;
    }

return sw;
}

int read_try(){
int sw=1;
    if(cabezaTry == NULL){
       sw=put_error((PHB_ITEM) pRET, "TRY STACK POINTER OVERFLOW", 101);
    }else{
       tryLabel *nodo = cabezaTry;
       CP = nodo->id - 1;   // -1 por ++CP del final del ciclo.
    }
return sw;
}

int pop_try(){
int sw=1;
    if(cabezaTry == NULL){
        sw=put_error((PHB_ITEM) pRET, "TRY STACK POINTER OVERFLOW", 101);
    }else{
        tryLabel *nodo = cabezaTry;
        //*dirJump = nodo->id;
        CP = nodo->id - 1;   // -1 por ++CP del final del ciclo.

        cabezaTry=nodo->siguiente;
        free(nodo);
    }
return sw;
}

/*
char * fun_notation( double x ){//, double nPrecision ){
char Times[] = "e ";
  char buffer[3 + DBL_DIG + sizeof(Times) + 20 + 1];
  char * dest = (char *)calloc(1024,1);
  if(fabs(x)!=0)
     sprintf(buffer, "%.*e", DBL_DIG, x);
  else{
     x=fabs(x);
     sprintf(buffer, "%.*e", DBL_DIG, x);
  }
///  printf("\ntemporal = %s\n",buffer);
  char *e = strchr(buffer, 'e');  // find exponent position
  if (e) {
    char *zero = e;
    
    while (zero[-1] == '0') zero--;
    if(zero[-1]=='.') zero--;
    *zero = '\0'; // OP wants excess zeros trimmed.
    int power = atoi(&e[1]);  // trim excess zeros by converting to int
    Times[1] = power>0? '+':power<0?'-':'\0';

    sprintf(dest, "%s%s%d", buffer, Times, abs(power));
    }
  else {
    strcpy(dest, buffer);
  }
  //printf("\ntemporal = %s\n",dest);
  ///const char * cBuffer = dest;
  return dest;
}
*/ 
/*  char *buf;
  double nExp;
  int signo;
  signo=nDec<0?-1:1;
  if (signo<0) nDec *= -1;
  if( nDec == 0) nExp = 0;
  else if (fabs( nDec ) < 1)  nExp = (double)(int)( log10( nDec ) ) - 1;
  else
      nExp = (double)(int)( log10( fabs( nDec ) + 0.00001 ) );   // 0.00001 == kludge 
             //for imprecise logs 
  nDec /= pow(10, nExp );  //pow(10, nExp);
  if (hb_numRound( fabs( nDec ), nPrecision ) >= 10){
      nDec /= 10;
      nExp++;
  }
  //buf = (char *) calloc(sizeof(char)*19+1,1);
  buf = (char *) calloc(32,1);
  switch((int)nPrecision){
     case 1:case 2:case 3: 
         sprintf(buf,"%1.3fe%d",nDec*signo,(int)nExp); break;
     case 4: sprintf(buf,"%1.4fe%d",nDec*signo,(int)nExp); break;
     case 5: sprintf(buf,"%1.5fe%d",nDec*signo,(int)nExp); break;
     case 6: sprintf(buf,"%1.6fe%d",nDec*signo,(int)nExp); break;
     case 7: sprintf(buf,"%1.7fe%d",nDec*signo,(int)nExp); break; 
     case 8: sprintf(buf,"%1.8fe%d",nDec*signo,(int)nExp); break;
     case 9: sprintf(buf,"%1.9fe%d",nDec*signo,(int)nExp); break; 
     default: sprintf(buf,"%1.10fe%d",nDec*signo,(int)nExp); 
  }  
  return buf; 
}*/


/*void put_vector(PHB_ITEM pARRAY, PHB_ITEM pSource, long uiArrayLen){
long i;
   // VER las marcas de MARK_ROW, etc.
   long nIni=1, nFin=uiArrayLen;
   
   if( HB_IS_STRING( pSource ) ){
       const char * pString = hb_itemGetCPtr( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetC( pARRAY, i, (const char *)  pString  );
       }
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNInt( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetNI( pARRAY, i, (int)  pNum  );
       }
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetND( pARRAY, i, (double) pDbl );
       }
   }else if( HB_IS_LONG( pSource )  ){
       long pLong = hb_itemGetNL( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetNL( pARRAY, i, (long) pLong );
       } 
   }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       for( i=nIni; i<=nFin; i++ ){
           hb_arraySetL( pARRAY, i, (HB_BOOL) pBool ) ;
       }
   }
}
*/
/*void echo_single( PHB_ITEM pSource, unsigned PRECISION, FILE * fhnd ){
   if( HB_IS_STRING( pSource ) ){
       const char * pString = hb_itemGetCPtr( pSource );
       long nText = hb_itemGetCLen( pSource );
       fwrite( pString, nText, 1, fhnd );
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNI( pSource );
       char * buf = (char *)calloc(32,1);
       int size = sprintf(buf,"%d", pNum);
       const char * pString = buf;
       fwrite( pString, size, 1, fhnd );
       free(buf);
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%'.*lf", PRECISION, pDbl);
       //int size = sprintf(buf,"%f", pDbl);
       const char * pString = buf;
       fwrite( pString, size, 1, fhnd );
       free(buf);
   }else if( HB_IS_LONG( pSource ) ) {
       long pLong = hb_itemGetNL( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%ld", pLong);
       const char * pString = buf;
       fwrite( pString, size, 1, fhnd );
       free(buf);
   }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) fwrite( "1", 1,1,fhnd );
       else fwrite( "0", 1,1, fhnd );
   }
}*/

void echo_single( PHB_ITEM pSource, unsigned PRECISION, FILE * fhnd ){

   if( HB_IS_STRING( pSource ) ){
       fprintf(fhnd,"%s",hb_itemGetCPtr( pSource ));
   }else if( HB_IS_DOUBLE( pSource ) ) {
       if( SW_PRECISION )
          //fprintf(fhnd,"%lf",hb_itemGetND( pSource ));
          fprintf(fhnd,"%.*lf",PRECISION,hb_itemGetND( pSource ));
       else
          fprintf(fhnd,"%lf",hb_itemGetND( pSource ));  // "%g"
   }else if( HB_IS_LONG( pSource ) ) {
        
       fprintf(fhnd,"%ld",hb_itemGetNL( pSource ));
       
   }else if ( HB_IS_INTEGER ( pSource ) ){
       fprintf(fhnd,"%d",hb_itemGetNI( pSource ));
/*   }else if( HB_IS_LONG( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) fprintf(fhnd,"1");
       else fprintf(fhnd, "0");*/
   }
   
}

/*void hout_single( PHB_ITEM pSource, unsigned PRECISION ){
            
   if( HB_IS_STRING( pSource ) ){
       hb_conOutStd( hb_itemGetCPtr( pSource ), hb_itemGetCLen( pSource ) );
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNI( pSource );
       char * buf = (char *)calloc(32,1);
       int size = sprintf(buf,"%d", pNum);
       const char * pString = buf;
       hb_conOutStd( pString, size );
       free(buf);
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%.*lf", PRECISION, pDbl);
       const char * pString = buf;
       hb_conOutStd( pString, size );
       free(buf);
   }else if( HB_IS_LONG( pSource ) ) {
       long pLong = hb_itemGetNL( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%ld", pLong);
       const char * pString = buf;
       hb_conOutStd( pString, size );
       free(buf); 
   }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) hb_conOutStd( "1", 1 );
       else hb_conOutStd( "0", 1 );
   }
}*/


void print_single( PHB_ITEM pSource, unsigned PRECISION ){
   if( HB_IS_STRING( pSource ) ){
       printf("%s", hb_itemGetCPtr( pSource ));

   }else if( HB_IS_DOUBLE( pSource ) ) {
       if( SW_PRECISION )
          printf("%.*lf",PRECISION,hb_itemGetND( pSource ));
       else
          printf("%lf",hb_itemGetND( pSource )); //"%g"
   }else if( HB_IS_LONG( pSource ) ) {
       printf("%ld", hb_itemGetNL( pSource ));
   }else if ( HB_IS_INTEGER ( pSource ) ){
       printf("%d", hb_itemGetNI( pSource ));
   }
}

void echo_matrix( PHB_ITEM pSource, unsigned PRECISION, char *TOKENIZER, FILE *fhnd ){
            HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
            const char * tokenizer=TOKENIZER;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pDato = hb_itemArrayGet( pSource, i);
            echo_single( (PHB_ITEM) pDato, PRECISION, fhnd );
            if( d1-i ) fprintf( fhnd,"%s",tokenizer );
            hb_itemRelease(pDato);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               echo_single( (PHB_ITEM) pPrint, PRECISION, fhnd );
               hb_itemRelease(pPrint);
               if( d2-j ) fprintf( fhnd,"%s",tokenizer );
            }
            fprintf( fhnd,"\n" );
            hb_itemRelease(pDato2D);
         }
         break;
      }case 3:{
         int i;
         int k;
         for( k=1; k<=d3; k++){
            for( i=1; i<=d1; i++){
               PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
                  PHB_ITEM pPrint2 = hb_itemArrayGet( pPrint, k);
                  echo_single( (PHB_ITEM) pPrint2, PRECISION, fhnd );
                  hb_itemRelease(pPrint2);
                  if( d2-j ) fprintf( fhnd,"%s", tokenizer );
                  hb_itemRelease(pPrint);
               }
               hb_itemRelease(pDato2D);
               fprintf( fhnd,"\n" );
            }
           // fprintf( fhnd,"\n" );
         }
         break;     
      }
   }
}

HB_FUNC( PRINT_MATRIX ){
   PHB_ITEM pSource = hb_param( 1, HB_IT_ARRAY );
   
   echo_matrix( pSource, 13, ",", stdout);
}


void print_matrix( PHB_ITEM pSource, unsigned PRECISION , char *TOKENIZER  ){
            HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
            const char * tokenizer=TOKENIZER;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pDato = hb_itemArrayGet( pSource, i);
            print_single( (PHB_ITEM) pDato, PRECISION );
            if( d1-i ) putchar(tokenizer[0]);  //printf( "%s",tokenizer );
            hb_itemRelease(pDato);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               print_single( (PHB_ITEM) pPrint, PRECISION );

               hb_itemRelease(pPrint);
               if( d2-j ) putchar(tokenizer[0]);  //printf( "%s",tokenizer );
            }
            //printf( "\n" );
            putchar('\n');
            hb_itemRelease(pDato2D);
         }
         break;
      }case 3:{
         int i;
         int k;
         for( k=1; k<=d3; k++){
            printf( "PAGE: %d\n",k );
            for( i=1; i<=d1; i++){
               PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
                  PHB_ITEM pPrint2 = hb_itemArrayGet( pPrint, k);
                  print_single( (PHB_ITEM) pPrint2, PRECISION );                  
                  
                  hb_itemRelease(pPrint2);
                  if( d2-j ) putchar(tokenizer[0]);  //printf( "%s",tokenizer );
                  hb_itemRelease(pPrint);
               }
               hb_itemRelease(pDato2D);
               //printf( "\n" );
               putchar('\n');
            }
            putchar('\n');
         }
         break;
      }
   }
}

/* DEPRECADO */
/*int escapeDump(){
int sw=1;
if(CADDR){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1; //1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_STRING(pSource) ){
            printf("\033%s", hb_itemGetCPtr( pSource ) );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
      CADDR += SWKEEP; SWKEEP = 0;
}
return sw;
}*/
int fun_show(){
int cntDIR=CADDR;
int nPrecision = SW_PRECISION ? PRECISION : 13;
   if ( CADDR ){
      int ndxCADDR = 1;
      while (cntDIR){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){
            print_matrix( pSource, nPrecision, (char *)TOKENIZER );
         }else{
            print_single( pSource, nPrecision );
         }
         hb_itemRelease(pSource);
         --cntDIR;
  //       --CADDR;
         ++ndxCADDR;
      }
       fflush(stdout);
   }
return 1;
}
int fun_printusingtoken(){
int nPrecision = SW_PRECISION ? PRECISION : 13;
   if ( CADDR ){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1; //1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){

            print_matrix( pSource, nPrecision, (char *)TOKENIZER );
         }else{
            print_single( pSource, nPrecision );
            if( CADDR-1 ) putchar(TOKENIZER[0]); //printf( "%s",(char *)TOKENIZER );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
     // CADDR += SWKEEP; SWKEEP = 0;
     SWKEEP = 0; fflush(stdout);
/*      hb_arraySize(pSTK_ADDR,0);
      hb_arraySize(pSTK_ADDR,nSizeStack);
      hb_ret();
      hb_gcCollect(); */
   }
return 1;
}

int fun_print(){
int nPrecision = SW_PRECISION ? PRECISION : 13;
   
   if ( CADDR ){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1;//1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){

            print_matrix( pSource, nPrecision, (char *)TOKENIZER );
         }else{
            print_single( pSource, nPrecision );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
      //CADDR += SWKEEP; SWKEEP = 0;
      SWKEEP = 0; fflush(stdout);
/*      hb_arraySize(pSTK_ADDR,0);
      hb_arraySize(pSTK_ADDR,nSizeStack);
      hb_ret();
      hb_gcCollect(); */
   }
return 1;
}

int fun_echo(/*FILE *fhnd*/){
int nPrecision = SW_PRECISION ? PRECISION : 13;
   if ( CADDR ){
      int ndxCADDR = SWKEEP ? SWKEEP+1 : 1;//1;
      while (CADDR>SWKEEP){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndxCADDR); // lee dato
         // IDENTIFICAR SI ES UN ARRAY.
         if( HB_IS_ARRAY(pSource) ){

            echo_matrix( pSource, nPrecision, (char *)TOKENIZER, (FILE *)stdout/*fhnd*/ );
         }else{
            echo_single( pSource, nPrecision, (FILE*)stdout /*fhnd*/ );
         }
         hb_itemRelease(pSource);
         --CADDR;
         ++ndxCADDR;
      }
      //CADDR += SWKEEP; SWKEEP = 0;
      SWKEEP = 0; fflush(stdout);
/*      hb_arraySize(pSTK_ADDR,0);
      hb_arraySize(pSTK_ADDR,nSizeStack);
      hb_ret();
      hb_gcCollect(); */
   }
return 1;
}


int fun_putstr(/* unsigned int nItem */){
int sw=1;
int nPrecision = SW_PRECISION ? PRECISION : 13;
//while(1){
   unsigned int nItem=(unsigned int)STK_PRG[++CP];
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY(pSource))
      print_matrix( pSource, nPrecision, (char *)TOKENIZER );
   else
      print_single( pSource, nPrecision );
   hb_itemRelease(pSource);
    fflush(stdout);
//   if(STK_PRG[ CP+1 ] != 288) break; else ++CP; // para el ajuste de comando
//}
return sw;
}

int fun_putstack(){
int sw=1;
int nPrecision = SW_PRECISION ? PRECISION : 13;
//while(CADDR){
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--); // lee dato
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_ARRAY(pSource))
      print_matrix( pSource, nPrecision, (char *)TOKENIZER );
   else
      print_single( pSource, nPrecision );
   hb_itemRelease(pSource);
    fflush(stdout);
//   if(STK_PRG[ CP+1 ] != 195) break; else ++CP; // para el ajuste de comando
//}
return sw;
}


#define XUINC1D   1
#define XUINC2D   1
#define XUDEC1D   2
#define XUDEC2D   2
void xu_incdec1d( PHB_ITEM pSource,/* PHB_ITEM pSTK_REG,*/ long nARG, HB_MAXINT d1, int CODE, int xcremento ){
    long i;
    //PHB_ITEM pARRAY = hb_itemArrayNew( d1 );  // crea un array vacío.
    for( i=1; i<=d1; i++ ){
        PHB_ITEM pNum = hb_itemArrayGet( pSource, i );
        
        switch( CODE ){
            //case XUINC1D: {put_inc_value(pARRAY, i, pNum,xcremento); break;}
            case XUINC1D: {put_inc_value(pSource, i, pNum,xcremento); break;}
            //case XUDEC1D: {put_dec_value(pARRAY, i, pNum,xcremento); break;}
            case XUDEC1D: {put_dec_value(pSource, i, pNum,xcremento); break;}
        }
        hb_itemRelease(pNum);
    }
    //hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pARRAY );
    hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pSource );
    //hb_itemRelease(pARRAY); 
}
                          
void xu_incdec2d( PHB_ITEM pSource, /*PHB_ITEM pSTK_REG,*/ long nARG, HB_MAXINT d1, HB_MAXINT d2, int CODE,int xcremento ){
   long i;
   //PHB_ITEM pARRAY = hb_itemArrayNew( d1 );  // crea un array vacío.
   for( i=1; i<=d1; i++ ){
        long j;
        PHB_ITEM pSource2 = hb_itemArrayGet( pSource, i );
        //PHB_ITEM pARRAY1 = hb_itemArrayNew( d2 );
        for( j=1; j<=d2; j++ ){ 
            PHB_ITEM pNum = hb_itemArrayGet( pSource2, j );

            switch( CODE ){
                //case XUINC2D: {put_inc_value(pARRAY1, j, pNum,xcremento); break;}
                case XUINC2D: {put_inc_value(pSource2, j, pNum,xcremento); break;}

                //case XUDEC2D: {put_dec_value(pARRAY1, j, pNum,xcremento); break;}
                case XUDEC2D: {put_dec_value(pSource2, j, pNum,xcremento); break;}

            }
            hb_itemRelease(pNum);
        }
        hb_arraySet( pSource, i, (PHB_ITEM) pSource2 );
        hb_itemRelease(pSource2);
        //hb_arraySet( pARRAY, i, (PHB_ITEM) pARRAY1 );
        //hb_itemRelease(pARRAY1);
        //hb_itemRelease(pSource2);
   }
   hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pSource );
   //hb_itemRelease(pSource);
   //hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pARRAY );
   //hb_itemRelease(pARRAY);
}

void xu_incdec3d( PHB_ITEM pSource, /*PHB_ITEM pSTK_REG,*/ long nARG, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, 
                  int CODE,int xcremento ){
   long i;
   //PHB_ITEM pARRAY = hb_itemArrayNew( d1 );  // crea un array vacío.
   for( i=1; i<=d1; i++ ){
        long j;
        PHB_ITEM pSource2 = hb_itemArrayGet( pSource, i );
        //PHB_ITEM pARRAY1 = hb_itemArrayNew( d2 );
        for( j=1; j<=d2; j++ ){ 
            PHB_ITEM pNum = hb_itemArrayGet( pSource2, j );
            //PHB_ITEM pARRAY2 = hb_itemArrayNew( d3 );
            long k;
            for( k=1; k<=d3; k++ ){ 
               PHB_ITEM pNum2 = hb_itemArrayGet( pNum, k );
               switch( CODE ){
                   //case XUINC2D: {put_inc_value(pARRAY2, k, pNum2,xcremento); break;}
                   case XUINC2D: {put_inc_value(pNum, k, pNum2,xcremento); break;}  
                   //case XUDEC2D: {put_dec_value(pARRAY2, k, pNum2,xcremento); break;}
                   case XUDEC2D: {put_dec_value(pNum, k, pNum2,xcremento); break;}

               }
               hb_itemRelease(pNum2);
            }
            hb_arraySet( pSource2, j, (PHB_ITEM) pNum );
            hb_itemRelease(pNum);
            //hb_arraySet( pARRAY1, j, (PHB_ITEM) pARRAY2 );
            //hb_itemRelease(pNum);
            //hb_itemRelease(pARRAY2);
        }
        hb_arraySet( pSource, i, (PHB_ITEM) pSource2 );
        hb_itemRelease(pSource2);
        //hb_arraySet( pARRAY, i, (PHB_ITEM) pARRAY1 );
        //hb_itemRelease(pARRAY1);
        //hb_itemRelease(pSource2);
   }
   hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pSource );
   //hb_arraySet( pSTK_REG, nARG, (PHB_ITEM) pARRAY );
   //hb_itemRelease(pARRAY);
}

void put_operator_value(PHB_ITEM pSTK_REG, unsigned int nARGo, PHB_ITEM pSource1, double num2, int OpCode){
   switch(OpCode){
      case 0:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(hb_itemGetND( pSource1 ) * num2, PRECISION) :
                                                            hb_itemGetND( pSource1 ) * num2 ) ; 
                                                            break;}
      case 1:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(hb_itemGetND( pSource1 ) / num2, PRECISION) :
                                                            hb_itemGetND( pSource1 ) / num2 ) ; 
                                                            break;}
      case 2:{hb_arraySetNL( pSTK_REG, nARGo, 
                             (long) (hb_itemGetND( pSource1 ) / num2 )) ; 
                                                            break;}
      case 3:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(pow(hb_itemGetND( pSource1 ), num2), PRECISION) :
                                                            pow(hb_itemGetND( pSource1 ), num2) ) ; 
                                                            break;}
      case 4:{hb_arraySetND( pSTK_REG, nARGo, 
                             SW_PRECISION ? xu_funprecision(fmod(hb_itemGetND( pSource1 ), num2), PRECISION) :
                                                            fmod(hb_itemGetND( pSource1 ), num2) ) ; 
                                                            break;}
      case 5:{hb_arraySetNI( pSTK_REG, nARGo, 
                             (int) (hb_itemGetNI( pSource1 ) >> (int)num2 ) ); 
                                                            break;}
      case 6:{hb_arraySetNI( pSTK_REG, nARGo, 
                             (int) (hb_itemGetNI( pSource1 ) << (int)num2 )) ; 
                                                            break;}
      case 7:{hb_arraySetNL( pSTK_REG, nARGo, 
                             (long) (hb_itemGetNL( pSource1 ) | (long)num2 )) ; 
                                                            break;}
      case 8:{hb_arraySetNL( pSTK_REG, nARGo, 
                             (long) (hb_itemGetNL( pSource1 ) & (long)num2 )) ; 
                                                            break;}
      case 9:{hb_arraySetNI( pSTK_REG, nARGo, 
                             (int) (hb_itemGetNI( pSource1 ) ^ (int)num2 )) ; 
                                                            break;}
   }
}

int fun_opeCode(){
int sw=1;

//do{
   //unsigned int nARGo = (unsigned int)STK_PRG[++CP];  //OPCODE
   //PHB_ITEM pOpCode   = hb_itemArrayGet( pSTK_REG, nARGo);
   int OpCode = (unsigned int)STK_PRG[++CP]-1;  //OPCODE
   
   unsigned int nARG1 = (unsigned int)STK_PRG[++CP];  //OPERANDO 1, RECIPIENTE
   PHB_ITEM pSource1  = hb_itemArrayGet( pSTK_REG, nARG1);
   unsigned int nARG2 = (unsigned int)STK_PRG[++CP];  //OPERANDO 2
   PHB_ITEM pSource2  = hb_itemArrayGet( pSTK_REG, nARG2);
   if( HB_IS_NUMERIC( pSource2 ) ){   // operando 2 debe ser numero
      double num2 = hb_itemGetND(pSource2);
      //int OpCode = hb_itemGetNI(pOpCode);
      if( HB_IS_NUMERIC( pSource1 ) ) {  // operando 1 es numero
         put_operator_value((PHB_ITEM)pSTK_REG,nARG1, pSource1, num2, OpCode);
         
      }else if( HB_IS_ARRAY(pSource1) ){   // es array
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
         get_size( (PHB_ITEM) pSource1, &nDim, &d1, &d2, &d3, &type); 
         if ( type == 11 ){
            switch( nDim ){
               case 1:{
                  long i;
                  for( i=1; i<=d1; i++ ){
                     PHB_ITEM pNum1 = hb_itemArrayGet( pSource1, i );
                     put_operator_value(pSource1,i, pNum1, num2, OpCode);
                     hb_itemRelease(pNum1);
                  }
                 // hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pSource1 );
                  break;
               }case 2:{
                  long i;
                  for( i=1; i<=d1; i++ ){
                     PHB_ITEM pNum1 = hb_itemArrayGet( pSource1, i );
                     long j;
                     for( j=1; j<=d2; j++ ){
                        PHB_ITEM pNum11 = hb_itemArrayGet( pNum1, j );
                        put_operator_value(pNum1,j, pNum11, num2, OpCode);
                        hb_itemRelease(pNum11);
                     }
                     hb_arraySet( pSource1, i, (PHB_ITEM) pNum1 );
                     hb_itemRelease(pNum1);
                  }
                 // hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pSource1 );
                  break;
               }case 3:{
                  long i;
                  for( i=1; i<=d1; i++ ){
                     PHB_ITEM pNum1 = hb_itemArrayGet( pSource1, i );
                     long j;
                     for( j=1; j<=d2; j++ ){
                        PHB_ITEM pNum11 = hb_itemArrayGet( pNum1, j );
                        long k;
                        for( k=1; k<=d3; k++ ){
                           PHB_ITEM pNum111 = hb_itemArrayGet( pNum11, k );
                           put_operator_value(pNum11,k, pNum111, num2, OpCode);
                           hb_itemRelease(pNum111);
                        }
                        hb_arraySet( pNum1, j, (PHB_ITEM) pNum11 );
                        hb_itemRelease(pNum11);
                     }
                     hb_arraySet( pSource1, i, (PHB_ITEM) pNum1 );
                     hb_itemRelease(pNum1);
                  }
                //  hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pSource1 );

                  break;
               }default:{
                    sw=0;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "<ope>= ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "?<ope>=... ARGUMENT ERROR - TYPE NUMBER REQUERED",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "REG<ope>=? ARGUMENT ERROR - SINGLE TYPE NUMBER REQUERED",103);
   }
   hb_itemRelease(pSource2);
   hb_itemRelease(pSource1);
 //  hb_itemRelease(pOpCode);
   //++CP;
//}while ( STK_PRG[CP]==305 ); // CP==operator code +=, -=
//--CP;
return sw;
}


int funInc_one(){
int sw=1;

//do{
   ///short Tipo = nPCP == 202 ? 0 : 1;
   // extrae argumentos:

   int incremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);

/*   if( HB_IS_NUMERIC( pSource ) ) {
      put_inc_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource); */
   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource )+1)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )+1 ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource )+1) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUINC1D,incremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUINC2D,incremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUINC2D,incremento);break;}
            default:{
                 sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR - NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==202 ); // CP==operator code +=, -=
//--CP;
return sw;
}

int funInc_much(){
int sw=1;

//do{
   //short Tipo = nPCP == 202 ? 0 : 1;
   // extrae argumentos:

   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);

   unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
   int incremento = hb_itemGetNInt(pSop2);
   hb_itemRelease(pSop2);

/*   if( HB_IS_NUMERIC( pSource ) ) {
      put_inc_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);
*/
   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource ) + incremento)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )+ incremento ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource ) + incremento) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);

   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUINC1D,incremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUINC2D,incremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUINC2D,incremento);break;}
            default:{
                 sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR - NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==207 ); // CP==operator code +=, -=
//--CP;
return sw;
}

int funDec_one(){
int sw=1;
//do{
   //short Tipo = nPCP == 203 ? 0 : 1;
   // extrae argumentos:
   int decremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);

   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource )-1)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )-1 ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource )-1) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);

   }else if( HB_IS_STRING(pSource) ){
      put_dec_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);
      
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUDEC1D,decremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUDEC2D,decremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUDEC2D,decremento);break;}
            default:{
               sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==203 ); // CP==operator code +=, -=
//--CP;
return sw;
}

int funDec_much(){
int sw=1;

//do{
//short Tipo = nPCP == 203 ? 0 : 1;
   // extrae argumentos:
   //int decremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);
//   if( Tipo ){   // es 1: saco sguiente elemento.
      unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
      PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
      int decremento = hb_itemGetNInt(pSop2);
      hb_itemRelease(pSop2);
//   }

   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource ) - decremento)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )- decremento ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource ) - decremento) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);

   }else if( HB_IS_STRING(pSource) ){
      put_dec_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);
      
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, XUDEC1D,decremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, XUDEC2D,decremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource,/* (PHB_ITEM) pSTK_REG,*/ nARG1, d1, d2, d3, XUDEC2D,decremento);break;}
            default:{
               sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- NUMBER REQUERED",103);
   }
//}while ( STK_PRG[++CP]==209 ); // CP==operator code +=, -=
//--CP;
return sw;
}
/*int funInc(){
int sw=1;

do{
   short Tipo = nPCP == 202 ? 0 : 1;
   // extrae argumentos:
//   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_PRG, ++CP);
//   long nARG1 = hb_itemGetNInt( pARG1 );
   int incremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);
   if( Tipo ){   // es 1: saco sguiente elemento.
      unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
      PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
      incremento = hb_itemGetND(pSop2);
      hb_itemRelease(pSop2);
   }
   if( HB_IS_NUMERIC( pSource )  || HB_IS_STRING(pSource) ) {
      put_inc_value(pSTK_REG, nARG1, pSource,incremento);
      hb_itemRelease(pSource);
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, XUINC1D,incremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, XUINC2D,incremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, d3, XUINC2D,incremento);break;}
            default:{
                 sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "INC ARGUMENT ERROR - NUMBER REQUERED",103);
   }
//   hb_itemRelease(pSource);
//   hb_itemRelease(pARG1);
return sw;
}*/

/*int funDec(){
int sw=1;
short Tipo = nPCP == 203 ? 0 : 1;
   // extrae argumentos:
   int decremento=1;
   unsigned int nARG1=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG1);
   if( Tipo ){   // es 1: saco sguiente elemento.
      unsigned int nARG2=(unsigned int)STK_PRG[++CP];
              // obtengo valor de registro:
      PHB_ITEM pSop2 = hb_itemArrayGet( pSTK_REG, nARG2);
      decremento = hb_itemGetND(pSop2);
      hb_itemRelease(pSop2);
   }

   if( HB_IS_INTEGER( pSource ) ) {
      //put_inc_INT_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNI( pSTK_REG, nARG1, (int)  (hb_itemGetNI( pSource ) - decremento)  );
      hb_itemRelease(pSource);
      
   }else if( HB_IS_LONG( pSource ) ) {
      //put_inc_LONG_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetNL( pSTK_REG, nARG1, (long) ( hb_itemGetNL( pSource )- decremento ) );
      hb_itemRelease(pSource);

   }else if( HB_IS_DOUBLE( pSource ) ) {
      //put_inc_DOUBLE_value(pSTK_REG, nARG1, pSource,incremento);
      hb_arraySetND( pSTK_REG, nARG1, (double) (hb_itemGetND( pSource ) - decremento) );
      hb_itemRelease(pSource);

   }else if ( HB_IS_STRING(pSource) ){
      put_inc_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);

   }else if( HB_IS_STRING(pSource) ){
      put_dec_str_value(pSTK_REG, nARG1, pSource,decremento);
      hb_itemRelease(pSource);
      
   }else if( HB_IS_ARRAY(pSource) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
      if ( type <= 11 ){
         switch( nDim ){
            case 1:{xu_incdec1d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, XUDEC1D,decremento);break;}
            case 2:{xu_incdec2d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, XUDEC2D,decremento);break;}
            case 3:{xu_incdec3d( (PHB_ITEM) pSource, (PHB_ITEM) pSTK_REG, nARG1, d1, d2, d3, XUDEC2D,decremento);break;}
            default:{
               sw=0;
            }
         }
         hb_itemRelease(pSource);
      }else{
         sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- ARRAY NUMBER REQUERED",103);
      }
   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "DEC ARGUMENT ERROR -- NUMBER REQUERED",103);
   }
return sw;
}*/

/********************************************************
               FUNCIONES STRING
 ********************************************************/

int concatenate_item( PHB_ITEM pARG1, PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR ){
   int sw=1;
   const char * pString1 = hb_itemGetCPtr( pARG1 );
   long nLen1 = hb_itemGetCLen( pARG1 );
   const char * pString2 = hb_itemGetCPtr( pARG2 );
   long nLen2 = hb_itemGetCLen( pARG2 );

   char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
   if ( pTarget == NULL ){
       sw=0;
       free(pTarget);
   }else{
     //  char * Temp = pTarget;
       hb_xmemcpy( pTarget, pString1, nLen1 );
       hb_xmemcpy( pTarget + nLen1, pString2, nLen2 );
       pTarget[nLen1 + nLen2 + 1] = '\0';
       hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pTarget );
       free(pTarget);
   }
   return sw;
}

int replicate_item(PHB_ITEM pTEXT, PHB_ITEM pSTK_ADDR, int CADDR, PHB_ITEM pTIMES){

   long nTimes = hb_itemGetNL( pTIMES );
   const char *szText = hb_itemGetCPtr( pTEXT );
   long nLen = hb_itemGetCLen( pTEXT );
   long nTotalLen = ( nLen * nTimes );
   char * szResult = (char *) calloc(( nTotalLen + 1),1);

   if ( szResult == NULL ) return 0;
     
   char * szPtr = szResult;

   while(nTimes)
   {
      int j=nLen;
      while(j--) szPtr[j] = szText[j];
      szPtr += nLen;
      --nTimes;
   }
   szResult[ nTotalLen ] = '\0';
   const char * pszResult = szResult;
   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
   free(szResult);
   return 1;
}

int stuff_item( PHB_ITEM pARG1, PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR, PHB_ITEM pPos, PHB_ITEM pDel ){
   int sw=1;
   const char * pString2 = hb_itemGetCPtr( pARG2 );  // lo que se corta.
   long nText = hb_itemGetCLen( pARG2 );
   
   long nPos = hb_itemGetNL( pPos );
   
   long nDel = ( pDel ) ? hb_itemGetNL( pDel ) : nText;
   
   const char * pString1;
   long nInsert;
   if( pARG1 != NULL ){
      pString1 = hb_itemGetCPtr( pARG1 );  // fuente
      nInsert = hb_itemGetCLen( pARG1 );
   }else{
      pString1 = "";
      nInsert=0;
   }
   long nTotalLen;
      if( nPos ){
         if( nPos < 1 || nPos > nText ){
            nPos = nText;
         }else{
            nPos--;
         }
      }

      if( nDel ){
         if( nDel < 1 || nDel > nText - nPos )  nDel = nText - nPos;
      }

      if( ( nTotalLen = nText + nInsert - nDel ) > 0 ){
         char * szResult = ( char * ) calloc( nTotalLen + 1, 1 );
         if( szResult != NULL ) {
             hb_xmemcpy( szResult, pString2, nPos );
             hb_xmemcpy( szResult + nPos, pString1, nInsert );
             hb_xmemcpy( szResult + nPos + nInsert, pString2 + nPos + nDel, nText - ( nPos + nDel ) );

             szResult[ nTotalLen ] = '\0';
             const char * pszResult = szResult;
             hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
             free(szResult);
         }else{
             sw=0;
         }
      }
      else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
      }
   return sw;
}

int strtran_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK, int NDX, long nInicio, long nCuenta ){
         
   int sw=1;
   if(!HB_IS_STRING(pARG3)){
       hb_arraySet( pSTK, NDX, pARG3 );
       return sw;
   }
   
   HB_SIZE nText = hb_itemGetCLen( pARG3 );
   HB_SIZE nSeek = hb_itemGetCLen( pARG2 );
         
   HB_SIZE nStart = nInicio<=0 ? 1 : nInicio;
   HB_SIZE nCount = nCuenta<=0 ? -1 : nCuenta;

   if( nSeek && nSeek <= nText && nStart > 0 ) {
      HB_SIZE nReplace; 
      const char * szReplace;
      if ( pARG1!=NULL ){
         szReplace = hb_itemGetCPtr( pARG1 );
         nReplace = hb_itemGetCLen( pARG1 ); 
      }else{
         szReplace = "";
         nReplace = 0;
      }
      
      const char * szText = hb_itemGetCPtr( pARG3 );
      const char * szSeek = hb_itemGetCPtr( pARG2 );
      HB_SIZE nFound = 0;
      HB_SIZE nReplaced = 0;
      HB_SIZE nT = 0;
      HB_SIZE nS = 0;

      while( nT < nText && nText - nT >= nSeek - nS ) {
         if( szText[ nT ] == szSeek[ nS ] ){
            ++nT;
            if( ++nS == nSeek ){
               if( ++nFound >= nStart ){
                  nReplaced++;
                  if( --nCount == 0 )
                     nT = nText;
               }
                  nS = 0;
            }
         }else if( nS ){
            nT -= nS - 1;
            nS = 0;
         }else
            ++nT;
      }

      if( nReplaced ){
         HB_SIZE nLength = nText;

         if( nSeek > nReplace )
            nLength -= ( nSeek - nReplace ) * nReplaced;
         else
            nLength += ( nReplace - nSeek ) * nReplaced;

         if( nLength ){
            char * szResult = ( char * ) calloc( nLength + 1, 1 );
            if ( szResult != NULL ){
               char * szPtr = szResult;

               nFound -= nReplaced;
               nT = nS = 0;
               do{
                  if( nReplaced && szText[ nT ] == szSeek[ nS ] ){
                     ++nT;
                     if( ++nS == nSeek ){
                        const char * szCopy;
   
                        if( nFound ){
                           nFound--;
                           szCopy = szSeek;
                        }else{
                           nReplaced--;
                           szCopy = szReplace;
                           nS = nReplace;
                        }
                        while( nS ){
                           *szPtr++ = *szCopy++;
                           --nS;
                        }
                     }
                  }else{
                     if( nS ){
                        nT -= nS;
                        nS = 0;
                     }
                     *szPtr++ = szText[ nT++ ];
                  }
               }while( nT < nText );
   
               const char * pszResult = szResult;
               hb_arraySetC( pSTK, NDX, (const char *) pszResult );
               
               free(szResult);
            }else{
               sw=0;
            }
         }else{
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
            hb_arraySet( pSTK, NDX, pARG3 );
         }
      }else{
         hb_arraySetC( pSTK, NDX, (const char *) szText );
      }
   }else{
      const char * szText = hb_itemGetCPtr( pARG3 );
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) szText );
   }
   return sw;
}
int strtran_item_single( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, long nInicio, long nCuenta ){
         
   int sw=1;
   if(!HB_IS_STRING(pARG3)){
       hb_arraySet( pSTK_ADDR, CADDR, pARG3 );
       return sw;
   }
   
   HB_SIZE nText = hb_itemGetCLen( pARG3 );
   HB_SIZE nSeek = hb_itemGetCLen( pARG2 );
         
   HB_SIZE nStart = nInicio<=0 ? 1 : nInicio;
   HB_SIZE nCount = nCuenta<=0 ? -1 : nCuenta;

   if( nSeek && nSeek <= nText && nStart > 0 ) {
      HB_SIZE nReplace; 
      const char * szReplace;
      if ( pARG1!=NULL ){
         szReplace = hb_itemGetCPtr( pARG1 );
         nReplace = hb_itemGetCLen( pARG1 ); 
      }else{
         szReplace = "";
         nReplace = 0;
      }
      
      const char * szText = hb_itemGetCPtr( pARG3 );
      const char * szSeek = hb_itemGetCPtr( pARG2 );
      HB_SIZE nFound = 0;
      HB_SIZE nReplaced = 0;
      HB_SIZE nT = 0;
      HB_SIZE nS = 0;

      while( nT < nText && nText - nT >= nSeek - nS ) {
         if( szText[ nT ] == szSeek[ nS ] ){
            ++nT;
            if( ++nS == nSeek ){
               if( ++nFound >= nStart ){
                  nReplaced++;
                  if( --nCount == 0 )
                     nT = nText;
               }
                  nS = 0;
            }
         }else if( nS ){
            nT -= nS - 1;
            nS = 0;
         }else
            ++nT;
      }

      if( nReplaced ){
         HB_SIZE nLength = nText;

         if( nSeek > nReplace )
            nLength -= ( nSeek - nReplace ) * nReplaced;
         else
            nLength += ( nReplace - nSeek ) * nReplaced;

         if( nLength ){
            char * szResult = ( char * ) calloc( nLength + 1, 1 );
            if ( szResult != NULL ){
               char * szPtr = szResult;

               nFound -= nReplaced;
               nT = nS = 0;
               do{
                  if( nReplaced && szText[ nT ] == szSeek[ nS ] ){
                     ++nT;
                     if( ++nS == nSeek ){
                        const char * szCopy;
   
                        if( nFound ){
                           nFound--;
                           szCopy = szSeek;
                        }else{
                           nReplaced--;
                           szCopy = szReplace;
                           nS = nReplace;
                        }
                        while( nS ){
                           *szPtr++ = *szCopy++;
                           --nS;
                        }
                     }
                  }else{
                     if( nS ){
                        nT -= nS;
                        nS = 0;
                     }
                     *szPtr++ = szText[ nT++ ];
                  }
               }while( nT < nText );
   
               const char * pszResult = szResult;
               hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
               
               free(szResult);
            }else{
               sw=0;
            }
         }else{
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
            hb_arraySet( pSTK_ADDR, CADDR, pARG3 );
         }
      }else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) szText );
      }
   }else{
      const char * szText = hb_itemGetCPtr( pARG3 );
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) szText );
   }
   return sw;
}

int substr_item( PHB_ITEM pText, PHB_ITEM pPos, PHB_ITEM pLen, PHB_ITEM pSTK_ADDR, int CADDR){
   int sw=1;
   if(!HB_IS_STRING(pText)){
       hb_arraySet( pSTK_ADDR, CADDR, pText );
       return sw;
   }
      long nPos = hb_itemGetNL( pPos );
      //HB_ISIZ nSize = 0;//hb_itemGetCLen( pText );
      HB_ISIZ nSize = hb_itemGetCLen( pText );
      
/*      char *szDest;
      const char *Text;
      int swUTF8=1;
      if(swUTF8){
         szDest = convertSTR( (PHB_ITEM) pText);
         Text = szDest;
         nSize = hb_cdpUTF8StringLength( hb_itemGetCPtr( pText ), hb_itemGetCLen( pText ) );
      }else{
         const char * Text = hb_itemGetCPtr( pText );
         nSize = hb_itemGetCLen( pText );
      }*/

      if( nPos < 0 ){
         nPos += nSize;
         if( nPos < 0 )
            nPos = 0;
      }
      else if( nPos ){
         nPos--;
      }

      if( nPos < nSize ){
         HB_ISIZ nLen;

         if ( pLen ) { 
               nLen = hb_itemGetNL( pLen );

               if( nLen > nSize - nPos )
                  nLen = nSize - nPos;
         }else{
            nLen = nSize - nPos;
         }
         
         if( nLen > 0 ){
            if( nLen == nSize ){
               const char * Text = hb_itemGetCPtr( pText );
               hb_arraySetC( pSTK_ADDR, CADDR, (const char *) Text  );
            }else{
               const char * Text = hb_itemGetCPtr( pText );

               char * szResult = ( char * ) calloc( nLen + 1, 1 );
               if ( szResult != NULL ){
                   Text = Text + nPos;
                   hb_xmemcpy( szResult, Text, nLen );
                   szResult[ nLen ] = '\0';
                   const char * pszResult = szResult;
                   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pszResult );
                   free(szResult);
               }else{
                   sw=0;
               }
            }
         }else{
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
            hb_arraySet( pSTK_ADDR, CADDR, pText );
         }
      }else{
         //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "" );
         hb_arraySet( pSTK_ADDR, CADDR, pText );
      }
   
 /*  if(swUTF8){
      free(szDest);
   }*/
   
   return sw;
}

int str_index_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pMATCH, PHB_ITEM pSTK_ADDR, int CADDR ){
int sw=1;
   const char *pcStringToMatch = hb_itemGetCPtr( pSTRING );
   HB_SIZE sStrToMatchLen = hb_itemGetCLen( pSTRING );
      
   const char *pcString = hb_itemGetCPtr( pTEXT );
   HB_SIZE sStrLen = hb_itemGetCLen( pTEXT );

   HB_SIZE sIgnore=0, sMatchStrLen = 0;
   HB_SIZE nCounter;
   const char *pc = NULL;

   /* nth match or last match ? */
   if( pMATCH != NULL ){
      /* find the <nCounter>th match */
      const char *pcSubStr;
      HB_SIZE sSubStrLen;
      HB_SIZE nMatchCounter = 0;

      pcSubStr = pcString;
      sSubStrLen = sStrLen;
      nCounter = hb_itemGetNL( pMATCH );
      
      if( nCounter > 0 ){
         while( nMatchCounter < nCounter ){
            pc = ct_at_exact_forward( pcSubStr, sSubStrLen, pcStringToMatch,
                                               sStrToMatchLen, &sMatchStrLen );
            if( pc == NULL ){
               /* no match found; if this happens at this point,
                  there are no <nCounter> matches, so return an empty string */
               hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
               return sw;
            }
            nMatchCounter++;

            if( MULTIPASS )
               pcSubStr = pc + 1;
            else
               pcSubStr = pc + sMatchStrLen;
            sSubStrLen = sStrLen - ( pcSubStr - pcString );
         }
      }else{  // busca igual como si no existiera el último
         pc = ct_at_exact_backward( pcString, sStrLen, pcStringToMatch,
                                          sStrToMatchLen, &sMatchStrLen );
         if( pc == NULL ){
            /* ATNUM */
            hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
           return sw;
         } 
      }
   }else{
      pc = ct_at_exact_backward( pcString, sStrLen, pcStringToMatch,
                                          sStrToMatchLen, &sMatchStrLen );
      if( pc == NULL ){
         /* ATNUM */
         hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
         return sw;
      }
   }
   hb_arraySetNInt( pSTK_ADDR, CADDR, ( pc - ( pcString - sIgnore ) + 1 ) );
return sw;
}

int str_count_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pIGNORE, PHB_ITEM pSTK, int NDX ){
int sw=1;
      const char *pcStringToMatch = hb_itemGetCPtr( pSTRING );
      HB_SIZE sStrToMatchLen = hb_itemGetCLen( pSTRING );
      
      const char *pcString = hb_itemGetCPtr( pTEXT );
      HB_SIZE sStrLen = hb_itemGetCLen( pTEXT );
      
      HB_SIZE sIgnore, sMatchStrLen = 0, sSubStrLen;
      HB_SIZE nCounter;
      const char *pc, *pcSubStr;

      /* eventually ignore some characters */
      if( pIGNORE!=NULL )
         sIgnore = hb_itemGetNL( pIGNORE );
      else
         sIgnore = 0;

      if( sIgnore >= sStrLen ){
         hb_arraySetNInt( pSTK, NDX, 0 );
         return sw;
      }else{
         pcString += sIgnore;
         sStrLen -= sIgnore;
      }

      nCounter = 0;
      pcSubStr = pcString;
      sSubStrLen = sStrLen;

      do{
         pc = ct_at_exact_forward( pcSubStr, sSubStrLen, pcStringToMatch,
                                   sStrToMatchLen, &sMatchStrLen );
         nCounter++;
         if( MULTIPASS ){
            pcSubStr = pc + 1;
         }else{
            pcSubStr = pc + sMatchStrLen;
         }
         sSubStrLen = sStrLen - ( pcSubStr - pcString );
      }while( pc != NULL );

      hb_arraySetNInt( pSTK, NDX, ( nCounter - 1 ) );
return sw;
}

int str_count_at_single( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pIGNORE ){
int sw=1;
      const char *pcStringToMatch = hb_itemGetCPtr( pSTRING );
      HB_SIZE sStrToMatchLen = hb_itemGetCLen( pSTRING );
      
      const char *pcString = hb_itemGetCPtr( pTEXT );
      HB_SIZE sStrLen = hb_itemGetCLen( pTEXT );
      
      HB_SIZE sIgnore, sMatchStrLen = 0, sSubStrLen;
      HB_SIZE nCounter;
      const char *pc, *pcSubStr;

      /* eventually ignore some characters */
      if( pIGNORE!=NULL )
         sIgnore = hb_itemGetNL( pIGNORE );
      else
         sIgnore = 0;

      if( sIgnore >= sStrLen ){
         hb_arraySetNInt( pSTK_ADDR, CADDR, 0 );
         return sw;
      }else{
         pcString += sIgnore;
         sStrLen -= sIgnore;
      }

      nCounter = 0;
      pcSubStr = pcString;
      sSubStrLen = sStrLen;

      do{
         pc = ct_at_exact_forward( pcSubStr, sSubStrLen, pcStringToMatch,
                                   sStrToMatchLen, &sMatchStrLen );
         nCounter++;
         if( MULTIPASS ){
            pcSubStr = pc + 1;
         }else{
            pcSubStr = pc + sMatchStrLen;
         }
         sSubStrLen = sStrLen - ( pcSubStr - pcString );
      }while( pc != NULL );

      hb_arraySetNInt( pSTK_ADDR, CADDR, ( nCounter - 1 ) );
return sw;
}


int str_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pSTK, int NDX ){
int sw=1;
   const char * pText = hb_itemGetCPtr( pTEXT );  // String base
   long nLenText = hb_itemGetCLen( pTEXT );
   const char * pSub = hb_itemGetCPtr( pSTRING );  // string to search
   long nLenSub = hb_itemGetCLen( pSTRING );

   hb_arraySetNInt( pSTK, NDX, hb_strAt( pSub, nLenSub, pText, nLenText ) );

return sw;
}
int str_at_single( PHB_ITEM pTEXT, PHB_ITEM pSTRING ){
int sw=1;
   const char * pText = hb_itemGetCPtr( pTEXT );  // String base
   long nLenText = hb_itemGetCLen( pTEXT );
   const char * pSub = hb_itemGetCPtr( pSTRING );  // string to search
   long nLenSub = hb_itemGetCLen( pSTRING );

   hb_arraySetNInt( pSTK_ADDR, CADDR, hb_strAt( pSub, nLenSub, pText, nLenText ) );

return sw;
}

int fun_mask_item( PHB_ITEM pARG, PHB_ITEM pMASK, PHB_ITEM pRELL, PHB_ITEM pSTK_ADDR, int CADDR ) {
int sw=1;
   
   const char * numero = hb_itemGetCPtr( pARG );
   const char * car = hb_itemGetCPtr( pRELL );
   const char * formato = hb_itemGetCPtr( pMASK );
   
   long ln = hb_itemGetCLen( pARG );
   long lf = hb_itemGetCLen( pMASK );
   
   char *buffer, *pBuf;

   pBuf = (char *)calloc(lf+1,1);
   if (pBuf==NULL) return 0;

   buffer = pBuf;
   int16_t i=lf, k=lf; 

   char c; 
   --lf; --ln; --k;
   while (lf>=0 && ln>=0) {
      c = formato[lf];
      if (c=='#') buffer[k] = numero[ln--]; 
      else buffer[k] = c;
      --k;
      --lf;
   }
   while (lf>=0) {
      c = formato[lf];
      if (*car) {
         if (c=='#') buffer[k] = *car;
         else buffer[k] = c;
      } else {
         buffer[k] = ' ';
      }
      --lf;
      --k;
   }
   buffer[i]='\0';
   const char * pBuffer = buffer; 
   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pBuffer );
   free(pBuf);
   
return sw;
}

int fun_money_item(PHB_ITEM pARG,PHB_ITEM pDEC,PHB_ITEM pSTK_ADDR,int CADDR){
int sw=1;
   double numero = hb_itemGetND( pARG );
   
   int decimales = hb_itemGetNI( pDEC );
   char *buffer = (char *)calloc (1024,1); 
   if (buffer==NULL) return 0;
   char *num = (char *)calloc (1024,1); 
   if (num==NULL) return 0;
   
   char *buf = buffer;

   int i=0,j=0,swNeg=0;
   if( numero < 0 ) {
      swNeg=1;
      numero *= -1;
   }
   
   uint16_t size = sprintf(buf,"%.*lf",decimales, numero);
   int intSize=size;
   if( decimales>0 ){
      intSize=size-decimales-1;  // longitud entero
   }

   if( swNeg ){  
      num[0] = '-';
      ++i;
   }
   num[i] = buf[0];
   ++j;++i;
   --intSize;
   
   while( intSize ){
      if( buf[j]=='.' ) {
         num[i++] = buf[j];
         break;
      }else{
         if( fmod(intSize,3) )
            num[i++] = buf[j];
         else{
            num[i++] = ',';
            num[i++] = buf[j];
         }
      }
      ++j;
      --intSize;
      --size;
   }
   while( size ){
      num[i++] = buf[j];
      --size;
      ++j;
   }
   free(buffer);
 // completar signo, moneda y pad.  
   num[i]='\0';
   const char * pBuffer = num; 
   hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pBuffer );
   free(num);

return sw;
}

int fun_str_item( PHB_ITEM pARG, PHB_ITEM pSTK, int NDX, int tCompare ){
int sw=1;

   switch( tCompare ){
      case 0:{
         //long cLen = hb_cdpUTF8StringLength( hb_itemGetCPtr( pARG ), hb_itemGetCLen( pARG ) );   
         long cLen = hb_itemGetCLen( pARG );
         hb_arraySetNL( pSTK, NDX, cLen ) ;
         break;  // LEN
      }case 1:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strUpper( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK, NDX, Buffer ); // UPPER
         else
            hb_arraySetC( pSTK, NDX, "error-memory-upper" );
         free(cBuffer);
         //free(Buffer);
         break;
      }case 2:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strLower( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK, NDX, Buffer ); // LOWER
         else
            hb_arraySetC( pSTK, NDX, "error-memory-lower" );
         free(cBuffer);
         //free(Buffer);
         break; 
      }case 3:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_alltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK, NDX, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK, NDX, "error-memory-trim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 4:{
         const char * Buffer = hb_itemGetCPtr( pARG );    // ASC
         hb_arraySetNInt( pSTK, NDX, ( HB_UCHAR ) Buffer[0] );
         break;
      }case 5:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_rtrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK, NDX, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK, NDX, "error-memory-rtrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 6:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_ltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK, NDX, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK, NDX, "error-memory-ltrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
         
      }case 7:{
         /*if( HB_IS_LOGICAL( pARG ) ){
            HB_BOOL lDato = hb_itemGetL( pARG );
            hb_arraySetNI( pSTK_ADDR, CADDR, (int) lDato ? 1 : 0 );
            
         }else*/ if( HB_IS_STRING( pARG ) ){
            const char * szText = hb_itemGetCPtr( pARG );  // XTONUM
            int iWidth, iDec, iLen = ( int ) hb_itemGetCLen( pARG );
            HB_BOOL fDbl;
            HB_MAXINT lValue;
            double dValue;

            fDbl = hb_valStrnToNum( szText, iLen, &lValue, &dValue , &iDec, &iWidth );

            if( !fDbl ){
               hb_arraySetNL( pSTK, NDX, (HB_MAXINT) lValue );
            }else{
               hb_arraySetND( pSTK, NDX, (double) dValue );
            }
         }else if( HB_IS_INTEGER(pARG)){
            int nInt = hb_itemGetNI( pARG );
            hb_arraySetNI( pSTK, NDX, (int) nInt );
         }else if( HB_IS_LONG(pARG)){
            long nLong = hb_itemGetNL( pARG );
            hb_arraySetNL( pSTK, NDX, (long) nLong );
         }else if( HB_IS_DOUBLE(pARG)){
            double nDouble = hb_itemGetND( pARG );
            hb_arraySetND( pSTK, NDX, (double) nDouble );
         }else{
            sw=0;
         }
         break;
         
      }default: sw=0;
   }

return sw;
}

int fun_str_item_single( PHB_ITEM pARG, int tCompare ){
int sw=1;

   switch( tCompare ){
      case 0:{
         long cLen = hb_itemGetCLen( pARG );
         hb_arraySetNL( pSTK_ADDR, CADDR, cLen ) ;
         break;  // LEN
      }case 1:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strUpper( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // UPPER
         else
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-upper" );
         free(cBuffer);
         //free(Buffer);
         break;
      }case 2:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         /*const char * */char * Buffer = hb_strLower( cBuffer, cLen );
         if( Buffer != NULL )
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // LOWER
         else
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-lower" );
         free(cBuffer);
         //free(Buffer);
         break; 
      }case 3:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_alltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-trim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 4:{
         const char * Buffer = hb_itemGetCPtr( pARG );    // ASC
         hb_arraySetNInt( pSTK_ADDR, CADDR, ( HB_UCHAR ) Buffer[0] );
         break;
      }case 5:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_rtrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-rtrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
      }case 6:{
         const char * pText = hb_itemGetCPtr( pARG );
         long cLen = hb_itemGetCLen( pARG );
         char * cBuffer = (char*) calloc(cLen+1,1);
         memcpy(cBuffer,pText,cLen);
         char * Buffer = fun_ltrim( cBuffer, cLen);
         if( Buffer!=NULL){
            hb_arraySetC( pSTK_ADDR, CADDR, Buffer ); // TRIM 
         }else{
            hb_arraySetC( pSTK_ADDR, CADDR, "error-memory-ltrim" );
         }
         free(cBuffer);
         free(Buffer);
         break;
         
      }case 7:{
         if( HB_IS_STRING( pARG ) ){
            const char * szText = hb_itemGetCPtr( pARG );  // XTONUM
            int iWidth, iDec, iLen = ( int ) hb_itemGetCLen( pARG );
            HB_BOOL fDbl;
            HB_MAXINT lValue;
            double dValue;

            fDbl = hb_valStrnToNum( szText, iLen, &lValue, &dValue , &iDec, &iWidth );

            if( !fDbl ){
               hb_arraySetNL( pSTK_ADDR, CADDR, (HB_MAXINT) lValue );
            }else{
               hb_arraySetND( pSTK_ADDR, CADDR, (double) dValue );
            }
         }else if( HB_IS_INTEGER(pARG)){
            int nInt = hb_itemGetNI( pARG );
            hb_arraySetNI( pSTK_ADDR, CADDR, (int) nInt );
         }else if( HB_IS_LONG(pARG)){
            long nLong = hb_itemGetNL( pARG );
            hb_arraySetNL( pSTK_ADDR, CADDR, (long) nLong );
         }else if( HB_IS_DOUBLE(pARG)){
            double nDouble = hb_itemGetND( pARG );
            hb_arraySetND( pSTK_ADDR, CADDR, (double) nDouble );
         }else{
            sw=0;
         }
         break;
         
      }default: sw=0;
   }

return sw;
}


int fun_num_item( PHB_ITEM pARG, PHB_ITEM pSTK, int NDX, int tCompare){//, int PRECISION ){
int sw=1;

   switch( tCompare ){
      case 0:{   // EXP
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( exp( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           exp( hb_itemGetND( pARG ) ) );
         break;
      }case 1:{  // INT
         hb_arraySetNL( pSTK, NDX, (long) ( hb_itemGetND( pARG ) ) );
         break;
      }case 2:{  // SIGN
         double nItem = hb_itemGetND( pARG );
         hb_arraySetNI( pSTK, NDX, (int) ( nItem > 0 ? 1 : nItem < 0 ? -1 : 0 ) );
         break;
      }case 3:{  // LOG
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( log( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           log( hb_itemGetND( pARG ) ) );
         break;
      }case 4:{  // LOG10
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( log10( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           log10( hb_itemGetND( pARG ) ) );
         break;
      }case 5:{  // SQRT
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( sqrt( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           sqrt( hb_itemGetND( pARG ) ) );
         break;
      }case 6:{  // SIN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( sin( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           sin( hb_itemGetND( pARG ) ) );
         break;
      }case 7:{  // COS
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( cos( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           cos( hb_itemGetND( pARG ) ) );
         break;
      }case 8:{  // TAN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( tan( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           tan( hb_itemGetND( pARG ) ) );
         break;
      }case 9:{  // SINH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( sinh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           sinh( hb_itemGetND( pARG ) ) );
         break;
      }case 10:{  // COSH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( cosh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           cosh( hb_itemGetND( pARG ) ) );
         break;
      }case 11:{  // TANH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( tanh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           tanh( hb_itemGetND( pARG ) ) );
         break;
      }case 12:{  // XTOSTR
         //itoa( hb_itemGetND( pARG ), cText);
         if ( HB_IS_INTEGER ( pARG ) ){
            int pNum = hb_itemGetNInt( pARG );
            char * buf = (char *)calloc(32,1);
            /*int size = */sprintf(buf,"%d", pNum);
            const char * pString = buf;
            hb_arraySetC( pSTK, NDX, pString );
            free(buf);
         }else if( HB_IS_NUMERIC( pARG ) ) {
            double pDbl = hb_itemGetND( pARG );
            
            char * buf = (char *)calloc(80,1);
            if(SW_PRECISION){
               sprintf(buf,"%.*lf",PRECISION, pDbl);

            }else{

               sprintf(buf,"%lf",pDbl);
            }
            const char * pString = buf;
            hb_arraySetC( pSTK, NDX, pString );
            free(buf);
         }else if( HB_IS_LONG( pARG ) ) {
            long pLong = hb_itemGetNL( pARG );
            char * buf = (char *)calloc(64,1);
            /*int size = */sprintf(buf,"%ld", pLong);
            const char * pString = buf;
            hb_arraySetC( pSTK, NDX, pString );
            free(buf);

         }else{  // es un string.
            const char* pString = hb_itemGetCPtr( pARG );
            hb_arraySetC( pSTK, NDX, pString );
         }
         break;
      }case 13:{  // FLOOR
         hb_arraySetNL( pSTK, NDX, (long)  floor( hb_itemGetND( pARG ) ) );
         break;
      }case 14:{  // ABS
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( fabs( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           fabs( hb_itemGetND( pARG ) ) );
         break;
      }case 15:{  // CHR
         hb_arraySetC( pSTK, NDX, hb_szAscii[ (int)hb_itemGetNInt( pARG ) & 0xFF ] );
         break;
      }case 16:{  // CEIL
         hb_arraySetNL( pSTK, NDX, (long) ceil( hb_itemGetND( pARG ) ) );
         break;
      }case 17:{  // EXP2
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( exp2( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           exp2( hb_itemGetND( pARG ) ) );
         break;
      }case 18:{  // LOG2
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( log2( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           log2( hb_itemGetND( pARG ) ) );
         break;
      }case 19:{  // EXP10
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( exp10( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           exp10( hb_itemGetND( pARG ) ) );
         break;
      }case 20:{  // HEX
         long pLong = hb_itemGetNL( pARG );
         char * buf = (char *)calloc(64,1);
         /*int size = */sprintf(buf,"%lX", pLong);
         const char * pString = buf;
         hb_arraySetC( pSTK, NDX, pString );
         free(buf);

         break;
      }case 21:{  // BIN
         long k, c, nNum = hb_itemGetNL( pARG );
         int size=63;
         if(SIZE_BINARY>0) size = SIZE_BINARY;
         char * buffer = (char *)calloc(size+2,1);
         for (c = size; c >= 0; c--){
            k = nNum >> c;
            if (k & 1)
               buffer[size-c] = '1';
            else
               buffer[size-c] = '0';
         }
         buffer[size+1] = '\0';
         const char * pString = buffer;
         if(!SIZE_BINARY){  // quita los ceros de más
            while(*pString!='1') pString++;
         }
         
         hb_arraySetC( pSTK, NDX, pString );
         free(buffer);

         break;
      }case 22:{  // OCT
         HB_MAXINT decimal = hb_itemGetNL( pARG );
/*         HB_MAXINT octal=0;
         int i=1;
//         printf("\nNUM = %ld\n",octal);
         while (decimal != 0){
            octal += (decimal % 8) * i;
            decimal /= 8;
            i *= 10;
         }*/
//         printf("\nOCTAL = %ld\n",octal);
//         hb_arraySetNL( pSTK, NDX, octal );
         char * buf = (char *)calloc(64,1);
         /*int size = */sprintf(buf,"%lo", decimal);
         const char * pString = buf;
         hb_arraySetC( pSTK, NDX, pString );
         free(buf);

         break;
      }case 23:{  // lennum
         hb_arraySetNI( pSTK, NDX, (int)ceil(log10( hb_itemGetND( pARG ) )) );
         break;
      }case 24:{  // FACTORIAL
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( FFACTORIAL( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           FFACTORIAL( hb_itemGetND( pARG ) ) );
         break;
      }case 25:{  // SCI, NOTATION
         char buf[1024];
         sprintf(buf,"%e", (double) hb_itemGetND( pARG ));
         //char *buf = fun_notation( (double) hb_itemGetND( pARG ), (double) PRECISION );
         const char * buffer = buf;
         hb_arraySetC( pSTK, NDX, buffer );
         //free(buf);
         break;
      }case 26:{   // D2R
         double dInput = hb_itemGetND( pARG );
         double dResult = ( 3.14159265358979323846 / 180.0 ) * dInput;
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision(dResult, PRECISION) : dResult );

         break;
      }case 27:{   // R2D
         double dInput = hb_itemGetND( pARG );
         double dResult = ( 180.0 / 3.14159265358979323846 ) * dInput;
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision(dResult, PRECISION) : dResult );
         
         break;
      }case 28:{   // CBRT raíz cubica
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( cbrt( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           cbrt( hb_itemGetND( pARG ) ) );
         break;
      }case 29:{   // RAND
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( ( hb_random_num() * hb_itemGetND( pARG ) ), PRECISION ) :
                                                           ( hb_random_num() * hb_itemGetND( pARG ) ) );
         break;
      }case 30:{   // TRUNC
         hb_arraySetNL( pSTK, NDX, (long) trunc( hb_itemGetND( pARG ) ));
         break;
      }case 31:{   // EVEN
         hb_arraySetNI( pSTK, NDX, (int) ( fmod(hb_itemGetND( pARG ),2 )==0 ? 1 : 0 ) );
         break;
      }case 32:{   // NEG
         if( HB_IS_DOUBLE( pARG ) )         hb_arraySetND( pSTK, NDX, (double) -hb_itemGetND(pARG) );
         else if( HB_IS_LONG( pARG ) )       hb_arraySetNL( pSTK, NDX, (long)   -hb_itemGetNL(pARG) );
         else if( HB_IS_INTEGER( pARG ) )    hb_arraySetNI( pSTK, NDX, (int)    -hb_itemGetNI(pARG) );
         else sw=0;
         break;
      }case 33:{  // ASIN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( asin( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           asin( hb_itemGetND( pARG ) ) );
         break;
      }case 34:{  // ACOS
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( acos( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           acos( hb_itemGetND( pARG ) ) );
         break;
      }case 35:{  // ATAN
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( atan( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           atan( hb_itemGetND( pARG ) ) );
         break;
      }case 36:{  // ASINH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( asinh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           asinh( hb_itemGetND( pARG ) ) );
         break;
      }case 37:{  // ACOSH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( acosh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           acosh( hb_itemGetND( pARG ) ) );
         break;
      }case 38:{  // ATANH
         hb_arraySetND( pSTK, NDX, (double) SW_PRECISION ? xu_funprecision( atanh( hb_itemGetND( pARG ) ), PRECISION ) :
                                                           atanh( hb_itemGetND( pARG ) ) );
         break;
      }case 39:{  // NOT NEG
         hb_arraySetND( pSTK, NDX, (double) hb_itemGetND( pARG ) >= 0 );
         break;
      }case 40:{  // NOT POS
         hb_arraySetND( pSTK, NDX, (double) hb_itemGetND( pARG ) <= 0 );
         break;

      }default: sw=0;
   }
return sw;
}

int fun_pad_item( PHB_ITEM pARG, PHB_ITEM pPAD, PHB_ITEM pRELL, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
   const char * cText = hb_itemGetCPtr( pARG );
   const char * cRelleno = hb_itemGetCPtr( pRELL );
   HB_MAXINT nSize = hb_itemGetCLen( pARG );
   HB_MAXINT nLen = hb_itemGetNL( pPAD );

   if( nLen <= nSize ){
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) cText );
   }else{
      switch( tCompare){
         case 0: {   // PADC 
            char * szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = cRelleno[0];
            HB_ISIZ nPad = ( ( HB_SIZE ) nLen - nSize ) >> 1;
            //cPad = ' '; //( HB_ISCHAR( 3 ) ? *( hb_parc( 3 ) ) : ' ' );
            memset( szResult, cPad, nPad );
            memcpy( szResult + nPad, cText, nSize );
            memset( szResult + nPad + nSize, cPad, ( HB_SIZE ) nLen - nSize - nPad );
            const char * milenka = szResult;
            hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            free( szResult );
            break;
         }case 1: {  // PADR
            char * szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = cRelleno[0];
//            cPad = ' ';
            memcpy( szResult, cText, nSize );
            memset( szResult + nSize, cPad, ( HB_SIZE ) nLen - nSize );
            const char * milenka = szResult;
            hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            free( szResult );
            break;
         }case 2: {  // PADL
            char * szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = cRelleno[0];
//            cPad = ' ';
            memset( szResult, cPad, ( HB_SIZE ) nLen - nSize );
            memcpy( szResult + ( HB_SIZE ) nLen - nSize, cText, nSize );
            const char * milenka = szResult;
            hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            free( szResult );
            break;
         }
      }
   }
return sw;
}

int fun_getseptok(){
int sw=1;
if(CADDR<nSizeStack){
   const char* tokenizer = TOKENIZER;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) tokenizer );
   
}else{
   sw=put_error((PHB_ITEM) pRET, "GET TOKEN SEPARATOR STACK UNDERFLOW",102); 
}
return sw;
}

int settokenizer(){
int sw=1;
   if( CADDR>0 ){
      PHB_ITEM pToken = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      CADDR += SWKEEP; SWKEEP = 0;
      const char * cToken = hb_itemGetCPtr( pToken );
      hb_itemRelease(pToken);
      TOKENIZER[0]=cToken[0];
   }else{
      sw=put_error((PHB_ITEM) pRET, "DEFINE TOKEN STACK UNDERFLOW",102); 
   }
return sw;
}

int fun_modtoken_item( PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pCTOKEN, PHB_ITEM pSTK_ADDR, int CADDR,char *TOKENIZER ){
int sw=1;

   long cLen = hb_itemGetCLen( pTEXT );
   
   if(cLen){
      long rLen = hb_itemGetCLen( pCTOKEN );
      const char * cTXT = hb_itemGetCPtr( pTEXT );
      const char * cTOK = hb_itemGetCPtr( pCTOKEN );
      int nToken = hb_itemGetNInt( pTOKEN );
   //if(rLen){
      const char* tokenizer = TOKENIZER;
      char *cTexto = (char *)calloc( cLen + 100, 1 );
      char *cFinal = (char *)calloc( cLen + rLen + 100, 1 );
      memcpy( cTexto, cTXT, cLen );
      char* token; 

   //printf("\nCTOK= [%s]\n",cTOK);

      int nTok=1;
      token = strtok(cTexto, tokenizer);
      if( !token ){
         sw=put_error((PHB_ITEM) pRET, "MOD TOKEN|$$ TOKEN SEPARATOR NOT FOUND",103); 
      }else{
      while( token ){
         if( nTok == nToken ){ // guardo el reemplazo
            if( nTok>1 ){
               strncat(cFinal, tokenizer,1 );
            }
            if( cTOK!=NULL ) {
               strcat(cFinal, cTOK );
            }
         }else{  // guardo el token leido
            if(nTok>1) {
               strncat(cFinal, tokenizer,1 );
            }
           /* if( token ) */strcat(cFinal, token );
            
         }  
         token = strtok(0, tokenizer);
         ++nTok;
      }
      }
      if( *cFinal ){
        // cFinal[ strlen(cFinal)]='\0';
         int nLen = strlen(cFinal)-1;
        // printf("LEN = %d- [%s] CHAR = %c\n",nLen,cFinal,cFinal[nLen]);
         if(cFinal[ nLen ]==*tokenizer){
            cFinal[ nLen ]='\0';
         }
         const char * pFinal = cFinal;
         if(*pFinal==*tokenizer){
            ++pFinal;
         }
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) pFinal );
         
      }else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "*");//cTXT );
      }
      free(cTexto);
      free(cFinal);
   }else{
      hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "*" );
   }
return sw;
}

int tottoken( /*int nItem */){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_REG, nItem );
   long cLen = hb_itemGetCLen( pTEXT );
   const char * cTXT = hb_itemGetCPtr( pTEXT );
   
   if( CADDR<nSizeStack ){

      const char* tokenizer = TOKENIZER;
      char *cTexto = (char *)calloc( cLen + 1, 1 );
      memcpy( cTexto, cTXT, cLen );
      char* token; 
      //char* rest = cTexto; 
      int nTok=0;
      token = strtok(cTexto, tokenizer);
      if( !token ){
         sw=put_error((PHB_ITEM) pRET, "TOTAL TOKEN - TOKEN SEPARATOR NOT FOUND",103); 
      }else{

         while( token ){
            token = strtok(0, tokenizer);
            ++nTok;

         }  

         ++CADDR;
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) nTok );
      }
      free(cTexto);
   }else{
      sw=put_error((PHB_ITEM) pRET, "TOTAL TOKEN STACK UNDERFLOW",102);
   }
   hb_itemRelease(pTEXT);
return sw;
}

int fun_gettoken_item( PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pSTK_ADDR, int CADDR, char *TOKENIZER ){
int sw=1;
   long cLen = hb_itemGetCLen( pTEXT );
   const char * cTXT = hb_itemGetCPtr( pTEXT );
   int nToken = hb_itemGetNInt( pTOKEN );
   
      const char* tokenizer = TOKENIZER;
      char *cTexto = (char *)calloc( cLen + 1, 1 );
      memcpy( cTexto, cTXT, cLen );
      char* token; 

      int nTok=1;
      token = strtok(cTexto, tokenizer);
      if( !token ){
         sw=put_error((PHB_ITEM) pRET, "GET TOKEN|$ - TOKEN SEPARATOR NOT FOUND",103); 
      }else{

      if( nToken > 1 ){
         while( token ){
            token = strtok(0, tokenizer);
            ++nTok;
            if( nTok==nToken) break;
         }  
      }
      //++CADDR;
      if( token ){
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) token );
      }else{
         hb_arraySetC( pSTK_ADDR, CADDR, (const char *) "*" );
      }
      }
      free(cTexto);
   
return sw;
}


int fun_pad_matrix_item( PHB_ITEM pARG, PHB_ITEM pPAD, PHB_ITEM pRELL, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);

   int swArrPad=0; //,swDoble=0;

   if( HB_IS_ARRAY(pPAD)){
      swArrPad=1;
   }
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         if(swArrPad){
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
               PHB_ITEM pPAD2 = hb_itemArrayGet( pPAD, i);
               sw=fun_pad_item( (PHB_ITEM)pARG22,(PHB_ITEM)pPAD2,(PHB_ITEM)pRELL,(PHB_ITEM)pRows,(int)i, (int) tCompare );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPAD2);
            }
         }else{
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
               sw=fun_pad_item( (PHB_ITEM)pARG22,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pRows,(int)i, (int) tCompare );
               hb_itemRelease(pARG22);
            }         
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            if(swArrPad){
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPAD2 = hb_itemArrayGet( pPAD, j);
                  sw=fun_pad_item( (PHB_ITEM)pARG222,(PHB_ITEM)pPAD2,(PHB_ITEM)pRELL,(PHB_ITEM)pCols,(int)j, (int) tCompare );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPAD2);
               }
            }else{
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  sw=fun_pad_item( (PHB_ITEM)pARG222,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pCols,(int)j, (int) tCompare );
                  hb_itemRelease(pARG222);
               }
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            if(swArrPad){
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPAD2 = hb_itemArrayGet( pPAD, j);
                  PHB_ITEM pPag = hb_itemArrayNew( d3 );
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     sw=fun_pad_item( (PHB_ITEM)pARG2222,(PHB_ITEM)pPAD2,(PHB_ITEM)pRELL,(PHB_ITEM)pPag,(int)k, (int) tCompare );
                     hb_itemRelease(pARG2222);
                  }
                  hb_arraySet( pCols, j, pPag );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPAD2);
                  hb_itemRelease(pPag);
               }
            }else{
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPag = hb_itemArrayNew( d3 );
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     sw=fun_pad_item( (PHB_ITEM)pARG2222,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pPag,(int)k, (int) tCompare );
                     hb_itemRelease(pARG2222);
                  }
                  hb_arraySet( pCols, j, pPag );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPag);
               }
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int strtran_matrix_item_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                              PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG3, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            sw=strtran_item( (PHB_ITEM) pARG33, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       i, nStart, nCount ) ;
            hb_itemRelease(pARG33);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               sw=strtran_item( (PHB_ITEM) pARG333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pCols,
                                                       j, nStart, nCount ) ;
               hb_itemRelease(pARG333);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG3333 = hb_itemArrayGet( pARG333, k);
                  sw=strtran_item( (PHB_ITEM) pARG3333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pPag,
                                                         k, nStart, nCount ) ;
                  hb_itemRelease(pARG3333);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG333);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int strtran_item_matrix_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                              PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   if(type!=10 || nDim!=1) return 0;

   PHB_ITEM pRows  = hb_itemArrayNew( 1 );
   
   PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, 1);
   sw=strtran_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

   hb_itemRelease(pARG22);
   int i;
   for (i=2; i<=d1; i++ ){
      PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
      PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
      sw=strtran_item( (PHB_ITEM) pString, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

      hb_itemRelease(pARG22);
      hb_itemRelease(pString);
   }
   PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
   hb_arraySet(pSTK_ADDR, CADDR, pString);
   hb_itemRelease(pRows);
   hb_itemRelease(pString);
return sw;
}

int strtran_item_matrix_matrix( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                                PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   HB_MAXINT nDim1=0,d11=0,d12=0, d13=0,type1=0;
   get_size( (PHB_ITEM) pARG1, &nDim1, &d11, &d12, &d13, &type1);
   if(type1!=10) return 0;
   
   if( type==type1 && d1==d11 && d2==d12 && d3==d13 && nDim==nDim1 ){
      PHB_ITEM pRows  = hb_itemArrayNew( 1 );
   
      PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, 1);
      PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, 1);
      sw=strtran_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

      hb_itemRelease(pARG11);
      hb_itemRelease(pARG22);
      int i;
      for (i=2; i<=d1; i++ ){
         PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
         PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
         PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
         sw=strtran_item( (PHB_ITEM) pString, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, (PHB_ITEM) pRows,
                                                       1, nStart, nCount ) ;

         hb_itemRelease(pARG11);
         hb_itemRelease(pARG22);
         hb_itemRelease(pString);
      }
      PHB_ITEM pString = hb_itemArrayGet( pRows, 1);
      hb_arraySet(pSTK_ADDR, CADDR, pString);
      hb_itemRelease(pRows);
      hb_itemRelease(pString);
   }else{
      //printf("T1=%ld DIM1=%ld D1=%ld D2=%ld D3=%ld\n",type,nDim,d1,d2,d3);
      //printf("T2=%ld DIM2=%ld D1=%ld D2=%ld D3=%ld\n",type1,nDim1,d11,d12,d13);
      sw=0;
   }
   
return sw;
}

int strtran_matrix_matrix_matrix( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                                  /*PHB_ITEM pSTK_ADDR, int CADDR,*/ int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG3, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            sw=strtran_item_matrix_matrix( (PHB_ITEM) pARG33, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       i, nStart, nCount ) ;
            hb_itemRelease(pARG33);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               sw=strtran_item_matrix_matrix( (PHB_ITEM) pARG333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pCols,
                                                       j, nStart, nCount ) ;
               hb_itemRelease(pARG333);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG3333 = hb_itemArrayGet( pARG333, k);
                  sw=strtran_item_matrix_matrix( (PHB_ITEM) pARG3333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pPag,
                                                       k, nStart, nCount ) ;
                  hb_itemRelease(pARG3333);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG333);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int strtran_matrix_matrix_item( PHB_ITEM pARG3, PHB_ITEM pARG2, PHB_ITEM pARG1, 
                                PHB_ITEM pSTK_ADDR, int CADDR, int nStart, int nCount ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pARG3, &nDim, &d1, &d2, &d3, &type);
   if(type!=10) return 0;

   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            sw=strtran_item_matrix_item( (PHB_ITEM) pARG33, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pRows,
                                                       i, nStart, nCount ) ;
            hb_itemRelease(pARG33);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               sw=strtran_item_matrix_item( (PHB_ITEM) pARG333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pCols,
                                                       j, nStart, nCount ) ;
               hb_itemRelease(pARG333);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG33 = hb_itemArrayGet( pARG3, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG333 = hb_itemArrayGet( pARG33, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG3333 = hb_itemArrayGet( pARG333, k);
                  sw=strtran_item_matrix_item( (PHB_ITEM) pARG3333, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (PHB_ITEM) pPag,
                                                       k, nStart, nCount ) ;
                  hb_itemRelease(pARG3333);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG333);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG33);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int stuff_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR, PHB_ITEM pPos, PHB_ITEM pDelete ){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;

            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               PHB_ITEM pPOS = hb_itemArrayGet( pPos, i);
               //PHB_ITEM pDELETE = ( HB_IS_ARRAY ( pDelete ) ) ? hb_itemArrayGet( pDelete, i) : pDelete;//NULL;
               sw=(int)stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG22, (PHB_ITEM) pRows, i, (PHB_ITEM) pPOS, (PHB_ITEM) pDelete );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPOS);
               //hb_itemRelease(pDELETE);
            }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;

            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               PHB_ITEM pPOS = hb_itemArrayGet( pPos, i);
              // PHB_ITEM pDELETE = hb_itemArrayGet( pDelete, i);
               PHB_ITEM pCols = hb_itemArrayNew( d2 );
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, j);
                 // PHB_ITEM pDELETE1 = hb_itemArrayGet( pDELETE, j);
                  sw=(int)stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG222, (PHB_ITEM) pCols, j, (PHB_ITEM) pPOS1, 
                                      (PHB_ITEM) pDelete );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPOS1);
                 // hb_itemRelease(pDELETE1);
               }
               hb_arraySet( pRows, i, pCols );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPOS);
               //hb_itemRelease(pDELETE);
               hb_itemRelease(pCols);
            }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         //if( pDelete ){
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               PHB_ITEM pPOS = hb_itemArrayGet( pPos, i);
               //PHB_ITEM pDELETE = hb_itemArrayGet( pDelete, i);
               PHB_ITEM pCols = hb_itemArrayNew( d2 );
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, j);
                  //PHB_ITEM pDELETE1 = hb_itemArrayGet( pDELETE, j);
                  PHB_ITEM pPag = hb_itemArrayNew( d3 );
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     PHB_ITEM pPOS11 = hb_itemArrayGet( pPOS1, k);
                     //PHB_ITEM pDELETE11 = hb_itemArrayGet( pDELETE1, k);
                     sw=(int)stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2222, (PHB_ITEM) pPag, k, (PHB_ITEM) pPOS11, 
                                         (PHB_ITEM) pDelete );
                     hb_itemRelease(pARG2222);
                     hb_itemRelease(pPOS11);
                 //    hb_itemRelease(pDELETE11);
                  }
                  hb_arraySet( pCols, j, pPag );
                  hb_itemRelease(pARG222);
                  hb_itemRelease(pPOS1);
                 // hb_itemRelease(pDELETE1);
                  hb_itemRelease(pPag);
               }
               hb_arraySet( pRows, i, pCols );
               hb_itemRelease(pARG22);
               hb_itemRelease(pPOS);
              // hb_itemRelease(pDELETE);
               hb_itemRelease(pCols);
            }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}



/***********************************************
     HEADER DE ACCESO MATRICIAL A FUNCIONES
 ***********************************************/

/* FUNCION INDEX AT */
int matrix_index_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pMATCH, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=str_index_at( (PHB_ITEM) pTEXT1, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=str_index_at( (PHB_ITEM) pTEXT11, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=str_index_at( (PHB_ITEM) pTEXT111, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int funIndexAt(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // String base
      PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string to search
      PHB_ITEM pMATCH = NULL;
      if( CADDR>0 ){
         pMATCH = hb_itemArrayGet( pSTK_ADDR, CADDR--);   // carcateres a ignorar
      }
      CADDR += SWKEEP; SWKEEP = 0;
      
      if( HB_IS_STRING( pTEXT ) ){
         if( HB_IS_STRING( pSTRING ) ){
            ++CADDR;
            str_index_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
         }else{
            sw=put_error((PHB_ITEM) pRET, "INDEX AT SECOND ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTEXT ) ){
         ++CADDR;

         sw=matrix_index_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pMATCH, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "INDEX AT FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pMATCH);
      hb_itemRelease(pSTRING);
      hb_itemRelease(pTEXT);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INDEX AT STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION COUNT AT */
int matrix_count_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pIGNORE, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=str_count_at( (PHB_ITEM) pTEXT1, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=str_count_at( (PHB_ITEM) pTEXT11, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=str_count_at( (PHB_ITEM) pTEXT111, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int funCountAt(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // String base
      PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string to search
      PHB_ITEM pIGNORE = NULL;
      if( CADDR>0 ){
         pIGNORE = hb_itemArrayGet( pSTK_ADDR, CADDR--);   // carcateres a ignorar
      }
      CADDR += SWKEEP; SWKEEP = 0;
      
      if( HB_IS_STRING( pTEXT ) ){
         if( HB_IS_STRING( pSTRING ) ){
            ++CADDR;
            str_count_at_single( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE/*, (PHB_ITEM) pSTK_ADDR, (int) CADDR*/ );
         }else{
            sw=put_error((PHB_ITEM) pRET, "COUNTER AT SECOND ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTEXT ) ){
         ++CADDR;

         sw=matrix_count_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pIGNORE, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "COUNTER AT FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pIGNORE);
      hb_itemRelease(pSTRING);
      hb_itemRelease(pTEXT);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COUNTER AT STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION AT */
int matrix_at( PHB_ITEM pTEXT, PHB_ITEM pSTRING, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=str_at( (PHB_ITEM) pTEXT1, (PHB_ITEM) pSTRING, (PHB_ITEM) pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=str_at( (PHB_ITEM) pTEXT11, (PHB_ITEM) pSTRING, (PHB_ITEM) pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=str_at( (PHB_ITEM) pTEXT111, (PHB_ITEM) pSTRING, (PHB_ITEM) pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}
int funAt(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // String base
      PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string to search
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pTEXT ) ){
         if( HB_IS_STRING( pSTRING ) ){
            ++CADDR;
            sw=str_at_single( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING /*, (PHB_ITEM) pSTK_ADDR, (int) CADDR */);
         }else{
            sw=put_error((PHB_ITEM) pRET, "AT SECOND ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTEXT ) ){
         ++CADDR;

         sw=matrix_at( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTRING, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "AT FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pSTRING);
      hb_itemRelease(pTEXT);
   }else{
      sw=put_error((PHB_ITEM) pRET, "AT STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCIONES DE STRING DE UN ARGUMENTO */

int fun_str_matrix_item( PHB_ITEM pTEXT, PHB_ITEM pSTK_REG, int CREGISTER, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_str_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i, (int) tCompare );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_str_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j, (int) tCompare );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_str_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k, (int) tCompare );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}

//"len"=>60, "upper"=>61, "lower"=>62, "trim"=>63, "asc"=>64, "rtrim"=>65, "ltrim"=>66, "val"=>67,;
int funStrOneArg( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP-60;
   if ( CADDR>=1 ){
      PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG ) || ( HB_IS_NUMERIC( pARG ) && tCompare==7 ) ){
         ++CADDR;
         sw=fun_str_item_single( (PHB_ITEM) pARG,/* (PHB_ITEM) pSTK_ADDR, (int) CADDR,*/ (int) tCompare );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_str_matrix_item( (PHB_ITEM) pARG, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int) tCompare );
      }else{
         sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(STR) FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(STR) STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCIONES MATEMATICAS DE UN ARGUMENTO */
int fun_num_matrix_item( PHB_ITEM pTEXT, /*PHB_ITEM pSTK_REG, int CREGISTER,*/ int tCompare){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_num_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i, (int) tCompare);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_num_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j, (int) tCompare);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_num_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k, (int) tCompare);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}


// "exp"=>80, "int"=>81, "sign"=>82, "log"=>83, "log10"=>84, "sqrt"=>85, "sin"=>86, "cos"=>87, "tan"=>88,;
// "sinh"=>89, "cosh"=>90, "tanh"=>91, "str"=>92, "floor"=>93, "abs"=>94, "chr"=>95, "ceil"=>96, "exp10"=>97;
int funNumOneArg( /*int tCompare */){
int sw=1;
int tCompare = nPCP<322 ? nPCP-80 : nPCP > 327 ? nPCP - 322 : nPCP-289 ;
   if ( CADDR>=1 ){
      PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_NUMERIC( pARG ) ){
         ++CADDR;
         sw=fun_num_item( (PHB_ITEM) pARG, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int) tCompare);//, (int) PRECISION );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_num_matrix_item( (PHB_ITEM) pARG, (int) tCompare);//, (int) PRECISION );
      }else{
         sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(NUM) FIRST ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INNER-FUNCTION(NUM) STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION MONEY */
int fun_money_matrix_item(PHB_ITEM pARG, PHB_ITEM pDEC, PHB_ITEM pSTK_REG,int CREGISTER){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG1 = hb_itemArrayGet( pARG, i);
            sw=fun_money_item((PHB_ITEM) pARG1, (PHB_ITEM) pDEC, pRows, i);
            hb_itemRelease(pARG1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               sw=fun_money_item((PHB_ITEM) pARG11, (PHB_ITEM) pDEC, pCols, j);
               hb_itemRelease(pARG11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, k);
                  sw=fun_money_item((PHB_ITEM) pARG111, (PHB_ITEM) pDEC, pPag, k);
                  hb_itemRelease(pARG111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}

int fun_money(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pARG  = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento: numero
      PHB_ITEM pDEC = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // decimales
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_NUMERIC( pARG ) ){
         ++CADDR;
         sw=fun_money_item((PHB_ITEM)pARG,(PHB_ITEM)pDEC,(PHB_ITEM)pSTK_ADDR,(int)CADDR);
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_money_matrix_item((PHB_ITEM)pARG,(PHB_ITEM)pDEC,(PHB_ITEM)pSTK_ADDR,(int) CADDR);
      }else{
         sw=put_error((PHB_ITEM) pRET, "MONEY ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
      hb_itemRelease(pDEC);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MONEY STACK UNDERFLOW",102); 
   }
return sw;
}

int fun_pad(/* int tCompare */){
int sw=1;
int tCompare = nPCP-167;
   if ( CADDR>=3 ){
      PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento: numero
      PHB_ITEM pPAD = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // pad
      PHB_ITEM pRELL = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // "relleno"
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG ) ){
         ++CADDR;
         sw=fun_pad_item( (PHB_ITEM)pARG,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pSTK_ADDR,(int)CADDR, (int) tCompare );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;
         sw=fun_pad_matrix_item( (PHB_ITEM)pARG,(PHB_ITEM)pPAD,(PHB_ITEM)pRELL,(PHB_ITEM)pSTK_ADDR,(int) CADDR, (int) tCompare );
      }else{
         sw=put_error((PHB_ITEM) pRET, "PAD ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
      hb_itemRelease(pPAD);
      hb_itemRelease(pRELL);
   }else{
      sw=put_error((PHB_ITEM) pRET, "PAD STACK UNDERFLOW",102); 
   }   
return sw;
}

/* FUNCION MASK */
int fun_mask_matrix_item( PHB_ITEM pTEXT, PHB_ITEM pMASK, PHB_ITEM pRELL, PHB_ITEM pSTK_REG, int CREGISTER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_mask_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, pRows, i );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_mask_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, pCols, j );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_mask_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, pPag, k );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int fun_mask(){
int sw=1;
   if ( CADDR>=3 ){
      PHB_ITEM pARG  = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Argumento
      PHB_ITEM pMASK = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // mascara
      PHB_ITEM pRELL = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // caracter de relleno
      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG ) ){
         ++CADDR;
         sw=fun_mask_item( (PHB_ITEM) pARG, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else if( HB_IS_ARRAY( pARG ) ){
         ++CADDR;

         sw=fun_mask_matrix_item( (PHB_ITEM) pARG, (PHB_ITEM) pMASK, (PHB_ITEM) pRELL, (PHB_ITEM) pSTK_ADDR, (int) CADDR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "MASK ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG);
      hb_itemRelease(pMASK);
      hb_itemRelease(pRELL);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MASK STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUNCION DE MODIFICACION DE TOKENS */
int fun_modtoken_matrix(PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pCTOKEN,
                                  PHB_ITEM pSTK_REG, int CREGISTER, char * TOKENIZER) {
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT1,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,
                                (PHB_ITEM)pRows,(int)i,(char *)TOKENIZER);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT11,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,
                                (PHB_ITEM)pCols,(int)j,(char *)TOKENIZER);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT111,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,
                                (PHB_ITEM)pPag,(int)k,(char *)TOKENIZER);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}


int modtoken( /*int nItem*/ ){
int sw=1;
if( CADDR>=2 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_REG, nItem );
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pCTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;
      sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;

      sw=(int)fun_modtoken_matrix((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else{
      sw=put_error((PHB_ITEM) pRET, "$$|MOD TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pCTOKEN);
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|MOD TOKEN STACK UNDERFLOW",102);
}
return sw;
}

int stack_modtoken(){
int sw=1;
if( CADDR>=3 ){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pCTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;
      sw=(int)fun_modtoken_item((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) && HB_IS_STRING(pCTOKEN) ){
      ++CADDR;

      sw=(int)fun_modtoken_matrix((PHB_ITEM)pTEXT,(PHB_ITEM)pTOKEN,(PHB_ITEM)pCTOKEN,(PHB_ITEM)pSTK_ADDR,(int)CADDR,(char *)TOKENIZER);
   }else{
      sw=put_error((PHB_ITEM) pRET, "$$|MOD TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pCTOKEN);
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|MOD TOKEN STACK UNDERFLOW",102);
}
return sw;
}

/* FUNCIONES OBTENCION DE TOKEN */
int fun_gettoken_matrix( PHB_ITEM pTEXT, PHB_ITEM pTOKEN, PHB_ITEM pSTK_REG, int CREGISTER, char * TOKENIZER ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXT, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            sw=fun_gettoken_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pTOKEN, (PHB_ITEM) pRows, (int) i, (char *)TOKENIZER );
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               sw=fun_gettoken_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pTOKEN, (PHB_ITEM) pCols, (int) j, (char *)TOKENIZER );
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pTEXT, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  sw=fun_gettoken_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pTOKEN, (PHB_ITEM) pPag, (int) k, (char *)TOKENIZER );
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}


int gettoken( /*int nItem*/ ){
int sw=1;
if( CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_REG, nItem );
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;
      sw=(int)fun_gettoken_item( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;

      sw=(int)fun_gettoken_matrix( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else{
      sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN STACK UNDERFLOW",102);
}
return sw;
}

int stack_gettoken(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pTOKEN = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;
      sw=(int)fun_gettoken_item( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else if( HB_IS_ARRAY(pTEXT) && HB_IS_NUMERIC( pTOKEN ) ){
      ++CADDR;

      sw=(int)fun_gettoken_matrix( (PHB_ITEM) pTEXT, (PHB_ITEM) pTOKEN, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (char *)TOKENIZER );
   }else{
      sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN ARGUMENT ERROR",101);
   }
   hb_itemRelease(pTOKEN);
   hb_itemRelease(pTEXT);
}else{
   sw=put_error((PHB_ITEM) pRET, "$|GET TOKEN STACK UNDERFLOW",102);
}
return sw;
}

/* FUNCION COPY - SUBSTR común */
int substr_matrix_item(PHB_ITEM pTEXTO, PHB_ITEM pPOS, PHB_ITEM pLONG, PHB_ITEM pSTK_REG, int CREGISTER){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXTO, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            sw=substr_item(pTEXTO1, pPOS, pLONG, (PHB_ITEM) pRows, i);
            hb_itemRelease(pTEXTO1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               sw=substr_item(pTEXTO11, pPOS, pLONG, (PHB_ITEM) pCols, j);
               hb_itemRelease(pTEXTO11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXTO111 = hb_itemArrayGet( pTEXTO11, k);
                  sw=substr_item(pTEXTO111, pPOS, pLONG, (PHB_ITEM) pPag, k);
                  hb_itemRelease(pTEXTO111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXTO11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }

return sw;
}

int substr_matrix_matrix(PHB_ITEM pTEXTO, PHB_ITEM pPOS, PHB_ITEM pLONG, PHB_ITEM pSTK_REG, int CREGISTER) {
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pTEXTO, &nDim, &d1, &d2, &d3, &type);
HB_MAXINT nDim2=0,d12=0,d22=0,d32=0,type2=0;
get_size( (PHB_ITEM) pPOS, &nDim2, &d12, &d22, &d32, &type2);
if( nDim!=nDim2 || d1!=d12 || d2!=d22 || d3!=d32 ){
   return -1;
}
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, i);
            sw=substr_item(pTEXTO1, pPOS1, pLONG, (PHB_ITEM) pRows, i);
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pPOS1);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               PHB_ITEM pPOS11 = hb_itemArrayGet( pPOS1, j);
               sw=substr_item(pTEXTO11, pPOS11, pLONG, (PHB_ITEM) pCols, j);
               hb_itemRelease(pTEXTO11);
               hb_itemRelease(pPOS11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pPOS1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pTEXTO1 = hb_itemArrayGet( pTEXTO, i);
            PHB_ITEM pPOS1 = hb_itemArrayGet( pPOS, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pTEXTO11 = hb_itemArrayGet( pTEXTO1, j);
               PHB_ITEM pPOS11 = hb_itemArrayGet( pPOS1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pTEXTO111 = hb_itemArrayGet( pTEXTO11, k);
                  PHB_ITEM pPOS111 = hb_itemArrayGet( pPOS11, k);
                  sw=substr_item(pTEXTO111, pPOS111, pLONG, (PHB_ITEM) pPag, k);
                  hb_itemRelease(pTEXTO111);
                  hb_itemRelease(pPOS111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXTO11);
               hb_itemRelease(pPOS11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXTO1);
            hb_itemRelease(pPOS1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_REG, CREGISTER, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=-1;
      }
   }

return sw;
}

int funSubstr(){
int sw=1;
   if (CADDR>=2){
      PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
      PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // string
      if (HB_IS_NUMERIC( pARG1 )){
         if( HB_IS_STRING(pARG2) ){   // tiene un solo argumento: nPos
            if( CADDR > 0 ){    // asume la existencia del tercer parámetro
               PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // porcion a copiar
               CADDR += SWKEEP; SWKEEP = 0;
               if( HB_IS_NUMERIC( pARG3 )){
                  ++CADDR;
                  if( !substr_item(pARG2, pARG1, pARG3, (PHB_ITEM) pSTK_ADDR, CADDR) ){
                     sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR",103); 
               }
               hb_itemRelease(pARG3);
            }else{  // solo actúa con la posición.
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;
               if( !substr_item(pARG2, pARG1, NULL, (PHB_ITEM) pSTK_ADDR, CADDR) ){
                  sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
               }
            }
         }else if( HB_IS_ARRAY( pARG2 ) ){   // es un array. POS puede ser un array, pero 3er arg no. 
            //HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            //get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
            //if( type==10 ){
               if( CADDR > 0 ){    // asume la existencia del tercer parámetro
                  PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // porcion a copiar
                  CADDR += SWKEEP; SWKEEP = 0;
                  if( HB_IS_NUMERIC( pARG3 )){   // solo debe ser numero.
                     ++CADDR;

                     if( !substr_matrix_item(pARG2, pARG1, pARG3, (PHB_ITEM) pSTK_ADDR, CADDR /*, nDim, d1, d2, d3*/) ){
                        sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pARG3);
               }else{
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;

                  if( !substr_matrix_item(pARG2, pARG1, NULL, (PHB_ITEM) pSTK_ADDR, CADDR/*, nDim, d1, d2, d3*/) ){
                     sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                  }
               }
            //}else{
            //   sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR - TYPE MISMATCH",104); 
            //}
         }else{
            sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR - TYPE MISMATCH",104); 
         }
      }else if( HB_IS_ARRAY( pARG1 ) ){   // POS es array.
         if( HB_IS_ARRAY( pARG2 ) ){    // argumento principal debe ser un array, porque POS es array. 3er arg debe ser escalar.
            //HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
            //get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
           // HB_MAXINT nDim1=0,d11=0,d22=0,d33=0,type1=0;
            //get_size( (PHB_ITEM) pARG1, &nDim1, &d11, &d22, &d33, &type1);
            //if( type==10 && type1==11 && nDim==nDim1 && d1==d11 && d2==d22 ){
               if( CADDR > 0 ){    // asume la existencia del tercer parámetro
                  PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // porcion a copiar
                  CADDR += SWKEEP; SWKEEP = 0;
                  if( HB_IS_NUMERIC( pARG3 )){   // solo debe ser numero.
                     ++CADDR;

                     if( !substr_matrix_matrix(pARG2, pARG1, pARG3, (PHB_ITEM) pSTK_ADDR, CADDR /*, nDim, d1, d2, d3*/) ){
                        sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pARG3);
               }else{
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;

                  if( !substr_matrix_matrix(pARG2, pARG1, NULL, (PHB_ITEM) pSTK_ADDR, CADDR /*, nDim, d1, d2, d3*/) ){
                     sw=put_error((PHB_ITEM) pRET, "COPY NOT ENOUGHT MEMORY",100); 
                  }
               }
            //}else{
            //   sw=put_error((PHB_ITEM) pRET, "COPY DIMENSION|RANGE|TYPE ERROR",105); 
            //}
         }else{
            sw=put_error((PHB_ITEM) pRET, "COPY ARGUMENT ERROR - TYPE MISMATCH",104);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "COPY (INITIAL POS) ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG2);
      hb_itemRelease(pARG1);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COPY STACK UNDERFLOW",102); 
   }
return sw;
}

/* FUN_CAT concatena items */

int fun_cat_item_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG2, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM)pARG22, (PHB_ITEM) pRows, (int) i );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM)pARG222, (PHB_ITEM) pCols, (int) j );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM)pARG2222, (PHB_ITEM) pPag, (int) k );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_cat_matrix_item( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=(int)concatenate_item( (PHB_ITEM) pARG11, (PHB_ITEM)pARG2, (PHB_ITEM) pRows, (int) i );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=(int)concatenate_item( (PHB_ITEM) pARG111, (PHB_ITEM)pARG2, (PHB_ITEM) pCols, (int) j );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=(int)concatenate_item( (PHB_ITEM) pARG1111, (PHB_ITEM)pARG2, (PHB_ITEM) pPag, (int) k );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_cat_matrix_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);

HB_MAXINT nDim2=0,d12=0,d22=0,d32=0,type2=0;
get_size( (PHB_ITEM)pARG2, &nDim2, &d12, &d22, &d32, &type2);

if( nDim!=nDim2 || d1!=d12 || d2!=d22 || d3!=d32 ){
   return -1;
} 
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=(int)concatenate_item( (PHB_ITEM) pARG11, (PHB_ITEM)pARG22, (PHB_ITEM) pRows, (int) i );
            hb_itemRelease(pARG11);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=(int)concatenate_item( (PHB_ITEM) pARG111, (PHB_ITEM)pARG222, (PHB_ITEM) pCols, (int) j );
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=(int)concatenate_item( (PHB_ITEM) pARG1111, (PHB_ITEM)pARG2222, (PHB_ITEM) pPag, (int) k );
                  hb_itemRelease(pARG2222); hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222); hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22); hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}
int fun_cat(){
int sw=1;
   if ( CADDR>=2 ){
      PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // primer argumento ARG1 + ARG2
      PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // segundo argumento

      CADDR += SWKEEP; SWKEEP = 0;
      
      /* evalua POSTFIX */  
  /*    if(SW_POSTFIX){    // está dentro de #MATH: invierte operandos.
         PHB_ITEM TMP = pARG1;
         pARG1 = pARG2;
         pARG2 = TMP;
      }*/
      /******************/ 
      if( HB_IS_STRING( pARG1 ) ){
         if( HB_IS_STRING( pARG2 ) ){
            ++CADDR;
            sw=(int)concatenate_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, (int) CADDR );

         }else if( HB_IS_ARRAY( pARG2 ) ){
            ++CADDR;

            sw=fun_cat_item_matrix( (PHB_ITEM)pARG1,(PHB_ITEM)pARG2 /*,(PHB_ITEM)pSTK_ADDR,(int)CADDR*/ );
         }else{
            sw=put_error((PHB_ITEM) pRET, "CAT ARGUMENT ERROR",103); 
         }
         
      }else if( HB_IS_ARRAY( pARG1 ) ){
         if( HB_IS_STRING( pARG2 ) ){
            ++CADDR;

            sw=fun_cat_matrix_item( (PHB_ITEM)pARG1,(PHB_ITEM)pARG2 /*,(PHB_ITEM)pSTK_ADDR,(int)CADDR */);
         }else if( HB_IS_ARRAY( pARG2 ) ){
            ++CADDR;

            sw=fun_cat_matrix_matrix( (PHB_ITEM)pARG1,(PHB_ITEM)pARG2 /*,(PHB_ITEM)pSTK_ADDR,(int)CADDR */);
         }else{
            sw=put_error((PHB_ITEM) pRET, "CAT ARGUMENT ERROR",103); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "CAT ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pARG2);
      hb_itemRelease(pARG1);
   }else{
      sw=put_error((PHB_ITEM) pRET, "CAT STACK UNDERFLOW",102); 
   }
   if( sw==-1) sw=put_error((PHB_ITEM) pRET, "CAT DIMENSION ERROR",106); 
return sw;
}

int fun_delete(){
int sw=1;
if ( CADDR >= 2 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   PHB_ITEM pARG1 = NULL; //hb_itemPutCLPtr( NULL, "", 0 ); //hb_itemPutStrLen( NULL, HB_CDP_ENDIAN_NATIVE, "", 1 );  // operando 1
   if ( HB_IS_STRING( pARG2 ) ){   
     // if ( HB_IS_STRING( pARG1 ) ){   // borra ARG1 en ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         PHB_ITEM pDelete = NULL;
                          
         if ( HB_IS_NUMERIC( pPos ) ){   // borra desde posicion!
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               CADDR += SWKEEP; SWKEEP = 0;
               if( HB_IS_NUMERIC( pDelete )){          
                  ++CADDR;
                  if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                     sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT (TO DELETE) ERROR",103);
               }
            }else{  // borra todo nomás.
               //pDelete = hb_itemPutNInt( NULL, (HB_MAXINT) hb_itemGetCLen( pARG2 ) );
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;  
               if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                  sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
               }
               //sw=put_error((PHB_ITEM) pRET, "DELETE STACK UNDERFLOW");
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT (TO INSERT) ERROR",103);
         }
         hb_itemRelease(pPos);
         if ( pDelete )
            hb_itemRelease(pDelete);
    //  }else{
    //     sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT STR-NULL ERROR");
    //  }
   }else if( HB_IS_ARRAY( pARG2 ) ){
      //if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en array ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         if ( HB_IS_ARRAY( pPos ) ){   // inserta en posicion! POSICION DEBE SER UN ARRAY
            PHB_ITEM pDelete = NULL;
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               CADDR += SWKEEP; SWKEEP = 0;
               if( !HB_IS_ARRAY( pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR (I NEED AN ARRAY)",103);
               }else{
                  ++CADDR;
                  if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                                     (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
                      sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
                  }
               }
            }else{
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;
               if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                                  (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "DELETE NOT ENOUGHT MEMORY",100); 
               }
               //sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT (TO DELETE) ERROR");
            }
            if ( pDelete )
               hb_itemRelease(pDelete);
         }else{
            sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
      //}else{
      //   sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR",103);
      //}                      
   }else{
      sw=put_error((PHB_ITEM) pRET, "DELETE ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG2);
   //hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "DELETE STACK UNDERFLOW",102); 
}

return sw;          
}

int fun_insert(){
int sw=1;
if ( CADDR >= 3 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 1
   if ( HB_IS_STRING( pARG2 ) ){   
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         PHB_ITEM pDelete = hb_itemPutNInt( NULL, (HB_MAXINT) 0 ); //hb_itemGetCLen( pARG2 ) );  //NULL;

         CADDR += SWKEEP; SWKEEP = 0;
         
         if ( HB_IS_NUMERIC( pPos ) ){   // inserta en posicion!
            //if(CADDR>=1) pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
            ++CADDR;
            if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
               sw=put_error((PHB_ITEM) pRET, "INSERT NOT ENOUGHT MEMORY",100); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
         if ( pDelete )
            hb_itemRelease(pDelete);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
      }
   }else if( HB_IS_ARRAY( pARG2 ) ){
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en array ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         if ( HB_IS_ARRAY( pPos ) ){   // inserta en posicion! POSICION DEBE SER UN ARRAY
            PHB_ITEM pDelete = hb_itemPutNInt( NULL, (HB_MAXINT) 0 ); //NULL;
            //if(CADDR>=1) {
              /// pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
            //   if( !HB_IS_ARRAY( pDelete ) ){
            //      sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR");
            //   }
           // }
            CADDR += SWKEEP; SWKEEP = 0;
            
            ++CADDR;
            if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                               (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
               sw=put_error((PHB_ITEM) pRET, "INSERT NOT ENOUGHT MEMORY",100); 
            }
            if ( pDelete )
               hb_itemRelease(pDelete);
         }else{
            sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
      }else{
         sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
      }                      
   }else{
      sw=put_error((PHB_ITEM) pRET, "INSERT ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "INSERT STACK UNDERFLOW",102); 
}

return sw;          
}

int fun_replace(){
int sw=1;
if ( CADDR >= 3 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 1
   if ( HB_IS_STRING( pARG2 ) ){   
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         PHB_ITEM pDelete = NULL;
                          
         if ( HB_IS_NUMERIC( pPos ) ){   // inserta en posicion!
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               CADDR += SWKEEP; SWKEEP = 0;
               
               if( !HB_IS_NUMERIC( pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
               }else{
                  ++CADDR;
                  if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                     sw=put_error((PHB_ITEM) pRET, "REPLACE NOT ENOUGHT MEMORY",100); 
                  }
               }
            }else{
               CADDR += SWKEEP; SWKEEP = 0;
               ++CADDR;
               if( !stuff_item( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, pPos, pDelete )){
                  sw=put_error((PHB_ITEM) pRET, "REPLACE NOT ENOUGHT MEMORY",100); 
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
         if ( pDelete )
            hb_itemRelease(pDelete);
      }else{
         sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
      }
   }else if( HB_IS_ARRAY( pARG2 ) ){
      if ( HB_IS_STRING( pARG1 ) ){   // inserta ARG1 en array ARG2
         PHB_ITEM pPos = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // posicion
         if ( HB_IS_ARRAY( pPos ) ){   // inserta en posicion! POSICION DEBE SER UN ARRAY
            PHB_ITEM pDelete = NULL;
            if(CADDR>=1) {
               pDelete = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // asume caracteres a borrar
               //if( !HB_IS_ARRAY( pDelete ) ){
               if( !HB_IS_NUMERIC( pDelete ) ){
                  sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            ++CADDR;
            if( !stuff_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, CADDR, 
                               (PHB_ITEM) pPos, (PHB_ITEM) pDelete ) ){
               sw=put_error((PHB_ITEM) pRET, "REPLACE NOT ENOUGHT MEMORY",100); 
            }
            if ( pDelete )
               hb_itemRelease(pDelete);
         }else{
            sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pPos);
      }else{
         sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
      }                      
   }else{
      sw=put_error((PHB_ITEM) pRET, "REPLACE ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "REPLACE STACK UNDERFLOW",102); 
}

return sw;          
}

/* REPLICATE FUNCION */

// pARG1 = TEXTO, pARG2 = TIMES

int fun_replicate_matrix_item( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=(int)replicate_item( (PHB_ITEM) pARG11, (PHB_ITEM) pRows, (int) i, (PHB_ITEM) pARG2 );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=(int)replicate_item( (PHB_ITEM) pARG111, (PHB_ITEM) pCols, (int) j, (PHB_ITEM) pARG2 );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=(int)replicate_item( (PHB_ITEM) pARG1111, (PHB_ITEM) pPag, (int) k, (PHB_ITEM) pARG2 );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_replicate_matrix_matrix( PHB_ITEM pARG1, PHB_ITEM pARG2 ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM)pARG1, &nDim, &d1, &d2, &d3, &type);

HB_MAXINT nDim2=0,d12=0,d22=0,d32=0,type2=0;
get_size( (PHB_ITEM)pARG2, &nDim2, &d12, &d22, &d32, &type2);

if( nDim!=nDim2 || d1!=d12 || d2!=d22 || d3!=d32 ){
   return -1;
} 
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1 && sw; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=(int)replicate_item( (PHB_ITEM) pARG11, (PHB_ITEM) pRows, (int) i, (PHB_ITEM) pARG22 );
            hb_itemRelease(pARG11);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=(int)replicate_item( (PHB_ITEM) pARG111, (PHB_ITEM) pCols, (int) j, (PHB_ITEM) pARG222 );
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1 && sw; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2 && sw; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3 && sw; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=(int)replicate_item( (PHB_ITEM) pARG1111, (PHB_ITEM) pPag, (int) k, (PHB_ITEM) pARG2222 );
                  hb_itemRelease(pARG2222); hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222); hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22); hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int fun_replicate(/*int nItem*/){
int sw=1;
int nItem = nPCP == 171 ? 0 : STK_PRG[ ++CP ];
//   if ( CADDR>=2 ){
   PHB_ITEM pTIMES;      // primer argumento: num
   if( nItem==0 ){
      pTIMES = hb_itemArrayGet( pSTK_ADDR, CADDR--);  
   }else{   // valor diferente de 0 = numero de registro
      pTIMES = hb_itemArrayGet( pSTK_REG, nItem );
   }
      PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  //segundo argumento string, replicate(ARG1, ARG2)
      
   CADDR += SWKEEP; SWKEEP = 0;
   
      if(HB_IS_NUMERIC( pTIMES )){
         if( HB_IS_STRING( pTEXT ) ){
            ++CADDR;
            if(! (int)replicate_item( (PHB_ITEM) pTEXT, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (PHB_ITEM) pTIMES )){
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            }
         }else if( HB_IS_ARRAY( pTEXT ) ){
            ++CADDR;
          /*****  
            PHB_ITEM pBUFFER = hb_itemArrayNew(3);
            hb_arraySet(pBUFFER,1,(PHB_ITEM) pTEXT);
            hb_arraySet(pBUFFER,2,(PHB_ITEM) pTIMES);
            hb_arraySet(pBUFFER,3,(PHB_ITEM) pSTK_ADDR);
            if(!(int)fun_generico_matrix_item((PHB_ITEM) pBUFFER, 3, 8))
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            hb_itemRelease(pBUFFER);
          *****/
            if(!fun_replicate_matrix_item( (PHB_ITEM)pTEXT, /*(PHB_ITEM) pSTK_ADDR, (int) CADDR, */(PHB_ITEM) pTIMES )){
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
         }
      }else if( HB_IS_ARRAY( pTIMES ) && HB_IS_ARRAY( pTEXT ) ){
            ++CADDR;
          /*****  
            PHB_ITEM pBUFFER = hb_itemArrayNew(3);
            hb_arraySet(pBUFFER,1,(PHB_ITEM) pTEXT);
            hb_arraySet(pBUFFER,2,(PHB_ITEM) pTIMES);
            hb_arraySet(pBUFFER,3,(PHB_ITEM) pSTK_ADDR);
            if(!(int)fun_generico_matrix_matrix((PHB_ITEM) pBUFFER, 3, 1))
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            hb_itemRelease(pBUFFER);
          *****/           
            if(!fun_replicate_matrix_matrix( (PHB_ITEM)pTEXT, /*(PHB_ITEM) pSTK_ADDR, (int) CADDR,*/ (PHB_ITEM) pTIMES )){
               sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
            }
      }else{
         sw=put_error((PHB_ITEM) pRET, "REPLICATE ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pTIMES);
      hb_itemRelease(pTEXT);
//   }else{
//      sw=put_error((PHB_ITEM) pRET, "REPLICATE STACK UNDERFLOW",102); 
//   }
   
return sw;
}

int fun_transform(){
int sw=1;
if ( CADDR >= 3 ) {
   PHB_ITEM pARG3 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // el string base
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // el reemplazo
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // lo que busca
   

   if( HB_IS_STRING( pARG1 ) ){   // el nuevo string es un escalar.
      if( HB_IS_STRING( pARG2 ) ){   // el string a reemplazar es un escalar.
         if( HB_IS_STRING( pARG3 ) ){  // string base es un escalar
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_item_single( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, /* (PHB_ITEM) pSTK_ADDR, 
                                     CADDR,*/ 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY",100); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_item_single( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,/* (PHB_ITEM) pSTK_ADDR,
                                        CADDR,*/ nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY",100); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_item_single( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,/* (PHB_ITEM) pSTK_ADDR,
                                        CADDR,*/ nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY",100);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else if( HB_IS_ARRAY( pARG3 ) ){  // string base es un array
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_matrix_item_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                 (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_matrix_item_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_matrix_item_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "TRANSFORM SOURCE STRING ARGUMENT ERROR",103);
         }
      }else if( HB_IS_ARRAY( pARG2 ) ){   // el nuevo string es un array de posibles string a reemplazar.
         if( HB_IS_STRING( pARG3 ) ){  // string base es un escalar
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_item_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                 (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_item_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_item_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                    (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else if( HB_IS_ARRAY( pARG3 ) ){  // string base es un array
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_matrix_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                   (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  } 
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_matrix_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_matrix_matrix_item( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "TRANSFORM SOURCE STRING ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "TRANSFORM STRING TO REPLACE ARGUMENT ERROR",103);
      }
   }else if( HB_IS_ARRAY( pARG1 ) ){   // nuevo string es un array
      if( HB_IS_ARRAY( pARG2 ) ){   // strnig a remplazar DEBE sER un array
         if( HB_IS_STRING( pARG3 ) ){  // string base es un escalar
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_item_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                   (PHB_ITEM) pSTK_ADDR, CADDR, 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_item_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_item_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                      (PHB_ITEM) pSTK_ADDR, CADDR, nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else if( HB_IS_ARRAY( pARG3 ) ){  // string base es un array
            switch( CADDR ){
               case 0: {  // reemplaza todo
                  CADDR += SWKEEP; SWKEEP = 0;
                  ++CADDR;
                  if( !strtran_matrix_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, 
                                                     /*(PHB_ITEM) pSTK_ADDR, CADDR,*/ 1, -1 ) ){
                     sw=put_error((PHB_ITEM) pRET, "(1)TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                  }
                  break;
               }case 1: {   // asume iniciar reemplazo en la "N" ocurrencia
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     if( !strtran_matrix_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                        /*(PHB_ITEM) pSTK_ADDR, CADDR,*/ nStart, -1 ) ){
                        sw=put_error((PHB_ITEM) pRET, "(2)TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110); 
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  break;
               }default: {  // asume iniciar en "N", y reemplazar "M" ocurrencias
                  PHB_ITEM pStart = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  PHB_ITEM pCount = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                  CADDR += SWKEEP; SWKEEP = 0;
                  if ( HB_IS_NUMERIC( pStart ) && HB_IS_NUMERIC( pCount ) ){
                     ++CADDR;
                     long nStart = hb_itemGetNInt( pStart );
                     long nCount = hb_itemGetNInt( pCount );
                     if( !strtran_matrix_matrix_matrix( (PHB_ITEM) pARG3, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1,
                                                        /*(PHB_ITEM) pSTK_ADDR, CADDR,*/ nStart, nCount ) ){
                        sw=put_error((PHB_ITEM) pRET, "(3)TRANSFORM NOT ENOUGHT MEMORY|TYPE MISMATCH",110);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "TRANSFORM START OR COUNT TO REPLACE ARGUMENT ERROR",103); 
                  }
                  hb_itemRelease(pStart);
                  hb_itemRelease(pCount);
                  break;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "TRANSFORM SOURCE STRING ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "TRANSFORM STRING TO REPLACE ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "TRANSFORM NEW STRING ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG3);
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "TRANSFORM STACK UNDERFLOW",102); 
}
return sw;
}


/****************************************************
    FUNCIONES DE ASIGNACIONES Y MANEJO DE STACK
 ****************************************************/

//int PushCopyReg(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int PushCopyReg(/* long nARG*/ ){

   // extrae argumentos:
int sw=1;
///do{
   long nARG = STK_PRG[ ++CP ];
   ++CADDR;  // aumenta CADDR
   // CHEQUEAR SI ES ARRAY LO QUE METE EN PILA
   if ( CADDR > nSizeStack ){ //ERROR
      sw=put_error((PHB_ITEM) pRET, "PUSH STACK OVERFLOW",101);
   }else{
      // obtengo valor de registro:
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG);
      if ( !HB_IS_ARRAY( pSource ) ){   // no es un array
         hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pSource  );  // parece que con esto basta. single copia igual

      }else{
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 ); // creo array ajustado a los rangos.
               int i;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                  put_value(pRows, pARGS, i, PRECISION);
                  hb_itemRelease(pARGS);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pCols, pARGC, j, PRECISION);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARGF);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               int i;
               for(i=1; i<=d1; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  int j;
                  for(j=1; j<=d2; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k;
                     for(k=d1; k<=d3; k++){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAYP, pARGP, k, PRECISION);
                        hb_itemRelease(pARGP);
                     }
                     hb_arraySet(pARRAYC, j, pARRAYP);
                     hb_itemRelease(pARRAYP);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet(pARRAY, i, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }
         }
      }
      hb_itemRelease(pSource);
   }
//}while ( STK_PRG[++CP] ); // CP==1 pushcopyreg
//--CP;
return sw;
}


int PushReg( /*long nARG*/ ){
   // extrae argumentos:
int sw=1;
do{
   long nARG = STK_PRG[ ++CP ];
   ++CADDR;  // aumenta CADDR
   // CHEQUEAR SI ES ARRAY LO QUE METE EN PILA
   if ( CADDR > nSizeStack ){ //ERROR
      sw=put_error((PHB_ITEM) pRET, "PUSH STACK OVERFLOW",101);
      return sw;
   }else{
      // obtengo valor de registro:
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARG);    
      // chequea tipo de valor obtenido y guarda en STK_ADDR:
      hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pSource  );  // parece que con esto basta. single copia igual
      //put_value(pSTK_ADDR, pSource, CADDR, PRECISION);
      hb_itemRelease(pSource);
   }
}while ( STK_PRG[++CP]==0 && sw); // CP==0 pushreg
--CP;
return sw;
}


//int PushDS( int STK_PRG[], PHB_ITEM pSTK_DS, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){//,
int PushDS( /*long nItem */){
int sw=1;
//do{
   // extrae argumentos:
   long nItem = STK_PRG[ ++CP ];
   PHB_ITEM pRegSource = hb_itemArrayGet( pSTK_REG, nItem );
   
   // obtengo valor de registro:
              
   ++CADDR;  // aumenta CADDR
   if ( CADDR > nSizeStack ){
      //ERROR
      sw=put_error((PHB_ITEM) pRET, "PUSH STACK OVERFLOW",101);
      hb_itemRelease(pRegSource);
      return sw;
   }else{
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_DS, hb_itemGetNInt( pRegSource ) );
      
      if ( HB_IS_ARRAY( pSource ) ){   // es un array
         PHB_ITEM pSourceA = hb_itemArrayGet( pSource, 1);
         // obtengo valor de registro:
         hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pSourceA  );
         hb_itemRelease(pSourceA);
      }else{
         // chequea tipo de valor obtenido y guarda en STK_ADDR:
         put_value(pSTK_ADDR, pSource, CADDR, PRECISION);
      }
      hb_itemRelease(pSource);
      hb_itemRelease(pRegSource);
   }   

//}while ( STK_PRG[++CP]==2 ); // CP==2 pushds
//--CP;
return sw;
}



/* 1=CPY: copia un dato del stack a un registro, igual que MOV, pero sin sacarlo */
/* 0=MOV: mueve el resultado a un registro. Si hay marcas, mueve el rango asociado */
int move_stack_reg( /*int nARGd,*//* int TIPO*/){
int sw=1;
//do{
   int nARGd = STK_PRG[++CP];
   if (CADDR >0){
      // extrae argumentos:

      //unsigned int nARGd=(unsigned int)STK_PRG[++CP];
      // obtengo valor de registro:
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, nPCP==245 ? CADDR : CADDR--); // lee dato
      
      if ( HB_IS_ARRAY( pSource ) ){  // es un array!!
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1:{
               int nIni=1, nFin=d1;
            //   if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
            //   if( OFFSET_POS ) {nFin=OFFSET_POS;}
               PHB_ITEM pRows  = hb_itemArrayNew( nFin - nIni + 1 ); // creo array ajustado a los rangos.
               int i, nPos=1;
               for (i=nIni; i<=nFin; i++ ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                  put_value(pRows, pARGS, nPos++, PRECISION);
                  hb_itemRelease(pARGS);
               }
               hb_arraySet(pSTK_REG, nARGd, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
            
               PHB_ITEM pRows = hb_itemArrayNew( nFinR - nIniR + 1 );
               int i,rPos=1;
               for( i=nIniR; i<=nFinR; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  PHB_ITEM pCols = hb_itemArrayNew( nFinC - nIniC + 1 );
                  int j,cPos=1;
                  for( j=nIniC; j<=nFinC; j++){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pCols, pARGC, cPos++, PRECISION);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet( pRows, rPos++, pCols );
                  hb_itemRelease(pARGF);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_REG, nARGd, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               int nPagIni=1, nPagFin=d3;
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;

   
               PHB_ITEM pARRAY = hb_itemArrayNew( nFinR - nIniR + 1 );
               int i, rPos=1;
               for(i=nIniR; i<=nFinR; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( nFinC - nIniC + 1 );
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                  int j, cPos=1;
                  for(j=nIniC; j<=nFinC; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( nPagFin - nPagIni + 1 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k,kPos=1;
                     for(k=nPagIni; k<=nPagFin; k++){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAYP, pARGP, kPos++, PRECISION);
                        hb_itemRelease(pARGP);
                     }
                     hb_arraySet(pARRAYC, cPos++, pARRAYP);
                     hb_itemRelease(pARRAYP);
                     hb_itemRelease(pARGC);
                  }
                  hb_arraySet(pARRAY, rPos++, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }
         }
      }else{
         put_value(pSTK_REG, pSource, nARGd, PRECISION);
      }
      hb_itemRelease(pSource);
/*      if(!TIPO) {
         hb_arrayDel(pSTK_ADDR,nSizeStack);
         hb_ret();
         hb_gcCollect();
      } */

   }else{
      // error
      sw=put_error((PHB_ITEM) pRET, "MOV|CPY STACK UNDERFLOW",102);                 
   }
  /* if(STK_PRG[CP+1]==201 || STK_PRG[CP+1]==245){ // mov o cpy
      ++CP;
      sw=move_stack_reg();
   }*/
//   ++CP;
//}while ( STK_PRG[CP]==201 || STK_PRG[CP]==245 ); // CP==1 pushreg
//--CP;
return sw;
}

/* DETERMINA LARGO DE LA DIMENSION A DEFINIR EN NUEVO ARRAY 
   PARA GETARRAY, PUTARRAY Y LET */
int get_length(int nIni, int nFin, int nInc){

   int n1 = nFin - nIni + 1;
   int n2 = (int) (n1 / nInc);
   return  n2 + (fmod(n1,nInc)>0 ? 1 : 0 );
}


//int LetReg(PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pRET, int PRECISION){//,
//int LetReg(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pRET){//, int PRECISION){//,
int LetReg(){
int sw=1;

//do{
int nARGd = STK_PRG[ ++CP ]; // destino
int nARGs = STK_PRG[ ++CP ]; // source
PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nARGd);
if (!HB_IS_ARRAY(pSource) && !HB_IS_ARRAY(pPRE)){
    put_value(pSTK_REG, pSource, nARGd, PRECISION);
    hb_itemRelease(pSource);hb_itemRelease(pPRE);
    return sw;
}

if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   //int nARGd = STK_PRG[ ++CP ]; // destino
   //int nARGs = STK_PRG[ ++CP ]; // source
   //PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
   if(HB_IS_ARRAY( pSource )){
      switch(RANGEDIM){
         case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==RANGEDIM){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                        
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i);
                  PHB_ITEM pELEM = hb_itemArrayGet( pSource, hb_itemGetNI(pCOORD));
                  put_value(pRows, pELEM, i, PRECISION);
                  hb_itemRelease(pELEM);
                  hb_itemRelease(pCOORD);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }case 2:{   // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==2 && RANGECOL==2){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                        
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  put_value(pRows, pELEMCOL, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pCOORDROW);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else if(nDim1==3 && RANGECOL==3){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                        
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  PHB_ITEM pELEMPAG = hb_itemArrayGet( pELEMCOL, hb_itemGetNI(pROWP));
                  put_value(pRows, pELEMPAG, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pROWP);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pELEMPAG);
                  hb_itemRelease(pCOORDROW);
               }
               hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }
      }
   }else{ // fuente no es array, pero target si.
      //sw=put_error((PHB_ITEM) pRET, "LET REGISTER TYPE MUST BE ARRAY WITH RANGE",104);
      //PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nARGd);
/*      if(!HB_IS_ARRAY(pPRE)){
         sw=put_error((PHB_ITEM) pRET, "LET TARGET TYPE MUST BE ARRAY",104);
      }else{*/
         if(HB_IS_ARRAY(pPRE)){   // target es array?
            switch(RANGEDIM){
               case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==RANGEDIM){
                     unsigned int i;
                     //PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                        
                        put_value(pPRE, pSource, hb_itemGetNI(pCOORD), PRECISION);

                        hb_itemRelease(pCOORD);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==2 && RANGECOL==2){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango


                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
   
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                  
                        put_value(pROW, pSource, hb_itemGetNI(pROWY), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else if(nDim1==3 && RANGECOL==3){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                       
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
      
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                        PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                        PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                        put_value(pCOL, pSource, hb_itemGetNI(pROWP), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);
                        hb_itemRelease(pROWP);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOL);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }
            }
         }else{  // es solo una asignación a una variable tipo simple
           // sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET TYPE MUST BE ARRAY",104);
            if( SW_PUNTERO ) hb_arraySet(pSTK_REG, nARGd, pSource); 
            else             put_value(pSTK_REG, pSource, nARGd, PRECISION);
         }
//      }
      hb_itemRelease(pPRE);
   }
   hb_itemRelease(pSource);
}else{

   int swOffset=0;
   // extrae argumentos:
   //int nARGd = STK_PRG[ ++CP ]; // destino
   //int nARGs = STK_PRG[ ++CP ]; // source
   // obtengo valor de registro:
   //PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
   // si quiero copiar un array en un registro, el destino debe ser un array?
   // ver hb_itemCopy y hb_itemMove. o dejo ARRAYSET, dado que funciona con PUSH.
   
   if ( HB_IS_ARRAY( pSource ) ){   // es un array. OK!
      if( SW_PUNTERO ){
         hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pSource  );  // esto copia el puntero. 
      }else{
     /* DECISION:
       X ¿copiare solo una porcion del arreglo segun rangos, creando una nueva matriz con rango ajustado?
        ¿crearé nueva matriz con dimensiones identicas al Source, pero solo copiaré lo definido por los rangos? */
     /* PROBLEMA: Si marco [2],[1:5,1] (una columna y una página), me genera un array 3D de size=5,1,1. Eso está mal.
        Debería generar un array simple de 5 elementos.
        Mismo caso para array simples desde donde saco solo un elemento ==> debería ser SINGLE.
        1D = OK
        2D = 
        3D = 
        TODO! */
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
      switch( nDim ){
         case 1:{
           // printf("\nENTRE A 1D INI=%d, FIN=%d",1,d1);
            unsigned int nIni=1, nFin=d1;
            //if( MARK_POS == 999999999 ) MARK_POS=d1;
            //if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
            if (normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)){
               if( OFFSET_POS ) {
                  if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                  nFin=OFFSET_POS;
               }
               if( nIni != nFin ){

                    PHB_ITEM pRows ; // = hb_itemArrayNew( nFin - nIni + 1 );
                    int nInc=SET_INTERVAL_ROW,i=nIni;
                    if(nFin < nIni){
                       int nTmp = nIni; nIni = nFin; nFin=nTmp; nInc=-SET_INTERVAL_ROW;
                    }
                    //int nLong=nFin - nIni + 1;
                    int nLong=get_length(nIni,nFin,SET_INTERVAL_ROW);
                    pRows  = hb_itemArrayNew( nLong );
                    int nPos=1;
                    while ( nLong-- ){
                       PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                       put_value(pRows, pARGS, nPos++, PRECISION);
                       hb_itemRelease(pARGS);
                       i = i + nInc;
                    }

                     hb_arraySet(pSTK_REG, nARGd, pRows);
                     hb_itemRelease(pRows);

               }else{   // solo devuelve un elemento  SINGLE.
                  if( MARK_POS<=d1 ){
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_POS );
                     put_value(pSTK_REG, pARGS, nARGd, PRECISION);
                     hb_itemRelease(pARGS);               
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET MARK OVERFLOW",101);
                  }
               }
            }
            break;
         }case 2:{
            //printf("\nENTRE A 2D\n");
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
           // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
            if( !( sw=normaliza_indices_2d( &nIniR, &nFinR, &nIniC, &nFinC, d1, d2, &swOffset,
                                            &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL) ) ){
                hb_itemRelease(pSource);hb_itemRelease(pPRE);
                return sw;
            }
          //  printf("\nPASA 2\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
          /* 4 CASOS:  
                1.- OFFSET ROW=OFFSET_COL=0     => devuelve SINGLE
                2.- OFFSET_ROW>0, OFFSET_COL=0  => devuelve array 1D
                3.- OFFSET_ROW=0, OFFSET_ROW>0  => devuelve array 1D
                4.- OFFSET_ROW>0, OFFSET_COL>0  => devuelve array 2D. Ya hecho. */
               
            if( !OFFSET_COL ){   // SINGLE
               if( !OFFSET_ROW ){
                  
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                  PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                  put_value(pSTK_REG, pARGC, nARGd, PRECISION);
                  hb_itemRelease(pARGC);
                  hb_itemRelease(pARGS);
               
               }else{  // ARRAY 1D (recorre las filas)
                  int nInc=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                  }
                  //int nLong=nFinR - nIniR + 1;
                  int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int rPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     put_value(pRows, pARGC, rPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     i = i + nInc;
                  }
                  hb_arraySet(pSTK_REG, nARGd, pRows);
                  hb_itemRelease(pRows);
               }   
            }else{ 
               if( !OFFSET_ROW ){  // ARRAY 1D (recorre las columnas)
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                  int nInc=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                  }
                  //int nLong=nFinC - nIniC + 1;
                  int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int cPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pRows, pARGC, cPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     j = j + nInc;                  
                  }
                  hb_itemRelease(pARGF);
                  hb_arraySet(pSTK_REG, nARGd, pRows);
                  hb_itemRelease(pRows);
               }else{   // 2D
                  int nIncR=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                  }
                  //int nLongR=nFinR - nIniR + 1;
                  int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLongR );
                  int rPos=1;
                  int nIncC=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                  }
                  //int nLongC=nFinC - nIniC + 1;
                  int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  int cTmp = j;  // guardo para reasignar dentro del ciclo
                  while ( nLongR-- ){
                     int cLongCTmp=nLongC;
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pCols  = hb_itemArrayNew( cLongCTmp );
                     int cPos=1, j=cTmp;
                     while ( cLongCTmp-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                        put_value(pCols, pARGC, cPos++, PRECISION);
                        hb_itemRelease(pARGC);
                        j = j + nIncC;
                     }
                     hb_arraySet( pRows, rPos++, pCols );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pCols);
                     i = i + nIncR;
                  }
                  
                  hb_arraySet(pSTK_REG, nARGd, pRows);
                  hb_itemRelease(pRows);
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
            break;
         }case 3:{
            unsigned int nPagIni=1, nPagFin=d3;
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
            if( !(sw=normaliza_indices_3d(&nIniR, &nFinR, &nIniC, &nFinC, &nPagIni, &nPagFin, d1, d2, d3, &swOffset,
                         &MARK_PAGE, &OFFSET_POS, &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL)) ){
                 hb_itemRelease(pSource);hb_itemRelease(pPRE);
                 return sw; 
            }

           /* CASOS:
               1.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS=0     => SINGLE
               2.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS=0     => 1D
               3.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS=0     => 1D
               4.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS=0     => 2D
               5.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS>0     => 1D
               6.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS>0     => 2D
               7.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS>0     => 2D
               8.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS>0     => 3D
           */
            if( !OFFSET_POS ){
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // SINGLE
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                     PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE );
                     put_value(pSTK_REG, pARGP, nARGd, PRECISION);
                     hb_itemRelease(pARGP);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGS);
                  }else{   // lee solo columnas: array 1D
                     int nInc=SET_INTERVAL_COL,i=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                     }
                     //int nLong=nFinC - nIniC + 1;
                     int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLong );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, i);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        i = i + nInc;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY);                   
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // lee solo filas: array 1D
                     int nInc=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                     }
                    // int nLong=nFinR - nIniR + 1;
                     int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nInc;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                    // int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongR );
                     int rPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                           put_value(pARRAYC, pARGP, cPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);  
                  }
               }
            }else{    // existe desplazamiento de páginas
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // solo desplaza un elemento por página: array 1D
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                    // int nLong=nPagFin - nPagIni + 1;
                     int nLong=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int kPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAY, pARGP, kPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        k = k + nIncP;
                     }
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     
                     hb_itemRelease(pARRAY);

                  }else{   // lee solo columnas por página: array 2D
                     // esto está mal: deben haber OFFSET_POS filas, y OFFSET_COL columnas, o sea, a verre.
                     // ahora sí:
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongP );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int kPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongP-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYP = hb_itemArrayNew( cLongCTmp );
                        int pPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYP, pARGP, pPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, kPos++, pARRAYP);
                        hb_itemRelease(pARRAYP);
                        k = k + nIncP;
                     }
                     
                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY); 
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // recorre solo filas, una columna, por página: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = k;
                     while( nLongR-- ){
                        int cLongPTmp=nLongP;
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);  // leo fila
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);  // leo única columna
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongPTmp );  // m-columnas                        
                        int kPos=1, k=cTmp;
                        while( cLongPTmp-- ){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYC, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           k = k + nIncP;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }

                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas y páginas: array 3D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = j;
                     int kTmp = k;
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1;
                        j=cTmp;
                        while( cLongCTmp-- ){
                           int cLongPTmp=nLongP;
                           PHB_ITEM pARRAYP = hb_itemArrayNew( cLongPTmp );
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           int kPos=1;
                           k=kTmp;
                           while( cLongPTmp-- ){
                              PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                              put_value(pARRAYP, pARGP, kPos++, PRECISION);
                              hb_itemRelease(pARGP);
                              k = k + nIncP;
                           }
                           hb_arraySet(pARRAYC, cPos++, pARRAYP);
                           hb_itemRelease(pARRAYP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }

                     hb_arraySet( pSTK_REG, nARGd, (PHB_ITEM) pARRAY );
                     hb_itemRelease(pARRAY);                  
                  }
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0; }
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "LET SOURCE DIMENSION ERROR",106);
         }
      }
      }
   }else {     // fuente no es un array
         // determinar get_size 
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pPRE, &nDim, &d1, &d2, &d3, &type);
         ///printf("DESTINO ARRAY indice = %d\n",nARGd); fflush(stdout);
         switch( nDim ){
            case 1: {
               unsigned int i;
               
               unsigned int nIni=1, nFin=d1;

               if (normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)){
                  if( OFFSET_POS ) {
                     if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                     nFin=OFFSET_POS;
                  }
               
                  unsigned int nInc=SET_INTERVAL_ROW; //,i=nIni;
                  if(nFin < nIni){
                      unsigned int nTmp = nIni; nIni = nFin; nFin=nTmp;// nInc=-SET_INTERVAL_ROW;
                  }
                  for(i=nIni; i<=nFin; i+=nInc){
                     put_value(pPRE, pSource, i, PRECISION);
                  }
                  hb_arraySet( pSTK_REG, nARGd, pPRE );
               }
               break;
            }case 2: {
               unsigned int i;

               unsigned int nIniR=1, nFinR=d1;
               unsigned int nIniC=1, nFinC=d2;
               if( !( sw=normaliza_indices_2d( &nIniR, &nFinR, &nIniC, &nFinC, d1, d2, &swOffset,
                                               &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL) ) ){
                   hb_itemRelease(pSource);hb_itemRelease(pPRE);
                   return sw;
               }
           // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);

               unsigned int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               unsigned int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               for(i=nIniR; i<=nFinR; i+=nIncR){
                  PHB_ITEM pREGF = hb_itemArrayGet( pPRE, i); 
                  unsigned int j;
                  for(j=nIniC; j<=nFinC; j+=nIncC){
                     put_value(pREGF, pSource, j, PRECISION);
                  }
                  hb_arraySet( pPRE, i, pREGF );
                  hb_itemRelease(pREGF);
               }
               hb_arraySet( pSTK_REG, nARGd, pPRE );
               break;
            }case 3: {

               unsigned int nPagIni=1, nPagFin=d3;
               unsigned int nIniR=1, nFinR=d1;
               unsigned int nIniC=1, nFinC=d2;
               if( !(sw=normaliza_indices_3d(&nIniR, &nFinR, &nIniC, &nFinC, &nPagIni, &nPagFin, d1, d2, d3, &swOffset,
                                             &MARK_PAGE, &OFFSET_POS, &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL)) ){
                   hb_itemRelease(pSource);hb_itemRelease(pPRE);
                   return sw; 
               }

               unsigned int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        unsigned int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               unsigned int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        unsigned int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               unsigned int nIncP=SET_INTERVAL_PAG; //,k=nIniP;
               if(nFinC < nIniC){
                        unsigned int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               unsigned int k=0;
               for(k=nPagIni; k<=nPagFin; k+=nIncP){
                  unsigned int i;
                  for( i=nIniR; i<=nFinR; i+=nIncR ){
                     PHB_ITEM pREGF = hb_itemArrayGet( pPRE, i);      // saco fila de REG
                     unsigned int j;
                     for( j=nIniC; j<=nFinC; j+=nIncC ){
                        PHB_ITEM pREGC = hb_itemArrayGet( pREGF, j);     // columna del registro
                        hb_arraySet( pREGC, k, pSource );
                        hb_arraySet( pREGF, j, pREGC );
                        hb_itemRelease( pREGC );
                     }
                     hb_arraySet( pPRE, i, pREGF );
                     hb_itemRelease( pREGF );
                  }
               }
               hb_arraySet(pSTK_REG, nARGd, pPRE);
               break;
            }default:{
               sw=put_error((PHB_ITEM) pRET, "LET TARGET DIMENSION ERROR",106);
            }
         }
   }
   SW_PUNTERO=0;
   hb_itemRelease(pSource);
   hb_itemRelease(pPRE);
}
//}while ( STK_PRG[++CP]==3 ); // CP==3 letreg
//--CP;
return sw;
}


int LetDS( /*long nARGd, long nARGs*/){

/* OJO: AQUI NO HAY PUNTEROS A ASIGNAR, PORQUE VIENE DEL STACK INTERNO DE HARBOUR */

SW_PUNTERO=0;   // RESETEO PUNTERO, POR SI EL PROGRAMADOR SACOHUEA SE EQUIVOCO
   
int sw=1;
//   int swOffset=0;
   // extrae argumentos:

if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   int nARGd = STK_PRG[ ++CP ]; // destino
   int nARGs = STK_PRG[ ++CP ]; // source
   PHB_ITEM pRegSource = hb_itemArrayGet( pSTK_REG, nARGs );//(int)STK_PRG[ ++CP ] );
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_DS, hb_itemGetNInt( pRegSource ));
   
   hb_itemRelease(pRegSource);
      PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nARGd);

         if(HB_IS_ARRAY(pPRE)){   // target es array?
            switch(RANGEDIM){
               case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==RANGEDIM){
                     unsigned int i;
                     //PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                        
                        put_value(pPRE, pSource, hb_itemGetNI(pCOORD), PRECISION);

                        hb_itemRelease(pCOORD);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
                  HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
                  get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
                  if(nDim1==2 && RANGECOL==2){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
   
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                  
                        put_value(pROW, pSource, hb_itemGetNI(pROWY), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else if(nDim1==3 && RANGECOL==3){
                     unsigned int i;
                     //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                     PHB_ITEM pREG = NULL;
                     if( SW_ORIGIN_RANGE )
                        pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                     else
                        pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                     for(i=1;i<=RANGEROW;i++){
                       
                        PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
      
                        PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                        PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                        PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                        PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                        put_value(pCOL, pSource, hb_itemGetNI(pROWP), PRECISION);
                        hb_itemRelease(pROWX);
                        hb_itemRelease(pROWY);
                        hb_itemRelease(pROWP);

                        hb_itemRelease(pROW);
                        hb_itemRelease(pCOL);
                        hb_itemRelease(pCOORDROW);
                     }
                     hb_itemRelease(pREG);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET DIMENSION ERROR",111);
                  }
                  break;
               }
            }
         }else{
           // sw=put_error((PHB_ITEM) pRET, "LET RANGE->ARRAY TARGET TYPE MUST BE ARRAY",104);
            if( SW_PUNTERO ) hb_arraySet(pSTK_REG, nARGd, pSource); 
            else             put_value(pSTK_REG, pSource, nARGd, PRECISION);
         }

      hb_itemRelease(pPRE);

      hb_itemRelease(pSource);
}else{   
   long nARGd = STK_PRG[ ++CP ]; // destino
   long nARGs = STK_PRG[ ++CP ]; // source
   
   PHB_ITEM pRegSource = hb_itemArrayGet( pSTK_REG, nARGs );//(int)STK_PRG[ ++CP ] );
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_DS, hb_itemGetNInt( pRegSource ));
   
   hb_itemRelease(pRegSource);
   // CHEQUEA ARRAY en DESTINO.
              
   if( ! HB_IS_ARRAY( pSource ) ){    // fuente no es un array?

      PHB_ITEM pARRAYTMP = hb_itemArrayGet( pSTK_REG, nARGd);
      if ( HB_IS_ARRAY( pARRAYTMP ) ) {      // destino es un array? 
         // determinar get_size 
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pARRAYTMP, &nDim, &d1, &d2, &d3, &type);
         switch( nDim ){
            case 1: {
               int i;

               int nIni=1, nFin=d1;
               if( MARK_POS == 999999999 ) MARK_POS=d1;
               if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
               if( OFFSET_POS ) {
                  if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                  nFin=OFFSET_POS;
               }
               
               int nInc=SET_INTERVAL_ROW; //,i=nIni;
               if(nFin < nIni){
                   int nTmp = nIni; nIni = nFin; nFin=nTmp;// nInc=-SET_INTERVAL_ROW;
               }
               for(i=nIni; i<=nFin; i+=nInc){
                  put_value(pARRAYTMP, pSource, i, PRECISION);
               }
               hb_arraySet( pSTK_REG, nARGd, pARRAYTMP );
               break;
            }case 2: {
               int i;

               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
           // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "LET ROW'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniR=MARK_ROW;nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET ROW'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
              //    swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "LET COL'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniC=MARK_COL;nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET COL'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
            //      swOffset=1;
                  OFFSET_COL=nFinC;
               }

               int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               for(i=nIniR; i<=nFinR; i+=nIncR){
                  PHB_ITEM pREGF = hb_itemArrayGet( pARRAYTMP, i); 
                  int j;
                  for(j=nIniC; j<=nFinC; j+=nIncC){
                     put_value(pREGF, pSource, j, PRECISION);
                  }
                  hb_arraySet( pARRAYTMP, i, pREGF );
                  hb_itemRelease(pREGF);
               }
               hb_arraySet( pSTK_REG, nARGd, pARRAYTMP );
               break;
            }case 3: {

               int nPagIni=1, nPagFin=d3;
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
               if( MARK_PAGE ){
                  if( MARK_PAGE == 999999999 ) MARK_PAGE=d3;
                  if( MARK_PAGE>d3 ){
                     sw=put_error((PHB_ITEM) pRET, "LET PAGE'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nPagIni=MARK_PAGE; nPagFin=MARK_PAGE;
                  if( OFFSET_POS ){
                     if( OFFSET_POS == 999999999 ) OFFSET_POS=d3;
                     if( OFFSET_POS<=d3 ){
                        nPagFin=OFFSET_POS;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET PAGE'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  } 
               }else{  // si no existe marca de página, se asume todo; luego:
   //               swOffset=1;
                  OFFSET_POS=nPagFin; 
               }
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "LET ROW'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniR=MARK_ROW;nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET ROW'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
                  //swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "LET COL'MARK OVERFLOW",101);
                     hb_itemRelease(pSource);
                     return sw;               
                  }
                  nIniC=MARK_COL;nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "LET COL'OFFSET OVERFLOW",101);
                        hb_itemRelease(pSource);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
         //         swOffset=1;
                  OFFSET_COL=nFinC;
               }


               int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
               if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
               }
               int nIncC=SET_INTERVAL_COL; //,j=nIniC;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               int nIncP=SET_INTERVAL_PAG; //,k=nIniP;
               if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; // nIncC=-SET_INTERVAL_COL;
               }
               int k=0;
               for(k=nPagIni; k<=nPagFin; k+=nIncP){
                  int i;
                  for( i=nIniR; i<=nFinR; i+=nIncR ){
                     PHB_ITEM pREGF = hb_itemArrayGet( pARRAYTMP, i);      // saco fila de REG
                     int j;
                     for( j=nIniC; j<=nFinC; j+=nIncC ){
                        PHB_ITEM pREGC = hb_itemArrayGet( pREGF, j);     // columna del registro
                        hb_arraySet( pREGC, k, pSource );
                        hb_arraySet( pREGF, j, pREGC );
                        hb_itemRelease( pREGC );
                     }
                     hb_arraySet( pARRAYTMP, i, pREGF );
                     hb_itemRelease( pREGF );
                  }
               }
               hb_arraySet(pSTK_REG, nARGd, pARRAYTMP);
               break;
            }default:{
               sw=put_error((PHB_ITEM) pRET, "LET TARGET DIMENSION ERROR",106);
            }
         }
      }else{    // destino no es un array    
         // chequea tipo de valor obtenido y guarda en STK_ADDR:
         if( SW_PUNTERO ) hb_arraySet(pSTK_REG, nARGd, pSource); 
         else             put_value(pSTK_REG, pSource, nARGd, PRECISION);
      }
      hb_itemRelease(pARRAYTMP);

   }else{  // esto NUNCA debería pasar.
      sw=put_error((PHB_ITEM) pRET, "LET TYPE MISMATCH",101);
   }
   hb_itemRelease(pSource);
}
return sw;
}


/****************************************************
    FUNCIONES DE SALTO Y SALTO CON RETORNO
 ***************************************************/

//int jumpEQ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpEQ( /* long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){
   long Jumper = STK_PRG[ ++CP ] - 1;
///   ++CP;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       double pDbl1 = hb_itemGetND( pARG1 );
       double pDbl2 = hb_itemGetND( pARG2 );
       // guardar dirección de retorno.
       if ( pDbl2 == pDbl1 ) CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
       const char * pString1 = hb_itemGetCPtr( pARG1 );
       const char * pString2 = hb_itemGetCPtr( pARG2 );
                      // guardar dirección de retorno.
       if ( strcmp(pString2,pString1) == 0 ) CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else{
       sw=put_error((PHB_ITEM) pRET, "JEQ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JEQ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNEQ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNEQ( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       double pDbl1 = hb_itemGetND( pARG1 );
       double pDbl2 = hb_itemGetND( pARG2 );
       // guardar dirección de retorno.
       if ( pDbl2 != pDbl1 ) CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
       const char * pString1 = hb_itemGetCPtr( pARG1 );
       const char * pString2 = hb_itemGetCPtr( pARG2 );
       // guardar dirección de retorno.
       if ( strcmp(pString2,pString1) != 0)  CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else{
       sw=put_error((PHB_ITEM) pRET, "JNEQ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNEQ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpLT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpLT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) < hb_itemGetND( pARG2 ) )  CP = Jumper; //STK_PRG[ CP ] - 1; 

   }else{
       sw=put_error((PHB_ITEM) pRET, "JLT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JLT STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpLTE( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpLTE( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) <= hb_itemGetND( pARG2 ) ) CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JLT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JLT STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpGT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpGT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) > hb_itemGetND( pARG2 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JGT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JGT STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpGTE( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpGTE( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 2 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // penultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) && HB_IS_NUMERIC( pARG2 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) >= hb_itemGetND( pARG2 ) ) CP = Jumper; //STK_PRG[ CP ] - 1;

   }else{
       sw=put_error((PHB_ITEM) pRET, "JGE ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JGE STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

 /*  if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else{
       sw=put_error((PHB_ITEM) pRET, "JT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JT STACK UNDERFLOW",102); 
}
return sw;
}

int jumpSpecialT( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
 ///  CADDR += SWKEEP; SWKEEP = 0;

 /*  if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else{
       sw=put_error((PHB_ITEM) pRET, "JST ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JST STACK UNDERFLOW",102); 
}
return sw;
}

int jumpSpecialNT(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
/////   CADDR += SWKEEP; SWKEEP = 0;

 /*  if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( !hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( !hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
        else  ++CADDR;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( !hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       else  ++CADDR;
   }else{
       
       sw=put_error((PHB_ITEM) pRET, "JSNT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JSNT STACK UNDERFLOW",102); 
}
return sw;
}


//int jumpNT( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNT(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

/*   if( HB_IS_LOGICAL( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( !hb_itemGetL( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else */if( HB_IS_NUMERIC( pARG1 )) {
       if ( !hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else if( HB_IS_STRING( pARG1 )) {
       if ( !hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       
       sw=put_error((PHB_ITEM) pRET, "JNT ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNT STACK UNDERFLOW",102); 
}
return sw;
}


//int jumpV( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpV( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_STRING( pARG1 ) ) {
       // guardar dirección de retorno.hb_itemGetCLen( pSource )
       if ( !hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JV ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JV STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNV( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNV(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_STRING( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetCLen( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1; 
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNV ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNV STACK UNDERFLOW",102); 
}
return sw;
}


int jumpNNeg(){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) >=0  )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNNEG ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNNEG STACK UNDERFLOW",102); 
}
return sw;
}

int jumpNPos(){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   if (SWKEEP){
       CADDR += SWKEEP; SWKEEP = 0;
   }
   //CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) <=0  )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNPOS ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNPOS STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpZ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpZ( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( !hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JZ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JZ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNZ( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNZ(/* long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNZ ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNZ STACK UNDERFLOW",102); 
}
return sw;
}

//int jumpNEG( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpNEG(/* long Jumper */){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) < 0 )  CP = Jumper; //STK_PRG[ CP ] - 1;
       
   }else{
       sw=put_error((PHB_ITEM) pRET, "JNEG ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JNEG STACK UNDERFLOW",102); 
}
return sw;
}


//int jumpPOS( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpPOS( /*long Jumper*/ ){
int sw=1;
if ( CADDR >= 1 ){

   long Jumper = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) > 0 )  CP = Jumper; //STK_PRG[ CP ] - 1;
   }else{
       sw=put_error((PHB_ITEM) pRET, "JPOS ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "JPOS STACK UNDERFLOW",102); 
}
return sw;
}

int jumpSingle(){
              ++CP;
              CP = STK_PRG[ CP ] - 1;
return 1;
}
//int jumpJSUB( int STK_PRG[], PHB_ITEM pRET ){
int jumpJSUB( ){
int sw=1;

unsigned int nJump = STK_PRG[ ++CP ];
              sw= (int) push_label( (int) (CP+1) ) ;
              CP = nJump - 1;

return sw;
}


//int jumpGOSUB( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int jumpGOSUB(/* long nJump */){
int sw=1;
if ( CADDR >= 1 ){

   long nJump = STK_PRG[ ++CP ] - 1;
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // no consume: va a usar el contenido del stack
   CADDR += SWKEEP; SWKEEP = 0;
   
 /*  if( HB_IS_LOGICAL ( pARG1 )) {  // quita el valor del stack
      // CADDR--;
       if ( hb_itemGetL( pARG1 ) ) {
          sw= (int) push_label( (int) (CP+1) ) ;
          CP = nJump; // - 1; 
       }
       
   }else */if( HB_IS_NUMERIC( pARG1 ) ) {
       // guardar dirección de retorno.
       if ( hb_itemGetND( pARG1 ) ) {
          sw= (int) push_label( (int) (CP+1) );
          CP = nJump; // - 1;
       }
   
   }else if( HB_IS_STRING ( pARG1 )) {
       if ( hb_itemGetCLen( pARG1 ) ) {
          sw= (int) push_label( (int) (CP+1) ) ;
          CP = nJump; // - 1;
       }

   }else if( HB_IS_ARRAY ( pARG1 )) {
       sw= (int) push_label( (int) (CP+1) ) ;
       CP = nJump; // - 1;
   
   }else{
       sw=put_error((PHB_ITEM) pRET, "GOSUB ARGUMENT ERROR -- TYPE MISMATCH",104); 
   }
   hb_itemRelease(pARG1);

}else{
   // error
   sw=put_error((PHB_ITEM) pRET, "GOSUB STACK UNDERFLOW",102); 
}
return sw;
}


/****************************************************
    FUNCIONES LOGICAS Y MATEMATICAS
 ****************************************************/


int fun_matrix_mul(){
int sw=1;
if( CADDR>=2 ){
    PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
    PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
    CADDR += SWKEEP; SWKEEP = 0;
    
    if( HB_IS_ARRAY( pA ) && HB_IS_ARRAY( pB ) ){
       HB_MAXINT nDimA=0,dA1=0,dA2=0, dA3=0,typeA=0;
       get_size( (PHB_ITEM) pA, &nDimA, &dA1, &dA2, &dA3, &typeA);
       HB_MAXINT nDimB=0,dB1=0,dB2=0, dB3=0,typeB=0;
       get_size( (PHB_ITEM) pB, &nDimB, &dB1, &dB2, &dB3, &typeB);
       
       unsigned int pRow = (unsigned int) dA1;
       unsigned int pCol1 = (unsigned int) dA2;   // cols1
       unsigned int pCol2 = (unsigned int) dB2;   // cols2
       
       if( nDimA == nDimB && dA2 == dB1 ){
          unsigned int ehx,eix,ejx;
          double ESX;
          PHB_ITEM pCWM = hb_itemArrayNew( pRow ); // CWM
          for( ehx=1; ehx<=pRow; ehx++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, ehx);
             PHB_ITEM pCC = hb_itemArrayNew( pCol2 ); // CWM
             for( ejx=1; ejx<=pCol2; ejx++){
                ESX = 0;
                for( eix=1; eix<=pCol1; eix++){
                   PHB_ITEM pA2 = hb_itemArrayGet( pAA, eix);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, eix);
                   PHB_ITEM pB2 = hb_itemArrayGet( pBB, ejx );
                   ESX = ESX + hb_itemGetND( pA2 ) *
                               hb_itemGetND( pB2 );
                   hb_itemRelease( pA2 );
                   hb_itemRelease( pB2 );
                   hb_itemRelease( pBB );
                } 
                hb_arraySetND( pCC, ejx, ESX );  
             }
             hb_arraySet( pCWM, ehx, pCC );
             hb_itemRelease(pCC);
             hb_itemRelease(pAA);
          }
          hb_arraySet( pSTK_ADDR, ++CADDR, pCWM );
          hb_itemRelease(pCWM);
       }else{
          sw=put_error((PHB_ITEM) pRET, "MATRICIAL MULTIPLICATION DIMENSION ERROR",106);
       }
    }else{
       sw=put_error((PHB_ITEM) pRET, "MATRICIAL MULTIPLICATION ARGUMENT ERROR",103);
    }
    hb_itemRelease(pB);
    hb_itemRelease(pA);    
}else{
    sw=put_error((PHB_ITEM) pRET, "MATRICIAL MULTIPLICATION INNER-STACK OVERFLOW",101);
}
return sw;
}


int compare_str_item(PHB_ITEM pSTK_ADDR, PHB_ITEM pARG2, PHB_ITEM pARG1, int CADDR, int tCompare){
int sw=1;
   switch( tCompare ){
      case 0:{hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( strcmp(hb_itemGetCPtr( pARG2 ),hb_itemGetCPtr( pARG1 )) == 0 ) );break;}
      case 1:{hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( strcmp(hb_itemGetCPtr( pARG2 ),hb_itemGetCPtr( pARG1 )) != 0 ) );break;}
      case 8:{hb_arraySetNI( pSTK_ADDR, CADDR, (int)  hb_strAt( hb_itemGetCPtr( pARG2 ), hb_itemGetCLen( pARG2 ),
                                                                    hb_itemGetCPtr( pARG1 ), hb_itemGetCLen( pARG1 ) ) > 0 );
              break;}
      case 9:{hb_arraySetNI( pSTK_ADDR, CADDR, (int)  hb_striAt( hb_itemGetCPtr( pARG2 ), hb_itemGetCLen( pARG2 ),
                                                                    hb_itemGetCPtr( pARG1 ), hb_itemGetCLen( pARG1 ) ) > 0 );
              break;}
      case 51:{   // xtobool  str-->bool
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) hb_itemGetCLen(pARG2));
         break;
      }default: sw=0;
   }
return sw;
}


int compare_item(PHB_ITEM pSTK, PHB_ITEM pARG2, PHB_ITEM pARG1, int ndx, int tCompare){
int sw=1;
   switch( tCompare ){
      case 0:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) == hb_itemGetND( pARG1 )) ); break;}
      case 1:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) != hb_itemGetND( pARG1 )) ); break;}
      case 2:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) <  hb_itemGetND( pARG1 )) ); break;}
      case 3:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) <= hb_itemGetND( pARG1 )) ); break;}
      case 4:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) >  hb_itemGetND( pARG1 )) ); break;}
      case 5:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) >= hb_itemGetND( pARG1 )) ); break;}
      case 6:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) < 0 )); break;}
      case 7:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) > 0 )); break;}
      case 10:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) == 0 )); break;}
      case 51:{  // xtobool num->bool
         hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetND( pARG2 ) ));
         break;
      }
      default: sw=0;
   }
return sw;
}


int logic_num_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=compare_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=compare_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=compare_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int logic_num_matrix_item(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=compare_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, i, (int) tCompare);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=compare_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG1, j, (int) tCompare);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=compare_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1, k, (int) tCompare);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int logic_str_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

int logic_str_matrix_item(PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, HB_MAXINT nDim, 
                           HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG1, (PHB_ITEM) pARG22, i, (int) tCompare);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG1, (PHB_ITEM) pARG222, j, (int) tCompare);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2222, k, (int) tCompare);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

// "eqto"=>267, "neqto"=>268,"lthan"=>269,"lethan"=>270,"gthan"=>271,"gethan"=>272,
int logical_espCompare( /*int nReg,*/ /*int tCompare*/){
int sw=1;
int tCompare = nPCP-267;
if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo. 
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pARG2  = hb_itemArrayGet( pSTK_REG, nReg);
   //printf("\nPASS...%d; %d\n",HB_IS_NUMERIC( pARG2 ),HB_IS_NUMERIC( pARG1 ));
   if ( HB_IS_NUMERIC( pARG2 ) && HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      if(!compare_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
      ++CADDR;
      if(!compare_str_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG1 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG2 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG2 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG2 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG1, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "(1)LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",103); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "(2)LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else if( HB_IS_ARRAY( pARG2 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG1 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG1 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG1 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG2, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",106); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "(3)LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else{
      sw=put_error((PHB_ITEM) pRET, "(4)LOGICAL COMPARE ARGUMENT ERROR",103); 
   }
  // if( tCompare!=6&&tCompare!=7&&tCompare!=10&&tCompare!=51 ){
      hb_itemRelease(pARG2);
  // }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE STACK UNDERFLOW",102); 
}
return sw;
}
              
//int logicalCompare( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET, int tCompare ){
int logicalCompare( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP != 51 ? (int)nPCP-23 : 51;
if ( CADDR >= 1 ){
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ultimo. 
   PHB_ITEM pARG1 = NULL; 
   
   if( tCompare==6||tCompare==7||tCompare==10||tCompare==51 ){
      //pARG2 = pARG1;
      pARG1 = pARG2;
   }else{
      if( CADDR == 0){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE STACK UNDERFLOW",102); 
         hb_itemRelease(pARG2);
         hb_itemRelease(pARG1);
         return sw;
      }
      pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      /* evalua POSTFIX */  
    /*  if(SW_POSTFIX){    // está dentro de #MATH: invierte operandos.
         PHB_ITEM TMP = pARG1;
         pARG1 = pARG2;
         pARG2 = TMP;
      }*/
      /******************/  
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if ( HB_IS_NUMERIC( pARG2 ) && HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      if(!compare_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_STRING(pARG2) && HB_IS_STRING(pARG1) ){
      ++CADDR;
      if(!compare_str_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG1 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG2 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG2 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG2 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG1, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG1, pARG2, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",103); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else if( HB_IS_ARRAY( pARG2 )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
      get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
      if( HB_IS_NUMERIC( pARG1 )){
         if( type == 11 ){
            ++CADDR;
            if(!logic_num_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_STRING( pARG1 )){
         if( type == 10 ){
            ++CADDR;
            if(!logic_str_matrix_item(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE TYPE MISMATCH",104); 
         }
      }else if(HB_IS_ARRAY( pARG1 )){                
         HB_MAXINT nDim2=0,d21=0,d22=0,d23=0/*,d4=0*/,type2=0;
         get_size( (PHB_ITEM) pARG2, &nDim2, &d21, &d22, &d23, &type2);
         if( type == type2 && nDim == nDim2 && d1 == d21 && d2 == d22 ){
            if(type == 11 ){
               ++CADDR;
               //printf("\nPASA*******************************\n");
               if(!logic_num_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else if(type == 10){
               ++CADDR;
               if(!logic_str_matrix_matrix(pARG2, pARG1, pSTK_ADDR, nDim, d1, d2, d3, tCompare)){
                  sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE FUNCTION OUT OF CONTEXT",108);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE DIMENSION ERROR",106); 
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
      }

   }else{
      sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE ARGUMENT ERROR",103); 
   }
   if( tCompare!=6&&tCompare!=7&&tCompare!=10&&tCompare!=51 ){
      hb_itemRelease(pARG2);
   }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "LOGICAL COMPARE STACK UNDERFLOW",102); 
}
return sw;
}


int logic_eqarr_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT nDim, 
                            HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3,int TIPO){
int swOK=1;
   double nArg1, nArg2;
   const char * cArg1, * cArg2;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            if(TIPO){
               nArg1 = hb_itemGetND(pARG11);
               nArg2 = hb_itemGetND(pARG22);
            }else{
               cArg1 = hb_itemGetCPtr( pARG11 );
               cArg2 = hb_itemGetCPtr( pARG22 );
            }
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            if(TIPO){
               if( nArg1!=nArg2 ){
                   swOK=0; break;
               }
            }else{
               if ( strcmp( cArg1 , cArg2 ) != 0 ){
                   swOK=0; break;
               }
            }
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               if(TIPO){
                  nArg1 = hb_itemGetND(pARG111);
                  nArg2 = hb_itemGetND(pARG222);
               }else{
                  cArg1 = hb_itemGetCPtr( pARG111 );
                  cArg2 = hb_itemGetCPtr( pARG222 );
               }
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);

               if(TIPO){
                  if( nArg1!=nArg2 ){
                      swOK=0; break;
                  }
               }else{
                  if ( strcmp( cArg1 , cArg2 ) != 0 ){
                      swOK=0; break;
                  }
               }
            }
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            if(!swOK) break;
         }
         break;
      }case 3:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  if(TIPO){
                     nArg1 = hb_itemGetND(pARG1111);
                     nArg2 = hb_itemGetND(pARG2222);
                  }else{
                     cArg1 = hb_itemGetCPtr( pARG1111 );
                     cArg2 = hb_itemGetCPtr( pARG2222 );
                  }
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
                  if(TIPO){
                     if( nArg1!=nArg2 ){
                         swOK=0; break;
                     }
                  }else{
                     if ( strcmp( cArg1 , cArg2 ) != 0 ){
                        swOK=0; break;
                     }
                  }
               }
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               if(!swOK) break;
            }
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            if(!swOK) break;
         }
         break;
      }
   }
return swOK;
}
/*

*/

int fun_eqarr(){
int sw=1;

if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pARG2 = NULL;
   if (nPCP == 339 || nPCP == 340 ) {
      if (CADDR>=1)
         pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      else{
         sw=put_error((PHB_ITEM) pRET, "EQARR STACK UNDERFLOW",102);
         hb_itemRelease(pARG1);
         return sw;
      }
   }else{
      int nARG2 = STK_PRG[++CP];
      pARG2 = hb_itemArrayGet( pSTK_REG, nARG2 );
   }
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_ARRAY( pARG1 ) && HB_IS_ARRAY( pARG2 )){

      HB_MAXINT nDim1=0,d1=0,d21=0,d31=0,type1=0;
      get_size( (PHB_ITEM) pARG1, &nDim1, &d1, &d21, &d31, &type1);       
      HB_MAXINT nDim2=0,d2=0,d22=0,d32=0,type2=0;
      get_size( (PHB_ITEM) pARG2, &nDim2, &d2, &d22, &d32, &type2);
      if( type1 == type2 && nDim1 == nDim2 && d1 == d2 && d21 == d22 && d31 == d32 ){
          if(type1 == 11 ){  // numeros
               int lEqual = logic_eqarr_matrix_matrix(pARG1, pARG2, nDim1, d1, d21, d31,1);
               if ( nPCP == 339 || nPCP == 375)  // EQARR|EQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, lEqual );
               else               // NEQARR|NEQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, ! lEqual );
          }else if(type1 == 10){  // strings
               int lEqual = logic_eqarr_matrix_matrix(pARG2, pARG1, nDim1, d1, d21, d31,0);
               if ( nPCP == 339 || nPCP == 375)  // EQARR|EQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, lEqual );
               else               // NEQARR|NEQARRTO
                  hb_arraySetNInt(pSTK_ADDR, ++CADDR, ! lEqual );
          }else{
               sw=put_error((PHB_ITEM) pRET, "EQARR|TO ARGUMENT ERROR",103); 
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "EQARR|TO DIMENSION ERROR",106); 
      }
   }else{
       sw=put_error((PHB_ITEM) pRET, "EQARR|TO ARGUMENT ERROR: MUST BE ARRAYS",103); 
   }
   hb_itemRelease(pARG1);
   hb_itemRelease(pARG2);
}else{
   sw=put_error((PHB_ITEM) pRET, "EQARR|TO STACK UNDERFLOW",102); 
}
return sw;
}

/* operación con cuadrados.
   1) todos son escalares
    */
int fun_sqrcompute(){
int sw=1;
int tCompare = nPCP - 333; /* 334=diff, 335=add, 336=hypot, 337=mulall, 338=sumall */
if (CADDR>=2){
//   PHB_ITEM pARGY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // X^2
//   PHB_ITEM pARGX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // Y^2
   
//   if(HB_IS_NUMERIC(pARGX) && HB_IS_NUMERIC(pARGY)){
//      double nARGX = hb_itemGetND( pARGX );
//      double nARGY = hb_itemGetND( pARGY );
      int nIndex=1;
      switch(tCompare){
         case 1:{ //  DIFF SQR
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, nIndex++);
            --CADDR;
            double nARG = hb_itemGetND( pARG );
            double nRES = SW_PRECISION ? xu_funprecision( nARG*nARG, PRECISION ) : nARG*nARG ;
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, nIndex++);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES -= (double) SW_PRECISION ? xu_funprecision( nARGZ*nARGZ, PRECISION ) : nARGZ*nARGZ;
               hb_itemRelease(pARGZ);
               --CADDR;
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);

/*                  CADDR += SWKEEP; SWKEEP = 0;
                  hb_arraySetND(pSTK_ADDR, ++CADDR, ( (double) SW_PRECISION ? xu_funprecision( nARGX*nARGX - nARGY*nARGY, PRECISION ) : nARGX*nARGX - nARGY*nARGY )); */
                  break; 
         }case 2:{ // ADD SQR 
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, nIndex++);
            --CADDR;
            double nARG = hb_itemGetND( pARG );
            double nRES = SW_PRECISION ? xu_funprecision( nARG*nARG, PRECISION ) : nARG*nARG ;
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, nIndex++);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES += (double) SW_PRECISION ? xu_funprecision( nARGZ*nARGZ, PRECISION ) : nARGZ*nARGZ;
               hb_itemRelease(pARGZ);
               --CADDR;
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);
            
/*                  CADDR += SWKEEP; SWKEEP = 0; 
                  hb_arraySetND(pSTK_ADDR, ++CADDR, ( (double) SW_PRECISION ? xu_funprecision( nARGX*nARGX + nARGY*nARGY, PRECISION ) : nARGX*nARGX + nARGY*nARGY )); */
                  break;
         }case 3:{  // HYPOT
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, nIndex++);
            --CADDR;
            double nARG = hb_itemGetND( pARG );
            double nRES = SW_PRECISION ? xu_funprecision( nARG*nARG, PRECISION ) : nARG*nARG ;
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, nIndex++);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES += (double) SW_PRECISION ? xu_funprecision( nARGZ*nARGZ, PRECISION ) : nARGZ*nARGZ;
               hb_itemRelease(pARGZ);
               --CADDR;
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) SW_PRECISION ? xu_funprecision( sqrt(nRES), PRECISION ) : sqrt(nRES));
/*                   CADDR += SWKEEP; SWKEEP = 0;
                   hb_arraySetND(pSTK_ADDR, ++CADDR, (double) SW_PRECISION ? xu_funprecision( sqrt( nARGX*nARGX + nARGY*nARGY ), PRECISION ) : sqrt( nARGX*nARGX + nARGY*nARGY )); */
                  break;
         }case 4:{   // MULALL
            //double nRES = (double) SW_PRECISION ? xu_funprecision( nARGX*nARGY, PRECISION ) : nARGX*nARGY;
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
            double nRES = hb_itemGetND( pARG );
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, CADDR--);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES = (double) SW_PRECISION ? xu_funprecision( nARGZ*nRES, PRECISION ) : nARGZ*nRES;
               hb_itemRelease(pARGZ);
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);
            break;
         }case 5:{   // SUMALL
            //double nRES = (double) SW_PRECISION ? xu_funprecision( nARGX+nARGY, PRECISION ) : nARGX+nARGY;
            PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
            double nRES = hb_itemGetND( pARG );
            hb_itemRelease(pARG);
            while(CADDR){
               PHB_ITEM pARGZ = hb_itemArrayGet( pSTK_ADDR, CADDR--);  //
               double nARGZ = hb_itemGetND( pARGZ );
               nRES = (double) SW_PRECISION ? xu_funprecision( nARGZ+nRES, PRECISION ) : nARGZ+nRES;
               hb_itemRelease(pARGZ);
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nRES);
            break;
         }
      }
//   }else{
//      sw=put_error((PHB_ITEM) pRET, "SQUARE OPERATION ARGUMENT ERROR",103);
//   }
//   hb_itemRelease(pARGX);
//   hb_itemRelease(pARGY);
}else{
   sw=put_error((PHB_ITEM) pRET, "SQUARE OPERATION STACK UNDERFLOW",102);
}
return sw;
}

//int between( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int between(){
int sw=1;
if( CADDR>=5 ){
   
   PHB_ITEM pTIPO2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo2 = hb_itemGetNI(pTIPO2); hb_itemRelease(pTIPO2);
   PHB_ITEM pARGf = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fin
   PHB_ITEM pTIPO1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo1 = hb_itemGetNI(pTIPO1); hb_itemRelease(pTIPO1);
   PHB_ITEM pARGi = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ini
   PHB_ITEM pARGv = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // variable
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(!HB_IS_ARRAY(pARGv)){
      long nARGv = hb_itemGetND( pARGv );
      ++CADDR;
      if(nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv >= hb_itemGetND( pARGi ) && nARGv <= hb_itemGetND( pARGf )) );
      else if( nTipo1 && !nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv >= hb_itemGetND( pARGi ) && nARGv < hb_itemGetND( pARGf )) );
      else if( !nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv > hb_itemGetND( pARGi ) && nARGv <= hb_itemGetND( pARGf )) );
      else
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv > hb_itemGetND( pARGi ) && nARGv < hb_itemGetND( pARGf )) );
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARGv, &nDim, &d1, &d2, &d3, &type);
      long nARGi = hb_itemGetND( pARGi );
      long nARGf = hb_itemGetND( pARGf );
      if (type>10){
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  long nARG22 = hb_itemGetND( pARG22 );
                  if( nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 >= nARGi && nARG22 <= nARGf ) );
                  else if( nTipo1 && !nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 >= nARGi && nARG22 < nARGf ) );
                  else if( !nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 > nARGi && nARG22 <= nARGf ) );
                  else
                     hb_arraySetNI( pRows, i, (int) ( nARG22 > nARGi && nARG22 < nARGf ) );
                  hb_itemRelease(pARG22);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     long nARG222 = hb_itemGetND( pARG222 );
                     if( nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 >= nARGi && nARG222 <= nARGf ) );
                     else if( nTipo1 && !nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 >= nARGi && nARG222 < nARGf ) );
                     else if( !nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 > nARGi && nARG222 <= nARGf ) );
                     else
                        hb_arraySetNI( pCols, j, (int) ( nARG222 > nARGi && nARG222 < nARGf ) );
                     
                     hb_itemRelease(pARG222);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     PHB_ITEM pPag = hb_itemArrayNew( d3 );
                     int k;
                     for( k=1; k<=d3; k++){
                        PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                        long nARG2222 = hb_itemGetND( pARG2222 );
                        if( nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 >= nARGi && nARG2222 <= nARGf ) );
                        else if( nTipo1 && !nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 >= nARGi && nARG2222 < nARGf ) );
                        else if( !nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 > nARGi && nARG2222 <= nARGf ) );
                        else
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 > nARGi && nARG2222 < nARGf ) );

                        hb_itemRelease(pARG2222);
                     }
                     hb_arraySet( pCols, j, pPag );
                     hb_itemRelease(pARG222);
                     hb_itemRelease(pPag);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=0;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "BETWEEN TYPE MISMATCH",104);
      }
   }
   hb_itemRelease(pARGf);
   hb_itemRelease(pARGi);
   hb_itemRelease(pARGv);
}else{
   sw=put_error((PHB_ITEM) pRET, "BETWEEN STACK UNDERFLOW",102); 
}
return sw;
}

int fun_outbetween(){
int sw=1;
if( CADDR>=5 ){
   
   PHB_ITEM pTIPO2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo2 = hb_itemGetNI(pTIPO2); hb_itemRelease(pTIPO2);
   PHB_ITEM pARGf = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fin
   PHB_ITEM pTIPO1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // I=1 o E=0
   int nTipo1 = hb_itemGetNI(pTIPO1); hb_itemRelease(pTIPO1);
   PHB_ITEM pARGi = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // ini
   PHB_ITEM pARGv = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // variable
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(!HB_IS_ARRAY(pARGv)){
      long nARGv = hb_itemGetND( pARGv );
      ++CADDR;
      if(nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv <= hb_itemGetND( pARGi ) || nARGv >= hb_itemGetND( pARGf )) );
      else if( nTipo1 && !nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv <= hb_itemGetND( pARGi ) || nARGv > hb_itemGetND( pARGf )) );
      else if( !nTipo1 && nTipo2 )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv < hb_itemGetND( pARGi ) || nARGv >= hb_itemGetND( pARGf )) );
      else
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) ( nARGv < hb_itemGetND( pARGi ) || nARGv > hb_itemGetND( pARGf )) );
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARGv, &nDim, &d1, &d2, &d3, &type);
      long nARGi = hb_itemGetND( pARGi );
      long nARGf = hb_itemGetND( pARGf );
      if (type>10){
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  long nARG22 = hb_itemGetND( pARG22 );
                  if( nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 <= nARGi || nARG22 >= nARGf ) );
                  else if( nTipo1 && !nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 <= nARGi || nARG22 > nARGf ) );
                  else if( !nTipo1 && nTipo2 )
                     hb_arraySetNI( pRows, i, (int) ( nARG22 < nARGi || nARG22 >= nARGf ) );
                  else
                     hb_arraySetNI( pRows, i, (int) ( nARG22 < nARGi || nARG22 > nARGf ) );
                  hb_itemRelease(pARG22);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     long nARG222 = hb_itemGetND( pARG222 );
                     if( nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 <= nARGi || nARG222 >= nARGf ) );
                     else if( nTipo1 && !nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 <= nARGi || nARG222 > nARGf ) );
                     else if( !nTipo1 && nTipo2 )
                        hb_arraySetNI( pCols, j, (int) ( nARG222 < nARGi || nARG222 >= nARGf ) );
                     else
                        hb_arraySetNI( pCols, j, (int) ( nARG222 < nARGi || nARG222 > nARGf ) );
                     
                     hb_itemRelease(pARG222);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pARGv, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     PHB_ITEM pPag = hb_itemArrayNew( d3 );
                     int k;
                     for( k=1; k<=d3; k++){
                        PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                        long nARG2222 = hb_itemGetND( pARG2222 );
                        if( nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 <= nARGi || nARG2222 >= nARGf ) );
                        else if( nTipo1 && !nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 <= nARGi || nARG2222 > nARGf ) );
                        else if( !nTipo1 && nTipo2 )
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 < nARGi || nARG2222 >= nARGf ) );
                        else
                           hb_arraySetNI( pPag, k, (int) ( nARG2222 < nARGi || nARG2222 > nARGf ) );

                        hb_itemRelease(pARG2222);
                     }
                     hb_arraySet( pCols, j, pPag );
                     hb_itemRelease(pARG222);
                     hb_itemRelease(pPag);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=0;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "OUTBETWEEN TYPE MISMATCH",104);
      }
   }
   hb_itemRelease(pARGf);
   hb_itemRelease(pARGi);
   hb_itemRelease(pARGv);
}else{
   sw=put_error((PHB_ITEM) pRET, "OUTBETWEEN STACK UNDERFLOW",102); 
}
return sw;
}

int fun_naninf_matrix( PHB_ITEM pARG2, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
if (type>10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            if( tCompare )
               hb_arraySetNI( pRows, i, (int) isnan( hb_itemGetND( pARG22 ) ) );
            else
               hb_arraySetNI( pRows, i, (int) isinf( hb_itemGetND( pARG22 ) ) );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               if( tCompare )
                  hb_arraySetNI( pCols, j, (int) isnan( hb_itemGetND( pARG222 ) ) );
               else
                  hb_arraySetNI( pCols, j, (int) isinf( hb_itemGetND( pARG222 ) ) );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  if( tCompare )
                     hb_arraySetNI( pPag, k, (int) isnan( hb_itemGetND( pARG2222 ) ) );
                  else
                     hb_arraySetNI( pPag, k, (int) isinf( hb_itemGetND( pARG2222 ) ) );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_isnaninf( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP-57;
if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   if ( HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      if( tCompare )
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) isnan( hb_itemGetND( pARG1 ) ) );
      else
         hb_arraySetNI( pSTK_ADDR, CADDR, (int) isinf( hb_itemGetND( pARG1 ) ) );
   }else if( HB_IS_ARRAY( pARG1 ) ){
      ++CADDR;
      if(!(int) fun_naninf_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int)tCompare )){
         sw=put_error((PHB_ITEM) pRET, "ISNAN|ISINF ARGUMENT ERROR",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "ISNAN|ISINF ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "ISNAN|ISINF STACK UNDERFLOW",103); 
}   
return sw;
}

int fun_anyall_matrix( PHB_ITEM pARG2, PHB_ITEM pARG1, PHB_ITEM pSTK_ADDR, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
if (type==10 || type==11){
   switch( nDim ){
      case 1:{
         
         int i;
         int swAll=1, swAny=0;
         if( HB_IS_NUMERIC(pARG1) ){
            double nDato = hb_itemGetND( pARG1 );
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               if( tCompare ){  // is any
                  if ( nDato == hb_itemGetND( pARG22 ) ){
                     swAny=1;
                  }
               }else{     // is all
                  if ( nDato != hb_itemGetND( pARG22 ) ){
                     swAll=0; 
                  }
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else if( HB_IS_STRING(pARG1) ){
            const char * cDato = hb_itemGetCPtr( pARG1 );
            for (i=1; i<=d1; i++ ){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               if( tCompare ){  // is any
                  if ( strcmp( cDato , hb_itemGetCPtr( pARG22 ) ) == 0 ){
                     swAny=1;
                  }
               }else{     // is all
                  if ( strcmp( cDato , hb_itemGetCPtr( pARG22 ) ) != 0 ){
                     swAll=0; 
                  }
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else{
            sw=0;
         }
         hb_arraySetNI(pSTK_ADDR, CADDR, (int) tCompare ? swAny : swAll);
         break;
      }case 2:{
         int i;
         int swAll=1, swAny=0;
         if( HB_IS_NUMERIC(pARG1) ){
            double nDato = hb_itemGetND( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  if( tCompare ){  // is any
                     if ( nDato == hb_itemGetND( pARG222 ) ){
                        swAny=1;
                     }
                  }else{     // is all
                     if ( nDato != hb_itemGetND( pARG222 ) ){
                        swAll=0; 
                     }
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else if( HB_IS_STRING(pARG1) ){
            const char * cDato = hb_itemGetCPtr( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  if( tCompare ){  // is any
                     if ( strcmp( cDato , hb_itemGetCPtr( pARG222 ) ) == 0 ){
                        swAny=1;
                     }
                  }else{     // is all
                     if ( strcmp( cDato , hb_itemGetCPtr( pARG222 ) ) != 0 ){
                        swAll=0; 
                     }
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else{
            sw=0;
         }
         hb_arraySetNI(pSTK_ADDR, CADDR, (int) tCompare ? swAny : swAll);
         break;
      }case 3:{
         
         int i;
         int swAll=1, swAny=0;
         if( HB_IS_NUMERIC(pARG1) ){
            double nDato = hb_itemGetND( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     if( tCompare ){  // is any
                        if ( nDato == hb_itemGetND( pARG2222 ) ){
                           swAny=1;
                        }
                     }else{     // is all
                        if ( nDato != hb_itemGetND( pARG2222 ) ){
                           swAll=0; 
                        }
                     }
                     hb_itemRelease(pARG2222);
                     if( swAny || !swAll ) break;
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else if( HB_IS_STRING(pARG1) ){
            const char * cDato = hb_itemGetCPtr( pARG1 );
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                  int k;
                  for( k=1; k<=d3; k++){
                     PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                     if( tCompare ){  // is any
                        if ( strcmp( cDato , hb_itemGetCPtr( pARG2222 ) ) == 0 ){
                           swAny=1;
                        }
                     }else{     // is all
                        if ( strcmp( cDato , hb_itemGetCPtr( pARG2222 ) ) != 0 ){
                           swAll=0; 
                        }
                     }
                     hb_itemRelease(pARG2222);
                     if( swAny || !swAll ) break;
                  }
                  hb_itemRelease(pARG222);
                  if( swAny || !swAll ) break;
               }
               hb_itemRelease(pARG22);
               if( swAny || !swAll ) break;
            }
         }else{
            sw=0;
         }
         hb_arraySetNI(pSTK_ADDR, CADDR, (int) tCompare ? swAny : swAll);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_isanyall( /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP-68;
if ( CADDR >= 2 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // matriz
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor a evaluar
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_ARRAY( pARG1 ) && (HB_IS_NUMERIC( pARG2 ) || HB_IS_STRING( pARG2 ))){
      ++CADDR;
      if(!(int) fun_anyall_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, (PHB_ITEM) pSTK_ADDR, (int) CADDR, (int)tCompare )){
         sw=put_error((PHB_ITEM) pRET, "ISANY|ISALL ARGUMENT ERROR",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "ISANY|ISALL ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
   hb_itemRelease(pARG2);
}else{
   sw=put_error((PHB_ITEM) pRET, "ISANY|ISALL STACK UNDERFLOW",102); 
}   
return sw;
}

int fun_boolean_matrix( PHB_ITEM pARG, PHB_ITEM pSTK_ADDR, int CADDR ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);
if (type>10 ){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            hb_arraySetNI( pRows, i, (int) !( hb_itemGetNI( pARG22 ) ) );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               hb_arraySetNI( pCols, j, (int) !( hb_itemGetNI( pARG222 ) ) );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, j);
                  hb_arraySetNI( pPag, k, (int) !( hb_itemGetNI( pARG2222 ) ) );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int boolean_not(){
int sw=1;
if ( CADDR >= 1 ){
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   if ( /*HB_IS_LOGICAL( pARG1 ) ||*/ HB_IS_NUMERIC( pARG1 ) ){
      ++CADDR;
      hb_arraySetNI( pSTK_ADDR, CADDR, (int) !( hb_itemGetNI( pARG1 ) ) );
   }else if( HB_IS_ARRAY( pARG1 ) ){
      ++CADDR;
      if(!(int) fun_boolean_matrix( (PHB_ITEM) pARG1, (PHB_ITEM) pSTK_ADDR, (int) CADDR )){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN NOT ARGUMENT ERROR",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "BOOLEAN NOT ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "BOOLEAN NOT STACK UNDERFLOW",102); 
}   
return sw;
}


int compare_bool_item(PHB_ITEM pSTK, PHB_ITEM pARG2, PHB_ITEM pARG1, int ndx, int tCompare){
int sw=1;
   switch( tCompare ){
      case 0:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetNI( pARG2 ) || hb_itemGetNI( pARG1 )) ); break;}
      case 1:{hb_arraySetNI( pSTK, ndx, (int) (hb_itemGetNI( pARG2 ) && hb_itemGetNI( pARG1 )) ); break;}
      case 2:{
              int lArg1 = hb_itemGetNI( pARG1 );
              int lArg2 = hb_itemGetNI( pARG2 );
              hb_arraySetNI( pSTK, ndx, (int) ( (lArg1 && !lArg2) || (!lArg1 && lArg2)  ) ); 
              break;}
      case 3:{hb_arraySetNI( pSTK, ndx, (int) !(hb_itemGetNI( pARG2 ) || hb_itemGetNI( pARG1 )) ); break;}
      case 4:{hb_arraySetNI( pSTK, ndx, (int) !(hb_itemGetNI( pARG2 ) && hb_itemGetNI( pARG1 )) ); break;}
      default: sw=0;
   }
return sw;
}

int compare_bool_matrix_item( PHB_ITEM pSTK_ADDR, PHB_ITEM pARG2, PHB_ITEM pARG1, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
if (type>10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            //sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, i, (int) tCompare);
            sw=compare_bool_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG1, i, (int) tCompare);
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               //sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG1, j, (int) tCompare);
               sw=compare_bool_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG1, j, (int) tCompare);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  //sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1, k, (int) tCompare);
                  sw=compare_bool_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1, k, (int) tCompare);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int compare_bool_matrix_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pARG2, PHB_ITEM pARG1, int CADDR, int tCompare ){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
get_size( (PHB_ITEM) pARG1, &nDim1, &d11, &d12, &d13, &type1);
if (type>10 && d1==d11 && d2==d12 && d3==d13){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            //sw=compare_str_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            sw=compare_bool_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               //sw=compare_str_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               sw=compare_bool_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  //sw=compare_str_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  sw=compare_bool_item((PHB_ITEM) pPag, (PHB_ITEM) pARG2222, (PHB_ITEM) pARG1111, k, (int) tCompare);
                  hb_itemRelease(pARG1111);
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int boolean_compare(/* int tCompare */){
int sw=1;
int tCompare = nPCP-125;
if ( CADDR >= 2 ){
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if ( /*(HB_IS_LOGICAL( pARG1 ) ||*/ HB_IS_NUMERIC( pARG1 ) && /*(HB_IS_LOGICAL( pARG2 ) ||*/ HB_IS_NUMERIC( pARG2 ) ){
      ++CADDR;
      if(!compare_bool_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG2 ) && (/*HB_IS_LOGICAL( pARG1 ) ||*/ HB_IS_NUMERIC( pARG1 ))){
      ++CADDR;
      if(!compare_bool_matrix_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }      
   }else if( HB_IS_ARRAY( pARG1 ) && ( /*HB_IS_LOGICAL( pARG2 ) || */HB_IS_NUMERIC( pARG2 )) ){
      PHB_ITEM pTEMP = pARG1;
      pARG1=pARG2;
      pARG2=pTEMP;
      ++CADDR;
      if(!compare_bool_matrix_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else if( HB_IS_ARRAY( pARG2 ) && HB_IS_ARRAY( pARG1 ) ){
      ++CADDR;
      if(!compare_bool_matrix_matrix((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG2, (PHB_ITEM) pARG1, (int) CADDR, (int) tCompare)){
         sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE FUNCTION OUT OF CONTEXT",108);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG1);
   hb_itemRelease(pARG2);
}else{
   sw=put_error((PHB_ITEM) pRET, "BOOLEAN COMPARE STACK UNDERFLOW",102); 
}
return sw;
}

double min(double x, double y){
   return x<y?x:y;
}

double max(double x, double y){
   return x>y?x:y;
}

/* 
    COMPUTO BASICO Y COMPUTO BASICO ESPECIAL 
                                               */
/* COMPUTE ITEMS SINGLE CON OPCION A VARIABLE */
void fun_compute_add_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) + xu_funprecision(nARG2,PRECISION) : (nARG1 + nARG2 ) );
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) + xu_funprecision(nARG2,PRECISION) : (nARG1 + nARG2 ) ); 
}

void fun_compute_sub_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) - xu_funprecision(nARG2,PRECISION) : (nARG1 - nARG2 ) );
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) - xu_funprecision(nARG2,PRECISION) : (nARG1 - nARG2 ) );
}

void fun_compute_mul_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) * xu_funprecision(nARG2,PRECISION) : (nARG1 * nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) * xu_funprecision(nARG2,PRECISION) : (nARG1 * nARG2 ) ); 
}
void fun_compute_div_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}

void fun_compute_idiv_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetNL( pSTK_REG, PUSH_VAR, (long)   SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetNL( pSTK, ndx, (long)   SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}

void fun_compute_pow_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(pow(nARG1, nARG2),PRECISION) : pow(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(pow(nARG1, nARG2),PRECISION) : pow(nARG1, nARG2 ) ); 
}

void fun_compute_mod_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR,  (double) SW_PRECISION ? xu_funprecision(fmod(nARG1, nARG2),PRECISION) : fmod(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(fmod(nARG1, nARG2),PRECISION) : fmod(nARG1, nARG2 ) ); 
}

void fun_compute_round_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if( nARG2 ){
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) xu_funprecision(nARG1, nARG2 ) );
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) xu_funprecision(nARG1, nARG2 ) ); 
       }
   }else{
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (long) xu_funprecision(nARG1, 0 ) ); 
           PUSH_VAR=-1;
       }else{
           hb_arraySetNL( pSTK, ndx, (long) xu_funprecision(nARG1, 0 ) ); 
       }
   }
}
void fun_compute_max_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(max(nARG1, nARG2),PRECISION) : max(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(max(nARG1, nARG2),PRECISION) : max(nARG1, nARG2 ) ); 
}

void fun_compute_min_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   if(PUSH_VAR!=-1){
       hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(min(nARG1, nARG2),PRECISION) : min(nARG1, nARG2 ) ); 
       PUSH_VAR=-1;
   }else
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(min(nARG1, nARG2),PRECISION) : min(nARG1, nARG2 ) ); 
}

void fun_compute_gcd_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){

   if( nARG1>0 && nARG2>0 ){
       while (nARG1!=nARG2){
          if (nARG1>nARG2) nARG1=nARG1-nARG2;
          else     nARG2=nARG2-nARG1;
       }
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) : nARG1 ); 
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) : nARG1 ); 
       }
   }else{
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) 0.0 );
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) 0.0 ); // error: ambos deben ser positivos
       }
   }
}

void fun_compute_lcm_single(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   double w;
   if( nARG1>0 && nARG2>0 ){
       w=nARG1*nARG2;
       while (nARG1!=nARG2){
           if (nARG1>nARG2)   nARG1=nARG1-nARG2;
           else       nARG2=nARG2-nARG1;
       }
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) SW_PRECISION ? xu_funprecision(w/nARG1,PRECISION) : w/nARG1 ); 
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(w/nARG1,PRECISION) : w/nARG1 ); 
       }
   }else{
       if(PUSH_VAR!=-1){
           hb_arraySetND( pSTK_REG, PUSH_VAR, (double) 0.0 );
           PUSH_VAR=-1;
       }else{
           hb_arraySetND( pSTK, ndx, (double) 0.0 );  // error: ambos deben ser positivos
       }
   }
}


/* COMPUTE ITEMS */
void fun_compute_add(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) + xu_funprecision(nARG2,PRECISION) : (nARG1 + nARG2 ) ); 
}

void fun_compute_sub(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) - xu_funprecision(nARG2,PRECISION) : (nARG1 - nARG2 ) );
}

void fun_compute_mul(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) * xu_funprecision(nARG2,PRECISION) : (nARG1 * nARG2 ) ); 
}
void fun_compute_div(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}
void fun_compute_idiv(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetNL( pSTK, ndx, (long)   SW_PRECISION ? xu_funprecision(nARG1,PRECISION) / xu_funprecision(nARG2,PRECISION) : (nARG1 / nARG2 ) ); 
}
void fun_compute_pow(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(pow(nARG1, nARG2),PRECISION) : pow(nARG1, nARG2 ) ); 
}
void fun_compute_mod(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(fmod(nARG1, nARG2),PRECISION) : fmod(nARG1, nARG2 ) ); 
}
void fun_compute_round(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   //double prec = hb_itemGetND( pARG2 );
   if( nARG2 )
       hb_arraySetND( pSTK, ndx, (double) xu_funprecision(nARG1, nARG2 ) ); 
   else
       hb_arraySetNL( pSTK, ndx, (long) xu_funprecision(nARG1, 0 ) ); 
}
void fun_compute_max(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(max(nARG1, nARG2),PRECISION) : max(nARG1, nARG2 ) ); 
}
void fun_compute_min(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(min(nARG1, nARG2),PRECISION) : min(nARG1, nARG2 ) ); 
}
void fun_compute_gcd(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   //double x = hb_itemGetND( pARG1 );
   //double y = hb_itemGetND( pARG2 );
   if( nARG1>0 && nARG2>0 ){
       while (nARG1!=nARG2){
          if (nARG1>nARG2) nARG1=nARG1-nARG2;
          else     nARG2=nARG2-nARG1;
       }
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(nARG1,PRECISION) : nARG1 ); 
   }else{
       hb_arraySetND( pSTK, ndx, (double) 0.0 ); // error: ambos deben ser positivos
   }
}

void fun_compute_lcm(PHB_ITEM pSTK, double nARG1, double nARG2, int ndx){
   double w;
//   double x = hb_itemGetND( nARG1 );
//   double y = hb_itemGetND( nARG2 );
   if( nARG1>0 && nARG2>0 ){
       w=nARG1*nARG2;
       while (nARG1!=nARG2){
           if (nARG1>nARG2)   nARG1=nARG1-nARG2;
           else       nARG2=nARG2-nARG1;
       }
       hb_arraySetND( pSTK, ndx, (double) SW_PRECISION ? xu_funprecision(w/nARG1,PRECISION) : w/nARG1 ); 
   }else{
       hb_arraySetND( pSTK, ndx, (double) 0.0 );  // error: ambos deben ser positivos
   }
}

struct {
   void (*p)(PHB_ITEM,double,double,int);
}funComputeItem_single[12] = { /*    0: */{fun_compute_add_single},
                               /*    1: */{fun_compute_sub_single},
                               /*    2: */{fun_compute_mul_single},
                               /*    3: */{fun_compute_div_single},
                               /*    4: */{fun_compute_idiv_single},
                               /*    5: */{fun_compute_pow_single},
                               /*    6: */{fun_compute_mod_single},
                               /*    7: */{fun_compute_round_single},
                               /*    8: */{fun_compute_max_single},
                               /*    9: */{fun_compute_min_single},
                               /*   10: */{fun_compute_gcd_single},
                               /*   11: */{fun_compute_lcm_single}
                             };

struct {
   void (*p)(PHB_ITEM,double,double,int);
}funComputeItem[12] = { /*    0: */{fun_compute_add},
                        /*    1: */{fun_compute_sub},
                        /*    2: */{fun_compute_mul},
                        /*    3: */{fun_compute_div},
                        /*    4: */{fun_compute_idiv},
                        /*    5: */{fun_compute_pow},
                        /*    6: */{fun_compute_mod},
                        /*    7: */{fun_compute_round},
                        /*    8: */{fun_compute_max},
                        /*    9: */{fun_compute_min},
                        /*   10: */{fun_compute_gcd},
                        /*   11: */{fun_compute_lcm}
                        };

/* COMPUTE MATRIX-ITEM */

int fun_compute_matrix_item_1d(double nARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d2=d2+d3;  // basura!
    PHB_ITEM pRows  = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for (i=1; i<=d1; i++ ){
        PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
        double nARG11 = hb_itemGetND( pARG11 );
        //compute_item((PHB_ITEM) pRows, (PHB_ITEM) pARG11, (PHB_ITEM) pARG2, i, (int) tCompare);
        (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pRows,(double) nARG11,(double) nARG2, i );
        hb_itemRelease(pARG11);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);

return sw;
}

int fun_compute_matrix_item_2d(double nARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d3=d3+0;
    PHB_ITEM pRows = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for( i=1; i<=d1; i++){
        PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
        PHB_ITEM pCols = hb_itemArrayNew( d2 );
        HB_MAXINT j;
        for( j=1; j<=d2; j++){
            PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
            double nARG111 = hb_itemGetND( pARG111 );
            //compute_item((PHB_ITEM) pCols, (PHB_ITEM) pARG111, (PHB_ITEM) pARG2, j, (int) tCompare);
            (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pCols, (double)nARG111, (double)nARG2, j );
            hb_itemRelease(pARG111);
        }
        hb_arraySet( pRows, i, pCols );
        hb_itemRelease(pARG11);
        hb_itemRelease(pCols);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);

return sw;
}

int fun_compute_matrix_item_3d(double nARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for(i=1; i<=d1; i++){
        PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
        PHB_ITEM pARGF = hb_itemArrayGet( pARG1, i);
        HB_MAXINT j;
        for(j=1; j<=d2; j++){
             PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
             PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
             HB_MAXINT k;
             for(k=1; k<=d3; k++){
                 PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                 double nARGP = hb_itemGetND( pARGP );
                 //compute_item((PHB_ITEM) pARRAYP, (PHB_ITEM) pARGP, (PHB_ITEM) pARG2, k, (int) tCompare);
                 (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pARRAYP,(double) nARGP,(double) nARG2, k );
                 hb_itemRelease(pARGP);
             }
             hb_arraySet(pARRAYC, j, pARRAYP);
             hb_itemRelease(pARRAYP);
             hb_itemRelease(pARGC);
        }
        hb_arraySet(pARRAY, i, pARRAYC);
        hb_itemRelease(pARRAYC);
        hb_itemRelease(pARGF);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, (PHB_ITEM) pARRAY );
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    }
    //hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    hb_itemRelease(pARRAY);
return sw;
}

struct {
   int (*p)(double,PHB_ITEM,HB_MAXINT,HB_MAXINT,HB_MAXINT,int);
}funComputeMatrixItem[3] = {/*    0: */{fun_compute_matrix_item_1d},
                            /*    1: */{fun_compute_matrix_item_2d},
                            /*    2: */{fun_compute_matrix_item_3d}};

int compute_matrix_item(PHB_ITEM pARG1, double nARG2, int tCompare){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
   if (type==11){
       sw = (int)(*funComputeMatrixItem[nDim-1].p)((double) nARG2, (PHB_ITEM) pARG1, d1,d2,d3, tCompare);
   }else{
       sw=0;
   }
return sw;
}

/* COMPUTE ITEM-MATRIX */

int fun_compute_item_matrix_1d(PHB_ITEM pARG2, double nARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d2=d2+d3;  // basura!
    PHB_ITEM pRows  = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for (i=1; i<=d1; i++ ){
        PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
        double nARG2 = hb_itemGetND( pARG22 );
        //compute_item((PHB_ITEM) pRows, (PHB_ITEM) pARG1, (PHB_ITEM) pARG22, i, (int) tCompare);
        (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pRows, (double) nARG1, (double) nARG2, i );
        hb_itemRelease(pARG22);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_item_matrix_2d(PHB_ITEM pARG2, double nARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d3=d3+0;  // basura!
    PHB_ITEM pRows = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for( i=1; i<=d1; i++){
        PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
        PHB_ITEM pCols = hb_itemArrayNew( d2 );
        HB_MAXINT j;
        for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               double nARG2 = hb_itemGetND( pARG222 );
               //compute_item((PHB_ITEM) pCols, (PHB_ITEM) pARG1, (PHB_ITEM) pARG222, j, (int) tCompare);
               (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pCols, (double) nARG1, (double) nARG2, j );
               hb_itemRelease(pARG222);
        }
        hb_arraySet( pRows, i, pCols );
        hb_itemRelease(pARG22);
        hb_itemRelease(pCols);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_item_matrix_3d(PHB_ITEM pARG2, double nARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for(i=1; i<=d1; i++){
        PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
        PHB_ITEM pARGF = hb_itemArrayGet( pARG2, i);
        HB_MAXINT j;
        for(j=1; j<=d2; j++){
            PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
            PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
            HB_MAXINT k;
            for(k=1; k<=d3; k++){
                     PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                     double nARG2 = hb_itemGetND( pARGP );
                     //compute_item((PHB_ITEM) pARRAYP, (PHB_ITEM) pARG1, (PHB_ITEM) pARGP, k, (int) tCompare);
                     (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pARRAYP, (double) nARG1, (double) nARG2, k );
                     hb_itemRelease(pARGP);
            }
            hb_arraySet(pARRAYC, j, pARRAYP);
            hb_itemRelease(pARRAYP);
            hb_itemRelease(pARGC);
        }
        hb_arraySet(pARRAY, i, pARRAYC);
        hb_itemRelease(pARRAYC);
        hb_itemRelease(pARGF);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, (PHB_ITEM) pARRAY );
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    }
    //hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    hb_itemRelease(pARRAY);

return sw;
}

struct {
   int (*p)(PHB_ITEM,double,HB_MAXINT,HB_MAXINT,HB_MAXINT,int);
}funComputeItemMatrix[3] = {/*    0: */{fun_compute_item_matrix_1d},
                            /*    1: */{fun_compute_item_matrix_2d},
                            /*    2: */{fun_compute_item_matrix_3d}};


int compute_item_matrix(double nARG1, PHB_ITEM pARG2, int tCompare){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARG2, &nDim, &d1, &d2, &d3, &type);
   if( type == 11 ){
       sw = (int)(*funComputeItemMatrix[nDim-1].p)((PHB_ITEM) pARG2, (double) nARG1, d1,d2,d3, tCompare);
   }else{
      sw=0;
   }
return sw;
}

/* COMPUTE MATRIX-MATRIX */

int fun_compute_matrix_matrix_1d(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d2=d2+d3;  // basura!
    PHB_ITEM pRows  = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
            double nARG22 = hb_itemGetND( pARG22 );
            double nARG11 = hb_itemGetND( pARG11 );
            //compute_item((PHB_ITEM) pRows, (PHB_ITEM) pARG22, (PHB_ITEM) pARG11, i, (int) tCompare);
            (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pRows, (double)nARG22, (double)nARG11, i );
            hb_itemRelease(pARG22);
            hb_itemRelease(pARG11);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_matrix_matrix_2d(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
    d3=d3+0;  // basura!
    PHB_ITEM pRows = hb_itemArrayNew( d1 );
    HB_MAXINT i;
    for( i=1; i<=d1; i++){
        PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
        PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, i);
        PHB_ITEM pCols = hb_itemArrayNew( d2 );
        HB_MAXINT j;
        for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               double nARG222 = hb_itemGetND( pARG222 );
               double nARG111 = hb_itemGetND( pARG111 );
               //compute_item((PHB_ITEM) pCols, (PHB_ITEM) pARG222, (PHB_ITEM) pARG111, j, (int) tCompare);
               (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pCols, (double)nARG222, (double)nARG111, j );
               hb_itemRelease(pARG111);
               hb_itemRelease(pARG222);
        }
        hb_arraySet( pRows, i, pCols );
        hb_itemRelease(pARG22);
        hb_itemRelease(pARG11);
        hb_itemRelease(pCols);
    }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, pRows);
    }
    //hb_arraySet(pSTK_ADDR, CADDR, pRows);
    hb_itemRelease(pRows);
return sw;
}

int fun_compute_matrix_matrix_3d(PHB_ITEM pARG2, PHB_ITEM pARG1, HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, int tCompare){
int sw=1;
   PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
   HB_MAXINT i;
   for(i=1; i<=d1; i++){
       PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
       PHB_ITEM pREGF2 = hb_itemArrayGet( pARG2, i);      // saco fila de primer item
       PHB_ITEM pREGF1 = hb_itemArrayGet( pARG1, i);      // saco fila de segundo item
       HB_MAXINT j;
       for(j=1; j<=d2; j++){
           PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
           PHB_ITEM pREGC1 = hb_itemArrayGet( pREGF1, j);     // columna del registro
           PHB_ITEM pREGC2 = hb_itemArrayGet( pREGF2, j);     // columna del registro
           HB_MAXINT k;
           for(k=1; k<=d3; k++){
                     PHB_ITEM pREGP1 = hb_itemArrayGet( pREGC1, k);
                     PHB_ITEM pREGP2 = hb_itemArrayGet( pREGC2, k);
                     double nREGP1 = hb_itemGetND( pREGP1 );
                     double nREGP2 = hb_itemGetND( pREGP2 );
                     //compute_item((PHB_ITEM) pARRAYP, (PHB_ITEM) pREGP2, (PHB_ITEM) pREGP1, k, (int) tCompare);
                     (void)(*funComputeItem[tCompare].p)( (PHB_ITEM)pARRAYP, (double)nREGP2, (double)nREGP1, k );
                     hb_itemRelease(pREGP1);
                     hb_itemRelease(pREGP2);
           }
           hb_arraySet(pARRAYC, j, pARRAYP);
           hb_itemRelease(pARRAYP);
           hb_itemRelease(pREGC1);
           hb_itemRelease(pREGC2);
       }
       hb_arraySet(pARRAY, i, pARRAYC);
       hb_itemRelease(pARRAYC);
       hb_itemRelease(pREGF2);
       hb_itemRelease(pREGF1);
   }
    if(PUSH_VAR!=-1){
        hb_arraySet(pSTK_REG, PUSH_VAR, (PHB_ITEM) pARRAY );
        PUSH_VAR=-1;
    }else{
        hb_arraySet(pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
    }
   //hb_arraySet( pSTK_ADDR, CADDR, (PHB_ITEM) pARRAY );
   hb_itemRelease(pARRAY);
return sw;
}

struct {
   int (*p)(PHB_ITEM,PHB_ITEM,HB_MAXINT,HB_MAXINT,HB_MAXINT,int);
}funComputeMatrixMatrix[3] = {/*    0: */{fun_compute_matrix_matrix_1d},
                              /*    1: */{fun_compute_matrix_matrix_2d},
                              /*    2: */{fun_compute_matrix_matrix_3d}
                              };
                            

int compute_matrix_matrix(PHB_ITEM pARG2, PHB_ITEM pARG1,int tCompare){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
HB_MAXINT nDim1=0,d11=0,d21=0,d31=0,type1=0;
get_size( (PHB_ITEM) pARG2, &nDim1, &d11, &d21, &d31, &type1);
   
if ( type==11 && type1==type && nDim == nDim1 && d1==d11 && d2==d21 && d3==d31){
   sw = (int)(*funComputeMatrixMatrix[nDim-1].p)((PHB_ITEM) pARG2, (PHB_ITEM) pARG1, d1,d2,d3, tCompare);
}else{
   sw=0;
}
return sw;
}


int computo_especial(){
//"divby"=>257, "idivby"=>258,"powby"=>259,"modit"=>260,"subit"=>261,"addit"=>262,"mulit"=>263
int sw=1;
int tCompare = nPCP!=277 ? nPCP-257: 7;
static int Compare[8]={3,4,5,6,1,0,2,7};

if(CADDR>=1){

  /// if( tCompare==277) tCompare=7; // round by
   
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pARG2  = hb_itemArrayGet( pSTK_REG, nReg);
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   
   CADDR += SWKEEP; SWKEEP = 0;
   if(PUSH_VAR==-1) ++CADDR;
   
   if( HB_IS_NUMERIC( pARG1 ) ){
      double nARG1 = hb_itemGetND( pARG1 );
      if( HB_IS_NUMERIC( pARG2 ) ) {   // operacion normal
         double nARG2 = hb_itemGetND( pARG2 );
         
         (void)(*funComputeItem_single[Compare[tCompare]].p)( (PHB_ITEM)pSTK_ADDR, (double)nARG1, (double)nARG2, CADDR );
         //compute_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, Compare[tCompare]);  //OK

      }else if( HB_IS_ARRAY( pARG2 ) ){   // operacion escalar numerico - ARRAY
         //++CADDR;
         if (!compute_item_matrix((double) nARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) Compare[tCompare])){
            sw=put_error((PHB_ITEM) pRET, "(1)COMPUTE-ESP INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
         }
      }else{
         // combinacion no coincide.
         sw=put_error((PHB_ITEM) pRET, "COMPUTE-ESP INVALID ARGUMENT ERROR",103); 
      }
   }else if( HB_IS_ARRAY( pARG1 ) ){   // operando 1 es array; op 2 escalar. izq->der, ARG2 op ARG1
      if( HB_IS_ARRAY( pARG2 ) ){    // operando 2 es array
         //++CADDR;   
         if( !compute_matrix_matrix((PHB_ITEM) pARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) Compare[tCompare]) ){
            sw=put_error((PHB_ITEM) pRET, "(2)COMPUTE-ESP(ARRAY-NUM ? ARRAY-NUM) NOT ENOUGHT MEMORY",100);
         }
      }else{                           // operando 1 es escalar
         // array  escalar
         if( HB_IS_NUMERIC( pARG2 ) ){   // MATRIZ num op escalar num. div, idiv, pow y mod son diferentes. Resto, igual
            double nARG2 = hb_itemGetND( pARG2 );
            //++CADDR;
            if (!compute_matrix_item((PHB_ITEM) pARG1, (double) nARG2, /*(PHB_ITEM) pSTK_ADDR,*/ (int) Compare[tCompare])){
               sw=put_error((PHB_ITEM) pRET, "(3)COMPUTE-ESP INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "COMPUTE-ESP INVALID ARGUMENT ERROR",103); 
         }
      }
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "COMPUTE-ESP STACK UNDERFLOW(1)",102);
}
return sw;
}
int computo(/*int tCompare*/){
int sw=1;
int tCompare;
if( nPCP==343 || nPCP == 344 ) tCompare = nPCP-333; // dejo 10 y 11 para gcd y para lcm!
else tCompare = nPCP-40;
if ( CADDR >= 2 ) {
   PHB_ITEM pARG2 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 1
   PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // operando 2
   
   CADDR += SWKEEP; SWKEEP = 0;
   if(PUSH_VAR==-1) ++CADDR;
      /* evalua POSTFIX */  
/*      if(SW_POSTFIX){    // está dentro de #MATH: invierte operandos.
         PHB_ITEM TMP = pARG1;
         pARG1 = pARG2;
         pARG2 = TMP;
      }*/
      /******************/ 
   // chequear el tipo, y evaluar. Por ahora: numeros
   if( HB_IS_NUMERIC( pARG1 ) ){
      double nARG1 = hb_itemGetND( pARG1 );
      if( HB_IS_NUMERIC( pARG2 ) ) {   // operacion normal
         double nARG2 = hb_itemGetND( pARG2 );
         //if(PUSH_VAR==-1) ++CADDR;
         (void)(*funComputeItem_single[tCompare].p)( (PHB_ITEM)pSTK_ADDR, (double)nARG1, (double)nARG2, CADDR );
         //compute_item((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pARG1, (PHB_ITEM) pARG2, CADDR, tCompare);  //OK

      }else if( HB_IS_ARRAY( pARG2 ) ){   // operacion escalar numerico - ARRAY
         //++CADDR;
         if (!compute_item_matrix((double) nARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) tCompare)){
            sw=put_error((PHB_ITEM) pRET, "(1)COMPUTE INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
         }
      }else{
         // combinacion no coincide.
         sw=put_error((PHB_ITEM) pRET, "COMPUTE INVALID ARGUMENT ERROR",103); 
      }
   }else if( HB_IS_ARRAY( pARG1 ) ){   // operando 1 es array; op 2 escalar. izq->der, ARG2 op ARG1
      if( HB_IS_ARRAY( pARG2 ) ){    // operando 2 es array
         //++CADDR;   
         if( !compute_matrix_matrix((PHB_ITEM) pARG1, (PHB_ITEM) pARG2,/* (PHB_ITEM) pSTK_ADDR,*/ (int) tCompare) ){
            sw=put_error((PHB_ITEM) pRET, "(2)COMPUTE(ARRAY-NUM ? ARRAY-NUM) NOT ENOUGHT MEMORY",100);
         }
      }else{                           // operando 1 es escalar
         // array  escalar
         if( HB_IS_NUMERIC( pARG2 ) ){   // MATRIZ num op escalar num. div, idiv, pow y mod son diferentes. Resto, igual
            double nARG2 = hb_itemGetND( pARG2 );
            //++CADDR;
            if (!compute_matrix_item((PHB_ITEM) pARG1, (double) nARG2, /*(PHB_ITEM) pSTK_ADDR,*/ (int) tCompare)){
               sw=put_error((PHB_ITEM) pRET, "(3)COMPUTE INVALID ARGUMENT ERROR|NOT ENOUGHT MEMORY",109); 
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "COMPUTE INVALID ARGUMENT ERROR",103); 
         }
      }
      
   }else{
      sw=put_error((PHB_ITEM) pRET, "COMPUTE ARGUMENT ERROR",103); 
   }
   hb_itemRelease(pARG2);
   hb_itemRelease(pARG1);
}else{
   sw=put_error((PHB_ITEM) pRET, "COMPUTE STACK UNDERFLOW(2)",102); 
}
return sw;
}

int logicalEmpty_matrix(PHB_ITEM pARG2, /*PHB_ITEM pSTK_ADDR,*/ HB_MAXINT nDim, 
                        HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3){
int sw=1;
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            hb_arraySetNI( (PHB_ITEM) pRows, i, (int) (! hb_itemGetCLen( pARG22 )) );
            hb_itemRelease(pARG22);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               hb_arraySetNI( (PHB_ITEM) pCols, j, (int) (! hb_itemGetCLen( pARG222 )) );
               hb_itemRelease(pARG222);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARG2, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                  hb_arraySetNI( (PHB_ITEM) pPag, k, (int) (! hb_itemGetCLen( pARG2222 )) );
                  hb_itemRelease(pARG2222);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG222);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG22);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
return sw;
}

//int logicalEmpty( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int logicalEmpty(){
int sw=1;

   if( CADDR ){
      PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_ADDR, CADDR--);

      CADDR += SWKEEP; SWKEEP = 0;

      if( HB_IS_STRING( pARG1 )){
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (! hb_itemGetCLen( pARG1 )) );
      }else if( HB_IS_ARRAY( pARG1 ) ){
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
         get_size( (PHB_ITEM) pARG1, &nDim, &d1, &d2, &d3, &type);
         if(type==10){
            ++CADDR;
            sw=(int)logicalEmpty_matrix((PHB_ITEM) pARG1, /*(PHB_ITEM) pSTK_ADDR,*/ (HB_MAXINT) nDim, 
                                        (HB_MAXINT) d1, (HB_MAXINT) d2, (HB_MAXINT) d3);
         }else{
            sw=put_error((PHB_ITEM) pRET, "EMPTY ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "EMPTY ARGUMENT ERROR",103);
      }
      hb_itemRelease(pARG1);
   }else{
      sw=put_error((PHB_ITEM) pRET, "EMPTY STACK UNDERFLOW",102); 
   }
return sw;
}

/* obtiene los primeros N elementos positivos desde cualquier array, y devuelve un array 
   Usos:
   [1:100] getpositive(v)  dejará los primeros 100 positivos que encuentre en v
   [1000] getpositive(v)   dejará el elemento #1000 positivo en v
   [1000] getpositive(-1)  dejará el elemento #1000 positivo en el stack, y así para los arrays
*/

PHB_ITEM fun_getNegativeItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){//, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)<0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)<0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonZeroItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){//, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)!=0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)!=0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonVoidItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){//, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }

   nTotal = get_length(nIni,nFin,1);
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_STRING(pROW)){
               if(strlen( hb_itemGetCPtr(pROW) )>0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_STRING(pROW)){
               if(strlen( hb_itemGetCPtr(pROW) )>0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}


PHB_ITEM fun_getPositiveItems1d(PHB_ITEM pSource, unsigned int d1, int *sw){ //, unsigned int d2, unsigned int d3){

   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
               
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)>0.0){
                   hb_arrayAdd(pRESULT, pROW);
                   ++nLong;
               }
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)>0.0){
                   ++nLong;
               }
           }
           if (nLong == MARK_POS) {
               hb_arrayAdd(pRESULT, pROW);
               hb_itemRelease(pROW);
               break;
           }
           hb_itemRelease(pROW);
       }
   }
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getPositiveItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)>0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)>0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNegativeItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   ///printf("nTOTAL = %d\n",nTotal); fflush(stdout);
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)<0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)<0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonZeroItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
   if( nTotal > 1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)!=0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                   if(hb_itemGetND(pCOL)!=0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

PHB_ITEM fun_getNonVoidItems2d(PHB_ITEM pSource, unsigned int d1, unsigned int d2, int *sw){ //, unsigned int d2, unsigned int d3){
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   unsigned int i;
   unsigned int nLong=0,nTotal=0;
   unsigned int nIni=1, nFin=d1+d2;
   if ( (*sw=normaliza_indices_1d( &nIni, &nFin, d1+d2, &MARK_POS)) ){
       if( OFFSET_POS ) {
           if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
           nFin=OFFSET_POS;
       }
   }
   nTotal = get_length(nIni,nFin,1);
   
   if( nTotal>1 ){ // quiero varios.
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_STRING(pCOL)){
                   if(strlen( hb_itemGetCPtr(pCOL) )>0.0){
                       hb_arrayAdd(pRESULT, pCOL);
                       ++nLong;
                   }
               }
               hb_itemRelease(pCOL);
               if (nLong == nTotal) break;
           }
           hb_itemRelease(pROW);
           if (nLong == nTotal) break;
       }
   }else{  // quiero uno en una posición específica:
       for(i=1; i<=d1; ++i){
           PHB_ITEM pROW = hb_itemArrayGet( pSource, i);
           unsigned int j;
           for(j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_STRING(pCOL)){
                   if(strlen( hb_itemGetCPtr(pCOL) )>0.0){
                       ++nLong;
                   }
               }
               if (nLong == MARK_POS) {
                  hb_arrayAdd(pRESULT, pCOL);
                  hb_itemRelease(pCOL);
                  break;
               }
               hb_itemRelease(pCOL);
           }
           hb_itemRelease(pROW);
           if (nLong == MARK_POS) break;
       }
   }
   
   fun_clear_interval();
   return pRESULT;
}

struct {
   PHB_ITEM (*p)(PHB_ITEM,unsigned int,int*); //,unsigned int,unsigned int);
}funGetPorcion1d[4] = { /*    0: */{fun_getPositiveItems1d},
                        /*    1: */{fun_getNegativeItems1d},
                        /*    2: */{fun_getNonZeroItems1d},
                        /*    3: */{fun_getNonVoidItems1d}
                      };

struct {
   PHB_ITEM (*p)(PHB_ITEM,unsigned int,unsigned int,int*); //,unsigned int,unsigned int);
}funGetPorcion2d[4] = { /*    0: */{fun_getPositiveItems2d},
                        /*    1: */{fun_getNegativeItems2d},
                        /*    2: */{fun_getNonZeroItems2d},
                        /*    3: */{fun_getNonVoidItems2d}
                      };

int fun_getsomething(){
int sw=1;

if (CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pTarget = hb_itemArrayGet( pSTK_REG, nItem );

   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--);

   CADDR += SWKEEP; SWKEEP = 0;

   int esAbstracta = hb_itemGetNInt(pTarget);
   int tCompare = nPCP-394;
   
   if (HB_IS_ARRAY(pSource)){ //  es array: puedo proseguir
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
      PHB_ITEM pRESULT = NULL;
      
      switch(nDim){
          case 1: {pRESULT = (PHB_ITEM)(*funGetPorcion1d[tCompare].p)(pSource,d1,&sw); break;}
          case 2: {pRESULT = (PHB_ITEM)(*funGetPorcion2d[tCompare].p)(pSource,d1,d2,&sw); break;}
          //case 3: {pRESULT = (PHB_ITEM)(*funGetPorcion3d[tCompare].p)(pSource,nDim,d1,d2,d3); break;}
      }
      if ( sw ){
          if (hb_arrayLen(pRESULT) == 1){
              if (esAbstracta!=-1){ // meto en pSTK_REG
                  put_value(pSTK_REG, pRESULT, nItem, PRECISION);
              }else{  // meto en pSTK_ADDR
                  put_value(pSTK_ADDR, pRESULT, ++CADDR, PRECISION);
              }          
          }else{      
              if (esAbstracta!=-1){ // meto en pSTK_REG
                  hb_arraySet(pSTK_REG, nItem, pRESULT);
              }else{  // meto en pSTK_ADDR
                  hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
              }
          }
          hb_itemRelease(pRESULT);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET SOMETHING ARRAY ARGUMENT ERROR",103);
   }
   hb_itemRelease(pTarget);hb_itemRelease(pSource);
}else{
   sw=put_error((PHB_ITEM) pRET, "GET SOMETHING STACK UNDERFLOW",102);
}
return sw;
}


int fun_compact(){
int sw=1;
if(CADDR){
   PHB_ITEM pSOUR = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pSOUR, &nDim, &d1, &d2, &d3, &type);
   PHB_ITEM pRESULT = hb_itemArrayNew(0);
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pROW = hb_itemArrayGet( pSOUR, i);
            if(HB_IS_NUMERIC(pROW)){
               if(hb_itemGetND(pROW)!=0.0)
                  hb_arrayAdd(pRESULT, pROW);
            }else if(HB_IS_STRING(pROW)){
               if(hb_itemGetCLen(pROW)>0)
                  hb_arrayAdd(pRESULT, pROW);
           /* }else if(HB_IS_LOGICAL(pROW)){
               if(hb_itemGetL(pROW))
                  hb_arrayAdd(pRESULT, pROW);*/
            }
            hb_itemRelease(pROW);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pROW = hb_itemArrayGet( pSOUR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               if(HB_IS_NUMERIC(pCOL)){
                  if(hb_itemGetND(pCOL)!=0.0)
                     hb_arrayAdd(pRESULT, pCOL);
               }else if(HB_IS_STRING(pCOL)){
                  if(hb_itemGetCLen(pCOL)>0)
                     hb_arrayAdd(pRESULT, pCOL);
              /* }else if(HB_IS_LOGICAL(pCOL)){
                  if(hb_itemGetL(pCOL))
                     hb_arrayAdd(pRESULT, pCOL);*/
               }
               hb_itemRelease(pCOL);
            }
            hb_itemRelease(pROW);
         }
         break;
      }case 3:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pROW = hb_itemArrayGet( pSOUR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pCOL = hb_itemArrayGet( pROW, j);
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pPAG = hb_itemArrayGet( pCOL, k);
                  if(HB_IS_NUMERIC(pPAG)){
                     if(hb_itemGetND(pPAG)!=0.0)
                        hb_arrayAdd(pRESULT, pPAG);
                  }else if(HB_IS_STRING(pPAG)){
                     if(hb_itemGetCLen(pPAG)>0)
                        hb_arrayAdd(pRESULT, pPAG);
                 /* }else if(HB_IS_LOGICAL(pPAG)){
                     if(hb_itemGetL(pPAG))
                        hb_arrayAdd(pRESULT, pPAG);*/
                  }
                  hb_itemRelease(pPAG);
               }
               hb_itemRelease(pCOL);
            }
            hb_itemRelease(pROW);
         }
         break;
      }default:{
         sw=0;
      }
   }
   hb_itemRelease(pSOUR);
   if ( PUSH_VAR != -1 ){
      hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
      PUSH_VAR=-1;
   }else{
      hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
   }
   hb_itemRelease(pRESULT);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "COMPACT STACK UNDERFLOW",102);
}
return sw;
}


/****************************************************
    FUNCIONES DE SISTEMA, FUNCIONES INTERNAS
 ****************************************************/

int fun_exec(){
int sw=1;
if(CADDR>=1){
   SW_PUNTERO=0;   // RESETEO PUNTERO, POR SI EL PROGRAMADOR SACOHUEA SE EQUIVOCO
   
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pSource ) ){

        // procesar:
      HB_MAXINT nLen = hb_itemGetCLen( pSource );
      char * s = (char*) calloc( nLen + 100, 1 );  // era 43
      const char * execstr = hb_itemGetCPtr( pSource );
      memcpy( s, execstr, nLen );
      s[nLen]='\0';
      
      if(nPCP==188){  // ejecuta y devuelve resutado      
        // generar nombre de archivo temporal:
         srand(time(NULL));
         long numrand = 10000 + rand() % (100000001 - 10000);
         char tmpFile[100];
         int ltmpf = sprintf(tmpFile," > /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
         tmpFile[ltmpf]='\0';

         memcpy( s + nLen, tmpFile, ltmpf ); 
         //memcpy( s + nLen, " > /tmp/tmpmacroMurrayfile000000000000.tmp", 42 ); 
      
         const char * t=s;
   
         int ret = system(t);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC CHILD TERMINATED",102);
         }
         free(s);
         if (sw){
            FILE *fp;
            char ch;
   
            //if( (fp=fopen("/tmp/tmpmacroMurrayfile000000000000.tmp","r"))!=NULL ){
            ltmpf = sprintf(tmpFile,"/tmp/tmpmacroMurrayfile%ld.tmp",numrand);
            tmpFile[ltmpf]='\0';
            if( (fp=fopen(tmpFile,"r"))!=NULL ){
               fseek(fp, 0L, SEEK_END);
               long int nFinalPos  = ftell( fp ) ;
       
               rewind( fp );
               fseek( fp, 0L, SEEK_CUR) ;

               char * output = (char *)calloc(nFinalPos + 2, 1);
               if( output ){
                  long int i=0;
                  while ((ch = fgetc(fp)) != EOF){
                     output[i++] = ch;
                  }
                  output[i] = '\0';
                  const char * cbuffer = output;
                  hb_arraySetC( pSTK_ADDR, ++CADDR, cbuffer );
                  free(output);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC NOT ENOUGH MEMORY",100);
               }
               fclose(fp);
              // rm file:
               int ltmpf = sprintf(tmpFile,"rm /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
               tmpFile[ltmpf]='\0';
               int ret = system(tmpFile);
               if (WIFSIGNALED(ret) &&
                  (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
                  sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC CHILD TERMINATED",102);
               }
               //system("rm /tmp/tmpmacroMurrayfile000000000000.tmp");
            }else{
               sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC TEMPFILE CREATION ERROR",107);
            }
         }
      }else{   // 198: ejecuta nada más: no devuelve nada
         const char * t=s;
         int ret = system(t);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV CHILD TERMINATED",102);
         }
         free(s);
      }
   
   }else if (HB_IS_ARRAY( pSource )){  // solo puede ser un array de strings
      if(nPCP!=188){ 
         int i;
         HB_MAXINT nLen = hb_arrayLen( pSource );
         for (i=1; i<=nLen; i++){
            PHB_ITEM pELEM = hb_itemArrayGet( pSource, i);
            if( HB_IS_STRING( pELEM ) ){
               const char * execstr = hb_itemGetCPtr( pELEM );
               int ret = system(execstr);
               if (WIFSIGNALED(ret) &&
                  (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
                  sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV CHILD TERMINATED",102);
                  hb_itemRelease(pELEM);
                  break;
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV ARGUMENT ARRAY NOT STRING ERROR",103);
               hb_itemRelease(pELEM);
               break;
            }
            hb_itemRelease(pELEM);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "MACRO-EXECV ARGUMENT ARRAY ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC|EXECV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pSource );
}else{
   sw=put_error((PHB_ITEM) pRET, "MACRO-EXEC|EXECV INNER-STACK UNDERFLOW",102);
}
return sw;
}

//int LetMacro(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pRET){//,
int LetMacro( /*long nARGr, long nARGs */){
int sw=1;
   
   SW_PUNTERO=0;   // RESETEO PUNTERO, POR SI EL PROGRAMADOR SACOHUEA SE EQUIVOCO
   long nARGr = STK_PRG[ ++CP ];
   long nARGs = STK_PRG[ ++CP ];
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nARGs);
   
  // generar nombre de archivo temporal:
   srand(time(NULL));
   long numrand = 10000 + rand() % (100000001 - 10000);
   char tmpFile[100];
   int ltmpf = sprintf(tmpFile," > /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
   tmpFile[ltmpf]='\0';
  // procesar:

   HB_MAXINT nLen = hb_itemGetCLen( pSource );
   char * s = (char*) calloc( nLen + 43, 1 );
   const char * execstr = hb_itemGetCPtr( pSource );
   memcpy( s, execstr, nLen );
   memcpy( s + nLen, tmpFile, ltmpf );
   //memcpy( s + nLen, " > /tmp/tmpmacroMurrayfile000000000000.tmp", 42 ); 
   const char * t=s;
   
   int ret = system(t);
   if (WIFSIGNALED(ret) &&
      (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
      sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` CHILD TERMINATED",102);
   }
   free(s);
   if(sw){
      FILE *fp;
      char ch;
      ltmpf = sprintf(tmpFile,"/tmp/tmpmacroMurrayfile%ld.tmp",numrand);
      tmpFile[ltmpf]='\0';
      if( (fp=fopen(tmpFile,"r"))!=NULL ){
      //if( (fp=fopen("/tmp/tmpmacroMurrayfile000000000000.tmp","r"))!=NULL ){
         fseek(fp, 0L, SEEK_END);
         long int nFinalPos  = ftell( fp ) ;
      
         rewind( fp );
         fseek( fp, 0L, SEEK_CUR) ;

         char * output = (char *)calloc(nFinalPos + 2, 1);
         if( output ){
            long int i=0;
            while ((ch = fgetc(fp)) != EOF){
               output[i++] = ch;
            }
            output[i] = '\0';
            const char * cbuffer = output;
            hb_arraySetC( pSTK_REG, nARGr, cbuffer );
            free(output);
         }else{
            sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` NOT ENOUGH MEMORY",100);
         }
         fclose(fp);
         // rm file:
         ltmpf = sprintf(tmpFile,"rm /tmp/tmpmacroMurrayfile%ld.tmp",numrand);
         tmpFile[ltmpf]='\0';
//         system(tmpFile);
         int ret = system(tmpFile);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` CHILD TERMINATED",102);
         }
         ///system("rm /tmp/tmpmacroMurrayfile000000000000.tmp");
      }else{
         sw=put_error((PHB_ITEM) pRET, "MACRO-LET `EXEC` TEMPFILE CREATION ERROR",107);
      }
   }
   hb_itemRelease( pSource );
   return sw;
}

int put_precision( /*unsigned int nARG, int tCompare*/){
int sw=1;
int tCompare = nPCP;
   //PHB_ITEM pARG1 = hb_itemArrayGet( pSTK_PRG, ++CP);
   unsigned int nARG=(unsigned int)STK_PRG[++CP];
   PHB_ITEM pPREC = NULL;
   switch( tCompare ){
      case 204: {
         pPREC = hb_itemArrayGet( pSTK_REG, nARG );//hb_itemGetNInt( pARG1 ));
         PRECISION = (unsigned) hb_itemGetNInt( pPREC );
         SW_PRECISION=1;
         if( PRECISION>15 /*|| PRECISION<0*/ ) SW_PRECISION=0;
         break;
      }case 215: {
         pPREC = hb_itemArrayGet( pSTK_DS, nARG );//hb_itemGetNInt( pARG1 ));
         PRECISION = (unsigned) hb_itemGetNInt( pPREC );
         SW_PRECISION=1;
         if( PRECISION>15 /*|| PRECISION<0*/ ) SW_PRECISION=0;
         break;
/*      }default: {
         *PRECISION = nARG;  //(unsigned) hb_itemGetNInt( pARG1 );
         SW_PRECISION=1;
         if( *PRECISION>=10 || *PRECISION<0 ) SW_PRECISION=0; */
      }
   }
   hb_itemRelease(pPREC);
//   hb_itemRelease(pARG1);
return sw;
}

/* Con estas coordenadas, se accederá a los datos de los arrays con GET y PUT.
   Con cada seteo, se realzan los cálculos */
int fun_cartesian(){
int sw=1;
if(CADDR>=1){
   PHB_ITEM pARG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_ARRAY(pARG)){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARG, &nDim, &d1, &d2, &d3, &type);
//      if(type>=11){  // numericos y logicos
         switch(nDim){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( 0 ); // creo array ajustado a los rangos.
               int i;
               int nSize=0;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pELEM = hb_itemArrayGet( pARG, i);
                  /*if(HB_IS_LOGICAL(pELEM)){
                     if(hb_itemGetL(pELEM)){
                        hb_arraySize(pRows, ++nSize);
                        hb_arraySetNI(pRows, nSize, i);
                     }
                  }else */if(HB_IS_NUMERIC(pELEM)){
                     double vonD = hb_itemGetND(pELEM);
                     if(vonD!=0 && !isnan(vonD) && !isinf(vonD)){
                     ////if(hb_itemGetND(pELEM)!=0){
                        hb_arraySize(pRows, ++nSize);
                        hb_arraySetNI(pRows, nSize, i);
                     }
                  }else if(HB_IS_STRING(pELEM)){
                     if(hb_itemGetCLen(pELEM)>0){
                        hb_arraySize(pRows, ++nSize);
                        hb_arraySetNI(pRows, nSize, i);
                     }
                  }
                  hb_itemRelease(pELEM);
               }
               hb_arraySet(pSTK_ADDR, ++CADDR, pRows);
               hb_itemRelease(pRows);
               break;               
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( 0 );
               int i;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARGF = hb_itemArrayGet( pARG, i);
                  
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pELEM = hb_itemArrayGet( pARGF, j);
                    /* if(HB_IS_LOGICAL(pELEM)){
                        if(hb_itemGetL(pELEM)){
                           PHB_ITEM pCols = hb_itemArrayNew( 2 );
                           hb_arraySetNI(pCols, 1, i);
                           hb_arraySetNI(pCols, 2, j);
                           hb_arrayAdd( pRows, pCols );
                           hb_itemRelease(pCols);
                        }
                     }else */if(HB_IS_NUMERIC(pELEM)){
                        double vonD = hb_itemGetND(pELEM);
                        if(vonD!=0 && !isnan(vonD) && !isinf(vonD)){
                        ////if(hb_itemGetND(pELEM)!=0){
                           PHB_ITEM pCols = hb_itemArrayNew( 2 );
                           hb_arraySetNI(pCols, 1, i);
                           hb_arraySetNI(pCols, 2, j);
                           hb_arrayAdd( pRows, pCols );
                           hb_itemRelease(pCols);
                        }
                     }else if(HB_IS_STRING(pELEM)){
                        if(hb_itemGetCLen(pELEM)>0){
                           PHB_ITEM pCols = hb_itemArrayNew( 2 );
                           hb_arraySetNI(pCols, 1, i);
                           hb_arraySetNI(pCols, 2, j);
                           hb_arrayAdd( pRows, pCols );
                           hb_itemRelease(pCols);
                        }
                     }
                     hb_itemRelease(pELEM);
                  }
                  hb_itemRelease(pARGF);
               }
               hb_arraySet(pSTK_ADDR, ++CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( 0 );
               int i;
               for(i=1; i<=d1; i++){

                  PHB_ITEM pARGF = hb_itemArrayGet( pARG, i);
                  int j;
                  for(j=1; j<=d2; j++){
                     
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     int k;
                     for(k=1; k<=d3; k++){
                        PHB_ITEM pELEM = hb_itemArrayGet( pARGC, k);
                       /* if(HB_IS_LOGICAL(pELEM)){
                           if(hb_itemGetL(pELEM)){
                              PHB_ITEM pCols = hb_itemArrayNew( 3 );
                              hb_arraySetNI(pCols, 1, i);
                              hb_arraySetNI(pCols, 2, j);
                              hb_arraySetNI(pCols, 3, k);
                              hb_arrayAdd( pRows, pCols );
                              hb_itemRelease(pCols);
                           }
                        }else */if(HB_IS_NUMERIC(pELEM)){
                           double vonD = hb_itemGetND(pELEM);
                           if(vonD!=0 && !isnan(vonD) && !isinf(vonD)){
                           ////if(hb_itemGetND(pELEM)!=0){
                              PHB_ITEM pCols = hb_itemArrayNew( 3 );
                              hb_arraySetNI(pCols, 1, i);
                              hb_arraySetNI(pCols, 2, j);
                              hb_arraySetNI(pCols, 3, k);
                              hb_arrayAdd( pRows, pCols );
                              hb_itemRelease(pCols);
                           }
                        }else if(HB_IS_STRING(pELEM)){
                           if(hb_itemGetCLen(pELEM)>0){
                              PHB_ITEM pCols = hb_itemArrayNew( 3 );
                              hb_arraySetNI(pCols, 1, i);
                              hb_arraySetNI(pCols, 2, j);
                              hb_arraySetNI(pCols, 3, k);
                              hb_arrayAdd( pRows, pCols );
                              hb_itemRelease(pCols);
                           }
                        }
                        hb_itemRelease(pELEM);
                     }
                     hb_itemRelease(pARGC);
                  }
                  hb_itemRelease(pARGF);
               }
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pRows );
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=put_error((PHB_ITEM) pRET, "CART REDIMENSION ERROR",111);
            }
         }
//      }else{
//         sw=put_error((PHB_ITEM) pRET, "CART ARGUMENT ERROR - MUST BE NUMBER OR LOGIC",103);
//      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "CART ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARG);
}else{
   sw=put_error((PHB_ITEM) pRET, "CART STACK UNDERFLOW",102);
}
return sw;
}   


//int put_coordinates_2D( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, int tCompare){
int put_coordinates_2D(){
int sw=1;
   PHB_ITEM pPREC = NULL;
   PHB_ITEM pPRER = NULL;
   if(nPCP==208){
      int ARGC = STK_PRG[++CP];
      int ARGR = STK_PRG[++CP];
      pPREC = hb_itemArrayGet( pSTK_REG, ARGC );
      pPRER = hb_itemArrayGet( pSTK_REG, ARGR );
   }else{
      if(CADDR>=2){
         pPREC = hb_itemArrayGet( pSTK_ADDR, CADDR--);
         pPRER = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOC2 STACK UNDERFLOW",102);
      }
   }
   MARK_ROW = (unsigned) hb_itemGetNInt( pPRER );
   MARK_COL = (unsigned) hb_itemGetNInt( pPREC );

   hb_itemRelease(pPREC);
   hb_itemRelease(pPRER);
return sw;
}

//int put_coordinates_1D( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, int tCompare){
int put_coordinates_1D( /*int ARG*/ ){
int sw=1;
   
   PHB_ITEM pPRE = NULL;
   if(nPCP==212){
      int ARG = STK_PRG[++CP];
      pPRE = hb_itemArrayGet( pSTK_REG, ARG );//hb_itemGetNInt( pARG ));
   }else{
      if(CADDR>=1)
         pPRE = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      else
         sw=put_error((PHB_ITEM) pRET, "LOC1 STACK UNDERFLOW",102);
   }   
   MARK_POS = (unsigned) hb_itemGetNInt( pPRE );
   MARK_PAGE=MARK_POS;

   hb_itemRelease(pPRE);
return sw;
}

int put_offset(){
int sw=1;
   if( CADDR>=1 ){      
      PHB_ITEM pARGC = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // saca solo 1
      OFFSET_POS = (unsigned int)hb_itemGetNInt( pARGC );
      hb_itemRelease(pARGC);
      /*if(OFFSET_POS>0){
         if(OFFSET_POS<MARK_POS){
            sw=put_error((PHB_ITEM) pRET, "OFFSET OFFSET POINT MINOR THAN INITIAL LOCATE",112);
         }
      }*///else if(OFFSET_POS<0) sw=put_error((PHB_ITEM) pRET, "OFFSET MUST NOT BE NEGATIVE");
      if(MARK_POS==0) MARK_POS=1;  // por default.
   }else{
      sw=put_error((PHB_ITEM) pRET, "OFFSET STACK UNDERFLOW",102);
   }
return sw;
}

int put_offset2D(){
int sw=1;
   if( CADDR>=2 ){
      PHB_ITEM pARGC = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // saca 2
      PHB_ITEM pARGR = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      OFFSET_ROW=(unsigned int)hb_itemGetNInt( pARGR ); 
      OFFSET_COL=(unsigned int)hb_itemGetNInt( pARGC );
      hb_itemRelease(pARGC);
      hb_itemRelease(pARGR);
     /* if( OFFSET_ROW>0 ) {
         if( OFFSET_ROW<MARK_ROW ) {
            sw=put_error((PHB_ITEM) pRET, "OFFSET OFFSET POINT MINOR THAN INITIAL LOCATE",112);
         }
      }
      if( OFFSET_COL>0 ){
         if( OFFSET_COL<MARK_COL ) {
            sw=put_error((PHB_ITEM) pRET, "OFFSET OFFSET POINT MINOR THAN INITIAL LOCATE",112);
         }
      }*/
      if(MARK_ROW==0) MARK_ROW=1;
      if(MARK_COL==0) MARK_COL=1;
   }else{
      sw=put_error((PHB_ITEM) pRET, "OFFSET STACK UNDERFLOW",102);
   }
return sw;
}

int fun_interval(){
int sw=1;
if(nPCP==123){
   if( CADDR>=3 ){  // {pag, col, fil}
      PHB_ITEM pIPAG = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      PHB_ITEM pICOL = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      PHB_ITEM pIROW = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      SET_INTERVAL_ROW = hb_itemGetNI(pIROW);
      SET_INTERVAL_COL = hb_itemGetNI(pICOL);
      SET_INTERVAL_PAG = hb_itemGetNI(pIPAG);
      if(SET_INTERVAL_ROW<=0) SET_INTERVAL_ROW=1;
      if(SET_INTERVAL_COL<=0) SET_INTERVAL_COL=1;
      if(SET_INTERVAL_PAG<=0) SET_INTERVAL_PAG=1;
      hb_itemRelease(pIROW);
      hb_itemRelease(pICOL);
      hb_itemRelease(pIPAG);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INTERVAL 3D STACK UNDERFLOW",102);
   }
}else if(nPCP==122){
   if(CADDR>=2){  // {col, fil}
      PHB_ITEM pICOL = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      PHB_ITEM pIROW = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      SET_INTERVAL_ROW = hb_itemGetNI(pIROW);
      SET_INTERVAL_COL = hb_itemGetNI(pICOL);
      if(SET_INTERVAL_ROW<=0) SET_INTERVAL_ROW=1;
      if(SET_INTERVAL_COL<=0) SET_INTERVAL_COL=1;
      hb_itemRelease(pIROW);
      hb_itemRelease(pICOL);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INTERVAL 2D STACK UNDERFLOW",102);
   }
}else{   // nPCP==121
   if(CADDR>=1){  // {fil}
      PHB_ITEM pIROW = hb_itemArrayGet( pSTK_ADDR, CADDR--);
      SET_INTERVAL_ROW = hb_itemGetNI(pIROW);
      if(SET_INTERVAL_ROW<=0) SET_INTERVAL_ROW=1;
      hb_itemRelease(pIROW);
   }else{
      sw=put_error((PHB_ITEM) pRET, "INTERVAL 1D STACK UNDERFLOW",102);
   }
}
return sw;
}

int fun_reshape_1D2D( PHB_ITEM pSTK_REG, PHB_ITEM pARRAY,PHB_ITEM pFILA,PHB_ITEM pCOLS, int nReg ){
int sw=1;
   
   HB_MAXINT nFIL=hb_itemGetNInt( pFILA );
   HB_MAXINT nCOL=hb_itemGetNInt( pCOLS );

   HB_MAXINT nLen = (HB_MAXINT)hb_arrayLen( pARRAY );
   if( nFIL * nCOL == nLen ){
      HB_MAXINT ndx=0;
      PHB_ITEM pRows  = hb_itemArrayNew( nFIL );
      int i;
      for(i=1; i<=nFIL; i++){
         PHB_ITEM pCols  = hb_itemArrayNew( nCOL );
         int j;
         for(j=1; j<=nCOL; j++){
            PHB_ITEM pREG1 = hb_itemArrayGet( pARRAY, ++ndx );
            put_value(pCols, pREG1, j, PRECISION);
            hb_itemRelease(pREG1);
         }
         hb_arraySet( pRows, i, pCols );
         hb_itemRelease(pCols);
      }
      hb_arraySet( pSTK_REG, nReg, pRows );
      hb_itemRelease(pRows);
   }else{
      PHB_ITEM pRows  = hb_itemArrayNew( 0 );
      hb_arraySet( pSTK_REG, nReg, pRows );
      hb_itemRelease(pRows);
      sw=0;
   }
return sw;
}

int fun_reshape_1D3D( PHB_ITEM pSTK_REG, PHB_ITEM pARRAY,PHB_ITEM pFILA,PHB_ITEM pCOLS, PHB_ITEM pPAGS, int nReg ){
int sw=1;
   
   HB_MAXINT nFIL=hb_itemGetNInt( pFILA );
   HB_MAXINT nCOL=hb_itemGetNInt( pCOLS );
   HB_MAXINT nPAG=hb_itemGetNInt( pPAGS );

   HB_MAXINT nLen = (HB_MAXINT)hb_arrayLen( pARRAY );
   HB_MAXINT ndx = nFIL * nCOL * nPAG;
   if( ndx == nLen ){
      HB_MAXINT i,j,n=1,m=1,o=1;
      // creo array receptor
      PHB_ITEM pA = hb_itemArrayNew( 0 ); // 
      for (i=1; i<=nFIL; i++){
         PHB_ITEM pAA = hb_itemArrayNew( 0 ); // 
         for (j=1; j<=nCOL; j++){
            PHB_ITEM pAAA = hb_itemArrayNew( nPAG ); // 
            hb_arrayAdd( pAA, pAAA );
            hb_itemRelease( pAAA );
         }
         hb_arrayAdd( pA, pAA );
         hb_itemRelease( pAA );
      }
      for( i=1; i<=ndx; i++){
         PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
         PHB_ITEM pC = hb_itemArrayGet( pARRAY, i );
         hb_arraySet( pAAA, o, pC );
         //put_value(pAAA, pC, o, PRECISION);
         if ( ++m > nCOL ){ 
            m=1; 
            if ( ++n > nFIL ){ 
               n=1; 
               ++o; 
            } 
         }
         hb_itemRelease( pC );
         hb_itemRelease( pAAA );
         hb_itemRelease( pAA );
      }
      hb_arraySet( pSTK_REG, nReg, pA );
      hb_itemRelease(pA);
   }else{
      PHB_ITEM pA  = hb_itemArrayNew( 0 );
      hb_arraySet( pSTK_REG, nReg, pA );
      hb_itemRelease(pA);
      sw=0;
   }
return sw;
}

PHB_ITEM fun_reshape_1D( PHB_ITEM pREG, PHB_ITEM pFILA,PHB_ITEM pCOLS, PHB_ITEM pPAGS, int *Dim, int tDim ){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pREG, &nDim, &d1, &d2, &d3, &type);
   PHB_ITEM pARRAY = NULL;
   switch(nDim){
      case 1:{
         if(tDim!=1){
            int i;
            pARRAY = hb_itemArrayNew( d1 );
            for(i=1; i<=d1; i++){
               PHB_ITEM pREG1 = hb_itemArrayGet( pREG, i);
               put_value(pARRAY, pREG1, i, PRECISION);
               hb_itemRelease(pREG1);
            }
         }else{
            nDim=0;
         }
         break;
      }case 2:{
         if(tDim==2 && d1 == hb_itemGetNInt( pFILA ) && d2 == hb_itemGetNInt( pCOLS ) ){
            nDim=0;
            break;
         }else{
            int i,ndx=0;
            pARRAY  = hb_itemArrayNew( d1 * d2 );
            for(i=1; i<=d1; i++){
               PHB_ITEM pREG1 = hb_itemArrayGet( pREG, i);
               int j;
               for(j=1; j<=d2; j++){
                  PHB_ITEM pREG2 = hb_itemArrayGet( pREG1, j);
                  put_value(pARRAY, pREG2, ++ndx, PRECISION);
                  hb_itemRelease(pREG2);
               }
               hb_itemRelease(pREG1);
            }
         }
         break;
      }case 3:{
         if(tDim==3 && d1 == hb_itemGetNInt( pFILA ) && d2 == hb_itemGetNInt( pCOLS ) && d3 == hb_itemGetNInt( pPAGS ) ){
            nDim=0;
            break;
         }else{
            HB_MAXINT ndx=d1 * d2 * d3;
            HB_MAXINT i,n=1,m=1,o=1;
            pARRAY  = hb_itemArrayNew( ndx );
            for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pREG, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                //hb_arraySetC( pARRAY, i, (const char *) hb_itemGetCPtr( pAAAA ) );
                hb_arraySet( pARRAY, i, pAAAA );
                if ( ++m > d2 ){ 
                   m=1; 
                   if ( ++n > d1 ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
            }
         }
         break;
      }
   }
   *Dim = nDim;
return pARRAY;
}

int fun_reshape( /*int nReg */){
int sw=1;
int tDim=0;
PHB_ITEM pFILA = NULL;
PHB_ITEM pCOLS = NULL;
PHB_ITEM pPAGS = NULL;

if( CADDR == 1){
   pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   tDim=1;
}else if(CADDR==2){
   pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // COLUMNAS
   pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   tDim=2;
}else if (CADDR >= 3 ){
   pPAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PAGINAS
   pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // COLUMNAS
   pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   tDim=3;
/*}else if( CADDR==0 ){
   tDim=0;*/
}
if(tDim){
/*if ( CADDR >= 1 ) {
   PHB_ITEM pFILA = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FILA
   int tDim=1;
   PHB_ITEM pCOLS = NULL;
   PHB_ITEM pPAGS = NULL;
   if( CADDR>=1){
      pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // COLUMNAS
      tDim=2;
      if( CADDR>=1){  // 3D
         pPAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PAGINAS
         tDim=3;
      }
   } */
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, nReg);
   if( HB_IS_ARRAY( pREG ) ){
      //PHB_ITEM pARRAY;   // array a procesar
      // pasar el array a 1D
      int nDim=0;
      PHB_ITEM pARRAY=fun_reshape_1D( (PHB_ITEM) pREG, (PHB_ITEM) pFILA, (PHB_ITEM) pCOLS, (PHB_ITEM) pPAGS, &nDim, (int) tDim);

      switch(nDim){
         case 1:{
            if( tDim==2 )
               sw=(int)fun_reshape_1D2D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(int)nReg );
            else if( tDim==3 )
               sw=(int)fun_reshape_1D3D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(PHB_ITEM) pPAGS,(int)nReg );
            break;
         }case 2:{
            if( tDim==1 )
               hb_arraySet( pSTK_REG, nReg, pARRAY );
            else if( tDim==3 )
               sw=(int)fun_reshape_1D3D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(PHB_ITEM) pPAGS,(int)nReg );
            else if( tDim==2 )
               sw=(int)fun_reshape_1D2D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(int)nReg );
            break;
         }case 3:{
            if( tDim==1 )
               hb_arraySet( pSTK_REG, nReg, pARRAY );
            else if( tDim==2 )
               sw=(int)fun_reshape_1D2D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(int)nReg );
            else if( tDim==3 )
               sw=(int)fun_reshape_1D3D( (PHB_ITEM)pSTK_REG, (PHB_ITEM) pARRAY,(PHB_ITEM) pFILA,(PHB_ITEM) pCOLS,(PHB_ITEM) pPAGS,(int)nReg );
            break;
         }
      }
      if( pARRAY ) hb_itemRelease(pARRAY);
      if ( !sw )
         sw=put_error((PHB_ITEM) pRET, "RESHAPE REDIMENSION ERROR",111); 
   }else{
      sw=put_error((PHB_ITEM) pRET, "RESHAPE IS NOT ARRAY - TYPE MISMATCH",104); 
   }

   hb_itemRelease(pREG);
/*   hb_itemRelease(pFILA);
   hb_itemRelease(pCOLS);
   hb_itemRelease(pPAGS); */
}else{
   sw=put_error((PHB_ITEM) pRET, "RESHAPE STACK UNDERFLOW",102); 
}
hb_itemRelease(pFILA);
/*if( pCOLS )*/ hb_itemRelease(pCOLS);
/*if( pPAGS )*/ hb_itemRelease(pPAGS);
return sw;
}


/*
   MODIFICADO: ES NECESARIO, PORQUE PONE EN EL STACK DIRECTAMENTE LO COPIADO, NO COMO LET, QUE LO
   ASIGNA A UNA VARIABLE.
   */


// RANGE: establece rango para acceder a matrices. 
int fun_range(){
int sw=1;
//if(CADDR>=1){

   int nReg = STK_PRG[ ++CP ];   // variable array   
   PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, nReg);

   if(!HB_IS_ARRAY(pREG)){
      //sw=put_error((PHB_ITEM) pRET, "RANGE ARGUMENT ERROR",103);
      // es abstracta:
      SW_ORIGIN_RANGE=0;
      PHB_ITEM pSTK  = hb_itemArrayGet( pSTK_ADDR, CADDR);
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSTK, &nDim, &d1, &d2, &d3, &type);
      switch(nDim){
         case 1:{
            SW_USERANGE = CADDR;
            RANGEDIM=1;
            RANGEROW=d1;
            RANGECOL=0;
            break;
         }case 2:{
            SW_USERANGE = CADDR;
            RANGEDIM=2;
            RANGEROW=d1;
            RANGECOL=d2;
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "RANGE RANGE DIMENSION ERROR",111);
            break;
         }
      }
      hb_itemRelease(pSTK);
   }else{
      SW_ORIGIN_RANGE=1;
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pREG, &nDim, &d1, &d2, &d3, &type);
      switch(nDim){
         case 1:{
/*            int i;
            for(i=1;i<=d1;i++){
               PHB_ITEM pRow = hb_itemArrayGet( pREG, i);
               if(!HB_IS_NUMERIC(pRow)){
                  sw=put_error((PHB_ITEM) pRET, "RANGE ARGUMENT ERROR - MUST BE NUMERIC",103);
                  break;
               }
               hb_itemRelease(pRow);
            }*/
            //if(sw){
               SW_USERANGE = nReg;
               RANGEDIM=1;
               RANGEROW=d1;
               RANGECOL=0;
               
            //}
            break;
         }case 2:{
/*            int i;
            for(i=1;i<=d1;i++){
               PHB_ITEM pRow = hb_itemArrayGet( pREG, i);
               int j;
               for(j=1;j<=d2;j++){
                  PHB_ITEM pCol = hb_itemArrayGet( pRow, j);
                  if(!HB_IS_NUMERIC(pCol)){
                     sw=put_error((PHB_ITEM) pRET, "RANGE ARGUMENT ERROR - MUST BE NUMERIC",103);
                     break;
                  }
                  hb_itemRelease(pCol);
               }
               hb_itemRelease(pRow);
            }*/
            //if(sw){
               SW_USERANGE = nReg;
               RANGEDIM=2;
               RANGEROW=d1;
               RANGECOL=d2;
           // }
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "RANGE RANGE DIMENSION ERROR",111);
            break;
         }
      }
   }
   hb_itemRelease(pREG);
//}else{   // instruccion con ()
//   sw=put_error((PHB_ITEM) pRET, "RANGE STACK UNDERFLOW",102);
//}
return sw;
}

// este no tiene validacion: se asume que hay un arary 1D, o un string?
int get_ewarray(){
int sw=1;
/*PHB_ITEM pARG = hb_itemArrayGet( pSTK_PRG, ++CP);
long nItem = hb_itemGetNInt( pARG );
hb_itemRelease(pARG);*/
int nItem = STK_PRG[++CP];
PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nItem );

if(HB_IS_ARRAY( pSource )){
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
   switch( nDim ){
      case 1:{
              if( MARK_POS == 999999999 ) MARK_POS=d1;
              if( MARK_POS<=d1 ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_POS );
                  if ( PUSH_VAR != -1 ){
                      //hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
                      put_value(pSTK_REG, pARGS, PUSH_VAR, PRECISION);
                      PUSH_VAR=-1;
                  }else{
                      //hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
                      put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                  }
               //   put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                  hb_itemRelease(pARGS);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "GET MARK POSITION OVERFLOW",101);
               }
              break;
     }case 2:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                     if ( PUSH_VAR != -1 ){
                         //hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
                         put_value(pSTK_REG, pARGC, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                     }else{
                         //hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
                         put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                     }
                     //put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGS);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "GET MARK COLUMN OVERFLOW",101);
                  }
              }else{
                  sw=put_error((PHB_ITEM) pRET, "GET MARK ROW OVERFLOW",101);
              }
              break;
     }case 3:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_POS == 999999999 ) MARK_POS=d3;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                      if( MARK_POS<=d3 ){
                          PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                          PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                          PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE );
                          if ( PUSH_VAR != -1 ){
                              //hb_arraySet(pSTK_REG, PUSH_VAR, pRESULT);
                              put_value(pSTK_REG, pARGP, PUSH_VAR, PRECISION);
                              PUSH_VAR=-1;
                          }else{
                              //hb_arraySet(pSTK_ADDR, ++CADDR, pRESULT);
                              put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                          }
                          //put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                          hb_itemRelease(pARGP);
                          hb_itemRelease(pARGC);
                          hb_itemRelease(pARGS);
                      }else{
                          sw=put_error((PHB_ITEM) pRET, "GET MARK PAGE OVERFLOW",101); 
                      }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "GET MARK COLUMN OVERFLOW",101);
                  }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "GET MARK ROW OVERFLOW",101);
              }
              break;
     }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "GET REGISTER TYPE MUST BE ARRAY WITH RANGE",104);
}
hb_itemRelease(pSource);
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
}*/
return sw;
}

int get_array(){
int sw=1;
int swOffset=0;

int nItem = STK_PRG[++CP];
PHB_ITEM pSource = hb_itemArrayGet( pSTK_REG, nItem );


if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   if(HB_IS_ARRAY( pSource )){
      switch(RANGEDIM){
         case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==RANGEDIM){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                     
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i);
                  PHB_ITEM pELEM = hb_itemArrayGet( pSource, hb_itemGetNI(pCOORD));
                  put_value(pRows, pELEM, i, PRECISION);
                  hb_itemRelease(pELEM);
                  hb_itemRelease(pCOORD);
               }
               if ( PUSH_VAR != -1 ){
                   hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                   PUSH_VAR=-1;
               }else{
                   hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               }
               //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "GET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }case 2:{   // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
            HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
            get_size( (PHB_ITEM) pSource, &nDim1, &d11, &d12, &d13, &type1);
            if(nDim1==2 && RANGECOL==2){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                     
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  put_value(pRows, pELEMCOL, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pCOORDROW);
               }
               if ( PUSH_VAR != -1 ){
                   hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                   PUSH_VAR=-1;
               }else{
                   hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               }
               //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else if(nDim1==3 && RANGECOL==3){
               unsigned int i;
               //PHB_ITEM pREG  = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
               PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                     
               PHB_ITEM pRows  = hb_itemArrayNew( RANGEROW );
               for(i=1;i<=RANGEROW;i++){
                  
                  PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango

                  PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                  PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                  PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                  PHB_ITEM pELEMROW = hb_itemArrayGet( pSource, hb_itemGetNI(pROWX));
                  PHB_ITEM pELEMCOL = hb_itemArrayGet( pELEMROW, hb_itemGetNI(pROWY));
                  PHB_ITEM pELEMPAG = hb_itemArrayGet( pELEMCOL, hb_itemGetNI(pROWP));
                  put_value(pRows, pELEMPAG, i, PRECISION);
                  hb_itemRelease(pROWX);
                  hb_itemRelease(pROWY);
                  hb_itemRelease(pROWP);
                  hb_itemRelease(pELEMROW);
                  hb_itemRelease(pELEMCOL);
                  hb_itemRelease(pELEMPAG);
                  hb_itemRelease(pCOORDROW);
               }
               if ( PUSH_VAR != -1 ){
                   hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                   PUSH_VAR=-1;
               }else{
                   hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               }
               ///hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
               hb_itemRelease(pRows);
               hb_itemRelease(pREG);
            }else{
               sw=put_error((PHB_ITEM) pRET, "GET RANGE->ARRAY TARGET DIMENSION ERROR",111);
            }
            break;
         }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET REGISTER TYPE MUST BE ARRAY WITH RANGE",104);
   }
}else{
   if(HB_IS_ARRAY( pSource )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
      switch( nDim ){
         case 1:{
            unsigned int nIni=1, nFin=d1;
            if (normaliza_indices_1d( &nIni, &nFin, d1, &MARK_POS)){
               if( OFFSET_POS ) {
                  if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
                  nFin=OFFSET_POS;
                  
                  PHB_ITEM pRows ; // = hb_itemArrayNew( nFin - nIni + 1 );
                  int nInc=SET_INTERVAL_ROW, i=nIni;
                  if(nFin < nIni){
                        int nTmp = nIni; nIni = nFin; nFin=nTmp; nInc=-SET_INTERVAL_ROW;
                  }
                  int nLong=get_length(nIni,nFin,SET_INTERVAL_ROW); //nFin - nIni + 1;
                  pRows  = hb_itemArrayNew( nLong );
                  int nPos=1;
                  while ( nLong-- ){
                        PHB_ITEM pARGS = hb_itemArrayGet( pSource, i);
                        put_value(pRows, pARGS, nPos++, PRECISION);
                        hb_itemRelease(pARGS);
                        i = i + nInc;
                  }
                  if ( PUSH_VAR != -1 ){
                      hb_arraySet(pSTK_REG, PUSH_VAR, pRows);
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  ///hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }else{   // solo devuelve un elemento  SINGLE.
                  if( MARK_POS<=d1 ){
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_POS );
                     if ( PUSH_VAR != -1 ){
                         put_value(pSTK_REG, pARGS, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                     }else{
                         put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                     }
                     //put_value(pSTK_ADDR, pARGS, ++CADDR, PRECISION);
                     hb_itemRelease(pARGS);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "GET MARK OVERFLOW",101);
                  }
               }
            } // solo si estan normalizados
            break;
         }case 2:{
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
//            printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
            if( !( sw=normaliza_indices_2d( &nIniR, &nFinR, &nIniC, &nFinC, d1, d2, &swOffset,
                                            &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL) ) ){
                hb_itemRelease(pSource);
                return sw;
            }

//            printf("\nPASA 2\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL); 
          /* 4 CASOS:  
                1.- OFFSET ROW=OFFSET_COL=0     => devuelve SINGLE
                2.- OFFSET_ROW>0, OFFSET_COL=0  => devuelve array 1D
                3.- OFFSET_ROW=0, OFFSET_ROW>0  => devuelve array 1D
                4.- OFFSET_ROW>0, OFFSET_COL>0  => devuelve array 2D. Ya hecho. */
            if( !OFFSET_COL ){   // SINGLE
               if( !OFFSET_ROW ){
                  PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                  PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                  if ( PUSH_VAR != -1 ){
                         put_value(pSTK_REG, pARGC, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                  }else{
                         put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                  }
                  //put_value(pSTK_ADDR, pARGC, ++CADDR, PRECISION);
                  hb_itemRelease(pARGC);
                  hb_itemRelease(pARGS);
               
               }else{  // ARRAY 1D (recorre las filas)
                  int nInc=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                  }
                  //int nLong=nFinR - nIniR + 1;
                  int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int rPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     put_value(pRows, pARGC, rPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     i = i + nInc;
                  }
                  if ( PUSH_VAR != -1 ){
                      hb_arraySet( pSTK_REG, PUSH_VAR, pRows );
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }   
            }else{ 
               if( !OFFSET_ROW ){  // ARRAY 1D (recorre las columnas)
                  PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                  int nInc=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                  }
                  //int nLong=nFinC - nIniC + 1;
                  int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLong );
                  int cPos=1;
                  while ( nLong-- ){
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     put_value(pRows, pARGC, cPos++, PRECISION);
                     hb_itemRelease(pARGC);
                     j = j + nInc;                  
                  }
                  hb_itemRelease(pARGF);
                  
                  if ( PUSH_VAR != -1 ){
                      hb_arraySet( pSTK_REG, PUSH_VAR, pRows );
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }else{   // 2D
                  int nIncR=SET_INTERVAL_ROW,i=nIniR;
                  if(nFinR < nIniR){
                     int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                  }
                  //int nLongR=nFinR - nIniR + 1;
                  int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                  PHB_ITEM pRows  = hb_itemArrayNew( nLongR );
                  int rPos=1;
                  int nIncC=SET_INTERVAL_COL,j=nIniC;
                  if(nFinC < nIniC){
                     int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                  }
                  //int nLongC=nFinC - nIniC + 1;
                  int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                  int cTmp = j;  // guardo para reasignar dentro del ciclo
                  while ( nLongR-- ){
                     int cLongCTmp=nLongC;
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                     PHB_ITEM pCols  = hb_itemArrayNew( cLongCTmp );
                     int cPos=1, j=cTmp;
                     while ( cLongCTmp-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                        put_value(pCols, pARGC, cPos++, PRECISION);
                        hb_itemRelease(pARGC);
                        j = j + nIncC;
                     }
                     hb_arraySet( pRows, rPos++, pCols );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pCols);
                     i = i + nIncR;
                  }

                  if ( PUSH_VAR != -1 ){
                      hb_arraySet( pSTK_REG, PUSH_VAR, pRows );
                      PUSH_VAR=-1;
                  }else{
                      hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  }
                  //hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
                  hb_itemRelease(pRows);
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
            break;
         }case 3:{
            unsigned int nPagIni=1, nPagFin=d3;
            unsigned int nIniR=1, nFinR=d1;
            unsigned int nIniC=1, nFinC=d2;
            if( !(sw=normaliza_indices_3d(&nIniR, &nFinR, &nIniC, &nFinC, &nPagIni, &nPagFin, d1, d2, d3, &swOffset,
                         &MARK_PAGE, &OFFSET_POS, &MARK_ROW, &OFFSET_ROW, &MARK_COL, &OFFSET_COL)) ){
                 hb_itemRelease(pSource);
                 return sw; 
            }

           /* CASOS:
               1.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS=0     => SINGLE
               2.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS=0     => 1D
               3.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS=0     => 1D
               4.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS=0     => 2D
               5.- OFFSET_ROW=0, OFFSET_COL=0, OFFSET_POS>0     => 1D
               6.- OFFSET_ROW>0, OFFSET_COL=0, OFFSET_POS>0     => 2D
               7.- OFFSET_ROW=0, OFFSET_COL>0, OFFSET_POS>0     => 2D
               8.- OFFSET_ROW>0, OFFSET_COL>0, OFFSET_POS>0     => 3D
           */
            if( !OFFSET_POS ){
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // SINGLE
                     PHB_ITEM pARGS = hb_itemArrayGet( pSource, MARK_ROW );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                     PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE );
                     if ( PUSH_VAR != -1 ){
                         put_value(pSTK_REG, pARGP, PUSH_VAR, PRECISION);
                         PUSH_VAR=-1;
                     }else{
                         put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                     }
                     //put_value(pSTK_ADDR, pARGP, ++CADDR, PRECISION);
                     hb_itemRelease(pARGP);
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGS);
                  }else{   // lee solo columnas: array 1D
                     int nInc=SET_INTERVAL_COL,i=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nInc=-SET_INTERVAL_COL;
                     }
                     //int nLong=nFinC - nIniC + 1;
                     int nLong=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLong );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, i);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        i = i + nInc;
                     }

                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY);                   
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // lee solo filas: array 1D
                     int nInc=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nInc=-SET_INTERVAL_ROW;
                     }
                     //int nLong=nFinR - nIniR + 1;
                     int nLong=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int rPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                        put_value(pARRAY, pARGP, rPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nInc;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongR );
                     int rPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, MARK_PAGE);
                           put_value(pARRAYC, pARGP, cPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);  
                  }
               }
            }else{    // existe desplazamiento de páginas
               if( !OFFSET_ROW ){
                  if( !OFFSET_COL ){   // solo desplaza un elemento por página: array 1D
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLong=nPagFin - nPagIni + 1;
                     int nLong=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLong );
                     int kPos=1;
                     while ( nLong-- ){
                        PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                        put_value(pARRAY, pARGP, kPos++, PRECISION);
                        hb_itemRelease(pARGP);
                        k = k + nIncP;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARGC);
                     hb_itemRelease(pARGF);
                     
                     hb_itemRelease(pARRAY);

                  }else{   // lee solo columnas por página: array 2D
                     // esto está mal: deben haber OFFSET_POS filas, y OFFSET_COL columnas, o sea, a verre.
                     // ahora sí:
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     PHB_ITEM pARRAY  = hb_itemArrayNew( nLongP );
                     PHB_ITEM pARGF = hb_itemArrayGet( pSource, MARK_ROW);
                     int kPos=1;
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     
                     int cTmp = j;  // guardo para reasignar dentro del ciclo
                     while ( nLongP-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYP = hb_itemArrayNew( cLongCTmp );
                        int pPos=1, j=cTmp;
                        while ( cLongCTmp-- ){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYP, pARGP, pPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, kPos++, pARRAYP);
                        hb_itemRelease(pARRAYP);
                        k = k + nIncP;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARGF);
                     hb_itemRelease(pARRAY); 
                  }
               }else{  // existe desplazamiento de filas y/o columnas, en una página
                  if( !OFFSET_COL ){  // recorre solo filas, una columna, por página: array 2D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = k;
                     while( nLongR-- ){
                        int cLongPTmp=nLongP;
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);  // leo fila
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, MARK_COL);  // leo única columna
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongPTmp );  // m-columnas                        
                        int kPos=1, k=cTmp;
                        while( cLongPTmp-- ){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pARRAYC, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                           k = k + nIncP;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);
                  }else{  // lee filas y columnas y páginas: array 3D
                     int nIncR=SET_INTERVAL_ROW,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                     PHB_ITEM pARRAY = hb_itemArrayNew( nLongR );
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                     if(nPagFin < nPagIni){
                        int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                     }
                     //int nLongP=nPagFin - nPagIni + 1;
                     int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                     int rPos=1;
                     int cTmp = j;
                     int kTmp = k;
                     while ( nLongR-- ){
                        int cLongCTmp=nLongC;
                        PHB_ITEM pARRAYC = hb_itemArrayNew( cLongCTmp );
                        PHB_ITEM pARGF = hb_itemArrayGet( pSource, i);
                        int cPos=1;
                        j=cTmp;
                        while( cLongCTmp-- ){
                           int cLongPTmp=nLongP;
                           PHB_ITEM pARRAYP = hb_itemArrayNew( cLongPTmp );
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           int kPos=1;
                           k=kTmp;
                           while( cLongPTmp-- ){
                              PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                              put_value(pARRAYP, pARGP, kPos++, PRECISION);
                              hb_itemRelease(pARGP);
                              k = k + nIncP;
                           }
                           hb_arraySet(pARRAYC, cPos++, pARRAYP);
                           hb_itemRelease(pARRAYP);
                           hb_itemRelease(pARGC);
                           j = j + nIncC;
                        }
                        hb_arraySet(pARRAY, rPos++, pARRAYC);
                        hb_itemRelease(pARRAYC);
                        hb_itemRelease(pARGF);
                        i = i + nIncR;
                     }
                     if ( PUSH_VAR != -1 ){
                         hb_arraySet( pSTK_REG, PUSH_VAR, pARRAY );
                         PUSH_VAR=-1;
                     }else{
                         hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     }
                     ///hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
                     hb_itemRelease(pARRAY);                  
                  }
               }
            }
            if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0; }
            break;
         }default:{
            sw=put_error((PHB_ITEM) pRET, "GET DIMENSION ERROR",106);
         }
      }
   }else if(HB_IS_STRING(pSource)){  // si es STRING: obtengo la porción requerida:
      const char * cString = hb_itemGetCPtr(pSource);
      long nLen = hb_itemGetCLen(pSource);
      ///long nLen = hb_cdpUTF8StringLength( hb_itemGetCPtr( pSource ), hb_itemGetCLen( pSource ) );
      long nIni=1,nFin=nLen;
      if( MARK_POS == 999999999 ) MARK_POS=nFin;
      if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
      if( OFFSET_POS ) {  // devuelve una porción
         if( OFFSET_POS == 999999999 ) OFFSET_POS=nLen;

         if(MARK_POS>0 && MARK_POS<=nLen && OFFSET_POS<=nLen && OFFSET_POS>=MARK_POS){
            nFin=OFFSET_POS;
            cString = cString + (nIni-1);
            char * cChar = (char*)calloc(nFin+nFin,1);
            memcpy(cChar, cString, nFin-nIni+1);

            const char * pChar=cChar;
            
            if ( PUSH_VAR != -1 ){
                hb_arraySetC( pSTK_REG, PUSH_VAR, (const char*) pChar );
                PUSH_VAR=-1;
            }else{
                hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
            }
            ///hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
            free(cChar);
         }else{
            sw=put_error((PHB_ITEM) pRET, "GET MARK|OFFSET OVERFLOW",101);
         }
      }else{   // solo devuelve un elemento  SINGLE.
         if( MARK_POS<=nFin && MARK_POS>0 ){
            char cChar[2];
            //cString = cString + MARK_POS-1;
            //cChar[0]=*cString; //cString[MARK_POS-1]; 
            cChar[0]=cString[MARK_POS-1]; 
            cChar[1] = '\0';

            const char * pChar=cChar;

            if ( PUSH_VAR != -1 ){
                hb_arraySetC( pSTK_REG, PUSH_VAR, (const char*) pChar );
                PUSH_VAR=-1;
            }else{
                hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
            }
            //hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pChar );
         }else{
            sw=put_error((PHB_ITEM) pRET, "GET MARK OVERFLOW",101);
         }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET REGISTER TYPE IS NOT AN ARRAY OR STRING",104);
   }
}
hb_itemRelease(pSource);
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
   fun_clear_interval();
}*/

return sw;
}


int put_ewarray(){
int sw=1;

int nItem = STK_PRG[++CP];

if(CADDR){

   PHB_ITEM pTarget = hb_itemArrayGet( pSTK_REG, nItem );
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // Source
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(HB_IS_ARRAY( pTarget )){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pTarget, &nDim, &d1, &d2, &d3, &type);
      switch( nDim ){
         case 1:{
              if( MARK_POS == 999999999 ) MARK_POS=d1;
              if( MARK_POS<=d1 ){
                  put_value(pTarget, pSource, MARK_POS, PRECISION);
                  //hb_arraySet( pSTK_REG, nItem, pPRE );
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT MARK POSITION OVERFLOW",101);
               }
              break;
        }case 2:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pTarget, MARK_ROW );
                     put_value((PHB_ITEM) pPRE1, pSource, MARK_COL, PRECISION );
                    // hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "PUT MARK COLUMN OVERFLOW",101);
                  }
              }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT MARK ROW OVERFLOW",101);
              }
              break;
        }case 3:{
              if( MARK_ROW == 999999999 ) MARK_ROW=d1;
              if( MARK_COL == 999999999 ) MARK_COL=d2;
              if( MARK_POS == 999999999 ) MARK_POS=d3;
              if( MARK_ROW<=d1 ){
                  if( MARK_COL<=d2 ){
                      if( MARK_POS<=d3 ){
                          PHB_ITEM pARGS = hb_itemArrayGet( pTarget, MARK_ROW );
                          PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                          put_value(pARGC, pSource, MARK_POS, PRECISION);
                        //  hb_arraySet( pARGS, MARK_COL, pARGC );
                        //  hb_arraySet( pPRE, MARK_ROW, pARGS );
                        //  hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                          hb_itemRelease(pARGC);
                          hb_itemRelease(pARGS);
                      }else{
                          sw=put_error((PHB_ITEM) pRET, "PUT MARK PAGE OVERFLOW",101); 
                      }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "PUT MARK COLUMN OVERFLOW",101);
                  }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "PUT MARK ROW OVERFLOW",101);
              }
              break;
        }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PUT REGISTER TYPE MUST BE ARRAY",104);
   }
   hb_itemRelease(pSource);
   hb_itemRelease(pTarget);
}else{
   sw=put_error((PHB_ITEM) pRET, "PUT STACK UNDERFLOW",102);
}
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
}*/
return sw;
}


/* MODIFICAR PORQUE EST┴ COMO EL PICO: hecho! */
int put_array(/* long nIndexReg*/ ){
int sw=1;
int swOffset=0;

int nIndexReg = STK_PRG[++CP];

if(SW_USERANGE){  // usa el array apuntado por SW_USERANGE
   PHB_ITEM pARRAYRES = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // Source
   PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nIndexReg );  // Target.
   if(HB_IS_ARRAY( pARRAYRES )){
      if(HB_IS_ARRAY(pPRE)){
         switch(RANGEDIM){
            case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==RANGEDIM){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                     PHB_ITEM pELEM = hb_itemArrayGet( pARRAYRES, i);
                     put_value(pPRE, pELEM, hb_itemGetNI(pCOORD), PRECISION);
                     hb_itemRelease(pELEM);
                     hb_itemRelease(pCOORD);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==2 && RANGECOL==2){
                  unsigned int i;
                  PHB_ITEM pREG  = NULL; //hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                    // caso elemento de array source:
                     PHB_ITEM pELEMROW = hb_itemArrayGet( pARRAYRES, i);

                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     
                     put_value(pROW, pELEMROW, hb_itemGetNI(pROWY), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pELEMROW);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else if(nDim1==3 && RANGECOL==3){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                  /// = hb_itemArrayGet( pSTK_REG, SW_USERANGE);

                  for(i=1;i<=RANGEROW;i++){
                     
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
   
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                     PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                     PHB_ITEM pELEMROW = hb_itemArrayGet( pARRAYRES, i);
                     
                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                     put_value(pCOL, pELEMROW, hb_itemGetNI(pROWP), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pROWP);
                     hb_itemRelease(pELEMROW);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOL);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "PUT TARGET TYPE MUST BE ARRAY",104);
      }
   }else{
///      sw=put_error((PHB_ITEM) pRET, "PUT SOURCE TYPE MUST BE ARRAY",104);
      if(HB_IS_ARRAY(pPRE)){
         switch(RANGEDIM){
            case 1:{  // RANGEDIM==1 Y DIM SOURCE=1
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==RANGEDIM){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                  //hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORD = hb_itemArrayGet( pREG, i); // saco coordenada
                     put_value(pPRE, pARRAYRES, hb_itemGetNI(pCOORD), PRECISION);
                     hb_itemRelease(pCOORD);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }case 2:{   // // RANGEDIM==2 Y DIm SOURCE==2 o 3, OJO!
               HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
               get_size( (PHB_ITEM) pPRE, &nDim1, &d11, &d12, &d13, &type1);
               if(nDim1==2 && RANGECOL==2){
                  unsigned int i;
                  PHB_ITEM pREG = NULL;
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango
                  // = hb_itemArrayGet( pSTK_REG, SW_USERANGE);

                  for(i=1;i<=RANGEROW;i++){
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                    // caso elemento de array source:

                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     
                     put_value(pROW, pARRAYRES, hb_itemGetNI(pROWY), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else if(nDim1==3 && RANGECOL==3){
                  unsigned int i;
                  PHB_ITEM pREG = NULL; // = hb_itemArrayGet( pSTK_REG, SW_USERANGE);
                  if( SW_ORIGIN_RANGE )
                     pREG = hb_itemArrayGet( pSTK_REG, SW_USERANGE);  // saco rango
                  else
                     pREG = hb_itemArrayGet( pSTK_ADDR, SW_USERANGE);  // saco rango

                  for(i=1;i<=RANGEROW;i++){
                     
                     PHB_ITEM pCOORDROW = hb_itemArrayGet( pREG, i); // fila del rango
   
                     PHB_ITEM pROWX = hb_itemArrayGet( pCOORDROW, 1); // ejex
                     PHB_ITEM pROWY = hb_itemArrayGet( pCOORDROW, 2); // ejey
                     PHB_ITEM pROWP = hb_itemArrayGet( pCOORDROW, 3); // ejey
                     
                     PHB_ITEM pROW = hb_itemArrayGet( pPRE, hb_itemGetNI(pROWX));
                     PHB_ITEM pCOL = hb_itemArrayGet( pROW, hb_itemGetNI(pROWY));

                     put_value(pCOL, pARRAYRES, hb_itemGetNI(pROWP), PRECISION);
                     hb_itemRelease(pROWX);
                     hb_itemRelease(pROWY);
                     hb_itemRelease(pROWP);
                     hb_itemRelease(pROW);
                     hb_itemRelease(pCOL);
                     hb_itemRelease(pCOORDROW);
                  }
                  hb_itemRelease(pREG);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT RANGE->ARRAY TARGET DIMENSION ERROR",111);
               }
               break;
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "PUT TARGET TYPE MUST BE ARRAY",104);
      }

   }
   hb_itemRelease(pARRAYRES);
   hb_itemRelease(pPRE);
}else{
if( CADDR>=1 ){
//   PHB_ITEM pARG = hb_itemArrayGet( pSTK_PRG, ++CP);
//   long nIndexReg = hb_itemGetNInt( pARG );
//   hb_itemRelease(pARG);
   PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nIndexReg );  // Target.
 
 // pPRE puede debe ser un array, porque recibe. Si no lo es, debe dar error, lo mismo lo que está en STACK.
   int swARR = 0;
   PHB_ITEM pARRAYRES = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // Source
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_ARRAY( pARRAYRES )){
      swARR=1;
   }else if(HB_IS_STRING(pPRE) && HB_IS_STRING(pARRAYRES)){  // si es STRING: copio la porción requerida:
      const char * cStringT = hb_itemGetCPtr(pPRE);     // target
      const char * cStringS = hb_itemGetCPtr(pARRAYRES);// Source
      long nLenT = hb_itemGetCLen(pPRE);
      long nLenS = hb_itemGetCLen(pARRAYRES);
      long nIni=1,nFin=nLenT;
      
      if( MARK_POS == 999999999 ) MARK_POS=nFin;
      if( MARK_POS )   {nIni=MARK_POS; nFin=MARK_POS;}
      if( OFFSET_POS ) {  // devuelve una porción
         if( OFFSET_POS == 999999999 ) OFFSET_POS=nLenT;
      }else{
         OFFSET_POS=MARK_POS;
      }
      if(MARK_POS>0 && MARK_POS<=nLenT && OFFSET_POS<=nLenT && OFFSET_POS>=MARK_POS){
         nFin=OFFSET_POS;
         char * buffer = (char*)calloc(nLenT+nLenS+1,1);
         if(nIni-1)
            memcpy(buffer, cStringT, (nIni-1));
         memcpy(buffer + (nIni-1), cStringS, nLenS);
         if(nFin<=nLenT){
            cStringT = cStringT + (nFin);
            memcpy(buffer + (nIni-1)+nLenS, cStringT, strlen(cStringT));

            hb_arraySetC( pSTK_REG, nIndexReg, (const char*) buffer );
            free(buffer);
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT MARK|OFFSET OVERFLOW",101);
         }

      }
      hb_itemRelease(pARRAYRES);
      hb_itemRelease(pPRE);
      return sw;
   }
    
   if(!HB_IS_ARRAY( pPRE )){
      sw=put_error((PHB_ITEM) pRET, "PUT REGISTER TYPE IS NOT AN ARRAY",104);
      hb_itemRelease(pPRE);
      //hb_itemRelease(pARG);
      hb_itemRelease(pARRAYRES);
      return sw;
   }
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pPRE, &nDim, &d1, &d2, &d3, &type);

   switch( nDim ){
      case 1:{
         if(MARK_POS>0) {
            if( !swARR ){
               if( MARK_POS == 999999999 ) MARK_POS=d1;
               if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
               
               if(MARK_POS<=d1 ){  // es un elemento
                  if( OFFSET_POS==0 ){
                     put_value(pPRE, pARRAYRES, MARK_POS, PRECISION);
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                  }else{
                     unsigned int i;
                    // int ndx=1;
                     for (i=MARK_POS; i<=OFFSET_POS; i+=SET_INTERVAL_ROW){//i++){
                        put_value((PHB_ITEM) pPRE, pARRAYRES, i, PRECISION);
                     }
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                 //   printf("PASO AQUI\n");
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUT INITIAL LOCATE OVERFLOW",113);
               }
            }else{   // hay desplazamiento, Ya se sabe que OFFSET_POS>=MARK_POS
               if( OFFSET_POS == 999999999 ) OFFSET_POS=d1;
              // if(OFFSET_POS<=d1 && MARK_POS<=d1){ 
                  unsigned int i;
                  int ndx=1;
                  if(MARK_POS<=OFFSET_POS){
                     for (i=MARK_POS; i<=OFFSET_POS; i+=SET_INTERVAL_ROW){
                        PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                        put_value((PHB_ITEM) pPRE, pPRE1, i, PRECISION);
                        hb_itemRelease(pPRE1);
                     }
                  }else{
                     for (i=MARK_POS; i>=OFFSET_POS; i-=SET_INTERVAL_ROW){
                        PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                        put_value((PHB_ITEM) pPRE, pPRE1, i, PRECISION);
                        hb_itemRelease(pPRE1);
                     }                  
                  }
                 // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT MARK 1D ERROR",113);
         }
         break;
      }case 2:{
         if(MARK_ROW>0 && MARK_COL>0){
               int /*nIniR=1,*/ nFinR=d1;
               int /*nIniC=1,*/ nFinC=d2;
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT ROW'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                  //   hb_itemRelease(pARG);
                     return sw;               
                  }
                  /*nIniR=MARK_ROW;*/nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT ROW'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                      //  hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
                  swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT COL'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                   //  hb_itemRelease(pARG);
                     return sw;               
                  }
                  /*nIniC=MARK_COL;*/nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT COL'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                     //   hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
                  swOffset=1;
                  OFFSET_COL=nFinC;
               }

            if ( swARR ){
               HB_MAXINT nDimS=0,d1S=0,d2S=0,d3S=0,typeS=0;
               get_size( (PHB_ITEM) pARRAYRES, &nDimS, &d1S, &d2S, &d3S, &typeS);
               
///  aqui iba control de rows y offset
            
               if(OFFSET_ROW==0){
                  if(OFFSET_COL==0){
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                     put_value((PHB_ITEM) pPRE1, pARRAYRES, MARK_COL, PRECISION );
                     hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }else{
                     if( nDimS == 1 ){
                        PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                        unsigned int j;
                        int ndx=1;
                        if(MARK_COL<=OFFSET_COL){
                           for( j=MARK_COL; j<=OFFSET_COL; j+=SET_INTERVAL_COL){
                              PHB_ITEM pPRE2 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              put_value((PHB_ITEM) pPRE1, pPRE2, j, PRECISION);
                              hb_itemRelease(pPRE2);
                           }
                        }else{
                           for( j=MARK_COL; j>=OFFSET_COL; j-=SET_INTERVAL_COL){
                              PHB_ITEM pPRE2 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              put_value((PHB_ITEM) pPRE1, pPRE2, j, PRECISION);
                              hb_itemRelease(pPRE2);
                           }
                        }
                        hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                       // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                        hb_itemRelease(pPRE1);
                     }else{
                        sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION 1D ERROR",113);
                     }
                  }
               }else{
                  if(OFFSET_COL==0){   // desplazamiento por una columna marcada por MARK_COL
                     if( nDimS == 1 ){
                        unsigned int i;
                        int ndx=1;
                        if(MARK_ROW<=OFFSET_ROW){
                           for( i=MARK_ROW; i<=OFFSET_ROW; i+=SET_INTERVAL_ROW){
                              PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              PHB_ITEM pPROW  = hb_itemArrayGet( pPRE, i);
                              put_value((PHB_ITEM) pPROW, pPRE1, MARK_COL, PRECISION);
                              hb_arraySet( pPRE, i, pPROW );
                              hb_itemRelease(pPROW);   
                              hb_itemRelease(pPRE1);
                           }
                        }else{
                           for( i=MARK_ROW; i>=OFFSET_ROW; i-=SET_INTERVAL_ROW){
                              PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                              PHB_ITEM pPROW  = hb_itemArrayGet( pPRE, i);
                              put_value((PHB_ITEM) pPROW, pPRE1, MARK_COL, PRECISION);
                              hb_arraySet( pPRE, i, pPROW );
                              hb_itemRelease(pPROW);   
                              hb_itemRelease(pPRE1);
                           }
                        }
                       // hb_arraySet(pSTK_REG, nIndexReg, pPRE);
                     }else{
                        sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION 1D ERROR",113);
                     }
                  }else{   // desplaza por filas y columnas, un rectángulo
                     if( nDimS == 2 ){
                        int nIniR = MARK_ROW, nFinR = OFFSET_ROW;
                        int nIniC = MARK_COL, nFinC = OFFSET_COL; 
                        int nIncR=SET_INTERVAL_ROW,i=nIniR;
                        if(nFinR < nIniR){
                           int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                        }
                        //int nLongR=nFinR - nIniR + 1;
                        int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                        int nIncC=SET_INTERVAL_COL,j=nIniC;
                        if(nFinC < nIniC){
                           int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                        }
                        //int nLongC=nFinC - nIniC + 1;
                        int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                        int cTmp = j;  // guardo para reasignar dentro del ciclo
                        int ndx=1;
                        while ( nLongR-- ){
                           int cLongCTmp=nLongC;
                           PHB_ITEM pPRE1 = hb_itemArrayGet( pARRAYRES, ndx++ );
                           PHB_ITEM pPROW  = hb_itemArrayGet( pPRE, i);
                           int j=cTmp;
                           int ndx2=1;
                           while ( cLongCTmp-- ){
                              PHB_ITEM pPRE2 = hb_itemArrayGet( pPRE1, ndx2++ );
                              put_value((PHB_ITEM) pPROW, pPRE2, j, PRECISION);
                              hb_itemRelease(pPRE2);
                              j = j + nIncC;
                           }
                           hb_arraySet(pPRE, i, pPROW);
                           hb_itemRelease(pPROW);
                           hb_itemRelease(pPRE1);
                           i = i + nIncR;
                        }

                     }else{
                        sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION 2D ERROR",113);
                     }
                  }
               }
            }else{  // es solo un elemento asignado a un array
               if(OFFSET_ROW==0){
                  if(OFFSET_COL==0){
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                     put_value((PHB_ITEM) pPRE1, pARRAYRES, MARK_COL, PRECISION );
                     hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                    // hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }else{
                     PHB_ITEM pPRE1 = hb_itemArrayGet( pPRE, MARK_ROW );
                     int nIniC = MARK_COL, nFinC = OFFSET_COL; 
                     int nIncC=SET_INTERVAL_COL,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                     }
                     //int nLongC=nFinC - nIniC + 1;
                     int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                     while ( nLongC-- ){
                        put_value((PHB_ITEM) pPRE1, pARRAYRES, j, PRECISION);
                        j = j + nIncC;
                     }

                     hb_arraySet( pPRE, MARK_ROW, pPRE1 );
                   //  hb_arraySet( pSTK_REG, nIndexReg, pPRE );
                     hb_itemRelease(pPRE1);
                  }
               }else{
                  if(OFFSET_COL==0){   // desplazamiento por una columna marcada por MARK_COL

                     int nIniR = MARK_ROW, nFinR = OFFSET_ROW;
                     int nIncR=SET_INTERVAL_ROW; //,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; // nIncR=-SET_INTERVAL_ROW;
                     }
                     int i;
                     for(i=nIniR; i<=nFinR; i+=nIncR){
                        PHB_ITEM pPROW = hb_itemArrayGet( pPRE, i); 
                        put_value(pPROW, pARRAYRES, MARK_COL, PRECISION);
                        hb_arraySet( pPRE, i, pPROW );
                        hb_itemRelease(pPROW);
                      }

                  }else{   // desplaza por filas y columnas, un rectángulo
                     int nIniR = MARK_ROW, nFinR = OFFSET_ROW;
                     int nIniC = MARK_COL, nFinC = OFFSET_COL; 
                     int nIncR=SET_INTERVAL_ROW;//,i=nIniR;
                     if(nFinR < nIniR){
                        int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp;// nIncR=-SET_INTERVAL_ROW;
                     }
                     //int nLongR=nFinR - nIniR + 1;
                     int nIncC=SET_INTERVAL_COL; //,j=nIniC;
                     if(nFinC < nIniC){
                        int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp;// nIncC=-SET_INTERVAL_COL;
                     }
                     int i;
                     for(i=nIniR; i<=nFinR; i+=nIncR){
                        PHB_ITEM pROW = hb_itemArrayGet( pPRE, i); 
                        int j;
                        for(j=nIniC; j<=nFinC; j+=nIncC){
                            put_value((PHB_ITEM) pROW, pARRAYRES, j, PRECISION);
                         }
                        hb_arraySet( pPRE, i, pROW );
                        hb_itemRelease(pROW);
                     }

                  }
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT INITIAL 2D LOCATE ERROR",113);
         }
         if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
         break;
      }case 3: { 
         if(MARK_ROW && MARK_COL && MARK_POS){
               int nPagIni=1, nPagFin=d3;
               int nIniR=1, nFinR=d1;
               int nIniC=1, nFinC=d2;
               if( MARK_PAGE ){
                  if( MARK_PAGE == 999999999 ) MARK_PAGE=d3;
                  if( MARK_PAGE>d3 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT PAGE'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                   //  hb_itemRelease(pARG);
                     return sw;               
                  }
                  nPagIni=MARK_PAGE; nPagFin=MARK_PAGE;
                  if( OFFSET_POS ){
                     if( OFFSET_POS == 999999999 ) OFFSET_POS=d3;
                     if( OFFSET_POS<=d3 ){
                        nPagFin=OFFSET_POS;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT PAGE'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                     //   hb_itemRelease(pARG);
                        return sw;
                     }
                  } 
               }else{  // si no existe marca de página, se asume todo; luego:
                  swOffset=1;
                  OFFSET_POS=nPagFin; 
                  //printf("\nPASE POR AQUI\nMARK_PAGE=%d\n",MARK_PAGE);
               }
               if( MARK_ROW ) {
                  if( MARK_ROW == 999999999 ) MARK_ROW=d1;
                  if( MARK_ROW>d1 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT ROW'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                    // hb_itemRelease(pARG);
                     return sw;               
                  }
                  nIniR=MARK_ROW;nFinR=MARK_ROW;
                  if( OFFSET_ROW ){
                     if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
                     if( OFFSET_ROW<=d1 ){
                        nFinR=OFFSET_ROW;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT ROW'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                      //  hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las filas
                  swOffset=1;
                  OFFSET_ROW=nFinR;
               }
               if( MARK_COL ) {
                  if( MARK_COL == 999999999 ) MARK_COL=d2;
                  if( MARK_COL>d2 ){
                     sw=put_error((PHB_ITEM) pRET, "PUT COL'MARK OVERFLOW",113);
                     hb_itemRelease(pARRAYRES);
                     hb_itemRelease(pPRE);
                   //  hb_itemRelease(pARG);
                     return sw;               
                  }
                  nIniC=MARK_COL;nFinC=MARK_COL;
                  if( OFFSET_COL ){
                     if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
                     if( OFFSET_COL<=d2 ){
                        nFinC=OFFSET_COL;
                     }else{   // es mayor! ERROR
                        sw=put_error((PHB_ITEM) pRET, "PUT COL'OFFSET OVERFLOW",113);
                        hb_itemRelease(pARRAYRES);
                        hb_itemRelease(pPRE);
                      //  hb_itemRelease(pARG);
                        return sw;
                     }
                  }
               }else{  // asume todas las columnas
                  swOffset=1;
                  OFFSET_COL=nFinC;
               } 

            if( swARR ){
               HB_MAXINT nDimS=0,d1S=0,d2S=0,d3S=0,typeS=0;
               get_size( (PHB_ITEM) pARRAYRES, &nDimS, &d1S, &d2S, &d3S, &typeS);

// aquí iba calculo de offset y marcas
               
               if( !OFFSET_POS ){
                  if( !OFFSET_ROW ){
                     if( !OFFSET_COL ){   // SINGLE
                        PHB_ITEM pARGS = hb_itemArrayGet( pPRE, MARK_ROW );
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGS, MARK_COL );
                        put_value(pARGC, pARRAYRES, MARK_PAGE, PRECISION);

                        hb_itemRelease(pARGC);
                        hb_itemRelease(pARGS);
                     }else{   // lee solo columnas: array 1D
                        if( nDimS == 1 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int cPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              j=cTmp;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }
                     }
                  }else{  // existe desplazamiento de filas y/o columnas, en una página
                     if( !OFFSET_COL ){  // lee solo filas: array 1D
                        if( nDimS == 1 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int cPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              j=cTmp;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }
                     }else{  // lee filas y columnas: array 2D
                        if( nDimS == 2 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int rPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, rPos++);
                              j=cTmp;
                              int cPos=1;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, cPos++);
                                    put_value(pARGC, pARRAY2, k, PRECISION);
                                    hb_itemRelease(pARRAY2);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              hb_itemRelease(pARRAY1);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        } 
                     }
                  }
               }else{    // existe desplazamiento de páginas
                  if( !OFFSET_ROW ){
                     if( !OFFSET_COL ){   // solo desplaza un elemento por página: array 1D
                        if( nDimS == 1 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int cPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              j=cTmp;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                              hb_itemRelease(pARGF);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }
                     }else{   // lee solo columnas por página: array 2D
                        // esto está mal: deben haber OFFSET_POS filas, y OFFSET_COL columnas, o sea, a verre.
                        // ahora sí:
                        if( nDimS == 2 ){
                           int jRES;
                              int nIncR=SET_INTERVAL_ROW,i=nIniR;
                              if(nFinR < nIniR){
                                 int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                              }
                              //int nLongR=nFinR - nIniR + 1;
                              int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                              int nIncC=SET_INTERVAL_COL,j=nIniC;
                              if(nFinC < nIniC){
                                 int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                              }
                             // int nLongC=nFinC - nIniC + 1;
                              int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                              if(nPagFin < nPagIni){
                                 int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                              }
                              //int nLongP=nPagFin - nPagIni + 1;
                              int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                              int kTmp = k;
                              int iTmp = i;
                            //  int cLongCTmp = nLongC;

                           for(jRES=1; jRES<=d2S; jRES++){  // columnas source

                              int iRES;
                              PHB_ITEM pNEW = hb_itemArrayNew(d1S);
                              for(iRES=1; iRES<=d1S; iRES++){   // filas source
                                 PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, iRES);
                                 PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, jRES);
                                 put_value(pNEW, pARRAY2, iRES, PRECISION); // obtengo primera columna
                                 hb_itemRelease(pARRAY2);
                                 hb_itemRelease(pARRAY1);
                              }

                              int cPos=1;
                              int cLongRTmp=nLongR;
                              i=iTmp;
                              while ( cLongRTmp-- ){
                                 PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 int cLongPTmp=nLongP;
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY1 = hb_itemArrayGet( pNEW, cPos++);
                                    put_value(pARGC, pARRAY1, k, PRECISION);
                                    hb_itemRelease(pARRAY1);
                                    k = k + nIncP;
                                 }
                                 hb_itemRelease(pARGC);
                                 hb_itemRelease(pARGF);
                                 i = i + nIncR;
                              }
                              j = j + nIncC;
                              // guardo en cada elemento de cada pagina de la fila y columna asignada.

                              hb_itemRelease(pNEW);
                              
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }  
                     }
                  }else{  // existe desplazamiento de filas y/o columnas, en una página
                     if( !OFFSET_COL ){  // recorre solo filas, una columna, por página: array 2D
                        if( nDimS == 2 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int rPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, rPos++);
                              j=cTmp;
                              int cPos=1;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 k=kTmp;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, cPos++);
                                    put_value(pARGC, pARRAY2, k, PRECISION);
                                    hb_itemRelease(pARRAY2);
                                    k = k + nIncP;
                                 }
                               //  hb_arraySet(pARGF, j, pARGC);
                                 hb_itemRelease(pARGC);
                                 j = j + nIncC;
                              }
                            //  hb_arraySet(pPRE, i, pARGF);
                              hb_itemRelease(pARGF);
                              hb_itemRelease(pARRAY1);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        } 
                     }else{  // lee filas y columnas y páginas: array 3D
                        if( nDimS == 3 ){
                           int nIncR=SET_INTERVAL_ROW,i=nIniR;
                           if(nFinR < nIniR){
                              int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
                           }
                           //int nLongR=nFinR - nIniR + 1;
                           int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
                           int nIncC=SET_INTERVAL_COL,j=nIniC;
                           if(nFinC < nIniC){
                              int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
                           }
                           //int nLongC=nFinC - nIniC + 1;
                           int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
                           int nIncP=SET_INTERVAL_PAG,k=nPagIni;
                           if(nPagFin < nPagIni){
                              int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
                           }
                           //int nLongP=nPagFin - nPagIni + 1;
                           int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);
                           int rPos=1;
                           int cTmp = j;
                           int kTmp = k;
                           while ( nLongR-- ){
                              int cLongCTmp=nLongC;
                              PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                              PHB_ITEM pARRAY1 = hb_itemArrayGet( pARRAYRES, rPos++);
                              j=cTmp;
                              int cPos=1;
                              while( cLongCTmp-- ){
                                 int cLongPTmp=nLongP;
                                 PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                                 PHB_ITEM pARRAY2 = hb_itemArrayGet( pARRAY1, cPos++);
                                 k=kTmp;
                                 int pPos=1;
                                 while( cLongPTmp-- ){
                                    PHB_ITEM pARRAY3 = hb_itemArrayGet( pARRAY2, pPos++);
                                    put_value(pARGC, pARRAY3, k, PRECISION);
                                    hb_itemRelease(pARRAY3);
                                    k = k + nIncP;
                                 }
                               //  hb_arraySet(pARGF, j, pARGC);
                                 hb_itemRelease(pARGC);
                                 hb_itemRelease(pARRAY2);
                                 j = j + nIncC;
                              }
                            //  hb_arraySet(pPRE, i, pARGF);
                              hb_itemRelease(pARGF);
                              hb_itemRelease(pARRAY1);
                              i = i + nIncR;
                           }

                        }else{
                           sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION LOCATE ERROR",113);
                        }                
                     }
                  }
               }
            }else{   // es un elemento que se es asignado a una porción del arreglo. Debo modificar
               int nIncR=SET_INTERVAL_ROW,i=nIniR;
               if(nFinR < nIniR){
                  int nTmp = nIniR; nIniR = nFinR; nFinR=nTmp; nIncR=-SET_INTERVAL_ROW;
               }
               //int nLongR=nFinR - nIniR + 1;
               int nLongR=get_length(nIniR,nFinR,SET_INTERVAL_ROW);
               int nIncC=SET_INTERVAL_COL,j=nIniC;
               if(nFinC < nIniC){
                  int nTmp = nIniC; nIniC = nFinC; nFinC=nTmp; nIncC=-SET_INTERVAL_COL;
               }
               //int nLongC=nFinC - nIniC + 1;
               int nLongC=get_length(nIniC,nFinC,SET_INTERVAL_COL);
               int nIncP=SET_INTERVAL_PAG,k=nPagIni;
               if(nPagFin < nPagIni){
                  int nTmp = nPagIni; nPagIni = nPagFin; nPagFin=nTmp; nIncP=-SET_INTERVAL_PAG;
               }
               //int nLongP=nPagFin - nPagIni + 1;
               int nLongP=get_length(nPagIni,nPagFin,SET_INTERVAL_PAG);

               int cTmp = j;
               int kTmp = k;
               while ( nLongR-- ){
                  int cLongCTmp=nLongC;
                  PHB_ITEM pARGF = hb_itemArrayGet( pPRE, i);
                  j=cTmp;
                  while( cLongCTmp-- ){
                     int cLongPTmp=nLongP;
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     k=kTmp;
                     while( cLongPTmp-- ){
                        put_value(pARGC, pARRAYRES, k, PRECISION);
                        k = k + nIncP;
                     }
                    // hb_arraySet(pARGF, j, pARGC);
                     hb_itemRelease(pARGC);
                     j = j + nIncC;
                  }
                 // hb_arraySet(pPRE, i, pARGF);
                  hb_itemRelease(pARGF);
                  i = i + nIncR;
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUT INITIAL 3D LOCATE ERROR",113);
         }
         if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; OFFSET_POS=0; }
         break;
      }default: {
         sw=put_error((PHB_ITEM) pRET, "PUT DIMENSION ERROR",113);
      }
   }
   hb_itemRelease(pARRAYRES);
   hb_itemRelease(pPRE);
//   hb_itemRelease(pARG);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "PUT STACK UNDERFLOW",102);
}
}
if (STK_PRG[CP+1]==199){  // clear interval
   fun_clear_interval();
   ++CP;
}
/*if(SW_CLRMARKSALL){
   fun_clear_marks();
   fun_clear_interval();
}*/

return sw;
}

/* realiza un volcado del array en el Stack. Sirve para no repetir líneas
   con GET y MOV. Mejor hago GET de una y luego los MOV.
   Atencion! si el array es largo, saturará el stack. */
int fun_dump_array(){
int sw=1;
   PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
   if( nDim==1 ){
       long i;
       for(i=1; i<=d1; ++i){
           PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
           //hb_arrayAdd(pSTACK, pREG);
           if (++CADDR <= nSizeStack ) {
               hb_arraySet(pSTK_ADDR, CADDR, pREG);
           }else{
              /* DECISION: aumentar el size del stack. Si dejo esto así
                 Es probable que logre saturar el stack con un array muy grande...
                 Mejor lo mando a la mierda!! */
              sw=put_error((PHB_ITEM) pRET, "DUMPARRAY STACK OVERFLOW",101); 
           }
           hb_itemRelease(pREG);
       }
   }else{
       sw=put_error((PHB_ITEM) pRET, "DUMPARRAY ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
   }
   hb_itemRelease(pDATO);
return sw;
}
   
   
/* Saca las columnas --desde el stack-- de un array y las deja en el stack. */
int getcol(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "GETCOL ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   CADDR += SWKEEP; SWKEEP = 0;
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "GETCOL REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d2) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim <= 3 ){
          PHB_ITEM pARRAY = hb_itemArrayNew( d1 ); // filas existentes.
          HB_MAXINT i;
          for(i=1; i<=d1; i++){
              PHB_ITEM pARRAYC = hb_itemArrayNew( nLong );
              PHB_ITEM pROW = hb_itemArrayGet( pPREG, i);  // tomo fila "i"
              HB_MAXINT j;

              for(j=0; j<nLong; ++j){
                  PHB_ITEM pCOL = hb_itemArrayGet( pROW, nColDel[ j ] );  // era j
                  put_value((PHB_ITEM) pARRAYC, pCOL, j + 1, PRECISION); // era j + 1
                  hb_itemRelease(pCOL);
              }
              hb_arraySet( pARRAY, i, pARRAYC);
              hb_itemRelease(pARRAYC);
              hb_itemRelease(pROW);
          }
          hb_arraySet(pSTK_ADDR, ++CADDR, pARRAY);
          hb_itemRelease(pARRAY);
          hb_itemRelease(pPREG);
      }else{
          sw=put_error((PHB_ITEM) pRET, "GETCOL SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "GETCOL STACK UNDERFLOW",102);
}
return sw;
}

/* Saca las filas --indicadas en stack-- desde un array y las deja disponibles en stack.
   podría dejar disponibles en una variable: pushvar(X);getrow; */
int getrow(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "GETROW ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   CADDR += SWKEEP; SWKEEP = 0;
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "GETROW REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d1) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim <= 3 ){
          PHB_ITEM pARRAY = hb_itemArrayNew( 0 );
          long i;
          for(i=0; i<nLong; ++i){
              PHB_ITEM pROW = hb_itemArrayGet( pPREG, nColDel[i]);
              hb_arrayAdd( pARRAY, pROW);
              hb_itemRelease(pROW);
          }
          hb_arraySet(pSTK_ADDR, ++CADDR, pARRAY);
          hb_itemRelease(pARRAY);
          hb_itemRelease(pPREG);
      }else{
          sw=put_error((PHB_ITEM) pRET, "GETROW SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "GETROW STACK UNDERFLOW",102);
}
return sw;
}

/* Saca las paginas --indicadas en stack-- desde un array 3D y las deja disponibles en stack.
   podría dejar disponibles en una variable: pushvar(X);getrow; */
int getpage(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "GETPAGE ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   CADDR += SWKEEP; SWKEEP = 0;
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "GETPAGE REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d3) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 3 ){
          
          PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                   long j, cPos=1;
                   for(j=1; j<=d2; j++){
                       PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                       PHB_ITEM pARRAYP = hb_itemArrayNew( nLong );
                       long k,kPos=1;

                       for(k=0; k<nLong; k++){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, nColDel[k]);
                           put_value(pARRAYP, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                       }
                       hb_itemRelease(pARGC);
                       hb_arraySet(pARRAYC, cPos++, pARRAYP);
                       hb_itemRelease(pARRAYP);
                   }
                   hb_arraySet(pARRAY, rPos++, pARRAYC);
                   hb_itemRelease(pARRAYC);
                   hb_itemRelease(pARGF);
               }
               //hb_itemRelease(pPREG);
               //hb_arraySet( pSTK_REG, nItem, pARRAY );
               //hb_itemRelease(pARRAY);
               
          hb_arraySet(pSTK_ADDR, ++CADDR, pARRAY);
          hb_itemRelease(pARRAY);
          hb_itemRelease(pPREG);
      }else{
          sw=put_error((PHB_ITEM) pRET, "GETPAGE SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "GETPAGE STACK UNDERFLOW",102);
}
return sw;
}


/*int catvector(){
int sw=1;

return sw;
}*/

int catrow(/* long nIndexReg*/ ){
int sw=1;
if( CADDR>=1 ){

   int nIndexReg = STK_PRG[++CP];

   PHB_ITEM pARRAY = hb_itemArrayNew( 0 );  // array retorno
      
   // obtener el oprimero: ese manda!
   PHB_ITEM pARRFIRST = (PHB_ITEM) hb_itemArrayGet( pSTK_ADDR, CADDR); // si resto CADDR, me salto el primer array
   if(!HB_IS_ARRAY( pARRFIRST)){
      sw=put_error((PHB_ITEM) pRET, "CATROW REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease( pARRFIRST );
      hb_itemRelease( pARRAY );
//      hb_itemRelease(pPRE);
      //hb_itemRelease(pARG);
      return sw;
   }
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARRFIRST, &nDim, &d1, &d2, &d3, &type);
   hb_itemRelease(pARRFIRST);
   int nLenCol = d2==0?d1:d2;  // un array simple se copiará con "transpuesta".
   
   
   while( CADDR ){
      PHB_ITEM pARRSTACK = (PHB_ITEM) hb_itemArrayGet( pSTK_ADDR, CADDR--);
      if( HB_IS_ARRAY(pARRSTACK) ){
            nDim=0,d1=0,d2=0,d3=0,type=0;
            get_size( (PHB_ITEM) pARRSTACK, &nDim, &d1, &d2, &d3, &type);
            switch(nDim){
               case 1:{
                  if(d1 == nLenCol){
                     hb_arrayAdd( pARRAY, pARRSTACK);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "CATROW SIZE(1D) COLUMN ERROR",113);
                  }
                  break;
               }case 2:{
                  if(d2 == nLenCol){
                     HB_MAXINT i;
                     for(i=1; i<=d1; i++){
                        PHB_ITEM pRow = hb_itemArrayGet( (PHB_ITEM) pARRSTACK, i );
                        hb_arrayAdd( pARRAY, pRow);
                        hb_itemRelease( pRow );
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "CATROW SIZE(2D) COLUMN ERROR",113);
                  }
                  break;
               }default:{
                  sw=put_error((PHB_ITEM) pRET, "CATROW DIMENSION ERROR: MUST BE 1D|2D ARRAY",113);
                  break;
               }
            }
      }else{
         sw=put_error((PHB_ITEM) pRET, "CATROW TYPE MISMATCH",104);
      }
      hb_itemRelease(pARRSTACK);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   hb_arraySet(pSTK_REG, nIndexReg, pARRAY);
   hb_itemRelease( pARRAY );
//   hb_itemRelease(pPRE);
 //  hb_itemRelease(pARG);
}else{
   sw=put_error((PHB_ITEM) pRET, "CATROW STACK UNDERFLOW",102);
}
return sw;
}

/* DECISION: añadir opción para seleccionar columnas en 3D, con MARK_PAGE, o solo dejarlo para 2D y VERIFICAR ESO */
int catcol(/* long nIndexReg */){
int sw=1;
if( CADDR>=2 ){

   int nIndexReg = STK_PRG[++CP];

   int nNumCols = 0;
   PHB_ITEM pCols[CADDR];  // arrays de punteros PHB_ITEM 
   int numCols[CADDR];
   
   pCols[ nNumCols ] = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   if (!HB_IS_ARRAY(pCols[ nNumCols ])){
      sw=put_error((PHB_ITEM) pRET, "CATCOL REGISTER TYPE IS NOT AN ARRAY",103);
//      hb_itemRelease(pPRE);
     // hb_itemRelease(pARG);
      return sw;
   }
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pCols[ nNumCols ], &nDim, &d1, &d2, &d3, &type);
   int nLenRow = d1, nLenCol=d2==0?1:d2;
   numCols[nNumCols] = d2;

   while( CADDR ){
      nNumCols++;
      pCols[ nNumCols ] = (PHB_ITEM) hb_itemArrayGet( pSTK_ADDR, CADDR--);
      if( !HB_IS_ARRAY( (PHB_ITEM)pCols[ nNumCols ] ) ){
         sw=put_error((PHB_ITEM) pRET, "CATCOL TYPE MISMATCH",104);
//         hb_itemRelease(pPRE);
       //  hb_itemRelease(pARG);
         int i;
         for(i=0; i<=nNumCols; i++){
            hb_itemRelease( pCols[ i ] );
         }
         return sw;      
      }
      nDim=0;d1=0;d2=0;d3=0;type=0;
      get_size( (PHB_ITEM) pCols[ nNumCols ], &nDim, &d1, &d2, &d3, &type);
      if(d1 != nLenRow){
         sw=put_error((PHB_ITEM) pRET, "CATCOL SIZE ROW ERROR",106);
//         hb_itemRelease(pPRE);
       //  hb_itemRelease(pARG);
         int i;
         for(i=0; i<=nNumCols; i++){
            hb_itemRelease( pCols[ i ] );
         }
         return sw;
      }
      numCols[nNumCols] = d2;

      nLenCol += d2==0?1:d2;
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   PHB_ITEM pARRAY = hb_itemArrayNew( 0 );

   HB_MAXINT j;

   for(j=1; j<=nLenRow; j++){
      int nArray=0;
      PHB_ITEM pARRAYADD = hb_itemArrayNew( nLenCol );
      int i;
      for(i=0; i<=nNumCols; i++){  // recorro cada array
         if(numCols[i]>0){   // matriz: añado la fila j.
            PHB_ITEM pRow = hb_itemArrayGet( (PHB_ITEM) pCols[ i ], j );  // fila i, de array i
            HB_MAXINT k;
            for(k=1; k<=numCols[i]; k++){
               PHB_ITEM pCol = hb_itemArrayGet( pRow, k );
               put_value((PHB_ITEM) pARRAYADD, pCol, ++nArray, PRECISION);
               hb_itemRelease( pCol );
            }
            hb_itemRelease( pRow );
         }else{   // array simple: añado el elemento de esa fila j en particular
            PHB_ITEM pCol = hb_itemArrayGet( (PHB_ITEM) pCols[ i ], j );
            put_value((PHB_ITEM) pARRAYADD, pCol, ++nArray, PRECISION);
            hb_itemRelease( pCol );
         }
      }
      hb_arrayAdd( pARRAY, pARRAYADD);
      hb_itemRelease( pARRAYADD );
   } 
   hb_arraySet(pSTK_REG, nIndexReg, pARRAY);
   hb_itemRelease( pARRAY );
   HB_MAXINT h;
   for(h=0; h<=nNumCols; h++){
      hb_itemRelease( (PHB_ITEM)pCols[ h ] );
   }
//   hb_itemRelease(pPRE);
 //  hb_itemRelease(pARG);

}else{
   sw=put_error((PHB_ITEM) pRET, "CATCOL STACK UNDERFLOW",102);
}
return sw;
}


//int putpage( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int putpage( /*long nIndexReg*/ ){
int sw=1;
if( CADDR>0 ){

   long nIndexReg = STK_PRG[ ++CP ];

   PHB_ITEM pPRE = hb_itemArrayGet( pSTK_REG, nIndexReg );
   
   if( HB_IS_ARRAY(pPRE)){

      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pPRE, &nDim, &d1, &d2, &d3, &type);  // verificar si registro destino puede recibir los datos
      if( nDim==3 && d3>0 ){
         if( MARK_PAGE<=d3 && MARK_PAGE>0 ){
            int i;
            if( CADDR>0 ){
               PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               CADDR += SWKEEP; SWKEEP = 0;
               if(HB_IS_ARRAY(pARRAY)){
                  HB_MAXINT nDim1=0,d11=0,d21=0, d31=0,type1=0;
                  get_size( (PHB_ITEM) pARRAY, &nDim1, &d11, &d21, &d31, &type1);
                  type=0; type1=0;
                  if( nDim1==2 && d1==d11 && d2==d21 ){
                     for( i=1; i<=d1; i++ ){
                        PHB_ITEM pARRAYF = hb_itemArrayGet( pARRAY, i);  // saco fila de STACK
                        PHB_ITEM pREGF = hb_itemArrayGet( pPRE, i);      // saco fila de REG
               
                        int j;
                        for( j=1; j<=d2; j++ ){
                           PHB_ITEM pARRAYC = hb_itemArrayGet( pARRAYF, j);   // columna del stack
                           PHB_ITEM pREGC = hb_itemArrayGet( pREGF, j);     // columna del registro
                           hb_arraySet( pREGC, MARK_PAGE, pARRAYC );
                           hb_arraySet( pREGF, j, pREGC );
                           hb_itemRelease( pREGC );
                           hb_itemRelease( pARRAYC );
                        }
                      //  hb_arraySet( pPRE, i, pREGF );
                        hb_itemRelease( pREGF );
                        hb_itemRelease( pARRAYF );
                     }
                    // hb_arraySet(pSTK_REG, nIndexReg, pPRE);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "PUTPAGE DIMENSION SOURCE ERROR",106);
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "PUTPAGE ARRAY TYPE IS NOT AN ARRAY",103);
               }
               hb_itemRelease(pARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "PUTPAGE STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "PUTPAGE MARK PAGE OVERFLOW",113);
         }   
      }else{
         sw=put_error((PHB_ITEM) pRET, "PUTPAGE DIMENSION TARGET ERROR",106);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PUTPAGE REGISTER TYPE IS NOT AN ARRAY",103);
   }
//   hb_itemRelease(pARG);
   hb_itemRelease(pPRE);
}else{
   sw=put_error((PHB_ITEM) pRET, "PUTPAGE STACK UNDERFLOW",102);
}
return sw;
}


int fun_mklist(){
int sw=1;
if(CADDR){
   int nIndex=0;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(nIndex<=CADDR){
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, ++nIndex);
      const char * Escape = hb_itemGetCPtr(pDATO);
      hb_itemRelease(pDATO);
      if (Escape[0]=='\033') break;
   }
   int nTope = nIndex; // para borra ESC.
 //  printf("FOUND = %d\n",nTope);
 //  hb_arraySetNI( pSTK_ADDR, nTope, 0 );
   nIndex++;
   while(nIndex<=CADDR){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "MKLIST ARGUMENT ERROR (ARRAY DIMENSION <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      ///hb_arrayAdd( pSTACK, pDATO );
      hb_itemRelease(pDATO);
   }
   //CADDR += SWKEEP; 
   SWKEEP = 0;
   CADDR = nTope-1;
 //  printf("NEWCADDR = %d\n",CADDR);
   hb_arraySet( pSTK_ADDR, ++CADDR, pSTACK );
   hb_itemRelease(pSTACK);
   
}
return sw;
}

int fun_pushall(){
   int sw=1;
   int nItem = STK_PRG[++CP];
   int nIndex=1;
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
   while(CADDR){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "PUSHALL ARGUMENT ERROR (ARRAY DIMENSION <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }
   hb_itemRelease(pSTACK);
   CADDR += SWKEEP; SWKEEP = 0;
   return sw;
}

int add_item_row(){
int sw=1;

   if ( CADDR>0 ){

      int nItem = STK_PRG[ ++CP ];

      PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); //
      
      
      unsigned int nMasterLong=CADDR;
      
      long uarray = hb_arrayLen( pPREG );
      PHB_ITEM pARR = hb_itemArrayGet( pPREG, 1 );
      long uiArrayLenReg = ( long ) hb_arrayLen( pARR );
      hb_itemRelease(pARR);
      
      PHB_ITEM pARRAY=hb_itemArrayNew(nMasterLong);
      int ndx = 1;
      while(CADDR && sw){
         PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, ndx );
         if (!HB_IS_ARRAY(pSource)){  // 1-NOV-2022
            put_value( pARRAY, pSource, ndx, PRECISION);
         }else{
            //sw=put_error((PHB_ITEM) pRET, "ADDROW ARGUMENT ERROR (NOT SINGLE VALUE)",103);
            HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
            get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type);
            if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pSource );
                hb_arraySize(pARRAY,--nMasterLong);
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pSource, i);
                    hb_arrayAdd(pARRAY, pREG);
                    hb_itemRelease(pREG);
                }
            }else{
                sw=put_error((PHB_ITEM) pRET, "ADDROW ARGUMENT ERROR (ARRAY DIMENSION <> 1)",103);
            }
         }
         hb_itemRelease(pSource);
         ++ndx;
         --CADDR;
      }
      CADDR += SWKEEP; SWKEEP = 0;
      if(sw){
         if( uarray > 0 ){  // ya hay datos en REG
            long uiArrayLenARRAY = ( long ) hb_arrayLen( pARRAY );
            if( uiArrayLenARRAY == uiArrayLenReg ){
               hb_arraySize( pPREG, uarray + 1 );
               hb_arraySet( pPREG, uarray + 1, (PHB_ITEM) pARRAY );
            }else{
               sw=put_error((PHB_ITEM) pRET, "ADDROW DIMENSION ERROR",106);
            }
         }else{
            hb_arrayAdd( pPREG, (PHB_ITEM) pARRAY );
         }
      }
      hb_itemRelease(pPREG);
      hb_itemRelease(pARRAY);
   }else{
      sw=put_error((PHB_ITEM) pRET, "ADDROW STACK OVERFLOW",101);
   }
return sw;
}

int fun_inspags(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "INSPAGS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "INSPAGS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nPagIns[nLong], nPagSup=0, nValid=0, cPos=0;
   
   long i;
   for(i=0;i<nLong;++i) nPagIns[i]=0; // para que valgrind no patalee!!
   
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0) {--nLong;/*--tLong;*/}  // para que no omita la última columna
       else if(nValid>d3) {
           int nAdd = nValid>d3+nPagSup ? (nValid - d3 - nPagSup) : 0;
           nPagSup += nAdd;
           --nLong;
           //nPagIns[cPos++] = nValid;
           }
       else {nPagIns[cPos++] = nValid;}
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 3 ){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 );
               //int ntPagSup = nPagSup;
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                   long j=0, cPos=1;
                   for (j=1; j<=d2; j++){
                        PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                        PHB_ITEM pPAGS = hb_itemArrayNew( d3 + nLong + nPagSup );
                        
                        long k,kPos=1;
                        for(k=1; k<=d3; k++){
                            long c;
                            for (c=0; c<nLong; c++){
                                if ( k == nPagIns[c] ){
                                    hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                                    //--ntPagSup;
                                    break;
                                }
                            }
                            PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                            put_value(pPAGS, pARGP, kPos++, PRECISION);
                            hb_itemRelease(pARGP);
                        }
                        for(k=1; k<=nPagSup; k++){
                            hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                        }
                        hb_arraySet(pCOLS, cPos++, pPAGS);
                        hb_itemRelease(pPAGS);
                        hb_itemRelease(pARGC);
                   }
                   hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                   hb_itemRelease(pCOLS);
                   hb_itemRelease(pARGF);
               }

              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);   

      }else{
          sw=put_error((PHB_ITEM) pRET, "INSPAGS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "INSPAGS STACK UNDERFLOW",102);
}
return sw;
}


int fun_insrows(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "INSROWS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "INSROWS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nRowIns[nLong], nRowSup=0, nValid=0, cPos=0;
   
   long i;
   for(i=0;i<nLong;++i) nRowIns[i]=0; // para que valgrind no patalee!!
   
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0) {--nLong;}  // para que no omita la última columna
       else if(nValid>d1) {
           int nAdd = nValid>d1+nRowSup ? (nValid - d1 - nRowSup) : 0;
           nRowSup += nAdd;
           --nLong;
           }
       else {nRowIns[cPos++] = nValid;}
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 + nLong + nRowSup );
                 long i=0, rPos=1;
                 int ntRowSup = nRowSup;
                 for (i=1; i<=d1; i++){  // busco cada fila que quiero insertar
                     long c;
                     for (c=0; c<nLong; c++){
                         if ( i == nRowIns[c] ){
                             PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                             long j=0, cPos=1;
                             for (j=1; j<=d2; j++){ 
                                 hb_arraySetND(pCOLS, cPos++, CTE_NAN);
                             }
                             hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                             hb_itemRelease(pCOLS);
                             //--ntRowSup;
                             break;
                         }
                     }
                     PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                     long j=0, cPos=1;
                     for (j=1; j<=d2; j++){ 
                         PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                         put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                         hb_itemRelease(pCOLUMNA);
                     }
                     hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                     hb_itemRelease(pFILA);
                 }
                 int extraFila=0;
                 for (extraFila=rPos; extraFila<rPos+ntRowSup; ++extraFila){
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                     long j=0, cPos=1;
                     for (j=1; j<=d2; j++){
                          hb_arraySetND(pCOLS, cPos++, CTE_NAN);
                     }
                     hb_arraySet( pROWS, extraFila, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                 }
              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);

      }else if (nDim == 3){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 + nLong + nRowSup );
               int ntRowSup = nRowSup;
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   long c;
                   for (c=0; c<nLong; c++){
                       if ( i == nRowIns[c] ){
                           PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                           long j=0, cPos=1;
                           for (j=1; j<=d2; j++){ 
                               PHB_ITEM pPAGS = hb_itemArrayNew( d3 );
                               long k,kPos=1;
                               for(k=1; k<=d3; k++){
                                  hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                               }
                               hb_arraySet(pCOLS, cPos++, pPAGS);
                               hb_itemRelease(pPAGS);
                           }
                           hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                           hb_itemRelease(pCOLS);
                           //--ntRowSup;
                           break; 
                       }
                   }
                   PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   long j=0, cPos=1;
                   for (j=1; j<=d2; j++){ 
                       PHB_ITEM pPAGS = hb_itemArrayNew( d3 );
                       PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                       long k,kPos=1;
                       for(k=1; k<=d3; k++){
                           PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                           put_value(pPAGS, pARGP, kPos++, PRECISION);
                           hb_itemRelease(pARGP);
                       }
                       hb_arraySet(pCOLS, cPos++, pPAGS);
                       hb_itemRelease(pPAGS);
                       hb_itemRelease(pARGC);
                   }
                   hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                   hb_itemRelease(pCOLS);
                   hb_itemRelease(pARGF);
               }
               int extraFila=0;
               for (extraFila=rPos; extraFila<rPos+ntRowSup; ++extraFila){
                   PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                   long j=0, cPos=1;
                   for (j=1; j<=d2; j++){
                       PHB_ITEM pPAGS = hb_itemArrayNew( d3 );
                       long k,kPos=1;
                       for(k=1; k<=d3; k++){
                           hb_arraySetND(pPAGS, kPos++, CTE_NAN);
                       }
                       hb_arraySet(pCOLS, cPos++, pPAGS);
                       hb_itemRelease(pPAGS);
                   }
                   hb_arraySet( pROWS, extraFila, (PHB_ITEM) pCOLS );
                   hb_itemRelease(pCOLS);
               }
              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);   

      }else{
          sw=put_error((PHB_ITEM) pRET, "INSROWS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "INSROWS STACK UNDERFLOW",102);
}
return sw;
}

int fun_inscols(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "INSCOLS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "INSCOLS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColIns[nLong], nColSup=0, nValid=0, cPos=0;
   
   long i;
   for(i=0;i<nLong;++i) nColIns[i]=0; // para que valgrind no patalee!!
   
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0) {--nLong;}  // para que no omita la última columna
       else if(nValid>d2) {
           int nAdd = nValid>d2+nColSup ? (nValid - d2 - nColSup) : 0;
           nColSup += nAdd;
           --nLong;
           }
       else {nColIns[cPos++] = nValid;}
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
              PHB_ITEM pROWS = hb_itemArrayNew( d1 );
                 long i=0, rPos=1;
                 
                 for (i=1; i<=d1; i++){  // busco cada columna que quiero borrar
                     int ntColSup = nColSup;
                     PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 + nLong + nColSup  ); // Si
                     long j=0, cPos=1;
                     for (j=1; j<=d2; j++){  // busco cada columna que quiero borrar
                         long c;
                         for (c=0; c<nLong; c++){
                             if ( j == nColIns[c] ){
                                 hb_arraySetND(pCOLS, cPos++, CTE_NAN);
                                 //--ntColSup;
                                 break;
                             }
                         }
                         PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                         put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                         hb_itemRelease(pCOLUMNA);
                     }
                     int extraColumna=0;
                     for (extraColumna=cPos; extraColumna<cPos+ntColSup; ++extraColumna){
                         hb_arraySetND(pCOLS, extraColumna, CTE_NAN);
                        // put_value(pCOLS, pNAN, extraColumna, PRECISION);
                     }
                     hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                     hb_itemRelease(pFILA);
                 }
                 
              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);

      }else if (nDim == 3){
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;

               for(i=1; i<=d1; i++){
                  int ntColSup = nColSup;
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 + nLong + nColSup );
                  PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                  long j, cPos=1;
                  for(j=1; j<=d2; j++){
                     long c;
                     for (c=0; c<nLong; c++){
                         if ( j == nColIns[c] ){
                             PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                             long k,kPos=1;
                             for(k=1; k<=d3; k++){
                                hb_arraySetND(pARRAYP, kPos++, CTE_NAN);
                             }
                             hb_arraySet(pARRAYC, cPos++, pARRAYP);
                             hb_itemRelease(pARRAYP);
                             //--ntColSup;
                             break;
                         }
                     }

                     PHB_ITEM pARRAYP1 = hb_itemArrayNew( d3 );
                     PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                     long k,kPos=1;
                     for(k=1; k<=d3; k++){
                         PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                         put_value(pARRAYP1, pARGP, kPos++, PRECISION);
                         hb_itemRelease(pARGP);
                     }
                     hb_itemRelease(pARGC);
                     hb_arraySet(pARRAYC, cPos++, pARRAYP1);

                     hb_itemRelease(pARRAYP1);
                  }
                  int extraColumna=0;
                  for (extraColumna=cPos; extraColumna<cPos+ntColSup; ++extraColumna){
                      PHB_ITEM pARRAYP1 = hb_itemArrayNew( d3 );
                      long k,kPos=1;
                      for(k=1; k<=d3; k++){
                          hb_arraySetND(pARRAYP1, kPos++, CTE_NAN);
                      }
                      hb_arraySet(pARRAYC, extraColumna, pARRAYP1);
                      hb_itemRelease(pARRAYP1);
                  }
                  hb_arraySet(pARRAY, rPos++, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
      }else{
          sw=put_error((PHB_ITEM) pRET, "INSCOLS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "INSCOLS STACK UNDERFLOW",102);
}
return sw;
}

int fun_delpags(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "DELPAGS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "DELPAGS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d3) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if (nDim == 3){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                   PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                   long j, cPos=1;
                   for(j=1; j<=d2; j++){
                       PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                       PHB_ITEM pARRAYP = hb_itemArrayNew( d3 - nLong );
                       long k,kPos=1;
                       for(k=1; k<=d3; k++){
                           long c;
                           int swRetiene=1;
                           for (c=0; c<nLong; c++){
                               if ( k == nColDel[c] ){
                                    swRetiene=0;break;
                               }
                           }
                           if (swRetiene){
                               PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                               put_value(pARRAYP, pARGP, kPos++, PRECISION);
                               hb_itemRelease(pARGP);
                           }
                       }
                       hb_itemRelease(pARGC);
                       hb_arraySet(pARRAYC, cPos++, pARRAYP);
                       hb_itemRelease(pARRAYP);
                   }
                   hb_arraySet(pARRAY, rPos++, pARRAYC);
                   hb_itemRelease(pARRAYC);
                   hb_itemRelease(pARGF);
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELPAGS #PAGES TO DEL > #PAGES OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "DELPAGS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "DELPAGS STACK UNDERFLOW",102);
}
return sw;
}


int fun_delrows(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "DELROWS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "DELROWS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d1) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pROWS = hb_itemArrayNew( d1 - nLong );
              
                 long i, rPos=1;
                 for (i=1; i<=d1; i++){  // busco cada fila que quiero borrar
                     long c;
                     int swRetiene=1;
                     for (c=0; c<nLong; c++){
                         if ( i == nColDel[c] ){
                             swRetiene=0;break;
                         }
                     }
                     if (swRetiene){
                         PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                         PHB_ITEM pCOLS = hb_itemArrayNew( d2 );
                         long j, cPos=1;
                         for (j=1; j<=d2; j++){
                             PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                             put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                             hb_itemRelease(pCOLUMNA);
                         }
                         hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                         hb_itemRelease(pCOLS);
                         hb_itemRelease(pFILA);
                     }
                 }
                 hb_itemRelease(pPREG);
                 hb_arraySet( pSTK_REG, nItem, pROWS);
                 hb_itemRelease(pROWS);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELROWS #ROWS TO DEL > #ROWS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else if (nDim == 3){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 - nLong );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                   long c;
                   int swRetiene=1;
                   for (c=0; c<nLong; c++){
                       if ( i == nColDel[c] ){
                             swRetiene=0;break;
                       }
                   }
                   if (swRetiene){
                       PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                       PHB_ITEM pARRAYC = hb_itemArrayNew( d2 );
                       long j, cPos=1;
                       for(j=1; j<=d2; j++){
                           PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                           PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                           long k,kPos=1;
                           for(k=1; k<=d3; k++){
                               PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                               put_value(pARRAYP, pARGP, kPos++, PRECISION);
                               hb_itemRelease(pARGP);
                           }
                           hb_itemRelease(pARGC);
                           hb_arraySet(pARRAYC, cPos++, pARRAYP);
                           hb_itemRelease(pARRAYP);
                       }
                       hb_arraySet(pARRAY, rPos++, pARRAYC);
                       hb_itemRelease(pARRAYC);
                       hb_itemRelease(pARGF);
                   }
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELROWS #ROWS TO DEL > #ROWS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "DELROWS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "DELROWS STACK UNDERFLOW",102);
}
return sw;
}


int fun_delcols(){
int sw=1;
if(CADDR){
   // necesito la funcionalidad de ADDROW para obtener las columnas a borrar
   // debo hacer el cuerpo de ADD row como una función utilitaria.
   /* OBTENER LISTA DE COLUMNAS A BORRAR */
   int nIndex=1;
   PHB_ITEM pSTACK = hb_itemArrayNew( 0 );
   while(CADDR && sw){
      
      PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, nIndex++);
      if(HB_IS_ARRAY(pDATO)){
          HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
          get_size( (PHB_ITEM) pDATO, &nDim, &d1, &d2, &d3, &type);
          if(nDim==1){
                unsigned int i;
                unsigned int nLong=hb_arrayLen( pDATO );
                for (i=1; i<=nLong; ++i){
                    PHB_ITEM pREG = hb_itemArrayGet( pDATO, i);
                    hb_arrayAdd(pSTACK, pREG);
                    hb_itemRelease(pREG);
                }
          }else{
                sw=put_error((PHB_ITEM) pRET, "DELCOLS ARGUMENT ERROR (DIMENSION LIST <> 1)",103);
          }
      }else{
          hb_arrayAdd( pSTACK, pDATO );
      }
      hb_itemRelease(pDATO);
      --CADDR;
   }   
   /* BORRAR COLUMAS, SEGUN SI DIM==2 O DIM==3 */
   long nLong=hb_arrayLen( pSTACK ), tLong=nLong;

   int nItem = STK_PRG[ ++CP ];
   PHB_ITEM pPREG = hb_itemArrayGet( pSTK_REG, nItem ); 
   if(!HB_IS_ARRAY( pPREG )){
      sw=put_error((PHB_ITEM) pRET, "DELCOLS REGISTER TYPE IS NOT AN ARRAY",103);
      hb_itemRelease(pPREG);
      hb_itemRelease(pSTACK);
      return sw;
   }
   /* PONER VERIFICACION DE ABSTRACTA */
   
   HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
   get_size( (PHB_ITEM) pPREG, &nDim, &d1, &d2, &d3, &type);
      
   /* traspasar a array C para hacerlo más manejable y rapido */
   int nColDel[nLong], nValid=0, cPos=0;
   long i;
   for ( i=1; i<=tLong; i++) {
       PHB_ITEM pREG = hb_itemArrayGet( pSTACK, i);
       nValid = hb_itemGetNInt(pREG);
       if (nValid<=0 || nValid>d2) --nLong;  // para que no omita la última columna
       else nColDel[cPos++] = nValid;
       hb_itemRelease(pREG);
   }
   hb_itemRelease(pSTACK);

 ///  printf("NLONG = %ld, cPOS = %d\n",nLong,cPos); fflush(stdout);
 
   /* DO! */
   if( nLong && sw ){
      
      if ( nDim == 2 ){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pROWS = hb_itemArrayNew( d1 );
              
                 long i, rPos=1;
                 for (i=1; i<=d1; i++){  // busco cada columna que quiero borrar
                     PHB_ITEM pFILA = hb_itemArrayGet( pPREG, i);
                     PHB_ITEM pCOLS = hb_itemArrayNew( d2 - nLong ); // Si
                     long j, cPos=1;
                     for (j=1; j<=d2; j++){  // busco cada columna que quiero borrar
                         long c;
                         int swRetiene=1;
                         for (c=0; c<nLong; c++){
                             if ( j == nColDel[c] ){
                                 swRetiene=0;break;
                             }
                         }
                         if (swRetiene){
                             PHB_ITEM pCOLUMNA = hb_itemArrayGet( pFILA, j);
                             put_value(pCOLS, pCOLUMNA, cPos++, PRECISION);
                             hb_itemRelease(pCOLUMNA);
                         }
                     }
                     hb_arraySet( pROWS, rPos++, (PHB_ITEM) pCOLS );
                     hb_itemRelease(pCOLS);
                     hb_itemRelease(pFILA);
                 }

              hb_itemRelease(pPREG);
              hb_arraySet( pSTK_REG, nItem, pROWS);
              hb_itemRelease(pROWS);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELCOLS #COLUMNS TO DEL > #COLUMNS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else if (nDim == 3){
          if( nLong <= d2 ){ // deben haber columnas que borrar
              PHB_ITEM pARRAY = hb_itemArrayNew( d1 );
               long i, rPos=1;
               for(i=1; i<=d1; i++){
                  PHB_ITEM pARRAYC = hb_itemArrayNew( d2 - nLong );
                  PHB_ITEM pARGF = hb_itemArrayGet( pPREG, i);
                  long j, cPos=1;
                  for(j=1; j<=d2; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( d3 );
                     long c;
                     int swRetiene=1;
                     for (c=0; c<nLong; c++){
                         if ( j == nColDel[c] ){
                             swRetiene=0;break;
                         }
                     }
                     if (swRetiene){
                         PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
                         long k,kPos=1;
                         for(k=1; k<=d3; k++){
                            PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                            put_value(pARRAYP, pARGP, kPos++, PRECISION);
                            hb_itemRelease(pARGP);
                         }
                         hb_itemRelease(pARGC);
                         hb_arraySet(pARRAYC, cPos++, pARRAYP);
                     }
                     hb_itemRelease(pARRAYP);
                  }
                  hb_arraySet(pARRAY, rPos++, pARRAYC);
                  hb_itemRelease(pARRAYC);
                  hb_itemRelease(pARGF);
               }
               hb_itemRelease(pPREG);
               hb_arraySet( pSTK_REG, nItem, pARRAY );
               hb_itemRelease(pARRAY);
          }else{
              sw=put_error((PHB_ITEM) pRET, "DELCOLS #COLUMNS TO DEL > #COLUMNS OF SOURCE",101);
              hb_itemRelease(pPREG);
          }
      }else{
          sw=put_error((PHB_ITEM) pRET, "DELCOLS SOURCE DIMENSION ERROR",106);
          hb_itemRelease(pPREG);
      }
   }else{ // si no hay datos, no hace nada.
      hb_itemRelease(pPREG);
   }
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "DELCOLS STACK UNDERFLOW",102);
}
return sw;
}


int revisa_cadena(const char * cText, HB_SIZE nLen, int *nPos, int Search, int tipo){
int vRet=1;
unsigned int i;
const char *pText = cText;
for(i=0;i<nLen;i++){
   char c = *pText;
   switch(tipo){
      case 0: {  // isalpha
         if(Search){
            if( !isalpha(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isalpha(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 1: {  // isdigit
         if(Search){
            if( !isdigit(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isdigit(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 2: {  // isalnum
         if(Search){
            if( !isalnum(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{   
            if( !isalnum(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 3: {  // isascii
         if(Search){
            if( !isascii(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isascii(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 4: {  // iscntrl
         if(Search){
            if( !iscntrl(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !iscntrl(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 5: {  // isgraph
         if(Search){
            if( !isgraph(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isgraph(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 6: {  // ispunct
         if(Search){
            if( !ispunct(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !ispunct(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 7: {  // isspace
         if(Search){
            if( !isspace(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isspace(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 8: {  // isxdigit
         if(Search){
            if( !isxdigit(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isxdigit(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 9: {  // isprint
         if(Search){
            if( !isprint(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isprint(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 10: {  // isupper
         if(Search){
            if( !isupper(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isupper(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 11: {  // islower
         if(Search){
            if( !islower(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !islower(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }case 12: {  // isblank
         if(Search){
            if( !isblank(c) ) {vRet = 0; *nPos=i+1; break;}
         }else{
            if( !isblank(c) ) {vRet = 1; *nPos=i+1; break;}
         }
         break;
     }
   }
   ++pText;
}
return vRet;
}

// {v,"tipo consultado"}type char? -> T o F
int type_item_string(){
int sw=1;
if( CADDR >= 2 ){
   PHB_ITEM pTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pVAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( !HB_IS_ARRAY( pVAR ) ){
      const char * cText = hb_itemGetCPtr(pVAR);
      HB_SIZE nLen = hb_itemGetCLen(pVAR);
      const char * cType = hb_itemGetCPtr(pTYPE);
      int nPos = 0;
      int Search = nPCP == 346? 1:0;
      if (strcmp(cType,"alpha")==0) { 
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 0);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"digit")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 1);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"alnum")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 2);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"ascii")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 3);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );
          
      }else if (strcmp(cType,"cntrl")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 4);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"graph")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 5);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"punct")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 6);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"space")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 7);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"xdigit")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 8);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"print")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 9);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"upper")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 10);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"lower")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 11);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else if (strcmp(cType,"blank")==0){
          int vRet = revisa_cadena(cText, nLen, &nPos, Search, 12);
          if(nPos>0)
             hb_arraySetNInt( pSTK_ADDR, ++CADDR, (int)  nPos );
          hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) vRet );

      }else{
         sw=put_error((PHB_ITEM) pRET, "TYPE STRING? TYPE ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "TYPE STRING? ARGUMENT ERROR",103);
   }
   hb_itemRelease(pTYPE);
   hb_itemRelease(pVAR);
}else{
   sw=put_error((PHB_ITEM) pRET, "TYPE STRING? INNER-STACK OVERFLOW",101);
}
return sw;
}
// {v,"tipo consultado"}type char? -> T o F
int type_item_char(){
int sw=1;
if( CADDR >= 2 ){
   PHB_ITEM pTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pVAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( !HB_IS_ARRAY( pVAR ) ){
      const char * cText = hb_itemGetCPtr(pVAR);
      const char * cType = hb_itemGetCPtr(pTYPE);
      char c = cText[0];  // primer caracter.
      if (strcmp(cType,"alpha")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isalpha(c) );
      else if (strcmp(cType,"digit")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isdigit(c) );
      else if (strcmp(cType,"alnum")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isalnum(c) );
      else if (strcmp(cType,"ascii")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isascii(c) );
      else if (strcmp(cType,"cntrl")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  iscntrl(c) );
      else if (strcmp(cType,"graph")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isgraph(c) );
      else if (strcmp(cType,"punct")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  ispunct(c) );
      else if (strcmp(cType,"space")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isspace(c) );
      else if (strcmp(cType,"xdigit")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isxdigit(c) );
      else if (strcmp(cType,"print")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isprint(c) );
      else if (strcmp(cType,"upper")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isupper(c) );
      else if (strcmp(cType,"lower")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  islower(c) );
      else if (strcmp(cType,"blank")==0) hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  isblank(c) );
      else
         sw=put_error((PHB_ITEM) pRET, "TYPE CHAR? TYPE ARGUMENT ERROR",103);
   }else{
      sw=put_error((PHB_ITEM) pRET, "TYPE CHAR? ARGUMENT ERROR",103);
   }
   hb_itemRelease(pTYPE);
   hb_itemRelease(pVAR);
}else{
   sw=put_error((PHB_ITEM) pRET, "TYPE CHAR? INNER-STACK OVERFLOW",101);
}
return sw;
}

//int type_item( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int type_item(/* int nItem*/ ){
int sw=1;
if( CADDR < nSizeStack ){

   
  // determinar si es instrucción o función
   PHB_ITEM pARRAY;
   if(nPCP == 226){
      int nItem = STK_PRG[ ++CP ];
      pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   }else{
      pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
   }
   if( !HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT type=0;
      get_item_type( (PHB_ITEM) pARRAY, &type);
      switch( type ){
         case 10: {   // string
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "string" );
            break;
         }case 11: case 12: case 13: {  // numint, double, long
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "number" );
            break;
         }case 14: {   // logical
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "boolean" );
            break;
         }
      }
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      switch(type){
         case 10: hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "<string>"  ); break;
         case 11: hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "<number>"  ); break;
         case 12: hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "<boolean>"  ); break;
      }
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "TYPE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_pages(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, d3 );

   }else{
      sw=put_error((PHB_ITEM) pRET, "PAGES ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "PAGES INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_cols(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, d2 );

   }else{
      sw=put_error((PHB_ITEM) pRET, "COLS ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "COLS INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_rows(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, d1 );

   }else{
      sw=put_error((PHB_ITEM) pRET, "ROWS ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "ROWS INNER-STACK OVERFLOW",101);
}
return sw;
}
int fun_get_dims(){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      hb_arraySetNInt( pSTK_ADDR, ++CADDR, nDim );

   }else{
      sw=put_error((PHB_ITEM) pRET, "DIMS ARGUMENT ERROR - I NEED AN ARRAY HERE",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "DIMS INNER-STACK OVERFLOW",101);
}
return sw;
}
//int size_array( PHB_ITEM pSTK_PRG, PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int size_array(/* int nItem*/ ){
int sw=1;
if( CADDR <= nSizeStack ){

   int nItem = STK_PRG[ ++CP ];

   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_ARRAY( pARRAY ) ){
      HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      PHB_ITEM pSIZE = hb_itemArrayNew( nDim + 1 );
      hb_arraySetNInt( pSIZE, 1, (HB_MAXINT)  nDim  );
      hb_arraySetNInt( pSIZE, 2, (HB_MAXINT)  d1  );
      if(nDim==2) hb_arraySetNInt( pSIZE, 3, (HB_MAXINT)  d2  );
      if(nDim==3) {hb_arraySetNInt( pSIZE, 3, (HB_MAXINT)  d2  );
                   hb_arraySetNInt( pSIZE, 4, (HB_MAXINT)  d3  );}
      hb_arraySet( pSTK_ADDR, ++CADDR, pSIZE );
      hb_itemRelease(pSIZE);
   }else{
      //sw=put_error((PHB_ITEM) pRET, "SIZE ARGUMENT ERROR");
      PHB_ITEM pSIZE = hb_itemArrayNew( 2 );
      hb_arraySetNInt( pSIZE, 1, (HB_MAXINT)  0  );
      HB_MAXINT size = 0;
      if( HB_IS_STRING( pARRAY ) )          size = sizeof(char) * hb_itemGetCLen(pARRAY) ;
      else if( HB_IS_DOUBLE( pARRAY ) )    size = sizeof( hb_itemGetND(pARRAY) );
      else if( HB_IS_LONG( pARRAY ) )       size = sizeof( hb_itemGetNL(pARRAY) );
      else if( HB_IS_INTEGER( pARRAY ) )    size = sizeof( hb_itemGetNInt(pARRAY) );

      hb_arraySetNInt( pSIZE, 2, (HB_MAXINT) size  );

      hb_arraySet( pSTK_ADDR, ++CADDR, pSIZE );
      hb_itemRelease(pSIZE);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "SIZE INNER-STACK OVERFLOW",101);
}
return sw;
}


int fun_create_fun_array( /*int nARG1,*/ /*int tCompare*/ ){
int sw=1;
int tCompare = nPCP==210 ? 5 : nPCP==321 ? 6 : nPCP-230;
   // extrae argumentos:
   long nARG1 = STK_PRG[++CP];  // indice de REG
////   printf("nARG1 = %d\nSTK_PRG = %ld\n",nARG1,hb_itemGetNInt(hb_itemArrayGet(pSTK_REG,nARG1)));
   PHB_ITEM pDato=NULL; //hb_itemNew(NULL);
   if(tCompare==5/*210*/){ // primer dato del stack será el elemento para relleno
//      tCompare=5;
      if(CADDR>=2){
         //hb_itemClear(pDato);
         pDato = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      }
   }
   PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nARG1);
   int esAbstracta = hb_itemGetNInt(pABSTRACT);
  // printf("ABSTRACT = %d",esAbstracta);
   hb_itemRelease(pABSTRACT);
   
   // saco dato desde ADDR para size de ARRAY: 1,2 y 3.
   if( CADDR==0 || (tCompare==5 && !pDato ) ){
      sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE ERROR",106);
   }else if( CADDR==1 ){  // 1D
      PHB_ITEM pSize = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( HB_IS_NUMERIC( pSize ) ) {
         HB_MAXINT nSize = hb_itemGetNL( pSize );
         if (nSize > 0){
            PHB_ITEM pARRAY = hb_itemArrayNew( nSize );
            HB_MAXINT i;
            for(i=1; i<=nSize; i++){
               switch( tCompare ){
                  case 1:{ hb_arraySetND(pARRAY, i, hb_random_num()); break; }
                  case 2:{ hb_arraySetNInt(pARRAY, i, 0); break; }
                  case 3: case 4: { hb_arraySetNInt(pARRAY, i, 1); break; }
                  case 5:{ hb_arraySet(pARRAY, i, pDato); break; }
                  case 6:{ hb_arraySetND(pARRAY, i, CTE_NAN); break; }  // nan array
               }
            }
            /* Es una matriz abstracta, o una matriz concreta? 0=abstracta */
         
            if (esAbstracta==-1 )  // es abstracta!
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
            else
               hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
            hb_itemRelease(pARRAY);
         }else{
            sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(1D) NEGATIVE OR ZERO ARGUMENT ERROR",106);
         }
      }else{
         //eRROR
         sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(1D) NOT A NUMBER ARGUMENT ERROR",106);
      }
      hb_itemRelease(pSize);
   }else if( CADDR==2 ){   // 2D
      PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizeCol ) ) {
         PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         if( HB_IS_NUMERIC( pSizeRow ) ) {
            HB_MAXINT i;
            HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
            if (nSizeRow > 0){
               HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
               if (nSizeCol > 0){        
                  PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
                  for(i=1; i<=nSizeRow; i++){
                     PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
                     HB_MAXINT j;
                     for(j=1; j<=nSizeCol; j++){
                        switch( tCompare ){
                           case 1:{ hb_arraySetND(pARRAYC, j, hb_random_num()); break; }
                           case 2:{ hb_arraySetNInt(pARRAYC, j, 0); break; }
                           case 3:{ hb_arraySetNInt(pARRAYC, j, 1); break; }
                           case 4:{
                              if(i == j) hb_arraySetNInt(pARRAYC, j, 1);
                              else       hb_arraySetNInt(pARRAYC, j, 0);
                              break;
                           }
                           case 5:{ hb_arraySet(pARRAYC, j, pDato); break; }
                           case 6:{ hb_arraySetND(pARRAYC, j, CTE_NAN); break; }  // nan array
                        }
//                        hb_arraySetND(pARRAYC, j, hb_random_num());
                     }
                     hb_arraySet(pARRAY, i, pARRAYC);
                     hb_itemRelease(pARRAYC);
                  }
            /* Es una matriz abstracta, o una matriz concreta? 0=abstracta */
                  if (esAbstracta==-1 )  // es abstracta!
                     hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
                  else
                     hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
                  hb_itemRelease(pARRAY);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NEGATIVE OR ZERO ARGUMENT ERROR",106);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NEGATIVE OR ZERO ARGUMENT ERROR",106);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NOT A NUMBER ARGUMENT ERROR",106);
         }
         hb_itemRelease(pSizeRow);
      }else{
         sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NOT A NUMBER ARGUMENT ERROR",106);
      }
      hb_itemRelease(pSizeCol);
   }else if( CADDR>=3 ){   // 3D
      PHB_ITEM pSizePag = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizePag ) ) {
         PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         if( HB_IS_NUMERIC( pSizeCol ) ) {
            PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
            CADDR += SWKEEP; SWKEEP = 0;
            if( HB_IS_NUMERIC( pSizeRow ) ) {
               HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
               HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
               HB_MAXINT nSizePag = hb_itemGetNInt( pSizePag );
               if(nSizeRow > 0){
                  if(nSizeCol > 0){
                     if(nSizePag > 0){
                        HB_MAXINT i;
                          
                        PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
                        for(i=1; i<=nSizeRow; i++){
                           HB_MAXINT j;
                           PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
                           for(j=1; j<=nSizeCol; j++){
                              PHB_ITEM pARRAYP = hb_itemArrayNew( nSizePag );
                              HB_MAXINT k;
                              for(k=1; k<=nSizePag; k++){
                                 switch( tCompare ){
                                    case 1:{ hb_arraySetND(pARRAYP, k, hb_random_num()); break; }
                                    case 2:{ hb_arraySetNInt(pARRAYP, k, 0); break; }
                                    case 3:{ hb_arraySetNInt(pARRAYP, k, 1); break; }
                                    case 4:{
                                       if(i == j) hb_arraySetNInt(pARRAYP, k, 1);
                                       else       hb_arraySetNInt(pARRAYP, k, 0);
                                    break;
                                    }
                                    case 5:{ hb_arraySet(pARRAYP, k, pDato); break; }
                                    case 6:{ hb_arraySetND(pARRAYP, k, CTE_NAN); break; }  // nan array
                                 }
                                 //hb_arraySetND(pARRAYP, k, hb_random_num());
                              }   
                              hb_arraySet(pARRAYC, j, pARRAYP);
                              hb_itemRelease(pARRAYP);
                           }
                           hb_arraySet(pARRAY, i, pARRAYC);
                           hb_itemRelease(pARRAYC);
                        }
                        /* Es una matriz abstracta, o una matriz concreta? 0=abstracta */
                        if (esAbstracta==-1 )  // es abstracta!
                           hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
                        else
                           hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
                        hb_itemRelease(pARRAY);
                     }else{
                        sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NEGATIVE OR ZERO ARGUMENT ERROR",106);
                     }
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NEGATIVE OR ZERO ARGUMENT ERROR",106);
                  }
               }else{
                  sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(PAG) NEGATIVE OR ZERO ARGUMENT ERROR",106);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(ROW) NOT A NUMBER ARGUMENT ERROR",103);
            }
            hb_itemRelease(pSizeRow);
         }else{
            sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(COL) NOT A NUMBER ARGUMENT ERROR",103);
         }
         hb_itemRelease(pSizeCol);
      }else{
         sw=put_error((PHB_ITEM) pRET, "FILL ARRAY SIZE(PAGE) NOT A NUMBER ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSizePag);
   }
   if(pDato) hb_itemRelease(pDato);
return sw;
}

int fun_size_binary( /*int nItem*/ ){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pSIZE = hb_itemArrayGet( pSTK_REG, nItem );
   if( HB_IS_NUMERIC( pSIZE) ){
      SIZE_BINARY = hb_itemGetNInt( pSIZE );
   }else{
      sw=put_error((PHB_ITEM) pRET, "SIZEBIN ARGUMENT ERROR",103);
   }
   hb_itemRelease(pSIZE);
return sw;
}

int fun_emptyarray( /*int nItem*/ ){
int sw=1;
if( CADDR < nSizeStack ){
   PHB_ITEM pARRAY=NULL;
//   printf("TIPO CODE = %d\n",nPCP);
   if(nPCP == 230){
      int nItem = STK_PRG[++CP];
      pARRAY = hb_itemArrayGet( pSTK_REG, nItem );
   }else{
      if(CADDR >= 1){
         pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      }else{
         sw=put_error((PHB_ITEM) pRET, "EMPTY INNER-STACK UNDERFLOW",102);
      }
   }
   if (sw){
      if( HB_IS_ARRAY( pARRAY ) ){
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) !hb_arrayLen( pARRAY ) );
      }else{
         sw=put_error((PHB_ITEM) pRET, "EMPTY ARGUMENT ERROR",103);
      }
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "EMPTY INNER-STACK OVERFLOW",101);
}
return sw;
}

int put_sequenceSpaced(/* int nItem*/ ){
int sw=1;
if( CADDR >= 3 ){
   PHB_ITEM pTOTAL = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pHASTA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDESDE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nItem = STK_PRG[++CP];
   if(HB_IS_NUMERIC(pDESDE)){
      if(HB_IS_NUMERIC(pHASTA)){
         if(HB_IS_NUMERIC(pTOTAL)){
            double pDesde    = hb_itemGetND( pDESDE );
            double pHasta    = hb_itemGetND( pHASTA );
            unsigned pTotal  = hb_itemGetNInt( pTOTAL );
   
            double inc = (pHasta - pDesde) / ( pTotal - 1);
            long n;
            PHB_ITEM pC = hb_itemArrayNew( pTotal );
   
            hb_arraySetND( pC, 1,     (double) pDesde );
            hb_arraySetND( pC, pTotal,(double) pHasta );
   
            for( n=2; n<=pTotal-1; n++){
               PHB_ITEM pCC = hb_itemArrayGet( pC, n-1);
               hb_arraySetND( pC, n, hb_itemGetND( pCC ) + inc );
               hb_itemRelease(pCC);
            }
            
            PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nItem);
            int esAbstracta = hb_itemGetNInt(pABSTRACT);
            hb_itemRelease(pABSTRACT);
            if( esAbstracta==-1 )
                hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pC );
            else
                hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pC );
            hb_itemRelease( pC );
         }else{
            sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED (NUM-ELEMENTS) ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED (END-RANGE) ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED (INI-RANGE) ARGUMENT ERROR",103);
   }
   hb_itemRelease( pTOTAL );
   hb_itemRelease( pHASTA );
   hb_itemRelease( pDESDE );
}else{
   sw=put_error((PHB_ITEM) pRET, "SEQUENCE SPACED INNER-STACK OVERFLOW",101);
}   
return sw;
}

int put_sequence( /*int nItem */){
int sw=1;
if( CADDR >= 3 ){
   PHB_ITEM pTOTAL = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pINC   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDESDE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nItem = STK_PRG[++CP];
   if(HB_IS_NUMERIC(pDESDE)){
      if(HB_IS_NUMERIC(pINC)){
         if(HB_IS_NUMERIC(pTOTAL)){

            double pDesde    = hb_itemGetND( pDESDE );
            double pInc      = hb_itemGetND( pINC );
            unsigned pTotal  = hb_itemGetNInt( pTOTAL );

            long n;
            PHB_ITEM pC = hb_itemArrayNew( pTotal );
   
            hb_arraySetND( pC, 1,     (double) pDesde );
   
            for( n=2; n<=pTotal; n++){
               PHB_ITEM pCC = hb_itemArrayGet( pC, n-1);
               hb_arraySetND( pC, n, hb_itemGetND( pCC ) + pInc );
               hb_itemRelease(pCC);
            }
            
            PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nItem);
            int esAbstracta = hb_itemGetNInt(pABSTRACT);
            hb_itemRelease(pABSTRACT);
            if( esAbstracta==-1 )
                hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pC );
            else
                hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pC );
            ///hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pC );
            hb_itemRelease( pC );
         }else{
            sw=put_error((PHB_ITEM) pRET, "SEQUENCE (NUM-ELEMENTS) ARGUMENT ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SEQUENCE (INCREMENT) ARGUMENT ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SEQUENCE (INIT-VALUE) ARGUMENT ERROR",103);
   }

   hb_itemRelease( pTOTAL );
   hb_itemRelease( pINC );
   hb_itemRelease( pDESDE );
}else{
   sw=put_error((PHB_ITEM) pRET, "SEQUENCE INNER-STACK OVERFLOW",101);
}   
return sw;
}

int fun_voidarray(){
int sw=1;
long nARG1 = STK_PRG[++CP]; // indice de REG
PHB_ITEM pARRAY = hb_itemArrayNew( 0 );  // crea un array vacío.
hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
hb_itemRelease(pARRAY);
return sw;
}

int fun_create_array( /*int nARG1 */){
int sw=1;
   // extrae argumentos:

   long nARG1 = STK_PRG[++CP]; // indice de REG
   PHB_ITEM pABSTRACT = hb_itemArrayGet(pSTK_REG,nARG1);
   int esAbstracta = hb_itemGetNInt(pABSTRACT);
  // printf("ABSTRACT = %d",esAbstracta);
   hb_itemRelease(pABSTRACT);
   
   // saco dato desde ADDR para size de ARRAY: 1,2 y 3.
   if( CADDR==0 ){
      PHB_ITEM pARRAY = hb_itemArrayNew( 0 );  // crea un array vacío.
      if (esAbstracta==-1 )  // es abstracta!
          hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
      else
          hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
      //hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
      hb_itemRelease(pARRAY);
   }else if( CADDR==1 ){  // 1D
      PHB_ITEM pSize = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( HB_IS_NUMERIC( pSize ) ) {
         PHB_ITEM pARRAY = hb_itemArrayNew( hb_itemGetNInt( pSize ) );
         if (esAbstracta==-1 )  // es abstracta!
             hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
         else
             hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
    //     hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
         hb_itemRelease(pARRAY);
      }else{
         //eRROR
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(1D) ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSize);
   }else if( CADDR==2 ){   // 2D
      PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizeCol ) ) {
         PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         if( HB_IS_NUMERIC( pSizeRow ) ) {
            HB_MAXINT i;
            HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
                       
            HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
                       
            PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
            for(i=1; i<=nSizeRow; i++){
               PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
               hb_arraySet(pARRAY, i, pARRAYC);
               hb_itemRelease(pARRAYC);
            }
            if (esAbstracta==-1 )  // es abstracta!
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pARRAY );
            else
               hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
            ///hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
            hb_itemRelease(pARRAY);
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(ROW) ARGUMENT ERROR",103);
         }
         hb_itemRelease(pSizeRow);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(COL) ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSizeCol);
   }else if( CADDR>=3 ){   // 3D
      PHB_ITEM pSizePag = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( HB_IS_NUMERIC( pSizePag ) ) {
         PHB_ITEM pSizeCol = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         if( HB_IS_NUMERIC( pSizeCol ) ) {
            PHB_ITEM pSizeRow = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
            CADDR += SWKEEP; SWKEEP = 0;
            if( HB_IS_NUMERIC( pSizeRow ) ) {
               HB_MAXINT nSizeRow = hb_itemGetNInt( pSizeRow );
               HB_MAXINT nSizeCol = hb_itemGetNInt( pSizeCol );
               HB_MAXINT nSizePag = hb_itemGetNInt( pSizePag );

               HB_MAXINT i;
                          
               PHB_ITEM pARRAY = hb_itemArrayNew( nSizeRow );
               for(i=1; i<=nSizeRow; i++){
                  HB_MAXINT j;
                  PHB_ITEM pARRAYC = hb_itemArrayNew( nSizeCol );
                  for(j=1; j<=nSizeCol; j++){
                     PHB_ITEM pARRAYP = hb_itemArrayNew( nSizePag );
                     HB_MAXINT k;
                     for(k=1; k<=nSizePag; k++){
                        hb_arraySetC(pARRAYP, k, "");
                     }   
                     hb_arraySet(pARRAYC, j, pARRAYP);
                     hb_itemRelease(pARRAYP);
                  }
                  hb_arraySet(pARRAY, i, pARRAYC);
                  hb_itemRelease(pARRAYC);
               }
               hb_arraySet( pSTK_REG, nARG1, (PHB_ITEM) pARRAY );
               hb_itemRelease(pARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(ROW) ARGUMENT ERROR",103);
            }
            hb_itemRelease(pSizeRow);
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(COL) ARGUMENT ERROR",103);
         }
         hb_itemRelease(pSizeCol);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE(PAGE) ARGUMENT ERROR",103);
      }
      hb_itemRelease(pSizePag);
   }
return sw;
}


int fun_ifenv(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      char * cValue = getenv( hb_itemGetCPtr(pVARIABLE) );
      if( cValue ){
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
      }else{
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "IFENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "IFENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_getenv_num(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      char * cValue = getenv( hb_itemGetCPtr(pVARIABLE) );
      if( cValue ){
         const char * pValue = cValue;
         int iWidth, iDec, iLen = ( int ) hb_itemGetCLen( pVARIABLE );
         HB_BOOL fDbl;
         HB_MAXINT lValue;
         double dValue;

         fDbl = hb_valStrnToNum( pValue, iLen, &lValue, &dValue , &iDec, &iWidth );

         if( !fDbl ){
               hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_MAXINT) lValue );
         }else{
               hb_arraySetND( pSTK_ADDR, ++CADDR, (double) dValue );
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "GETENV VARIABLE ERROR",103);
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "GETENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "GETENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_getenv(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      char * cValue = getenv( hb_itemGetCPtr(pVARIABLE) );
      if( cValue ){
         const char * pValue = cValue;
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
      }else{
         sw=put_error((PHB_ITEM) pRET, "GETENV VARIABLE ERROR",103);
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "GETENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "GETENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_setenv(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pVALOR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( !HB_IS_STRING( pVALOR ) ){
      sw=put_error((PHB_ITEM) pRET, "SETENV TYPE MISMATCH VALUE ERROR",104);
   }else{
      if( HB_IS_STRING( pVARIABLE ) ){
         int status = setenv(hb_itemGetCPtr(pVARIABLE), hb_itemGetCPtr(pVALOR), 1); 
         if( status ){
            sw=put_error((PHB_ITEM) pRET, "SETENV VARIABLE ERROR",103);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SETENV ARGUMENT ERROR",103);
      }
   }
   hb_itemRelease( pVARIABLE );
   hb_itemRelease( pVALOR );
}else{
   sw=put_error((PHB_ITEM) pRET, "SETENV INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_unsetenv(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pVARIABLE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pVARIABLE ) ){
      int status = unsetenv( hb_itemGetCPtr(pVARIABLE) );
      if( status ){
         sw=put_error((PHB_ITEM) pRET, "UNSETENV VARIABLE ERROR",103);
      }
     // free(cValue);
   }else{
      sw=put_error((PHB_ITEM) pRET, "UNSETENV ARGUMENT ERROR",103);
   }
   hb_itemRelease( pVARIABLE );
}else{
   sw=put_error((PHB_ITEM) pRET, "UNSETENV INNER-STACK OVERFLOW",101);
}
return sw;
}
/*
#define BLACK        0
#define BLUE         1
#define GREEN        2
#define CYAN         3
#define RED          4
#define MAGENTA      5
#define BROWN        6
#define LIGHTGRAY    7
#define DARKGRAY     8
#define LIGHTBLUE    9
#define LIGHTGREEN   10
#define LIGHTCYAN    11
#define LIGHTRED     12
#define LIGHTMAGENTA 13
#define YELLOW       14
#define WHITE        15
// Special attributes 
#define UNDERLINE    64
#define BLINK        128

// Special font attributes 
#define UNDERLINE_ATTR 4
#define BLINK_ATTR     5
#define BRILLO_ATTR    1

// Bright colors start in color number 9 
#define BRILLO_MIN     9
*/



/*int fun_colortext(PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pCOLOR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if( HB_IS_NUMERIC( pCOLOR ) ) {
      //static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};
     HB_INT color = (HB_INT) hb_itemGetNInt( pCOLOR );
     int atrval=0;
     if (color & UNDERLINE)
       atrval=UNDERLINE_ATTR;
     else if (color & BLINK)
       atrval=BLINK_ATTR;
     else if (color>=BRILLO_MIN)
       atrval=BRILLO_ATTR;

     color=ansicolors[color & 15];
  
     printf("\033[%d;%dm", atrval, color);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COLOR ARGUMENT ERROR",103);
   }
   hb_itemRelease( pCOLOR );
}else{
   sw=put_error((PHB_ITEM) pRET, "COLOR INNER-STACK OVERFLOW",101);
}
return sw;  
}

int fun_background(PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pCOLOR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if( HB_IS_NUMERIC( pCOLOR ) ) {
      //static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};
     HB_INT color = (HB_INT) hb_itemGetNInt( pCOLOR );
  
     if (color<BRILLO_MIN){				   
        color=ansicolors[color & 15]+10;
  
        printf("\033[%dm", color);
     }
   }else{
     sw=put_error((PHB_ITEM) pRET, "BACKGROUND ARGUMENT ERROR",103);
   }
   hb_itemRelease( pCOLOR );
}else{
   sw=put_error((PHB_ITEM) pRET, "BACKGROUND INNER-STACK OVERFLOW",101);
}
return sw;
}
*/

/*
    PROTOTIPOS
*/

int fun_char_pos(){
int sw=1;
if (CADDR>=3){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pCHAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pTIPO = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   
   const char * cCar    = hb_itemGetCPtr( pCHAR );
   const char * cString = hb_itemGetCPtr( pTEXT );
   int tipo = hb_itemGetNI( pTIPO );
   int pos = 0,i;
   
   i=strlen(cString)-1;
   
   const char * b = cString;
   if (tipo){  // desde principio
      while (*cCar == *b) ++b;
      pos = (b - cString) + 1;
   }else{      // desde final
      while( *cCar == cString[i] ) --i;
      pos = i+1;
   }
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) pos );
   hb_itemRelease( pTEXT );
   hb_itemRelease( pCHAR );
   hb_itemRelease( pTIPO );
}else{
   sw=put_error((PHB_ITEM) pRET, "POS CHAR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_cut_single( /*int tipo*/ ){
int sw=1;
int tipo = nPCP;
if( CADDR>=2 ){
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pCHAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING( pTEXT ) && HB_IS_STRING( pCHAR ) ){
      const char *pText = hb_itemGetCPtr( pTEXT );
      const char *pChar = hb_itemGetCPtr( pCHAR );
      char *base;
      if(tipo==59){
         base = index (pText, pChar[0]);
      }else{
         base = rindex (pText, pChar[0]);
      }
      const char * buff = base;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) base ? ++buff : pText );
     // free(base);
   }else{
      sw=put_error((PHB_ITEM) pRET, "CUT ARGUMENT ERROR",103);
   }
   hb_itemRelease( pTEXT );
   hb_itemRelease( pCHAR );
}else{
   sw=put_error((PHB_ITEM) pRET, "CUT INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_char_one(){
int sw=1;
if (CADDR>=2){
   const char *pcString;
   HB_SIZE sStrLen;
   const char *pcDeleteSet;
   HB_SIZE sDeleteSetLen;

   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDELSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   
   pcString = hb_itemGetCPtr( pSTRING );
   sStrLen = hb_itemGetCLen( pSTRING );
   pcDeleteSet = hb_itemGetCPtr( pDELSET );
   sDeleteSetLen = hb_itemGetCLen( pDELSET );
   
   if( sStrLen > 1 )
   {
      const char *pcSub;
      char *pcRet;
      HB_SIZE sRetStrLen = 0;
      char cCurrent = *pcString;

      pcRet = ( char * ) calloc( sStrLen + 1, 1 );//hb_xgrab( sStrLen );
      /* copy first char */
      pcRet[sRetStrLen++] = cCurrent;
      for( pcSub = pcString + 1; pcSub < pcString + sStrLen; pcSub++ )
      {
         if( *pcSub != cCurrent )
         {
            cCurrent = *pcSub;
            pcRet[sRetStrLen++] = cCurrent;
         }
         else if( pcDeleteSet != NULL &&
                           !ct_at_exact_forward( pcDeleteSet, sDeleteSetLen,
                                                 pcSub, 1, NULL ) )
         {
            pcRet[sRetStrLen++] = cCurrent;
         }
      }

      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pcRet );
      free(pcRet);

   }
   else                /* if( sStrLen > 1 ) */
   {
      /* algorithm does nothing to 1-char-strings */
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pcString );
   }
   hb_itemRelease( pSTRING );
   hb_itemRelease( pDELSET );
   
}else{
   sw=put_error((PHB_ITEM) pRET, "ONECHAR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_onlychar(){
int sw=1;
if (CADDR>=2){
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDELSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   const char *pcString = hb_itemGetCPtr( pSTRING );
   HB_SIZE sStrLen = hb_itemGetCLen( pSTRING );
   const char *pcOnlySet = hb_itemGetCPtr( pDELSET );
   HB_SIZE sOnlySetLen = hb_itemGetCLen( pDELSET );
   char *pcRet;
   HB_SIZE sRetStrLen = 0;
   int iShift, iBool;
   const char *pcSub, *pc;

   if( HB_IS_STRING( pSTRING ) && HB_IS_STRING( pDELSET ) ){
      if( sStrLen == 0 || sOnlySetLen == 0 ){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "" );
         hb_itemRelease( pSTRING );
         hb_itemRelease( pDELSET );
         return sw;
      }

      iShift = 1;
      
      pcRet = ( char * ) calloc( sStrLen + 1, 1 );//hb_xgrab( sStrLen );

      for( pcSub = pcString; pcSub < pcString + sStrLen + 1 - iShift; pcSub += iShift )
      {
         pc = ct_at_exact_forward( pcOnlySet, sOnlySetLen, pcSub, iShift, NULL );
         iBool = ( ( pc != NULL ) && ( ( ( pc - pcOnlySet ) % iShift ) == 0 ) );

         if( iBool )
         {
            for( pc = pcSub; pc < pcSub + iShift; pc++ )
               pcRet[sRetStrLen++] = *pc;
         }
      }
      /* copy last character if string len is odd */
      if( iShift == 2 && sStrLen % 2 == 1 )
      {
         pcRet[sRetStrLen++] = pcString[sStrLen - 1];
      }
      const char * buff = pcRet;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) buff );
      free( pcRet );
   }else{
      sw=put_error((PHB_ITEM) pRET, "ONLYCHAR ARGUMENT ERROR",103);
   }
   hb_itemRelease(pSTRING);
   hb_itemRelease(pDELSET);
}else{
   sw=put_error((PHB_ITEM) pRET, "ONLYCHAR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_char_rem(){
int sw=1;
if (CADDR>=2){
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pDELSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   const char *pcString = hb_itemGetCPtr( pSTRING );
   HB_SIZE sStrLen = hb_itemGetCLen( pSTRING );
   const char *pcOnlySet = hb_itemGetCPtr( pDELSET );
   HB_SIZE sOnlySetLen = hb_itemGetCLen( pDELSET );
   char *pcRet;
   HB_SIZE sRetStrLen = 0;
   int iShift, iBool;
   const char *pcSub, *pc;

   if( HB_IS_STRING( pSTRING ) && HB_IS_STRING( pDELSET ) ){
      if( sStrLen == 0 ){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "" );
         hb_itemRelease( pSTRING );
         hb_itemRelease( pDELSET );
         return sw;
      }
      if( sOnlySetLen == 0 ){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pcString );
         hb_itemRelease( pSTRING );
         hb_itemRelease( pDELSET );
         return sw;
      }
      iShift = 1;

      pcRet = ( char * ) calloc( sStrLen + 1, 1 );//hb_xgrab( sStrLen );

      for( pcSub = pcString; pcSub < pcString + sStrLen + 1 - iShift; pcSub += iShift )
      {
         pc = ct_at_exact_forward( pcOnlySet, sOnlySetLen, pcSub, iShift, NULL );
         iBool = ( ( pc != NULL ) && ( ( ( pc - pcOnlySet ) % iShift ) == 0 ) );

         if( !iBool )
         {
            for( pc = pcSub; pc < pcSub + iShift; pc++ )
               pcRet[sRetStrLen++] = *pc;
         }
      }
      /* copy last character if string len is odd */
      if( iShift == 2 && sStrLen % 2 == 1 )
      {
         pcRet[sRetStrLen++] = pcString[sStrLen - 1];
      }
      const char * buff = pcRet;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) buff );
      free( pcRet );
   }else{
      sw=put_error((PHB_ITEM) pRET, "DELETECHAR ARGUMENT ERROR",103);
   }
   hb_itemRelease(pSTRING);
   hb_itemRelease(pDELSET);
}else{
   sw=put_error((PHB_ITEM) pRET, "DELETECHAR INNER-STACK OVERFLOW",101);
}
return sw;
}



/***************************************************
     FUNCIONES DE ARCHIVOS Y CARGA DE MATRICES
 ***************************************************/
 
#define MAXREADBUFFER   2048

void strtoutf8_item(PHB_ITEM pSTRING, PHB_ITEM pSTK, int NDX){
      HB_SIZE nLen = hb_itemGetCLen ( pSTRING ), nDest = 0;
      const char * szString;
      char * szDest = NULL;

      if( nLen )
      {
         PHB_CODEPAGE cdp = hb_vmCDP();

         if( cdp )
         {
            szString = hb_itemGetCPtr( pSTRING );
            nDest = hb_cdpStrAsUTF8Len( cdp, szString, nLen, 0 );
            szDest = ( char * ) calloc( nDest + 1, 1 );
            hb_cdpStrToUTF8( cdp, szString, nLen, szDest, nDest + 1 );
         }
      }
      if( szDest ){
         const char *buff = szDest;
         hb_arraySetC( pSTK, NDX, (const char*) buff );
         free(szDest);
      }else{
         //hb_arraySetC( pSTK, NDX, (const char*) "" );
         hb_arraySet( pSTK, NDX, pSTRING );
      }

}

void strtoutf8_matrix(PHB_ITEM pMATRIX){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pMATRIX, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            strtoutf8_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               strtoutf8_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  strtoutf8_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }
   }
}

int fun_str2utf8(){
int sw=1;
if( CADDR>=1 ){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pSTRING)){
      ++CADDR;
      strtoutf8_item( (PHB_ITEM) pSTRING, (PHB_ITEM) pSTK_ADDR, (int) CADDR);

   }else if(HB_IS_ARRAY(pSTRING)){
      ++CADDR;
      strtoutf8_matrix((PHB_ITEM) pSTRING);
   }else{  // no es string: pasa tal cual.
      hb_arraySet( pSTK_ADDR, ++CADDR, pSTRING );
   }
   hb_itemRelease( pSTRING );
}else{
   sw=put_error((PHB_ITEM) pRET, "STRTOUTF8 INNER-STACK OVERFLOW",101);
}
return sw;
}

void utf8tostr_item(PHB_ITEM pSTRING, PHB_ITEM pSTK, int NDX){
      const char * szString = hb_itemGetCPtr( pSTRING );

      if( szString )
      {
         HB_SIZE nLen = hb_itemGetCLen( pSTRING ), nDest = 0;
         char * szDest = NULL;

         if( nLen )
         {
            PHB_CODEPAGE cdp = hb_vmCDP(); 

            if( cdp )
            {
               nDest = hb_cdpUTF8AsStrLen( cdp, szString, nLen, 0 );
               szDest = ( char * ) calloc( nDest + 1, 1);
               hb_cdpUTF8ToStr( cdp, szString, nLen, szDest, nDest + 1 );
            }
         }

         if( szDest ){
            const char *buff = szDest;
            hb_arraySetC( pSTK, NDX, (const char*) buff );
            free(szDest);
         }else{
            hb_arraySet( pSTK, NDX, pSTRING );
         }
      }else{
         hb_arraySet( pSTK, NDX, pSTRING );
      }
}

void utf8tostr_matrix(PHB_ITEM pMATRIX){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pMATRIX, &nDim, &d1, &d2, &d3, &type);
   
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            utf8tostr_item( (PHB_ITEM) pTEXT1, (PHB_ITEM) pRows, (int) i);
            hb_itemRelease(pTEXT1);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               utf8tostr_item( (PHB_ITEM) pTEXT11, (PHB_ITEM) pCols, (int) j);
               hb_itemRelease(pTEXT11);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pTEXT1 = hb_itemArrayGet( pMATRIX, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pTEXT11 = hb_itemArrayGet( pTEXT1, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pTEXT111 = hb_itemArrayGet( pTEXT11, k);
                  utf8tostr_item( (PHB_ITEM) pTEXT111, (PHB_ITEM) pPag, (int) k);
                  hb_itemRelease(pTEXT111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pTEXT11);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pTEXT1);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }
   }
}

int fun_utf82str(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pSTRING)){
      ++CADDR;
      utf8tostr_item( (PHB_ITEM) pSTRING, (PHB_ITEM) pSTK_ADDR, (int) CADDR);

   }else if(HB_IS_ARRAY(pSTRING)){
      ++CADDR;
      utf8tostr_matrix((PHB_ITEM) pSTRING);
   }else{  // no es string: pasa tal cual.
      hb_arraySet( pSTK_ADDR, ++CADDR, pSTRING );
   }
   hb_itemRelease( pSTRING );
}else{
   sw=put_error((PHB_ITEM) pRET, "UTF8TOSTR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_seek( /*int nItem*/ ){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pPOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // posicion
   PHB_ITEM pSET = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // SET
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   
   int Retorno;
   FILE_ERROR=0;
   if( HB_IS_NUMERIC( pPOS ) && HB_IS_NUMERIC( pSET ) )
   {
      Retorno = hb_fsSeekLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), 
                                hb_itemGetNInt( pPOS ), ( HB_USHORT ) hb_itemGetNInt( pSET ) ) ;
      FILE_ERROR = hb_fsError();
   }
   else
      Retorno = 0;

   hb_fsSetFError( FILE_ERROR );
   hb_arraySetNInt( pSTK_ADDR, ++CADDR, Retorno );
   hb_itemRelease( pFD );
   hb_itemRelease( pPOS );
   hb_itemRelease( pSET );
}else{
   sw=put_error((PHB_ITEM) pRET, "SEEK INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_count_lines(){
int sw=1;
if( CADDR<=nSizeStack-3 ){    // porque dejará 3 datos en el stack.
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;

   if( HB_IS_STRING( pFILE ) ){  //&& HB_IS_STRING( pTOKEN ) ){
      
      const char * pFile = hb_itemGetCPtr( pFILE );
      const char * pSep = TOKENIZER;
      
      char cSep = pSep[0];
      FILE *fp;
      long nLin=0,nTotCar=0,nLong=0,noldLong=0;
      int sw_Enter=0,sw_Car=0, nTokens=0, maxTokens=0, antChar=0; //, swFirstLine=1;
      char ch;
   
      fp=fopen(pFile,"r");
      if (fp!=NULL){
         nLin = 0;
         while ((ch = fgetc(fp)) != EOF){
            if (ch == '\n'){
               sw_Enter=1;
               sw_Car=0;
               //swFirstLine=0;
               nLin++;
               if (noldLong < nLong) { // longitud máxima de la línea
                  noldLong = nLong;
               }
               if( antChar != cSep )
                   ++nTokens;
              // printf(" nTokens = %d, maxTokens = %d\n",nTokens, maxTokens);
               if(nTokens > maxTokens ){
                  maxTokens = nTokens;
               }
               nTokens=0;
              // printf(" ---> NEW maxTokens = %d\n",maxTokens);
               nLong=0;
            }else{
              // if( swFirstLine ) 
               antChar=ch;
               if( cSep == ch ){
                   ++nTokens;
                   if ((ch = fgetc(fp)) != EOF){
                       if( ch == '\n' ){
                           --nTokens;
                       }
                   }
                   ungetc( ch, fp );
               }
               sw_Enter=0;
               sw_Car=1;
               nLong++;
            }
            nTotCar++;
         }
         fclose(fp);
         // suma 1 a nToken, por el último que no leyó:
         //nTokens++;
         ++maxTokens;
         if(sw_Enter==0 && sw_Car==1)
           ++nLin;
         if(nLong > noldLong) noldLong = nLong;
      }else{
         sw=put_error((PHB_ITEM) pRET, "COUNTFILE FILE OPEN TO READ ERROR",114);
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, (long) nLin );
      hb_arraySetNL( pSTK_ADDR, ++CADDR, (long) nTotCar );
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  noldLong );
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)  maxTokens /*nTokens*/ );
      hb_itemRelease(pFILE);
    //  hb_itemRelease(pTOKEN);
   }else{
      sw=put_error((PHB_ITEM) pRET, "COUNTFILE ARGUMENT ERROR",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "COUNTFILE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_error(){
int sw=1;
if( CADDR<nSizeStack ){   // analizar el tipo de error, entregar el mensaje correspondiente.
   HB_MAXINT nTypeErr = (HB_MAXINT) hb_fsGetFError();
   switch( nTypeErr ){
      case 0:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Successful" ); break; }
      case 2:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "File not found" ); break; }
      case 3:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Path not found" ); break; }
      case 4:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Too many files open" ); break; }
      case 5:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Access denied" ); break; }
      case 6:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Invalid handle" ); break; }
      case 8:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Insufficient memory" ); break; }
      case 15:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Invalid drive specified" ); break; }
      case 19:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Attempted to write to a write-protected disk" ); break; }
      case 21:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Drive not ready" ); break; }
      case 23:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Data CRC error" ); break; }
      case 29:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Write fault" ); break; }
      case 30:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Read fault" ); break; }
      case 32:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Sharing violation" ); break; }
      case 33:{ hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) "Lock Violation" ); break; }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "FILEERROR INNER-STACK OVERFLOW",101);
}
return sw;
}

short int fun_isNumber(const char * AX){
  int DX;
  short int SW_M=0,SW_N=0,SW_P=0;
  short int retorne;
  
  retorne = AX[0]!='\0' ? 1 : 0;
  
  while( (DX=*AX)!='\0'){
    if(DX=='-'){
       if (SW_N || SW_P || SW_M) {retorne=0;break;}
       SW_M=1;
    }else if (DX=='.'){
       if (!SW_N || SW_P) {retorne=0;break;}
       SW_P=1;
    }else if (isdigit(DX)) {SW_N=1;
    }else {retorne=0;break;}
    ++AX;
  }
  if (retorne==0) { SW_P = SW_N = SW_M = 0;}
  retorne=retorne<<1;
  retorne|=SW_P;     // 1=es decimal; 0=entero
  return (retorne);
}

void echo_matrix_token( PHB_ITEM pSource, unsigned PRECISION, HB_MAXINT nDim, 
                        HB_MAXINT d1, HB_MAXINT d2, HB_MAXINT d3, char * TOKENIZER, FILE *fhnd ){
   const char * cSep = TOKENIZER;
   switch( nDim ){
      case 1:{
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pDato = hb_itemArrayGet( pSource, i);
            echo_single( (PHB_ITEM) pDato, PRECISION, fhnd );
            if( d1-i ) fwrite( cSep, 1,1, fhnd );
            hb_itemRelease(pDato);
         }
         break;
      }case 2:{
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               echo_single( (PHB_ITEM) pPrint, PRECISION, fhnd );
               hb_itemRelease(pPrint);
               if( d2-j ) fwrite( cSep, 1,1,fhnd );
            }
            fwrite( "\n", 1,1,fhnd );
            hb_itemRelease(pDato2D);
         }
         break;
      }case 3:{
         int i;
         int k;
         for( k=1; k<=d3; k++){
            for( i=1; i<=d1; i++){
               PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
               int j;
               for( j=1; j<=d2; j++){
                  PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
                  PHB_ITEM pPrint2 = hb_itemArrayGet( pPrint, k);
                  echo_single( (PHB_ITEM) pPrint2, PRECISION, fhnd );
                  hb_itemRelease(pPrint2);
                  if( d2-j ) fwrite( cSep, 1,1, fhnd );
                  hb_itemRelease(pPrint);
               }
               hb_itemRelease(pDato2D);
               fwrite( "\n", 1,1, fhnd );
            }
            fwrite( "\n", 1,1,fhnd );
         }
         break;     
      }
   }
}

int fun_savemat(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pFILE   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  nombre de archivo a guardar
   PHB_ITEM pMATRIX = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  matriz
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING( pFILE ) && HB_IS_ARRAY( pMATRIX ) ){
      const char * szFile = hb_itemGetCPtr( pFILE );
      int nPrecision = SW_PRECISION ? PRECISION : 13;
      
      FILE *fp;         
      fp=fopen(szFile,"w");
      if( fp!=NULL ){
         HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
         get_size( (PHB_ITEM) pMATRIX, &nDim, &d1, &d2, &d3, &type);
         echo_matrix_token( pMATRIX, nPrecision, nDim, d1, d2, d3, (char *)TOKENIZER, (FILE*) fp );
         fclose(fp);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SAVE OPEN ERROR",115);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SAVE ARGUMENT (FILENAME|MATRIX) ERROR",103);
   }
   hb_itemRelease( pFILE );
   hb_itemRelease( pMATRIX );   
   
}else{
   sw=put_error((PHB_ITEM) pRET, "SAVE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_loadmat(){
int sw=1;
if( CADDR>=5 ){
   PHB_ITEM pFILE   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  archivo a leer
   PHB_ITEM pTOTTOK = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  total de tokens encontrados en primera linea.
   PHB_ITEM pMAXLIN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  maxima longitud de linea --> importante
   PHB_ITEM pTOTCAR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  total caracteres
   PHB_ITEM pTOTLIN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  //  total lineas --> este es importante aqui
   CADDR += SWKEEP; SWKEEP = 0;
   
   if( HB_IS_STRING( pFILE ) ){ //&& HB_IS_STRING( pTOKEN ) ){
      const char * szFile = hb_itemGetCPtr( pFILE );
      const char * szSeparator = TOKENIZER; //hb_itemGetCPtr( pTOKEN );
   
      char cSep = szSeparator[0];  // tommo primer caracter como separador.
   
      if( HB_IS_NUMERIC( pMAXLIN ) && HB_IS_NUMERIC( pTOTCAR ) && HB_IS_NUMERIC( pTOTLIN ) &&
          HB_IS_NUMERIC( pTOTTOK ) ){
         // aqui empieza todo!
         FILE *fp;         
         fp=fopen(szFile,"r");
         if (fp!=NULL){
            long nCurrLine=0, ctaLines=0, nTotLines = hb_itemGetNInt( pTOTLIN );
           // int  nMaxLine = hb_itemGetNI( pMAXLIN );
            unsigned int ctaToken=0, relaToken=0; 
            unsigned int nTokens = (unsigned)hb_itemGetNI( pTOTTOK );
          //  HB_MAXINT nTotCar = hb_itemGetNInt( pTOTCAR );
            char ch, buffer[MAXREADBUFFER]; 
            int i=0;
            
            // verificar si hay filas y columnas prestablecidas:
            unsigned int nIniR=1, nFinR=nTotLines;
            unsigned int nIniC=1, nFinC=nTokens;
            if( MARK_ROW ) {
               if( MARK_ROW == 999999999 ) MARK_ROW=nTotLines;
               if( MARK_ROW>nTotLines ){
                  sw=put_error((PHB_ITEM) pRET, "LOAD ROW'MARK OVERFLOW",113);
               }
               nIniR=MARK_ROW;nFinR=MARK_ROW;
               if( OFFSET_ROW ){
                  if( OFFSET_ROW == 999999999 ) OFFSET_ROW=nTotLines;
                  if( OFFSET_ROW<=nTotLines ){
                     nFinR=OFFSET_ROW;
                  }else{   // es mayor! ERROR
                     sw=put_error((PHB_ITEM) pRET, "LOAD ROW'OFFSET OVERFLOW",113);
                  }
               }
            }else{  // asume todas las filas
               OFFSET_ROW=nFinR;
            }
            if( MARK_COL ) {
               if( MARK_COL == 999999999 ) MARK_COL=nTokens;
               if( MARK_COL>nTokens ){
                  sw=put_error((PHB_ITEM) pRET, "LOAD COL'MARK OVERFLOW",113);
               }
               nIniC=MARK_COL;nFinC=MARK_COL;
               if( OFFSET_COL ){
                  if( OFFSET_COL == 999999999 ) OFFSET_COL=nTokens;
                  if( OFFSET_COL<=nTokens ){
                     nFinC=OFFSET_COL;
                  }else{   // es mayor! ERROR
                     sw=put_error((PHB_ITEM) pRET, "LOAD COL'OFFSET OVERFLOW",113);
                  }
               }
            }else{  // asume todas las columnas
               OFFSET_COL=nFinC;
            }
          /*****/
          if (sw){
            //PHB_ITEM pRow = hb_itemArrayNew( nTotLines );
            PHB_ITEM pRow = hb_itemArrayNew( nFinR - nIniR + 1 );
            /* avanzo el puntero hasta la línea donde empiezo a leer */
            if( nIniR>1 ){
               while ((ch = fgetc(fp)) != EOF){
                  if ( ch == '\n' ){
                     nCurrLine++;
                     if(nCurrLine == nIniR-1) break;
                  }
               }
            }
            if( feof(fp) ){
               sw=put_error((PHB_ITEM) pRET, "LOAD FILE IS NOT MATRIX COMPATIBLE",116);
            }else{
               /***/
               //PHB_CODEPAGE cdp = hb_vmCDP();
               while( nCurrLine <= nFinR && sw){  //nTotLines ){

                  //PHB_ITEM pCol = hb_itemArrayNew( nTokens );
                  PHB_ITEM pCol = hb_itemArrayNew( nFinC - nIniC + 1 );
                  ctaToken=0;
                  relaToken=0;
                  i=0;
                  while ((ch = fgetc(fp)) != EOF){
                     if ( ch == '\n' ){
                        ++ctaToken;
                        if( ctaToken > nTokens ){   // error!
                           sw=put_error((PHB_ITEM) pRET, "LOAD FILE IS NOT MATRIX COMPATIBLE (TOKENS)",116);
                        }else if( ctaToken>=nIniC && ctaToken<=nFinC ){
                           // verificar el tipo y guardar en pCol:
                          if( i ){
                              buffer[i] = '\0';
                              const char *cBuffer = buffer;
                              double nDbl;
                             // int nInt;
                              long nLong;
                              int nRet = fun_isNumber( cBuffer );
                              relaToken++; 
                              if( nRet ){  // es numero normal?
                                 if( nRet == 2 ){  // entero o long?
                                    sscanf(cBuffer, "%ld", &nLong);
                                    if( nLong >= INT_MIN && nLong <= INT_MAX )
                                       hb_arraySetNI( pCol, relaToken, (int)nLong );
                                    else
                                       hb_arraySetNL( pCol, relaToken, (long)nLong );
                                 }else{    // decimal: double!
                                    sscanf(cBuffer, "%lf", &nDbl);
                                    hb_arraySetND( pCol, relaToken, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                                 }
                              }else if( xu_funIsnotation( cBuffer ) ){  // es un numero con notación cientifica?
                                 nDbl = xu_funE2D( cBuffer );
                                 hb_arraySetND( pCol, relaToken, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                              }else{   // debe ser string, por default la hueá.

                                 hb_arraySetC( pCol, relaToken, (const char*)cBuffer );
                              }
                              //i=0;
                           }else{
                              sw=put_error((PHB_ITEM) pRET, "LOAD FILE IS NOT MATRIX COMPATIBLE (BLANK LINE)",116);
                           }
                         //  break;
                        }
                        i=0;
                        relaToken=0;
                        break;
                     }else if( ch == cSep ){  // encontró un separador?
                        ++ctaToken;
                        if( ctaToken > nTokens ){   // error!
                           sw=put_error((PHB_ITEM) pRET, "LOAD(2) FILE IS NOT MATRIX COMPATIBLE (TOKENS)",116);
                           break;
                        }else if( ctaToken>=nIniC && ctaToken<=nFinC ){
                           // verificar el tipo y guardar en pCol:
                           if( i ){
                              buffer[i] = '\0';
                              const char *cBuffer = buffer;
                              double nDbl;
                            //  int nInt;
                              long nLong;
                        
                              int nRet = fun_isNumber( cBuffer );
                              relaToken++;
                              if( nRet ){  // es numero normal?
                                 if( nRet == 2 ){  // entero o long?
                                    sscanf(cBuffer, "%ld", &nLong);
                                    if( nLong >= INT_MIN && nLong <= INT_MAX )
                                       hb_arraySetNI( pCol, relaToken, (int)nLong );
                                    else
                                       hb_arraySetNL( pCol, relaToken, (long)nLong );

                                 }else{    // decimal: double!
                                    sscanf(cBuffer, "%lf", &nDbl);
                                    hb_arraySetND( pCol, relaToken, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                                 }
                              }else if( xu_funIsnotation( cBuffer ) ){  // es un numero con notación cientifica?
                                 nDbl = xu_funE2D( cBuffer );
                                 hb_arraySetND( pCol, relaToken, (double) SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl );
                              }else{   // debe ser string, por default la hueá.
                                 hb_arraySetC( pCol, relaToken, (const char*)cBuffer );
                              }
                            //  i=0;
                           }else{
                              sw=put_error((PHB_ITEM) pRET, "LOAD(2) FILE IS NOT MATRIX COMPATIBLE (BLANK LINE)",116);
                              break;
                           }
                        }
                        i=0;
                     }else{
                        buffer[i++] = ch;
                     }
                  }
                  if( sw ){
                     hb_arraySet( pRow, ++ctaLines, pCol );
                     ++nCurrLine;
                  }
                  hb_itemRelease( pCol );
               }
               hb_arraySet( pSTK_ADDR, ++CADDR, pRow );
               hb_itemRelease( pRow );
               MARK_ROW = MARK_COL = OFFSET_ROW = OFFSET_COL = 0;
            }
            fclose(fp);
          }
         }else{
            sw=put_error((PHB_ITEM) pRET, "LOAD FILE OPEN TO READ ERROR",114);
         }
         
      }else{
         sw=put_error((PHB_ITEM) pRET, "LOAD ARGUMENT (COUNT FILE) ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "LOAD ARGUMENT (FILENAME|SEPARATOR) ERROR",103);
   }
   hb_itemRelease( pFILE );
//   hb_itemRelease( pTOKEN );
   hb_itemRelease( pTOTLIN );
   hb_itemRelease( pMAXLIN );
   hb_itemRelease( pTOTCAR );
   hb_itemRelease( pTOTTOK );
}else{
   sw=put_error((PHB_ITEM) pRET, "LOAD INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_writeline( /*int nItem,int TypeRead */)
{
int sw=1;
int TypeRead = nPCP == 236 ? 1 : 0;
if( CADDR>=1 ){
   PHB_ITEM pTOWRITE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // string a escribir
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );

   int nWriteS;
   FILE_ERROR=0;
   
   if( HB_IS_NUMERIC( pFD ) ){
      if( TypeRead ){   // write line string
         if( HB_IS_STRING( pTOWRITE ) ){
            HB_SIZE nLen = hb_itemGetCLen( pTOWRITE );
            nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), hb_itemGetCPtr( pTOWRITE ), nLen ) ;
            FILE_ERROR = hb_fsError();
            if(nWriteS<=0)
              sw=put_error((PHB_ITEM) pRET, "WRITELINE WRITE FAILED",103);
         }else{
            sw=put_error((PHB_ITEM) pRET, "WRITELINE ARGUMENT ERROR",103);
         }
      }else{   // write row. graba cada token.
         if( HB_IS_ARRAY( pTOWRITE ) ){
            HB_MAXINT nDim=0,d1=0,d2=0, d3=0,type=0;
            get_size( (PHB_ITEM) pTOWRITE, &nDim, &d1, &d2, &d3, &type);
            
            if( nDim == 1 ){
               int i;
               int nPrec = SW_PRECISION ? PRECISION : 13;
               for( i=1; i<=d1; i++ ){
                  PHB_ITEM pSource = hb_itemArrayGet( pTOWRITE, i );
                  if( HB_IS_STRING( pSource ) ){
                     const char * pString = hb_itemGetCPtr( pSource );
                     long nText = hb_itemGetCLen( pSource );
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, nText ) ;
                  }else if ( HB_IS_INTEGER ( pSource ) ){
                     int pNum = hb_itemGetNI( pSource );
                     char * buf = (char *)calloc(32,1);
                     int size = sprintf(buf,"%d", pNum);
                     const char * pString = buf;
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, size ) ;
                     free(buf);
                  }else if( HB_IS_DOUBLE( pSource ) ) {
                     double pDbl = hb_itemGetND( pSource );
                     char * buf = (char *)calloc(64,1);
                     int size = sprintf(buf,"%'.*lf", nPrec, pDbl);
                     const char * pString = buf;
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, size ) ;
                     free(buf);
                  }else if( HB_IS_LONG( pSource ) ) {
                     long pLong = hb_itemGetNL( pSource );
                     char * buf = (char *)calloc(64,1);
                     int size = sprintf(buf,"%ld", pLong);
                     const char * pString = buf;
                     nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), pString, size ) ;
                     free(buf);
                /*  }else if( HB_IS_LOGICAL( pSource ) ){
                     HB_BOOL pBool = hb_itemGetL( pSource );
                     if (pBool) hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), "1", 1 ) ;
                     else hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), "0", 1 ) ;*/
                  }
                  if ( d1-i ) nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), TOKENIZER, 1 ) ;
                  else nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), "\n", 1 ) ;
                  FILE_ERROR = hb_fsError();
                  hb_itemRelease( pSource );
                  if(nWriteS<=0)
                     sw=put_error((PHB_ITEM) pRET, "WRITELINE WRITE FAILED",103);
               }
            }else{
               sw=put_error((PHB_ITEM) pRET, "WRITEROW DIMENSION ERROR",106);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "WRITEROW ARGUMENT ERROR",103);
         }
      }
   }else
      if( TypeRead )
         sw=put_error((PHB_ITEM) pRET, "WRITELINE FILE DESCRIPTOR ERROR",117);
      else
         sw=put_error((PHB_ITEM) pRET, "WRITEROW FILE DESCRIPTOR ERROR",117);

   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pTOWRITE );
   hb_itemRelease( pFD );
}else{
   sw=put_error((PHB_ITEM) pRET, "WRITELINE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_writestring()
{
int sw=1;

if( CADDR>=1 ){
   PHB_ITEM pTOWRITE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // string a escribir
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );

   int nWriteS;
   FILE_ERROR=0;
   
   if( HB_IS_NUMERIC( pFD ) ){
      
      if( HB_IS_STRING( pTOWRITE ) ){
          HB_SIZE nLen = hb_itemGetCLen( pTOWRITE );
          nWriteS = hb_fsWriteLarge( hb_numToHandle( hb_itemGetNInt( pFD ) ), hb_itemGetCPtr( pTOWRITE ), nLen ) ;
          FILE_ERROR = hb_fsError();
          if(nWriteS<=0)
             sw=put_error((PHB_ITEM) pRET, "WRITESTRING WRITE FAILED",103);
      }else{
          sw=put_error((PHB_ITEM) pRET, "WRITESTRING ARGUMENT ERROR",103);
      }
      
   }else

      sw=put_error((PHB_ITEM) pRET, "WRITESTRING FILE DESCRIPTOR ERROR",117);

   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pTOWRITE );
   hb_itemRelease( pFD );
}else{
   sw=put_error((PHB_ITEM) pRET, "WRITESTRING INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_readstring()
{
int sw=1;

if( CADDR>=1 ){
   PHB_ITEM pNTOREAD = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // n a leer
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   
   HB_FHANDLE fhnd = ( HB_FHANDLE ) hb_itemGetNInt( pFD );
   HB_SIZE nToRead = ( HB_SIZE ) hb_itemGetNInt( pNTOREAD );  // numero de chars a leer
   
   char * buffer = ( char * ) calloc( nToRead + 1, 1 ); 
   HB_SIZE nRead;
//   HB_SIZE cbuf = 0;
   /* primer intento */
   /* obtener total de caracteres del archivo */
   HB_SIZE nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 1 ) ;
   HB_SIZE nFinalPos  = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 2 ) ;
           nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos, 0 ) ;

   if( nToRead + nSavePos > nFinalPos ) 
      nToRead -= ( nToRead + nSavePos ) - nFinalPos; 
   
   if(nSavePos>nFinalPos){
      FILE_ERROR=30;
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   nRead = hb_fsReadLarge( fhnd, buffer, nToRead );
   FILE_ERROR = hb_fsError();

   if(FILE_ERROR!=0){
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   long nLen;
   buffer[ nToRead ] = '\0';
   const char * pValue = buffer;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
   nLen = strlen( pValue );

   // calcula nueva posición.
   nLen++;
   nSavePos = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos + nLen, 0 ) ;

   free(buffer);
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pNTOREAD );
   hb_itemRelease( pFD );
   if(nRead<=0)
       sw=put_error((PHB_ITEM) pRET, "READSTRING READ FAILED",103);

}else{
   sw=put_error((PHB_ITEM) pRET, "READSTRING INNER-STACK OVERFLOW",101);
}
return sw;
}


int fun_readline( /*int nItem, int TypeRead*/ )
{
int sw=1;
int TypeRead = nPCP == 213 ? 0 : 1;
if( CADDR>=1 ){
   PHB_ITEM pNTOREAD = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // n a leer
   CADDR += SWKEEP; SWKEEP = 0;
   
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   
   HB_FHANDLE fhnd = ( HB_FHANDLE ) hb_itemGetNInt( pFD );
   HB_SIZE nToRead = ( HB_SIZE ) hb_itemGetNInt( pNTOREAD );
   
   /* obtener total de caracteres del archivo */
   HB_SIZE nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 1 ) ;
   HB_SIZE nFinalPos  = hb_fsSeekLarge( hb_numToHandle( fhnd ), 0, 2 ) ;
           nSavePos   = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos, 0 ) ;

   if( nToRead + nSavePos > nFinalPos ) 
      nToRead -= ( nToRead + nSavePos ) - nFinalPos; 
   
   if(nSavePos>nFinalPos){
      FILE_ERROR=30;
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   char * buffer = ( char * ) calloc( nToRead + 1, 1 ); 
   HB_SIZE nRead;
   HB_SIZE cbuf = 0;
   /* primer intento */

   nRead = hb_fsReadLarge( fhnd, buffer, nToRead );
   FILE_ERROR = hb_fsError();
   
   if(FILE_ERROR!=0){
      hb_fsSetFError( FILE_ERROR );
      hb_itemRelease( pNTOREAD );
      hb_itemRelease( pFD );
      //sw=0;
      return sw;
   }
   
   while( cbuf<=nToRead ){
      if(buffer[cbuf]!='\n') ++cbuf;
      else break;
   }
   long nLen;
   if( cbuf<=nToRead ){  // encontró un '\n'
      buffer[ cbuf ] = '\0';
      const char * pValue = buffer;
      if( TypeRead ){  // lee string
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
      }else{    // lee row
         const char * tokenizer = TOKENIZER;
         char *cTexto = (char *)calloc( cbuf + 1, 1 );
         memcpy( cTexto, buffer, cbuf );
         char *cBuffer = strtok(cTexto, tokenizer);

         int size=0;
         long nLong;
         double nDbl;
         PHB_ITEM pCol = hb_itemArrayNew( 0 );
         while( cBuffer ){
            hb_arraySize( pCol, ++size );
            const char * pBuffer = cBuffer;
            int nRet = fun_isNumber( pBuffer );
            if( nRet ){  // es numero normal?
               if( nRet == 2 ){  // entero o long?
                  sscanf(pBuffer, "%ld", &nLong);
                  if( nLong >= INT_MIN && nLong <= INT_MAX )
                     hb_arraySetNI( pCol, size, (int)nLong );
                  else
                     hb_arraySetNL( pCol, size, (long)nLong );
               }else{    // decimal: double!
                  sscanf(pBuffer, "%lf", &nDbl);
                  //hb_arraySetND( pCol, size, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                  hb_arraySetND( pCol, size, (double) nDbl  );
               }
            }else if( xu_funIsnotation( pBuffer ) ){  // es un numero con notación cientifica?
               nDbl = xu_funE2D( pBuffer );
               //hb_arraySetND( pCol, size, (double) SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl );
               hb_arraySetND( pCol, size, (double) nDbl );
            }else{   // debe ser string, por default la hueá.
               hb_arraySetC( pCol, size, (const char*)pBuffer );
            }
            
            cBuffer = strtok(0, tokenizer);
         }
         free(cTexto);
         // guardo array en STK_ADDR
         if( pCol ){
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pCol );
         }
         hb_itemRelease( pCol );
      }
      nLen = strlen( pValue );
   }else{     // no encontró '\n'
      buffer[ nToRead ] = '\0';
      const char * pValue = buffer;
      if( TypeRead ){  // lee string
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) pValue );
      }else{    // lee row
         const char * tokenizer = TOKENIZER;
         char *cTexto = (char *)calloc( nToRead + 1, 1 );
         memcpy( cTexto, buffer, nToRead );
         char *cBuffer = strtok(cTexto, tokenizer);
         
         int size=0;
         long nLong;
         double nDbl;
         PHB_ITEM pCol = hb_itemArrayNew( 0 );
         while( cBuffer ){
            hb_arraySize( pCol, ++size );
            const char * pBuffer = cBuffer;
            int nRet = fun_isNumber( pBuffer );
            if( nRet ){  // es numero normal?
               if( nRet == 2 ){  // entero o long?
                  sscanf(pBuffer, "%ld", &nLong);
                  if( nLong >= INT_MIN && nLong <= INT_MAX )
                     hb_arraySetNI( pCol, size, (int)nLong );
                  else
                     hb_arraySetNL( pCol, size, (long)nLong );
               }else{    // decimal: double!
                  sscanf(pBuffer, "%lf", &nDbl);
                  //hb_arraySetND( pCol, size, (double)SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl  );
                  hb_arraySetND( pCol, size, (double) nDbl  );
               }
            }else if( xu_funIsnotation( pBuffer ) ){  // es un numero con notación cientifica?
               nDbl = xu_funE2D( pBuffer );
               //hb_arraySetND( pCol, size, (double) SW_PRECISION ? xu_funprecision(nDbl,PRECISION) : nDbl );
               hb_arraySetND( pCol, size, (double) nDbl );
            }else{   // debe ser string, por default la hueá.
               hb_arraySetC( pCol, size, (const char*) pBuffer );
            }
            
            cBuffer = strtok(0, tokenizer);
         }
         free(cTexto);
         // guardo array en STK_ADDR
         if( pCol ){
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) pCol );
         }
         hb_itemRelease( pCol );
      }
      nLen = strlen( pValue );
   }
   // calcula nueva posición.
   nLen++;
   nSavePos = hb_fsSeekLarge( hb_numToHandle( fhnd ), nSavePos + nLen, 0 ) ;
         
   free(buffer);
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pNTOREAD );
   hb_itemRelease( pFD );
   if(nRead<=0)
       sw=put_error((PHB_ITEM) pRET, "READXXX READ FAILED",103);
}else{
   if( TypeRead )
      sw=put_error((PHB_ITEM) pRET, "READLINE INNER-STACK OVERFLOW",101);
   else
      sw=put_error((PHB_ITEM) pRET, "READROW INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_eof(/* int nItem */){
int sw=1;
if( CADDR < nSizeStack ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
   if( HB_IS_NUMERIC( pFD ) )
   {
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) hb_fsEof( hb_numToHandle( hb_itemGetNInt( pFD ) ) ) );
      FILE_ERROR=hb_fsError();
   }
   else
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );

   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFD );
}else{
  sw=put_error((PHB_ITEM) pRET, "EOF INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_ferror(){
int sw=1;
if( CADDR < nSizeStack ){
  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) FILE_ERROR ? 1 : 0 );
  FILE_ERROR=0;
}else{
  sw=put_error((PHB_ITEM) pRET, "ERROR INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_fclose(/* int nItem*/ ){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
//   HB_ERRCODE uiError = 0;
   if( HB_IS_NUMERIC( pFD ) )
   {
      hb_fsClose( hb_numToHandle( hb_itemGetNInt( pFD ) ) );
      FILE_ERROR = hb_fsError();
   }
   else{
      sw=put_error((PHB_ITEM) pRET, "CLOSE INVALID FILE DESCRIPTOR",117);
   }
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFD );
return sw;
}

int fun_create(/* int nItem */){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   PHB_ITEM pMODE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // modo
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
   const char * szFile = hb_itemGetCPtr( pFILE );  //hb_parc( 1 );
   if( szFile ){
      hb_arraySetNInt( pSTK_REG, nItem, ( HB_NHANDLE ) hb_fsCreate( szFile,
                                        ( HB_USHORT ) hb_itemGetNInt( pMODE ) ) );
      FILE_ERROR = hb_fsError();
   }else{
      sw=put_error((PHB_ITEM) pRET, "CREATE INVALID FILENAME",107);
   }
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFILE );
   hb_itemRelease( pFD );
   hb_itemRelease( pMODE );
}else{
   sw=put_error((PHB_ITEM) pRET, "CREATE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_fopen( /*int nItem */){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   PHB_ITEM pMODE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // modo
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_REG, nItem );
   FILE_ERROR=0;
   const char * szFile = hb_itemGetCPtr( pFILE );  //hb_parc( 1 );
   if( szFile ){
      hb_arraySetNInt( pSTK_REG, nItem, ( HB_NHANDLE ) hb_fsOpen( szFile,
                  ( HB_USHORT ) hb_itemGetNInt( pMODE ) ) );
      
      FILE_ERROR = hb_fsError();
   }else{
      sw=put_error((PHB_ITEM) pRET, "OPEN INVALID FILENAME",114);
   }
   hb_fsSetFError( FILE_ERROR );
   hb_itemRelease( pFILE );
   hb_itemRelease( pFD );
   hb_itemRelease( pMODE );
}else{
   sw=put_error((PHB_ITEM) pRET, "OPEN INNER-STACK OVERFLOW",101);
}
return sw;
}

/***************************************
    SWITCH  -  CASE
 ***************************************/
//int jumpCase( int STK_PRG[], PHB_ITEM pSTK_ADDR, PHB_ITEM pRET, PHB_ITEM SWITCH_VAR ){
int jumpCase(/* int nJump */){
int sw=1;
if( CADDR>=1 ){
   int nJump = STK_PRG[ ++CP ] - 1;
   
   PHB_ITEM pDATO = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_NUMERIC( pDATO ) ){  
      PHB_ITEM pSWVAR = hb_itemArrayGet( SWITCH_VAR, 1 );
      if( hb_itemGetND( pSWVAR ) != hb_itemGetND( pDATO ) ){
         CP = nJump;// - 1;
      }
      hb_itemRelease( pSWVAR );
   }else if( HB_IS_STRING( pDATO ) ){
      PHB_ITEM pSWVAR = hb_itemArrayGet( SWITCH_VAR, 2 );
      if( strcmp( hb_itemGetCPtr( pSWVAR ), hb_itemGetCPtr( pDATO ) ) != 0 ){
         CP = nJump;// - 1;
      }
      hb_itemRelease( pSWVAR );
   }else{
      sw=put_error((PHB_ITEM) pRET, "CASE ARGUMENT ERROR",103);
   }
   hb_itemRelease( pDATO );
}else{
   sw=put_error((PHB_ITEM) pRET, "CASE INNER-STACK OVERFLOW",101);
}
return sw;
}

int put_switch( /*int nItem*/ ){

   int nItem = STK_PRG[++CP];
   PHB_ITEM pSWITCH = hb_itemArrayGet( pSTK_REG, nItem );

   if ( HB_IS_NUMERIC( pSWITCH) )
      hb_arraySetND( SWITCH_VAR, 1, (double) hb_itemGetND( pSWITCH ) );

   else if( HB_IS_STRING( pSWITCH ) )
      hb_arraySetC( SWITCH_VAR, 2, (const char*) hb_itemGetCPtr( pSWITCH ) );

   hb_itemRelease( pSWITCH );

return 1;
}

/*  TRUE y FALSE */
int fun_bool( /*int nItem, HB_BOOL lBool */){
int sw=1;
   int nItem = STK_PRG[++CP];
   hb_arraySetNI( pSTK_REG, nItem, (int) nPCP == 247 ? 1 : 0 );
return sw;
}

/**********************************************
         FUNCIONES ESPECIALES ARRAY 
 **********************************************/
int fun_array_especial(/* int nItem */){
int sw=1;

int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int tCompare = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

switch(tCompare){
   case 0:{   // SORT
      if(CADDR>=1){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pSTART = NULL;
         PHB_ITEM pCOUNT = NULL;
         HB_SIZE nStart = 0;
         HB_SIZE nCount = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            if(CADDR>=1){
               pSTART = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               nStart = hb_itemGetNInt( pSTART );
               if(CADDR>=1){
                  pCOUNT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                  nCount = hb_itemGetNInt( pCOUNT );
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            hb_arraySort( pARRAY,
                    pSTART ? &nStart : NULL,
                    pCOUNT ? &nCount : NULL,
                    NULL );  //hb_param( 4, HB_IT_BLOCK ) );
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SORT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         if(pSTART) hb_itemRelease(pSTART);
         if(pCOUNT) hb_itemRelease(pCOUNT);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SORT INNER-STACK OVERFLOW",101);
      }
      break;
   }case 1:{   // SCAN
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pVALUE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pSTART = NULL;
         PHB_ITEM pCOUNT = NULL;
         HB_SIZE nStart = 0;
         HB_SIZE nCount = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            if(CADDR>=1){
               pSTART = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               nStart = hb_itemGetNInt( pSTART );
               if(CADDR>=1){
                  pCOUNT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                  nCount = hb_itemGetNInt( pCOUNT );
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            HB_SIZE nPos = ( hb_arrayScan( pARRAY, pVALUE,
                              pSTART ? &nStart : NULL,
                              pCOUNT ? &nCount : NULL,
                              HB_TRUE ) );
            hb_arraySetNInt( pSTK_ADDR, ++CADDR, nPos );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pVALUE);
         if(pSTART) hb_itemRelease(pSTART);
         if(pCOUNT) hb_itemRelease(pCOUNT);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN INNER-STACK OVERFLOW",101);
      }
      break;
   }case 2:{   // REV SCAN
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pVALUE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pSTART = NULL;
         PHB_ITEM pCOUNT = NULL;
         HB_SIZE nStart = 0;
         HB_SIZE nCount = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            if(CADDR>=1){
               pSTART = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
               nStart = hb_itemGetNInt( pSTART );
               if(CADDR>=1){
                  pCOUNT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                  nCount = hb_itemGetNInt( pCOUNT );
               }
            }
            CADDR += SWKEEP; SWKEEP = 0;
            HB_SIZE nPos = ( hb_arrayRevScan( pARRAY, pVALUE,
                              pSTART ? &nStart : NULL,
                              pCOUNT ? &nCount : NULL,
                              HB_TRUE ) );
            hb_arraySetNInt( pSTK_ADDR, ++CADDR, nPos );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY REVERSE SCAN ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pVALUE);
         if(pSTART) hb_itemRelease(pSTART);
         if(pCOUNT) hb_itemRelease(pCOUNT);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY REVERSE SCAN INNER-STACK OVERFLOW",101);
      }
      break;
   }case 3:{   // INSERT
      if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pVALUE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOS) ){
            HB_ISIZ nPos = hb_itemGetNInt( pPOS );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            if( nPos == 0 )
               nPos = 1;
            
            if(!HB_IS_ARRAY(pVALUE)){
               hb_arraySize( pARRAY, nLen + 1 );

               hb_arrayIns( pARRAY, nPos );
               put_value( pARRAY, pVALUE, nPos, PRECISION);
            }else{  // es un array: lo inserta en la posición
               HB_SIZE nLenS=hb_arrayLen( pVALUE );
               
               hb_arraySize(pARRAY,  nLen + nLenS);
               HB_SIZE i;
               for(i=nLenS;i>=1;i--){
                  hb_arrayIns( pARRAY, nPos );
                  PHB_ITEM pELEM = hb_itemArrayGet(pVALUE,i);
                  hb_arraySet(pARRAY, nPos, pELEM);
                  hb_itemRelease(pELEM);
               }
            }
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY INSERT ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pVALUE);
         hb_itemRelease(pPOS);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY INSERT INNER-STACK OVERFLOW",101);
      }
      break;
   }case 4:{  // DELETE
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOS) ){
            
            HB_ISIZ nPos = hb_itemGetNInt( pPOS );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            
            if( nPos == 0 )
               nPos = 1;

            hb_arrayDel( pARRAY, nPos );
            hb_arraySize( pARRAY, nLen - 1 );
            
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pPOS);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 5:{  // SIZE
      if(CADDR>=2){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pNEWLEN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pNEWLEN) ){
            
            HB_ISIZ nNewLen = hb_itemGetNInt( pNEWLEN );
            ///HB_SIZE nLen = hb_arrayLen( pARRAY );
            
            hb_arraySize( pARRAY, HB_MAX( nNewLen, 0 ) );
             
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pNEWLEN);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SIZE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 6:{  // ADD: une un array al principio del array target.
      if(CADDR>=2){
         PHB_ITEM pARRAYT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // objetivo
         PHB_ITEM pARRAYS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // lo que une a objetivo
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAYS) && HB_IS_ARRAY(pARRAYT) ){
            HB_SIZE nLenT=hb_arrayLen( pARRAYT );
            HB_SIZE nLenS=hb_arrayLen( pARRAYS );
            
            hb_arraySize(pARRAYT,  nLenT + nLenS);
            HB_SIZE i;
            for(i=1;i<=nLenS;i++){
               PHB_ITEM pELEM = hb_itemArrayGet(pARRAYS,i);
               hb_arraySet(pARRAYT, i+nLenT, pELEM);
               hb_itemRelease(pELEM);
            }
             
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAYT );

         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY ADD ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAYT);
         hb_itemRelease(pARRAYS);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY ADD INNER-STACK OVERFLOW",101);
      }
      break;
   }case 7:{ // ZAPRANGE
      if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOSF = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pPOSI = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOSI) && HB_IS_NUMERIC(pPOSF) ){
            
            HB_ISIZ nPosI = hb_itemGetNInt( pPOSI );
            HB_ISIZ nPosF = hb_itemGetNInt( pPOSF );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            
            if( nPosI <= 0 )
               nPosI = 1;
            if( nPosF <= 0 )
               nPosF = 1;
            if( nPosI>nPosF ){
               int nTmp = nPosI;nPosI=nPosF;nPosF=nTmp;
            }
            HB_SIZE nPorcion = nPosF-nPosI+1;
            HB_SIZE i;
            for(i=1; i<=nPorcion; i++)
               hb_arrayDel( pARRAY, nPosI );
            hb_arraySize( pARRAY, nLen - nPorcion );
            
            //hb_arraySet( pSTK_ADDR, ++CADDR, pARRAY );
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE RANGE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pPOSI);
         hb_itemRelease(pPOSF);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY DELETE RANGE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 8: {   // SCAN2D ==> para buscar un dato en un array 2D
      if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pELEM = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pCOL = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pCOL) ){
            double nElemento=0; // deben ser distintos
            const char* cElemento;
            int nCol = hb_itemGetNInt( pCOL );
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            int swOk=0;
            if(HB_IS_NUMERIC(pELEM)){
               nElemento = hb_itemGetND( pELEM );
               HB_SIZE i;
               for (i=1; i<=nLen; i++){
                  PHB_ITEM pROW = hb_itemArrayGet( pARRAY, i );
                  PHB_ITEM pFIND = hb_itemArrayGet( pROW, nCol );
                  if(HB_IS_NUMERIC(pFIND)){  // solo si es numérico
                     double nDato = hb_itemGetND( pFIND );
                     if(nElemento == nDato){
                        hb_itemRelease(pFIND); hb_itemRelease(pROW);
                        swOk=1;
                        break;
                     }
                  }
                  hb_itemRelease(pFIND);
                  hb_itemRelease(pROW);
               }
               if (swOk){
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) i);
               }else{
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) -1);
               }
            }else if(HB_IS_STRING(pELEM)){
               cElemento = hb_itemGetCPtr( pELEM );
               HB_SIZE i;
               for (i=1; i<=nLen; i++){
                  PHB_ITEM pROW = hb_itemArrayGet( pARRAY, i );
                  PHB_ITEM pFIND = hb_itemArrayGet( pROW, nCol );
                  if(HB_IS_STRING(pFIND)){  // solo si es numérico
                     const char* cDato = hb_itemGetCPtr( pFIND );
                     if(strcmp(cElemento, cDato)==0){
                        hb_itemRelease(pFIND); hb_itemRelease(pROW);
                        swOk=1;
                        break;
                     }
                  }
                  hb_itemRelease(pFIND);
                  hb_itemRelease(pROW);
               }
               if (swOk){
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) i) ;
               }else{
                  hb_arraySetNL( pSTK_ADDR, ++CADDR, (long int) -1) ;
               }
               
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN2D TYPE ARGUMENT ERROR",103);   
            }

         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN2D TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pELEM);
         hb_itemRelease(pCOL);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SCAN2D INNER-STACK OVERFLOW",101);
      }
      break;
   }case 9:{    // distribution array
      if(CADDR>=2){
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY1) && HB_IS_ARRAY(pARRAY2) ){
            HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nLen2 = hb_arrayLen( pARRAY2 );
            HB_SIZE i;
            if( nLen1>0 && nLen2>0 ){
            PHB_ITEM NEWARRAY = hb_itemArrayNew( nLen1 * nLen2 * 2 );
            HB_SIZE nSize=0;
            for (i=1; i<=nLen1; i++){
               PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
               ///const char* cDato = hb_itemGetCPtr( pELEM1 );
               ///if(HB_IS_STRING(pELEM1)){
                  HB_SIZE j;
                  for (j=1; j<=nLen2; j++){
                     PHB_ITEM pELEM2 = hb_itemArrayGet( pARRAY2, j );
                     ++nSize;
                     hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM1 );
                     ++nSize;
                     hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM2 );
                     //if(HB_IS_STRING(pELEM2)){
                     /*   const char* cDato2 = hb_itemGetCPtr( pELEM2 );
                        int len1=strlen(cDato);
                        int len2=strlen(cDato2);
                        char * cString = (char*)calloc(len1 + len2 + 1,1);
                        memcpy(cString,cDato,len1);
                        memcpy(cString+len1,cDato2,len2);
                        cString[len1 + len2] = '\0';
                        const char * cBuffer = cString;
                        hb_arraySize(NEWARRAY,++nSize);
                        hb_arraySetC( NEWARRAY, nSize, (const char*) cBuffer );
                        free(cString); */
                     //}
                     hb_itemRelease(pELEM2);
                  }
              /// }
               hb_itemRelease(pELEM1);
            }
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) NEWARRAY) ;
            hb_itemRelease(NEWARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY DISTRIB LENGTH ZERO ERROR",103);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY DISTRIB TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY DISTRIB INNER-STACK OVERFLOW",101);
      }
      break;
   }case 10: case 11: case 12: case 13: case 14: case 15:{    // MAX=10, MIN=11
      if(CADDR>=1 && CADDR<nSizeStack-1){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         if( HB_IS_ARRAY(pARRAY) ){
            HB_SIZE nLen = hb_arrayLen( pARRAY );
            HB_SIZE i, nPosition = 1;
            // escoge elemento pivote
            PHB_ITEM pPIVOTE = hb_itemArrayGet( pARRAY, 1 );
            double nPivote = hb_itemGetND( pPIVOTE );
            hb_itemRelease( pPIVOTE );
            if (tCompare >= 10 && tCompare <=12){
               // busca el maximo:
               for (i=2; i<=nLen; i++){
                  PHB_ITEM pELEM = hb_itemArrayGet( pARRAY, i );
                  if ( HB_IS_NUMERIC(pELEM) ){
                     double nElemento = hb_itemGetND( pELEM );
                     if ( nPivote < nElemento ) {
                        nPivote = nElemento;
                        nPosition = i;
                     }
                  }  // si no es numérico, no hace nada.
                  hb_itemRelease(pELEM);
               }
            }else{
               // busca el minimo:
               for (i=2; i<=nLen; i++){
                  PHB_ITEM pELEM = hb_itemArrayGet( pARRAY, i );
                  if ( HB_IS_NUMERIC(pELEM) ){
                     double nElemento = hb_itemGetND( pELEM );
                     if ( nPivote > nElemento ) {
                        nPivote = nElemento;
                        nPosition = i;
                     }
                  }  // si no es numérico, no hace nada.
                  hb_itemRelease(pELEM);
               }
            }
            if ( tCompare == 10 || tCompare == 13 ){
               hb_arraySetND( pSTK_ADDR, ++CADDR, (double) nPivote ) ;
            }else if ( tCompare == 11 || tCompare == 14 ){
               hb_arraySetNInt( pSTK_ADDR, ++CADDR, (HB_SIZE) nPosition ) ;
            }else{
               hb_arraySetND( pSTK_ADDR, ++CADDR, (double) nPivote ) ;
               hb_arraySetNInt( pSTK_ADDR, ++CADDR, (HB_SIZE) nPosition ) ;
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY MAX|MIN TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY MAX|MIN INNER-STACK OVER OR UNDERFLOW",101);
      }
      break;
   }case (16):{   // array mix: {a,b,c} {1,2,3} => {a,1,b,2,c,3}
       if(CADDR>=2){
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY1) && HB_IS_ARRAY(pARRAY2) ){
            HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nLen2 = hb_arrayLen( pARRAY2 );
            if( nLen1 == nLen2 ){
               HB_SIZE i;
               PHB_ITEM NEWARRAY = hb_itemArrayNew( nLen1 + nLen2 );
               HB_SIZE nSize=0;
               for (i=1; i<=nLen1; i++){
                  PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
                  PHB_ITEM pELEM2 = hb_itemArrayGet( pARRAY2, i );
                  ++nSize;
                  hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM1 );
                  ++nSize;
                  hb_arraySet( NEWARRAY, nSize, (PHB_ITEM) pELEM2 );
                  hb_itemRelease(pELEM1);
                  hb_itemRelease(pELEM2);
               }
               hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM) NEWARRAY) ;
               hb_itemRelease(NEWARRAY);
            }else{
               sw=put_error((PHB_ITEM) pRET, "ARRAY MIX LENGTH ERROR",103);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY MIX TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY MIX INNER-STACK OVERFLOW",101);
      }
  
      
      break;
   }case (17): case (18): { // array rotate R y L
       if(CADDR>=3){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // array
         PHB_ITEM pHASTA  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // desde
         PHB_ITEM pDESDE  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // hasta
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY1) && HB_IS_NUMERIC(pDESDE) && HB_IS_NUMERIC(pHASTA)){
           // HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nDesde = hb_itemGetNI( pDESDE );
            HB_SIZE nHasta = hb_itemGetNI( pHASTA );
            HB_SIZE i;
            if(tCompare==17){
               PHB_ITEM pELEMi = hb_itemArrayGet( pARRAY1, nDesde );
               for (i=nDesde+1; i<=nHasta; i++){
                  PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
                  hb_arraySet( pARRAY1, i-1, (PHB_ITEM) pELEM1 );
                  hb_itemRelease(pELEM1);
               }
               hb_arraySet( pARRAY1, nHasta, (PHB_ITEM) pELEMi );
               hb_itemRelease(pELEMi);
            }else{
               PHB_ITEM pELEMi = hb_itemArrayGet( pARRAY1, nHasta );
               for (i=nHasta-1; i>=nDesde; i--){
                  PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY1, i );
                  hb_arraySet( pARRAY1, i+1, (PHB_ITEM) pELEM1 );
                  hb_itemRelease(pELEM1);
               }
               hb_arraySet( pARRAY1, nDesde, (PHB_ITEM) pELEMi );
               hb_itemRelease(pELEMi);               
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY ROTATE TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pDESDE);
         hb_itemRelease(pHASTA);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY ROTATE INNER-STACK OVERFLOW",101);
      }
      break;
   }case(19): { // swap element (range puede ser hecho con hopper rápidamente!
       if(CADDR>=3){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // array
         PHB_ITEM pPOS2  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // posicion
         PHB_ITEM pPOS1  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // posicion
         CADDR += SWKEEP; SWKEEP = 0;
         
         if( HB_IS_ARRAY(pARRAY) && HB_IS_NUMERIC(pPOS1) && HB_IS_NUMERIC(pPOS2)){
            //HB_SIZE nLen1 = hb_arrayLen( pARRAY1 );
            HB_SIZE nPos1 = hb_itemGetNI( pPOS1 );
            HB_SIZE nPos2 = hb_itemGetNI( pPOS2 );
           // HB_SIZE i;
            PHB_ITEM pELEM1 = hb_itemArrayGet( pARRAY, nPos1 );
            PHB_ITEM pELEM2 = hb_itemArrayGet( pARRAY, nPos2 );
            PHB_ITEM pTEMP = pELEM1;
            hb_arraySet( pARRAY, nPos1, (PHB_ITEM)pELEM2 );
            hb_arraySet( pARRAY, nPos2, (PHB_ITEM)pTEMP );
            hb_itemRelease(pELEM1);
            hb_itemRelease(pELEM2);
         }else{
            sw=put_error((PHB_ITEM) pRET, "ARRAY SWAP-ELEMENTS TYPE ARGUMENT ERROR",103);
         }
         hb_itemRelease(pARRAY);
         hb_itemRelease(pPOS2);
         hb_itemRelease(pPOS1);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ARRAY SWAP-ELEMENTS INNER-STACK OVERFLOW",101);
      }
      break;
   }
}
return sw;
}


/***************************************************
         FUNCIONES DE CONJUNTOS
 ***************************************************/

PHB_ITEM fun_set_unique( PHB_ITEM pSTACK ){
    
    // Creo el array, después ajusto. Siempre será menor o igual a tamaño original.
    HB_SIZE nLen = hb_arrayLen( pSTACK );
    PHB_ITEM pUNIQUE = hb_itemArrayNew( nLen );
    unsigned int n;
    
    HB_MAXINT type=0;
    PHB_ITEM pItem = hb_itemArrayGet( pSTACK, 1);
    get_item_type( (PHB_ITEM) pItem, &type );
    hb_itemRelease( pItem );

    // EL ARRAY DEBE ESTAR ORDENADO.
    if ( type>=11 && type<=13 ){   // number
       HB_MAXINT nSize=1;

       PHB_ITEM pAA = hb_itemArrayGet( pSTACK, 1); 
       double npA = hb_itemGetND(pAA);
       hb_itemRelease( pAA );
       hb_arraySetND( pUNIQUE, 1, (double) npA );

       for(n=2;n<=nLen;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK, n);
          double npAA = hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          if( npAA != npA ){
             hb_arraySetND( pUNIQUE, ++nSize, (double) npAA );
          }
          npA = npAA;
       }
       hb_arraySize( pUNIQUE, nSize ); // ajusto array final

    }else if( type==10 ){  // string
       HB_MAXINT nSize=1;

       PHB_ITEM pAA = hb_itemArrayGet( pSTACK, 1);
       const char * npA = hb_itemGetCPtr(pAA);
       hb_itemRelease( pAA );
       hb_arraySetC( pUNIQUE, 1, (const char *) npA );

       for(n=2;n<=nLen;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK, n);
          const char * npAA = hb_itemGetCPtr(pAA);
          if( strcmp ( npA, npAA ) != 0 ){
             hb_arraySetC( pUNIQUE, ++nSize, (const char *) npAA );
          }
          npA = hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
       }
       hb_arraySize( pUNIQUE, nSize ); // ajusto array final
    }

    return pUNIQUE;
}

PHB_ITEM fun_set_union( PHB_ITEM pSTACK1, PHB_ITEM pSTACK2 ){

    HB_SIZE nRowA = hb_arrayLen( pSTACK1 );
    HB_SIZE nRowB = hb_arrayLen( pSTACK2 );
    
    PHB_ITEM pUNION = hb_itemArrayNew( nRowA + nRowB );
    unsigned int n;
    
    HB_MAXINT type1=0;
    PHB_ITEM pItem1 = hb_itemArrayGet( pSTACK1, 1);
    get_item_type( (PHB_ITEM) pItem1, &type1 );
    hb_itemRelease( pItem1 );
    HB_MAXINT type2=0;
    PHB_ITEM pItem2 = hb_itemArrayGet( pSTACK2, 1);
    get_item_type( (PHB_ITEM) pItem2, &type2 );
    hb_itemRelease( pItem2 );
    
    if( (type1>=11 && type1<=13) || (type2>=11 && type2<=13) ){
    
          HB_MAXINT nSize=0;
          // RELLENO EL ARRAY INICIAL
          for(n=1;n<=nRowA;n++){
             PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
             hb_arraySetND( pUNION, ++nSize, (double) hb_itemGetND(pAA) );
             hb_itemRelease( pAA );
          }
          for(n=1;n<=nRowB;n++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, n);
             hb_arraySetND( pUNION, ++nSize, (double) hb_itemGetND(pBB) );
             hb_itemRelease( pBB );
          }    
    }else if( (type1==10 && type2==10) ){  // sting
          HB_MAXINT nSize=0;
          for(n=1;n<=nRowA;n++){
             PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
             hb_arraySetC( pUNION, ++nSize, (const char*) hb_itemGetCPtr(pAA) );
             hb_itemRelease( pAA );
          }
          for(n=1;n<=nRowB;n++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, n);
             hb_arraySetC( pUNION, ++nSize, (const char*) hb_itemGetCPtr(pBB) );
             hb_itemRelease( pBB );
          }
    }
    return pUNION;
}

PHB_ITEM fun_set_intersection( PHB_ITEM pSTACK1, PHB_ITEM pSTACK2 ){

    HB_SIZE nRowA = hb_arrayLen( pSTACK1 );
    HB_SIZE nRowB = hb_arrayLen( pSTACK2 );
    
    PHB_ITEM pINTER = hb_itemArrayNew( nRowA > nRowB ? nRowA : nRowB );
    
    HB_MAXINT type1=0;
    PHB_ITEM pItem1 = hb_itemArrayGet( pSTACK1, 1);
    get_item_type( (PHB_ITEM) pItem1, &type1 );
    hb_itemRelease( pItem1 );
    HB_MAXINT type2=0;
    PHB_ITEM pItem2 = hb_itemArrayGet( pSTACK2, 1);
    get_item_type( (PHB_ITEM) pItem2, &type2 );
    hb_itemRelease( pItem2 );
    
    unsigned m,n,piv;
    
    if( (type1>=11 && type1<=13) || (type2>=11 && type2<=13) ){
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=nRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          double npA=hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             double npB=hb_itemGetND(pBB);
             hb_itemRelease( pBB );
             if( npA == npB ){
                hb_arraySetND( pINTER, ++nSize, (double) npA );
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if ( npA < npB ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
       }
       hb_arraySize( pINTER, nSize ); // ajusto array final
    }else if( (type1==10 && type2==10) ){  // sting

       HB_MAXINT nSize=0;
       for(n=1;n<=nRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          const char * npA=hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
          for(m=1;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             const char * npB=hb_itemGetCPtr(pBB);
             hb_itemRelease( pBB );
             if( strcmp ( npA, npB ) == 0 ){
                hb_arraySetC( pINTER, ++nSize, (const char*) npA );
                break;
             }
          }
       }
       hb_arraySize( pINTER, nSize ); // ajusto array final
    }
    return pINTER;
}

PHB_ITEM fun_set_difference( PHB_ITEM pSTACK1, PHB_ITEM pSTACK2 ){

    HB_SIZE nRowA = hb_arrayLen( pSTACK1 );
    HB_SIZE nRowB = hb_arrayLen( pSTACK2 );
    
    PHB_ITEM pDIFF = hb_itemArrayNew( nRowA > nRowB ? nRowA : nRowB );
    
    HB_MAXINT type1=0;
    PHB_ITEM pItem1 = hb_itemArrayGet( pSTACK1, 1);
    get_item_type( (PHB_ITEM) pItem1, &type1 );
    hb_itemRelease( pItem1 );
    HB_MAXINT type2=0;
    PHB_ITEM pItem2 = hb_itemArrayGet( pSTACK2, 1);
    get_item_type( (PHB_ITEM) pItem2, &type2 );
    hb_itemRelease( pItem2 );

    unsigned n,m,sw,piv;
    
    if( (type1>=11 && type1<=13) || (type2>=11 && type2<=13) ){
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=nRowA;n++){
          sw = 1;
          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          double npA=hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             double npB=hb_itemGetND(pBB);
             hb_itemRelease( pBB );
             if( npA == npB ){
                sw = 0;
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if ( npA < npB ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
          if( sw ){
             hb_arraySetND( pDIFF, ++nSize, (double) npA );
          }
       }
       hb_arraySize( pDIFF, nSize ); // ajusto array final
    }else if( (type1==10 && type2==10) ){  // sting
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=nRowA;n++){
          sw = 1;

          PHB_ITEM pAA = hb_itemArrayGet( pSTACK1, n);
          const char * npA = hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=nRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pSTACK2, m);
             const char * npB = hb_itemGetCPtr(pBB);
             hb_itemRelease( pBB );
             if( strcmp ( npA, npB ) == 0 ){
                sw = 0;
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if( strcmp( npA, npB ) < 0 ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
          if( sw ){
             hb_arraySetC( pDIFF, ++nSize, (const char *) npA );
          }
       }
       hb_arraySize( pDIFF, nSize ); // ajusto array final    
    }
    return pDIFF;
}

// "setunique"=>52, "setunion"=>53,"setintersec"=>54,"setdiff"=>55,"setsimmetricdiff"=>56,;
int fun_set_especial( /*int nItem*/ ){
int sw=1;
int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int tCompare = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

switch(tCompare){
   case 0:{  // UNIQUE
      if(CADDR>=1){
         PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pARRAY );
         hb_arraySet( pSTK_ADDR, ++CADDR, pUNIQUE );
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAY);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET UNIQUE INNER-STACK OVERFLOW",101);
      }
      break;
   }case 1:{   // UNION
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pUNIQUE );
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET UNION INNER-STACK OVERFLOW",101);
      }   
      break;
   }case 2:{  //INTERSECTION
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pINTER = fun_set_intersection( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pINTER );
         hb_itemRelease(pINTER);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET INTERSEC INNER-STACK OVERFLOW",101);
      }
      break;
   }case 3:{   // SETDIFF
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pINTER = fun_set_intersection( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         PHB_ITEM pDIFF = fun_set_difference( (PHB_ITEM) pARRAY1, (PHB_ITEM) pINTER );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pDIFF );
         hb_itemRelease(pINTER);
         hb_itemRelease(pDIFF);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET DIFF INNER-STACK OVERFLOW",101);
      }
      break;
   }case 4:{   // SIMMETRIC DIFF
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         PHB_ITEM pINTER = fun_set_intersection( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         PHB_ITEM pTEMPORAL = fun_set_intersection( (PHB_ITEM) pUNIQUE, (PHB_ITEM) pINTER );
         
         PHB_ITEM pDIFF = fun_set_difference( (PHB_ITEM) pUNIQUE, (PHB_ITEM) pTEMPORAL );
         
         hb_arraySet( pSTK_ADDR, ++CADDR, pDIFF );
         hb_itemRelease(pINTER);
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pDIFF);
         hb_itemRelease(pTEMPORAL);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET SIMMETRIC DIFF INNER-STACK OVERFLOW",101);
      }
      break;
   }case 5: {   // DISJOINT
      if(CADDR>=2){
         PHB_ITEM pARRAY1 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pARRAY2 = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAY1, (PHB_ITEM) pARRAY2 );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         if( hb_arrayLen( pARRAY1 ) + hb_arrayLen( pARRAY2 ) == hb_arrayLen( pUNIQUE )){
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
         }else{
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
         }
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAY1);
         hb_itemRelease(pARRAY2);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET DISJOINT INNER-STACK OVERFLOW",101);
      }
      break;
   }case 6: {   //  SUBSET
      if(CADDR>=2){
         PHB_ITEM pARRAYB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // B
         PHB_ITEM pARRAYA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // A es subconjunto de B
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAYA, (PHB_ITEM) pARRAYB );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         if( hb_arrayLen( pARRAYB ) == hb_arrayLen( pUNIQUE )){
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
         }else{
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
         }
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAYA);
         hb_itemRelease(pARRAYB);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET SUBSET INNER-STACK OVERFLOW",101);
      }
      break;
   }case 7: {   //  SUPERSET
      if(CADDR>=2){
         PHB_ITEM pARRAYB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // B
         PHB_ITEM pARRAYA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // A es superconjunto de B
         CADDR += SWKEEP; SWKEEP = 0;
         
         PHB_ITEM pUNION = fun_set_union( (PHB_ITEM) pARRAYA, (PHB_ITEM) pARRAYB );
         hb_arraySort( pUNION, NULL, NULL, NULL );
         PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pUNION );
         
         if( hb_arrayLen( pARRAYA ) == hb_arrayLen( pUNIQUE )){
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
         }else{
            hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
         }
         hb_itemRelease(pUNION);
         hb_itemRelease(pUNIQUE);
         hb_itemRelease(pARRAYA);
         hb_itemRelease(pARRAYB);
      }else{
         sw=put_error((PHB_ITEM) pRET, "SET SUPERSET INNER-STACK OVERFLOW",101);
      }
      break;
   }
}
return sw;
}


/*********************************************
         FUNCIONES DE CLASE STRING
 *********************************************/

int fun_getstringarray(/* long nItem */){
int sw=1;
if( CADDR>=1 ){
   long nItem = STK_PRG[++CP];
   
   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if ( HB_IS_ARRAY(pARRAY) ){
      
      long nLen = hb_arrayLen( pARRAY );
      CADDR += SWKEEP; SWKEEP = 0;
      // size total
      int i,sw_error=0;
      long size=0, acumulado=0;
      for(i=1; i<=nLen; i++){
         PHB_ITEM pString = hb_itemArrayGet( pARRAY, i );
         if( HB_IS_STRING(pString))
            size += hb_itemGetCLen( pString );
         else{
            sw_error=1;
         }
         hb_itemRelease(pString);
         if(sw_error) break;
      }
      if(sw_error || !size || !nLen){
         sw=put_error((PHB_ITEM) pRET, "PACK STRING ARGUMENT ARRAY ERROR : VOID",103);   
      }else{
         //printf("NLEN=%ld, SIZE=%ld\n",nLen,size);
         char *separator = TOKENIZER;
         char * line = (char *)calloc( (size * nLen * 2) + size, 1 );
         for(i=1; i<=nLen; i++){
            PHB_ITEM pString = hb_itemArrayGet( pARRAY, i );
            size = hb_itemGetCLen( pString );
            const char * cString = hb_itemGetCPtr( pString );
            strcat(line, cString);
            if( i<nLen )
                line[acumulado + size]=separator[0];
   
         //memcpy(line, cString, size);
            acumulado += size+1;
            hb_itemRelease(pString);
         }
         line[acumulado]='\0';
         const char * cbuffer = line;
         hb_arraySetC( pSTK_REG, nItem, cbuffer );
         free(line);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PACK STRING ARGUMENT ARRAY ERROR",103);   
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "PACK STRING INNER-STACK OVERFLOW",101);
}
return sw;
}

unsigned char * revisa_caracter_especial(const char * pTexto){

  unsigned char * cChar = (unsigned char *) calloc(10,1);
  cChar[0] = *pTexto;
  if (cChar[0]==194 || cChar[0]==195 || cChar[0]==207 || cChar[0]==198 || cChar[0]==197
      || cChar[0]==234 || cChar[0]==180 ){
      ++pTexto;
      cChar[1] = *pTexto;
      cChar[2] = '\0';
  }else if (cChar[0]==226 || cChar[0]==239 ){
      ++pTexto;cChar[1] = *pTexto;
      ++pTexto;cChar[2] = *pTexto;
      cChar[3] = '\0';
  }else if(cChar[0]==206 ){
      ++pTexto;cChar[1] = *pTexto;
      ++pTexto;cChar[2] = *pTexto;
      ++pTexto;cChar[3] = *pTexto;
      cChar[4] = '\0';
  }else{ 
      cChar[1] = '\0';
  }
  return cChar;
}

int fun_getarraystring( /*long nItem */){
int sw=1;
if( CADDR>=1 ){
   
   long nItem = STK_PRG[++CP];
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * pText = hb_itemGetCPtr( pSTRING );
   long nLen = hb_itemGetCLen( pSTRING );
   hb_itemRelease(pSTRING);
   
   const char *separator = TOKENIZER;
   char * cTexto = (char*) calloc(nLen+1,1);
   memcpy(cTexto,pText,nLen);
   PHB_ITEM pCWM = hb_itemArrayNew(0); // CWM
   int cnt=0;
   
  //// printf("token=[%s]\n",separator);
   if(*separator!='\0'){
      char * token = strtok(cTexto, separator);

      while (token){
         //char * cToken = (char *)calloc(strlen(token)+1,1);
         //memcpy(cToken, token, strlen(token));
         const char * pBuffer = token; //cToken
         //printf("TOKEN = [%s]\n",token);
         hb_arraySize( pCWM, ++cnt);
         if(strlen(token)>0){
         
            hb_arraySetC( pCWM,   cnt, (const char *) pBuffer);
         }else{
            hb_arraySetC( pCWM,   cnt, (const char *) "");
         }
         token = strtok(0, separator);
         //free(cToken);
      }
   }else{
      const char * pTexto = cTexto;
      while(*pTexto){
         unsigned char * cChar = (unsigned char *) calloc(10,1);
         cChar[0] = *pTexto;
         if (cChar[0]==194 || cChar[0]==195 || cChar[0]==207 || cChar[0]==198 || cChar[0]==197
             || cChar[0]==234 || cChar[0]==180 ){
             ++pTexto;
             cChar[1] = *pTexto;
             cChar[2] = '\0';
         }else if (cChar[0]==226 || cChar[0]==239 ){
             ++pTexto;cChar[1] = *pTexto;
             ++pTexto;cChar[2] = *pTexto;
             cChar[3] = '\0';
         }else if(cChar[0]==206 ){
             ++pTexto;cChar[1] = *pTexto;
             ++pTexto;cChar[2] = *pTexto;
             ++pTexto;cChar[3] = *pTexto;
             cChar[4] = '\0';
         }else{ 
             cChar[1] = '\0';
         }
         const char * pChar=cChar;
         hb_arraySize( pCWM, ++cnt);
         hb_arraySetC( pCWM,   cnt, (const char *) pChar); 
         free(cChar);
         ++pTexto;
      }
   }
   free(cTexto);
   
  // hb_arraySize(pCWM,cnt);
   hb_arraySet( pSTK_REG, nItem, (PHB_ITEM)pCWM );
//   int i;
//   for(i=1; i<=cnt;i++){
//      PHB_ITEM f=hb_itemArrayGet(pCWM,i);
//      printf("LEN = %ld LINEA %d = %s\n", hb_itemGetCLen( f ), i, hb_itemGetCPtr(f));
//      hb_itemRelease(f);
//   }

   hb_itemRelease(pCWM);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "PACK ARRAY INNER-STACK OVERFLOW",101);
}
return sw;
}
/*
int fun_especialstring(int STK_PRG[], PHB_ITEM pSTK_REG, PHB_ITEM pSTK_ADDR, PHB_ITEM pRET, char *TOKENIZER){
int sw=1;
int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int tCompare = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

switch(tCompare){
   case 0:{    // load string
      sw=fun_loadstring((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET);
      break;
   }case 1:{   // get array from string
      sw=fun_getarraystring((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET);
      break;
   }case 2:{   // get string from array
      sw=fun_getstringarray((PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET, (char *)TOKENIZER);
      break;
   } 
}

return sw;
} */

int fun_countstring(/*int nItem*/){
int sw=1;
if( CADDR<=nSizeStack ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, nItem);  // string
   const char * cString = hb_itemGetCPtr( pREG );
   hb_itemRelease( pREG );

   const char * tb=cString;
   long nLine=0;
   while(*tb!='\0'){
      if(*tb=='\n' || *tb=='\0'){
         ++nLine;
      }
      ++tb;
   }
   //if(*tb=='\0') ++nLine;
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (long)nLine );
}else{
   sw=put_error((PHB_ITEM) pRET, "STRING - COUNT INNER-STACK OVERFLOW",101);
}
return sw;
}



int fun_linestring(/*int nItem*/){
int sw=1;

int nItem = STK_PRG[++CP];
PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, nItem);  // string
const char * cString = hb_itemGetCPtr( pREG );
hb_itemRelease( pREG );
   
long nLine=1,cLine=0;
if( MARK_POS ){
   cLine = MARK_POS;
}else{
   if( CADDR>=1 ){
      PHB_ITEM pLINE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // linea
      CADDR += SWKEEP; SWKEEP = 0;
      cLine = hb_itemGetNL( pLINE );
      hb_itemRelease( pLINE );
   }else{
      sw=put_error((PHB_ITEM) pRET, "GET LINE INNER-STACK OVERFLOW",101);
   }
}
   
if(sw){
   const char * tb=cString;

   if(cLine==1){  // primera linea
      char *line = (char *)calloc(MAXREADBUFFER,1);
      int i=0;
      while(*tb!='\n' && *tb!='\0'){
         line[i++] = *tb; ++tb;
      }
      line[i]='\0';
      const char *buffer = line;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)buffer );
      free(line);
   }else{
      while(*tb!='\0'){
         if(*tb=='\n'){
            ++nLine;
            if(nLine == cLine){
               char *line = (char *)calloc(MAXREADBUFFER,1);
               int i=0;
               ++tb;  // saltar último '\n'
               while(*tb!='\n' && *tb!='\0'){
                  line[i++] = *tb; ++tb;
               }
               line[i]='\0';
               const char *buffer = line;
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)buffer );
               free(line);
               break;
            }
         }
         ++tb;
      }
      if(*tb=='\0'){
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)"" );
      }
   }
 //  }
}else{
   sw=put_error((PHB_ITEM) pRET, "GET LINE INNER-STACK OVERFLOW",101);
}
return sw;
}
   

int fun_savestring(/*int nItem*/){
int sw=1;
if( CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pREG = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   
   if( HB_IS_STRING(pREG) ){
      const char * cString = hb_itemGetCPtr( pREG );
      PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
      CADDR += SWKEEP; SWKEEP = 0;
      const char * szFile = hb_itemGetCPtr( pFILE );
      hb_itemRelease( pFILE );
      FILE *fp;
      if( (fp = fopen(szFile,"w"))!=NULL ){
         const char * tb = cString;
         while(*tb){
            if(*tb!='\0') fputc(*tb,fp);
            tb++;
         }
      }
      fclose(fp);
      
   }else{
      sw=put_error((PHB_ITEM) pRET, "STRING - SAVE ARGUMENT ERROR",103);
   }
   hb_itemRelease( pREG );
}else{
   sw=put_error((PHB_ITEM) pRET, "STRING - SAVE INNER-STACK OVERFLOW",101);
}
return sw;
}
   
int fun_loadstring(/*int nItem*/ ){
int sw=1;
if( CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * szFile = hb_itemGetCPtr( pFILE );
   hb_itemRelease( pFILE );

   FILE *fp;
   if( (fp=fopen(szFile,"rb") ) != NULL ){
      
      fseek(fp, 0L, SEEK_END);
      long int nFinalPos  = ftell( fp ) ;
      
      rewind( fp );
      fseek( fp, 0L, SEEK_CUR) ;

      char * output = (char *)calloc(nFinalPos + 2, 1);
      if( output ){
         long int i=0;
         char ch;
         while ((ch = fgetc(fp)) != EOF){
            output[i++] = ch;
         }
         output[i] = '\0';
         const char * cbuffer = output;
         //hb_arraySetC( pSTK_ADDR, ++CADDR, cbuffer );
         hb_arraySetC( pSTK_REG, nItem, cbuffer );
         free(output);
      }else{
         sw=put_error((PHB_ITEM) pRET, "STRING - LOAD NOT ENOUGH MEMORY",100);
      }
      fclose(fp);

   }else{
      sw=put_error((PHB_ITEM) pRET, "STRING - LOAD FILE NOT EXIST OR BAD FILENAME",114);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "STRING - LOAD INNER-STACK OVERFLOW",101);
}
return sw;
}

/**************************************************
     FUNCIONES ESTADISTICAS
 ***************************************************/

int fun_get_multiplicatory( PHB_ITEM pARRAY, double *MULTI, long *NUMELEMENTS){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
if (type>=11){
   switch( nDim ){
      case 1:{
         *NUMELEMENTS = d1;
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            *MULTI *= hb_itemGetND( pARG22);
            hb_itemRelease(pARG22);
         }
         break;
      }case 2:{
         *NUMELEMENTS = d1 * d2;
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               *MULTI *= hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_itemRelease(pARG22);
         }
         break;
      }case 3:{
         *NUMELEMENTS = d1 * d2 * d3;
         int i;
         for(i=1; i<=d1; i++){
            PHB_ITEM pARGF = hb_itemArrayGet( pARRAY, i);
            int j;
            for(j=1; j<=d2; j++){
               PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
               int k;
               for(k=1; k<=d3; k++){
                  PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                  *MULTI *= hb_itemGetND( pARGP);
                  hb_itemRelease(pARGP);
               }
               hb_itemRelease(pARGC);
            }
            hb_itemRelease(pARGF);
         }
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_get_summatory( PHB_ITEM pARRAY, double *SUMMA, long *NUMELEMENTS, int TYPE){
int sw=1;
HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
if (type>=11){
   switch( nDim ){
      case 1:{
         *NUMELEMENTS = d1;
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            if(TYPE)   // 1=suma simple; 0=suma reciprocos
                *SUMMA += hb_itemGetND( pARG22);
            else
                *SUMMA += 1 / hb_itemGetND( pARG22);
            hb_itemRelease(pARG22);
         }
         break;
      }case 2:{
         *NUMELEMENTS = d1 * d2;
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               if(TYPE)   // 1=suma simple; 0=suma reciprocos
                  *SUMMA += hb_itemGetND( pARG222);
               else
                  *SUMMA += 1 / hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_itemRelease(pARG22);
         }
         break;
      }case 3:{
         *NUMELEMENTS = d1 * d2 * d3;
         int i;
         for(i=1; i<=d1; i++){
            PHB_ITEM pARGF = hb_itemArrayGet( pARRAY, i);
            int j;
            for(j=1; j<=d2; j++){
               PHB_ITEM pARGC = hb_itemArrayGet( pARGF, j);
               int k;
               for(k=1; k<=d3; k++){
                  PHB_ITEM pARGP = hb_itemArrayGet( pARGC, k);
                  if(TYPE)   // 1=suma simple; 0=suma reciprocos
                     *SUMMA += hb_itemGetND( pARGP);
                  else
                     *SUMMA += 1 / hb_itemGetND( pARGP);
                  hb_itemRelease(pARGP);
               }
               hb_itemRelease(pARGC);
            }
            hb_itemRelease(pARGF);
         }
         break;
      }default:{
         sw=0;
      }
   }
}else{
   sw=0;
}
return sw;
}

int fun_get_sumespecial(PHB_ITEM pARRAY, int d1, int d2, int type){
int sw=1;
if(CADDR<nSizeStack){
   switch(type){
      case 6:{  // suma columnas
         int j;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d2 );
         for( j=1; j<=d2; j++){
            int i;
            double SUMMA=0;
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA += hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG22);
            }
            hb_arraySetND( pNEWARRAY, j, (double) SUMMA );
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;
      }
      case 7:{   // suma filas
         int i;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d1 );
         for( i=1; i<=d1; i++){  // fila
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            double SUMMA=0;
            for( j=1; j<=d2; j++){  // columna
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA += hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_arraySetND( pNEWARRAY, i, (double) SUMMA );
            hb_itemRelease(pARG22);
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;
      }
      case 8:{   // multiplica columnas
         int j;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d2 );
         for( j=1; j<=d2; j++){
            int i;
            double SUMMA=1;
            for( i=1; i<=d1; i++){
               PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA *= hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
               hb_itemRelease(pARG22);
            }
            hb_arraySetND( pNEWARRAY, j, (double) SUMMA );
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;
      }
      case 9:{  // multiplica filas
         int i;
         PHB_ITEM pNEWARRAY = hb_itemArrayNew( d1 );
         for( i=1; i<=d1; i++){  // fila
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, i);
            int j;
            double SUMMA=1;
            for( j=1; j<=d2; j++){  // columna
               PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
               SUMMA *= hb_itemGetND( pARG222);
               hb_itemRelease(pARG222);
            }
            hb_arraySetND( pNEWARRAY, i, (double) SUMMA );
            hb_itemRelease(pARG22);
         }
         hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
         hb_itemRelease(pNEWARRAY);
         break;

      }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INNER-STACK UNDERFLOW",102);
}
return sw;
}

PHB_ITEM fun_get_class( PHB_ITEM pARRAY, PHB_ITEM pUNIQUE ){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);

   HB_MAXINT nDim1=0,d11=0,d12=0,d13=0,type1=0;
   get_size( (PHB_ITEM) pUNIQUE, &nDim1, &d11, &d12, &d13, &type1);
      
   int i;
   long Ni = 0;
   double Fi = 0;
   PHB_ITEM pNEWARRAY = hb_itemArrayNew( d11 );  // resultado
   for (i=1; i<=d11; i++ ){
      PHB_ITEM pARG2 = hb_itemArrayGet( pUNIQUE, i);
      PHB_ITEM pRows = hb_itemArrayNew( 5 );  // elemento, ocurrencias
      if( HB_IS_NUMERIC(pARG2) ){
         double nDato = hb_itemGetND( pARG2);
         int j;
         long SUMMA = 0;

         for (j=1; j<=d1; j++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, j);
            if( HB_IS_NUMERIC( pARG22 )){
               if( nDato == hb_itemGetND( pARG22) )
                  SUMMA++;
            }
            hb_itemRelease(pARG22);
         }
         double mean =  (double)SUMMA / (double)d1;
         Ni += SUMMA;
         Fi += mean;

         hb_arraySetND( pRows, 1, (double) nDato );
         hb_arraySetNL( pRows, 2, (long) SUMMA );
         hb_arraySetND( pRows, 3, (double) mean );
         hb_arraySetNL( pRows, 4, (long) Ni );
         hb_arraySetND( pRows, 5, (double) Fi );

      }else if( HB_IS_STRING(pARG2)){
         const char * cDato = hb_itemGetCPtr( pARG2);
         int j;
         long SUMMA = 0;
         for (j=1; j<=d1; j++ ){
            PHB_ITEM pARG22 = hb_itemArrayGet( pARRAY, j);
            if( HB_IS_STRING( pARG22 )){
                if( strcmp( cDato, hb_itemGetCPtr( pARG22)) == 0 )
                   SUMMA++;
            }
            hb_itemRelease(pARG22);
         }
         double mean =  (double)SUMMA / (double)d1;
         Ni += SUMMA;
         Fi += mean;
         
         hb_arraySetC( pRows, 1, (const char *) cDato );
         hb_arraySetNL( pRows, 2, (long) SUMMA );
         hb_arraySetND( pRows, 3, (double) mean );
         hb_arraySetNL( pRows, 4, (long) Ni );
         hb_arraySetND( pRows, 5, (double) Fi );
      }
      hb_arraySet( pNEWARRAY, i, pRows );
      hb_itemRelease(pRows);
      hb_itemRelease(pARG2);
   }

return pNEWARRAY;
}

PHB_ITEM fun_get_sturgesbin( PHB_ITEM pARRAY, int K ){

   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
   
   PHB_ITEM pELEMI = hb_itemArrayGet( pARRAY, 1);
   PHB_ITEM pELEMF = hb_itemArrayGet( pARRAY, d1);
   double nEi = floor(hb_itemGetND( pELEMI ));
   double nEf = ceil(hb_itemGetND( pELEMF ));
   double nFinal = nEf;
   hb_itemRelease(pELEMI);
   hb_itemRelease(pELEMF);
   double R = nEf - nEi;        // rango
   int C = ceil((double)R / K);   // amplitud intervalo de clase
   double P=0;               // ajuste para clases inicio y fin 
   if( (double)C*K > R)
      P = ceil( ( (double)C*K - R ) / 2.0 );
   nEi -= P;
   nFinal += P;
   if( nEi<0 ){
      nEf += fabs(nEi);
      nEi = 0; 
   }
   int i;
   long Ni = 0;
   double Fi = 0;
   // llenado de clases:
   PHB_ITEM pNEWARRAY = hb_itemArrayNew( K );  // resultado
   nEf = nEi + C;
   for( i=1; i<=K; i++){   // para cada clase

      PHB_ITEM pRows = hb_itemArrayNew( 7 );  // elemento, ocurrencias
      hb_arraySetNI( pRows, 1, (int) nEi );
      hb_arraySetNI( pRows, 2, (int) nEf );
      hb_arraySetND( pRows, 3, (double) (nEf + fabs(nEi))/2 );
      int j;
      long SUMMA=0;
      
      for(j=1; j<=d1; j++){
         PHB_ITEM pARG = hb_itemArrayGet( pARRAY, j);
         if( HB_IS_NUMERIC( pARG )){
            double nDato = hb_itemGetND( pARG );
            if( nDato >= nEi && nDato < nEf )   // cuenta para [a, b[
               SUMMA++;
         }
         hb_itemRelease(pARG);
      }
      double mean =  (double)SUMMA / (double)d1;
      Ni += SUMMA;
      Fi += mean;

      hb_arraySetNI( pRows, 4, (int) SUMMA );
      hb_arraySetND( pRows, 5, (double) mean );
      hb_arraySetNI( pRows, 6, (int) Ni );
      hb_arraySetND( pRows, 7, (double) Fi );
      hb_arraySet( pNEWARRAY, i, pRows );
      hb_itemRelease(pRows);
      nEi = nEf;
     // if( i==K-1){
     //    nEf = nFinal;//C+nEf > nFinal ? C+nEf : nFinal;
     //    if( nEf-nEi != C )
            
     // }else 
         nEf += C;
         //nEf = nEf + C + ((i==K-1) ? ( -C + nFinal ): 0.0);  // para incluir el último dato de la lista [a, B]
   }
   // recopilacion de datos y llenado de tabla
   //printf("\nK = %d\n",K);
return pNEWARRAY;
}


int fun_stat_especial(/*int nItem */){
int sw=1;

if( CADDR >= 1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int tCompare = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   
   PHB_ITEM pARRAY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );   // array

   if( HB_IS_ARRAY(pARRAY) ){
      if( tCompare < 3 ){
         // esta es fundamental, sobre esta se construye la estadística descriptiva con MACROS. 
         long NUMELEMENTS=0;
         double SUMMA=0;
         CADDR += SWKEEP; SWKEEP = 0;
         if(!(int)fun_get_summatory(pARRAY, &SUMMA, &NUMELEMENTS, 1)){
            sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (SUMMATORY BASED) ARGUMENT ERROR",103);
         }else{
            switch( tCompare ){
               case 0:{   // suma
                  hb_arraySetND( pSTK_ADDR, ++CADDR, (double) SUMMA ); break; 
               }case 1: {   // busca promedio
                  hb_arraySetND( pSTK_ADDR, ++CADDR, (double) ( SUMMA / NUMELEMENTS ) ); break;
               }case 2: {  // suma y promedio
                  if( CADDR<=nSizeStack){
                     hb_arraySetND( pSTK_ADDR, ++CADDR, (double) SUMMA );
                     hb_arraySetND( pSTK_ADDR, ++CADDR, (double) ( SUMMA / NUMELEMENTS ) );
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (SUM OR MEAN) INNER-STACK UNDERFLOW",102);
                  }
                  break;
               }default:{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INVALID FUNC - ARGUMENT ERROR",103);break;
               }
            }
         }
      }else{   // otras cosas. por ahora: error
         switch( tCompare ){
            case 3: case 4:{   // sturges class  // variable continua
               // el array debe ser 1D. si no es, usar reshape afuera.
               long N = hb_arrayLen(pARRAY);
               hb_arraySort( pARRAY, NULL, NULL, NULL );
               int K=0;
               // calcular K según strges o bindado.
               if( tCompare == 4 ){  // sacar desde el Stack el bin dado
                  if(CADDR>=1){
                     PHB_ITEM pBIN = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                     CADDR += SWKEEP; SWKEEP = 0;
                     K = hb_itemGetNI(pBIN);
                     hb_itemRelease(pBIN);
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (STURGESS) INVALID BIN - ARGUMENT ERROR",103);break;
                  }
               }else{
                  K = ceil(1+3.3*log10(N));
               }
               
               PHB_ITEM pNEWARRAY = fun_get_sturgesbin( (PHB_ITEM) pARRAY, (int) K );
               hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
               hb_itemRelease(pNEWARRAY);
               
               break;
            }case 5: {   // ocurrencias de cada elemento. un elemento es una clase en sí misma.
               // el array debe ser 1D. si no es, usar reshape afuera.
              
               hb_arraySort( pARRAY, NULL, NULL, NULL );
               PHB_ITEM pUNIQUE = fun_set_unique( (PHB_ITEM) pARRAY );
               PHB_ITEM pNEWARRAY = fun_get_class( (PHB_ITEM) pARRAY, (PHB_ITEM) pUNIQUE );
               hb_arraySet( pSTK_ADDR, ++CADDR, pNEWARRAY );
               hb_itemRelease(pUNIQUE);
               hb_itemRelease(pNEWARRAY);
               break;
            }case 6:{   // suma columnas => vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,6);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (COLUMN SUM) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 7:{   // suma filas ==> vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,7);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (ROW SUM) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 8: case 9:{   // multiplica todo, como la suma
               long NUMELEMENTS=0;
               double MULTI=1;
               CADDR += SWKEEP; SWKEEP = 0;
               if(!(int)fun_get_multiplicatory(pARRAY, &MULTI, &NUMELEMENTS)){
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (MULTIPLICATORY BASED) ARGUMENT ERROR",103);
               }else{
                  switch( tCompare ){
                     case 8:{   // multiplicatoria
                        hb_arraySetND( pSTK_ADDR, ++CADDR, (double) MULTI ); break; 
                     }case 9: {   // media geométrica
                       //printf("\nMULTI= %lf, NUMELE=%ld, 1/NUM=%lf, PRUEBA: %lf\n",(double)MULTI,(long)NUMELEMENTS,(double)(1/NUMELEMENTS),(double) pow( (double)MULTI, (double)(1.0 / NUMELEMENTS) ));
                        hb_arraySetND( pSTK_ADDR, ++CADDR, (double) pow( (double)MULTI, (double)(1.0 / NUMELEMENTS) ) ); break;
                     }default:{
                        sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INVALID FUNC - ARGUMENT ERROR",103);break;
                     }
                  }
               }
               break;
            }case 10:{  // media harmónica: suma reciprocos
               long NUMELEMENTS=0;
               double SUMMA=0;
               CADDR += SWKEEP; SWKEEP = 0;
               if(!(int)fun_get_summatory(pARRAY, &SUMMA, &NUMELEMENTS, 0)){
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (HARMONIC MEAN) ARGUMENT ERROR",103);
               }else{
                  hb_arraySetND( pSTK_ADDR, ++CADDR, (double) (NUMELEMENTS / SUMMA) );
               }
               break;
            }case 11:{   // multiplica columnas => vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,8);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (COLUMN MULT) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 12:{   // multiplica filas ==> vector
               HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
               get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
               if (nDim==2 && type==11){
                  sw=fun_get_sumespecial((PHB_ITEM) pARRAY,d1,d2,9);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "STATS-FUNC (ROW MULT) - ARGUMENT ERROR: I NEED NUMBER'2D-MATRIX",103);break;
               }
               break;
            }case 13: case 14:{  // ADDSUB | SUBADD
                  CADDR += SWKEEP; SWKEEP = 0;
                  HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
                  get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
                  if(type==11 && nDim==1 && d1>0){
                     HB_SIZE nLenT=hb_arrayLen( pARRAY );
            
                     HB_SIZE i;
                     int swAlter;
                     if (tCompare==13) swAlter=1; else swAlter=0;
                     PHB_ITEM pELEM = hb_itemArrayGet(pARRAY,1);
                     double nResul=(double)hb_itemGetND(pELEM);
                     hb_itemRelease(pELEM);
                     for(i=2;i<=nLenT;i++){
                        PHB_ITEM pELEM = hb_itemArrayGet(pARRAY,i);
                        if(swAlter){
                           nResul += (double)hb_itemGetND(pELEM); swAlter=0;
                        }else{
                           nResul -= (double)hb_itemGetND(pELEM); swAlter=1;
                        }
                        hb_itemRelease(pELEM);
                     }
                     hb_arraySetND( pSTK_ADDR, ++CADDR, (double) (nResul) );
                  }else{
                     sw=put_error((PHB_ITEM) pRET, "ARRAY ADDSUB|SUBADD ARGUMENT ERROR: I NEED AN NUMBER'S UNIDIM ARRAY",103);
                  }
               break;

            }default:{
               sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INVALID FUNC - ARGUMENT ERROR",103);break;
            }
         }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "STATS-FUNC ARGUMENT ERROR",103);
   }
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "STATS-FUNC INNER-STACK OVERFLOW",101);
}
return sw;
}

/***********************************************
     FUNCIONES TRY CATCH, RAISE ATRAPAN
     ERRORES
 ************************************************/
// "poptry"=>71, "gettry"=>264, "swtrap"=>265, "throw"=>266
int fun_trycatch( /*int nItem,*//* int tCompare*/){
int sw=1;

int tCompare = nPCP==71 ? 3 : nPCP-264;
switch( tCompare){
   case /*264*/0:{  // GETTRY
      int nItem = STK_PRG[++CP]; // para colocar el codigo del error
      PHB_ITEM pERRCOD = hb_itemArrayGet( pRET, 7 );
      if( HB_IS_NUMERIC(pERRCOD)){
         hb_arraySetNI( pSTK_REG, nItem, (int) hb_itemGetNI(pERRCOD) );
      }else{
         sw=put_error((PHB_ITEM) pRET, "TRY BAD FORMED",118);
      }
      hb_itemRelease(pERRCOD);
      break;
   }case /*265*/1:{  // SWTRAP
      unsigned int nItem = STK_PRG[ ++CP ];
      sw= (int) push_try( (unsigned int) nItem ) ;
      break;
   }case /*266*/ 2:{   // RAISE
      int nItem = STK_PRG[++CP];
      PHB_ITEM pERRCOD = hb_itemArrayGet( pSTK_REG, nItem );
      int nErrCode=hb_itemGetNI(pERRCOD);
      hb_itemRelease(pERRCOD);
      if(CADDR>=1){
         PHB_ITEM pSTRERR = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         CADDR += SWKEEP; SWKEEP = 0;
         const char * cMsgErr = hb_itemGetCPtr(pSTRERR);
         sw=put_error((PHB_ITEM) pRET, (const char *) cMsgErr,nErrCode);
         hb_itemRelease(pSTRERR);
      }else{
         sw=put_error((PHB_ITEM) pRET, "USER RAISED ERROR ",nErrCode);
      }
      break;
   }case /*71*/ 3:{   // POPTRY
      int tCP = CP;
      sw=(int) pop_try();  // esto obtiene nueva direccion. Aquí no sirve.
      CP = tCP;
      break;
   }
}
return sw;
}


/*
 * Additional date functions
 *
 * Copyright 1999 Jose Lalin <dezac@corevia.com>
 */

static int hb_isleapyear( int iYear )
{
   return ( iYear % 4 == 0 && iYear % 100 != 0 ) || ( iYear % 400 == 0 );
}

void fun_get_time(const char * szTime, int nLen, int *iHour, int *iMinute, int *iSeconds, int *iMillisec){
   if( nLen >= 8 ){
      *iHour    = 10 * ( szTime[ 0 ] - '0' ) + ( szTime[ 1 ] - '0' );
      *iMinute  = 10 * ( szTime[ 3 ] - '0' ) + ( szTime[ 4 ] - '0' );
      *iSeconds = 10 * ( szTime[ 6 ] - '0' ) + ( szTime[ 7 ] - '0' );
      if( nLen == 11 ){
         *iMillisec = 10 * ( szTime[ 9 ] - '0' ) + ( szTime[ 10 ] - '0' );
      }else{
         *iMillisec = 0;
      }
   }else{
      *iHour = *iMinute = *iSeconds = *iMillisec = 0;
   }
}
static int _hb_timeValid( const char * szTime, HB_SIZE nLen, int * piDecode )
{
   int fValid = 0;

   if( nLen == 2 || nLen == 5 || nLen == 8 || nLen == 11 )
   {
      static const int sc_iMax[] = { 23, 59, 59, 99 };
      int     i, iVal;
      HB_SIZE ul;

      fValid = 1;
      for( ul = 0; fValid && ul < nLen; ++ul )
      {
         fValid = ul % 3 == 2 ? szTime[ ul ] == ':' :
                  ( szTime[ ul ] >= '0' && szTime[ ul ] <= '9' );
      }
      for( ul = 0, i = 0; fValid && ul < nLen; ul += 3, ++i )
      {
         iVal   = 10 * ( szTime[ ul ] - '0' ) + ( szTime[ ul + 1 ] - '0' );
         fValid = iVal <= sc_iMax[ i ];
         if( piDecode )
            piDecode[ i ] = iVal;
      }
   }

   return fValid;
}

int _hb_dateValid( const char * cDate, HB_SIZE nLen ){
   const char * pDate = cDate;
   
   int fecha_correcta = 0;

   char *fecha = (char *)calloc( nLen+10, 1 );
   memcpy(fecha,pDate,nLen);
   char * cDia = strtok(fecha, "/");
   if(cDia){
      char * cMes = strtok(0, "/");
      if(cMes){
         char * cAnio = strtok(0, "/");
         if(cAnio){
            const char *pDia = cDia;
            const char *pMes = cMes;
            const char *pAnio = cAnio;
            int nDia = atoi( pDia );
            int nMes = atoi( pMes );
            int nAnio = atoi( pAnio );
            int dia_maximo=0;

            if ( nMes >= 1 && nMes <= 12 ){
               switch ( nMes ){
                  case  1 : case  3 : case  5 : case  7 : case  8 : case 10 :
                  case 12 : dia_maximo = 31;
                            break;
                  case  4 : case  6 : case  9 :
                  case 11 : dia_maximo = 30;
                            break;
                  case  2 : if ( nAnio % 4 == 0 && nAnio % 100 != 0 || nAnio % 400 == 0 )
                               dia_maximo = 29;
                            else
                                dia_maximo = 28;
               }

               if ( nDia >= 1 && nDia <= dia_maximo )
                  fecha_correcta = 1;
            }
         }
      }
   }
   free(fecha); //free(cDia);free(cMes);free(cAnio);
   return fecha_correcta;
}

static int ct_doy( long lDate )
{
   int iYear, iMonth, iDay;
   long lFirst;

   hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
   lFirst = hb_dateEncode( iYear, 1, 1 );
   return ( int ) ( lDate - lFirst + 1 );
}

static int ct_daysinmonth( int iMonth, int bLeap )
{
   if( iMonth == 2 )
      return bLeap ? 29 : 28;
   else if( iMonth == 4 || iMonth == 6 || iMonth == 9 || iMonth == 11 )
      return 30;
   else
      return 31;
}


static char * hb_SecToTimeStr( char * pszTime, long lTime )
{
   int iValue;

   HB_TRACE(HB_TR_DEBUG, ("hb_SecToTimeStr(%p, %ld)", pszTime, lTime));

   iValue = ( int ) ( ( lTime / 3600 ) % 24 );
   pszTime[ 0 ] = ( char ) ( iValue / 10 ) + '0';
   pszTime[ 1 ] = ( char ) ( iValue % 10 ) + '0';
   pszTime[ 2 ] = ':';
   iValue = ( int ) ( ( lTime / 60 ) % 60 );
   pszTime[ 3 ] = ( char ) ( iValue / 10 ) + '0';
   pszTime[ 4 ] = ( char ) ( iValue % 10 ) + '0';
   pszTime[ 5 ] = ':';
   iValue = ( int ) ( lTime % 60 );
   pszTime[ 6 ] = ( char ) ( iValue / 10 ) + '0';
   pszTime[ 7 ] = ( char ) ( iValue % 10 ) + '0';
   pszTime[ 8 ] = '\0';

   return pszTime;
}

static long hb_TimeStrToSec( const char * pszTime )
{
   HB_SIZE nLen;
   long lTime = 0;

   HB_TRACE(HB_TR_DEBUG, ("hb_TimeStrToSec(%s)", pszTime));

   nLen = strlen( pszTime );

   if( nLen >= 1 )
      lTime += ( long ) hb_strVal( pszTime, nLen ) * 3600;

   if( nLen >= 4 )
      lTime += ( long ) hb_strVal( pszTime + 3, nLen - 3 ) * 60;

   if( nLen >= 7 )
      lTime += ( long ) hb_strVal( pszTime + 6, nLen - 6 );

   return lTime;
}

int fun_get_dateadd_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pA, PHB_ITEM pB) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pB, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            long lStart = hb_dateUnformat( hb_itemGetCPtr( pARG11 ), hb_setGetDateFormat() );
            long lEnd = hb_itemGetNI( pA );
            char szDate[ 9 ];
            char szFormatted[ 11 ];
            hb_arraySetC( pRows, i, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                                szFormatted, hb_setGetDateFormat() ) );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               long lStart = hb_dateUnformat( hb_itemGetCPtr( pARG111 ), hb_setGetDateFormat() );
               long lEnd = hb_itemGetNI( pA );
               char szDate[ 9 ];
               char szFormatted[ 11 ];
               hb_arraySetC( pCols, j, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                                szFormatted, hb_setGetDateFormat() ) );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  long lStart = hb_dateUnformat( hb_itemGetCPtr( pARG1111 ), hb_setGetDateFormat() );
                  long lEnd = hb_itemGetNI( pA );
                  char szDate[ 9 ];
                  char szFormatted[ 11 ];
                  hb_arraySetC( pPag, k, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                                   szFormatted, hb_setGetDateFormat() ) );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int get_dateadd(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING( pB ) && HB_IS_NUMERIC( pA )){
      long lStart = hb_dateUnformat( hb_itemGetCPtr( pB ), hb_setGetDateFormat() );
      long lEnd = hb_itemGetNI( pA );
      char szDate[ 9 ];
      char szFormatted[ 11 ];
      hb_arraySetC( pSTK_ADDR, ++CADDR, hb_dateFormat(hb_dateDecStr( szDate, lStart + lEnd ),
                    szFormatted, hb_setGetDateFormat() ) );
   }else if(HB_IS_ARRAY( pB ) && HB_IS_NUMERIC( pA )){
      ++CADDR;
      sw=fun_get_dateadd_matrix( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM)pA, (PHB_ITEM)pB );
   }else{
      sw=put_error((PHB_ITEM) pRET, "DATE ADD ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
   hb_itemRelease(pB);
}else{
   sw=put_error((PHB_ITEM) pRET, "DATE ADD INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_daysdiff_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pA, PHB_ITEM pB) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pB, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
            long lEnd = hb_dateUnformat( hb_itemGetCPtr( pARG11 ), hb_setGetDateFormat() );      
            hb_arraySetNI( pRows, i, lStart - lEnd );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
               long lEnd = hb_dateUnformat( hb_itemGetCPtr( pARG111 ), hb_setGetDateFormat() );      
               hb_arraySetNI( pCols, j, lStart - lEnd );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
                  long lEnd = hb_dateUnformat( hb_itemGetCPtr( pARG1111 ), hb_setGetDateFormat() );      
                  hb_arraySetNI( pPag, k, lStart - lEnd );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int get_daysdiff(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING( pA ) && HB_IS_STRING( pB )){
      long lStart = hb_dateUnformat( hb_itemGetCPtr( pA ), hb_setGetDateFormat() );
      long lEnd = hb_dateUnformat( hb_itemGetCPtr( pB ), hb_setGetDateFormat() );      
      hb_arraySetNI( pSTK_ADDR, ++CADDR, lStart - lEnd );
   }else if(HB_IS_STRING( pA ) && HB_IS_ARRAY( pB )){
      ++CADDR;
      sw=fun_get_daysdiff_matrix( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM)pA, (PHB_ITEM)pB );
   }else{
      sw=put_error((PHB_ITEM) pRET, "DAYS DIFF ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
   hb_itemRelease(pB);
}else{
   sw=put_error((PHB_ITEM) pRET, "DAYS DIFF INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_elaptime_matrix( PHB_ITEM pSTK_ADDR, PHB_ITEM pA, PHB_ITEM pB) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pB, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pARG11 ) );
            long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
            char szTime[ 9 ];
            hb_arraySetC( pRows, i, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pARG111 ) );
               long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
               char szTime[ 9 ];
               hb_arraySetC( pCols, j, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pB, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pARG1111 ) );
                  long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
                  char szTime[ 9 ];
                  hb_arraySetC( pPag, k, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int get_elaptime(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pB = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING( pA ) && HB_IS_STRING( pB )){
      long lStart = hb_TimeStrToSec( hb_itemGetCPtr( pB ) );
      long lEnd = hb_TimeStrToSec( hb_itemGetCPtr( pA ) );
      char szTime[ 9 ];
      hb_arraySetC( pSTK_ADDR, ++CADDR, hb_SecToTimeStr( szTime, ( lEnd < lStart ? 86400 : 0 ) + lEnd - lStart ) );
   }else if(HB_IS_STRING( pA ) && HB_IS_ARRAY( pB )){
      ++CADDR;
      sw=fun_get_elaptime_matrix( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM)pA, (PHB_ITEM)pB );
   }else{
      sw=put_error((PHB_ITEM) pRET, "ELAPTIME ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
   hb_itemRelease(pB);
}else{
   sw=put_error((PHB_ITEM) pRET, "ELAPTIME INNER-STACK OVERFLOW",101);
}
return sw;
}

int get_seconds(){
int sw=1;

if( CADDR<nSizeStack ){
   if(CADDR>=1){
      PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if(HB_IS_STRING( pA )){
         hb_arraySetND( pSTK_ADDR, ++CADDR, hb_TimeStrToSec( hb_itemGetCPtr( pA ) ) );
      }
      hb_itemRelease(pA);
   }else{   // segundos transcurridos desde la medianoche-
      hb_arraySetND( pSTK_ADDR, ++CADDR, (double) hb_dateSeconds() );
      ///hb_arraySetND( pSTK_ADDR, ++CADDR, clock() );
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SECONDS INNER-STACK OVERFLOW",101);
}   
return sw;
}

int get_sectotime(/* PHB_ITEM pSTK_ADDR, PHB_ITEM pRET */){
int sw=1;

if(CADDR>=1){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_NUMERIC( pA )){
      char pszTime[ 9 ];
      hb_arraySetC( pSTK_ADDR, ++CADDR, hb_SecToTimeStr( pszTime, hb_itemGetNInt( pA ) ) );
   }else{
      sw=put_error((PHB_ITEM) pRET, "SECONDS TO TIME ARGUMENT ERROR",103);
   }
   hb_itemRelease(pA);
}else{
   sw=put_error((PHB_ITEM) pRET, "SECONDS TO TIME INNER-STACK OVERFLOW",101);
}
return sw;
}

int put_sleep(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   hb_idleSleep( hb_itemGetND( pA ) );
   //sleep( hb_itemGetNInt( pA ) );
   hb_itemRelease(pA);
}else{
   sw=put_error((PHB_ITEM) pRET, "SLEEP INNER-STACK OVERFLOW",101);
}   
return sw;
}

int put_microseconds(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pA = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   // hb_idleSleep( hb_itemGetNInt( pA ) / 1000 );
   usleep( hb_itemGetNInt( pA ) );// * 1000 );
   hb_itemRelease(pA);
}else{
   sw=put_error((PHB_ITEM) pRET, "MICROSECONDS INNER-STACK OVERFLOW",101);
}   
return sw;
}

int fun_timecpu(){  // milisegundos desde iniciado el proceso.
int sw=1;
int nItem = STK_PRG[++CP];
clock_t tiempo = clock();
hb_arraySetNI( pSTK_REG, nItem, (int) tiempo );
return sw;
}

int fun_timer(){   // trabaja con TIMECPU.
int sw=1;
if(CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pVARTIMER = hb_itemArrayGet( pSTK_REG, nItem);
   double nVarTimer = hb_itemGetND(pVARTIMER);
   hb_itemRelease(pVARTIMER);
   
   PHB_ITEM pTIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   double nTimeMillisec = hb_itemGetND(pTIME);
   hb_itemRelease(pTIME);
   clock_t tiempo = clock();
  // if( ( (double) hb_dateSeconds() - nVarTimer ) * 1000 >= nTimeMillisec ){
  if( ( tiempo - nVarTimer ) * 1000 / CLOCKS_PER_SEC >= nTimeMillisec ){
      hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
      //hb_arraySetND(pSTK_REG, nItem, (double) hb_dateSeconds());
      tiempo = clock();
      hb_arraySetND(pSTK_REG, nItem, tiempo);
   }else{
      hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "TIMER INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_clock_per_sec(){
int sw=1;
if(CADDR<nSizeStack){
   hb_arraySetND(pSTK_ADDR, ++CADDR, CLOCKS_PER_SEC);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLOCKPERSEC INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_get_notation(){
int sw=1;
if(CADDR){
   PHB_ITEM pNUMBER = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING(pNUMBER)){
      const char * AX = hb_itemGetCPtr(pNUMBER);
      hb_itemRelease(pNUMBER);
      if( xu_funIsnotation((const char *) AX) ){
         double nDbl = xu_funE2D( (const char *) AX );
         hb_arraySetND(pSTK_ADDR, ++CADDR, (double) nDbl);
         hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
      }else{
         hb_arraySetC(pSTK_ADDR, ++CADDR, (const char * ) AX);
         hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "GETNOTATION? ARGUMENT ERROR",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "GETNOTATION? INNER-STACK UNDERFLOW",104);
}
return sw;
}

int fun_get_datetime_item(PHB_ITEM pDATETIME, PHB_ITEM pSTK, int ndx,/* PHB_ITEM pRET,*/ int nCode, int single){
int sw=1;
   const char * cDate = hb_itemGetCPtr(pDATETIME);
   long nLen = hb_itemGetCLen(pDATETIME);
   
   switch( nCode ){
      case 1:{
         char pszTime[24];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 24, "%02d de %s de %4d", iDay,XU_ANO[iMonth], iYear);
         hb_arraySetC( pSTK, ndx, (const char * )pszTime );
         break;
      // 2 y 3 no aplican, porque ya son strings
      }case 4: case 5:{  // fecha en stack, hora
         if( single ){
            if( nCode==4 ){
               if( CADDR<=nSizeStack-3 ){
                  int iYear, iMonth, iDay;
                  hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                     &iYear, &iMonth, &iDay );
                  hb_arraySetNI( pSTK, CADDR, iYear);
                  hb_arraySetNI( pSTK, ++CADDR, iMonth);
                  hb_arraySetNI( pSTK, ++CADDR, iDay);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "DATE INNER-STACK OVERFLOW",101);
               }
            }else{
               if( CADDR<=nSizeStack-4 ){
                  int iHour, iMinute, iSeconds, iMillisec;
                  fun_get_time( cDate, nLen, &iHour, &iMinute, &iSeconds, &iMillisec );
                  hb_arraySetNI( pSTK, CADDR, iMillisec);
                  hb_arraySetNI( pSTK, ++CADDR, iSeconds);
                  hb_arraySetNI( pSTK, ++CADDR, iMinute);
                  hb_arraySetNI( pSTK, ++CADDR, iHour);
               }else{
                  sw=put_error((PHB_ITEM) pRET, "DATE INNER-STACK OVERFLOW",101);
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "DATE INNER-STACK OUT OF CONTEXT",108);
         }
         break;
      }case 6:case 7: case 8:{   //año, mes, dia, 
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         switch( nCode ){
            case 6: {hb_arraySetNI( pSTK, ndx, iYear); break;}
            case 7: {hb_arraySetNI( pSTK, ndx, iMonth); break;}
            case 8: {hb_arraySetNI( pSTK, ndx, iDay); break;}
         }
         break;
      }case 9:case 10: case 11:{    //hora, minuto, segundos
         int iHour, iMinute, iSeconds, iMillisec;
         fun_get_time( cDate, nLen, &iHour, &iMinute, &iSeconds, &iMillisec );
         switch( nCode ){
            case 9: {hb_arraySetNI( pSTK, ndx, iHour); break;}
            case 10: {hb_arraySetNI( pSTK, ndx, iMinute); break;}
            case 11: {hb_arraySetNI( pSTK, ndx, iSeconds); break;}
         }
         break;
      }case 12:{  // dia de la semana en palabras
         char pszTime[ 11 ];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         if( nDow > 0){
            const char * semana = XU_SEMANA[ nDow ];
            hb_arraySetC( pSTK, ndx, semana);
         }else{
            hb_arraySetC( pSTK, ndx, cDate );
         }
         break;
      }case 13:{   // mes en palabras
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         const char * mes = XU_ANO[ iMonth ];
         hb_arraySetC( pSTK, ndx, mes);
         break;
      }case 14:{    // es año bisiesto?
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_arraySetNI( pSTK, ndx, (int) hb_isleapyear( iYear ) );
         break;
      }case 15:{    // días en el mes
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         int bLeap = hb_isleapyear( iYear );
         hb_arraySetNI( pSTK, ndx, ct_daysinmonth( iMonth, bLeap ) );
         break;
      }case 16:{   // dia de la semana en indice.
         char pszTime[ 11 ];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK, ndx, nDow );
         break;
      }case 17:{   // semana del año
         long lDate2;
         char pszTime[ 11 ];
         int iYear, iMonth, iDay;
         hb_dateDecode( hb_dateUnformat( cDate, hb_setGetDateFormat() ), 
                                  &iYear, &iMonth, &iDay );
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         long lDate = hb_dateUnformat( cDate, hb_setGetDateFormat() );
         if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
             lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
         else
             lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
         hb_arraySetNI( pSTK, ndx, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
         break;
      }case 18:{   // día del año
         int ndiadelYear = ct_doy( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK, ndx, ndiadelYear );
         break;
      }case 19:{  // hora valida?
         hb_arraySetNI( pSTK, ndx, (int) _hb_timeValid( cDate, nLen, NULL ));
         break;
      }case 20:{   // fecha valida?
         hb_arraySetNI( pSTK, ndx, (int) _hb_dateValid( cDate, nLen));
         break;
      }default: sw=put_error((PHB_ITEM) pRET, "DATE ARGUMENT ERROR",103); break;
   
   }
return sw;
}

int fun_get_datetime_matrix(PHB_ITEM pDATETIME, PHB_ITEM pSTK_ADDR, int CADDR,/* PHB_ITEM pRET,*/int nCode){
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pDATETIME, &nDim, &d1, &d2, &d3, &type);
   if (type==10){
   switch( nDim ){
      case 1:{
         PHB_ITEM pRows  = hb_itemArrayNew( d1 );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
            sw=fun_get_datetime_item( (PHB_ITEM) pARG11, (PHB_ITEM) pRows, i, /*(PHB_ITEM) pRET,*/ (int) nCode, 0);
            hb_itemRelease(pARG11);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 2:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               sw=fun_get_datetime_item( (PHB_ITEM) pARG111, (PHB_ITEM) pCols, j,/* (PHB_ITEM) pRET,*/ (int) nCode, 0);
               hb_itemRelease(pARG111);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }case 3:{
         PHB_ITEM pRows = hb_itemArrayNew( d1 );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
            PHB_ITEM pCols = hb_itemArrayNew( d2 );
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
               PHB_ITEM pPag = hb_itemArrayNew( d3 );
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                  sw=fun_get_datetime_item( (PHB_ITEM) pARG1111, (PHB_ITEM) pPag, k,/* (PHB_ITEM) pRET,*/ (int) nCode, 0);
                  hb_itemRelease(pARG1111);
               }
               hb_arraySet( pCols, j, pPag );
               hb_itemRelease(pARG111);
               hb_itemRelease(pPag);
            }
            hb_arraySet( pRows, i, pCols );
            hb_itemRelease(pARG11);
            hb_itemRelease(pCols);
         }
         hb_arraySet(pSTK_ADDR, CADDR, pRows);
         hb_itemRelease(pRows);
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int fun_date_time( /*int nItem */){
int sw=1;
if(CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int nCode = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   PHB_ITEM pDATETIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pDATETIME)){
      ++CADDR;
      sw=fun_get_datetime_item( (PHB_ITEM) pDATETIME, (PHB_ITEM) pSTK_ADDR, CADDR,/* (PHB_ITEM) pRET,*/ (int) nCode, 1);
      
   }else if( HB_IS_ARRAY(pDATETIME)){
      ++CADDR;
      sw=fun_get_datetime_matrix( (PHB_ITEM) pDATETIME, (PHB_ITEM) pSTK_ADDR, CADDR,/* (PHB_ITEM) pRET,*/ (int) nCode);
//   long lDate = hb_dateUnformat( cDate, hb_setGetDateFormat() );
   }
   hb_itemRelease(pDATETIME);

}else{
   sw=put_error((PHB_ITEM) pRET, "DATE & TIME INNER-STACK OVERFLOW",101);
}
return sw;
}

void fun_put_names(PHB_ITEM pDATETIME, int tCompare){

       HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
       get_size( (PHB_ITEM) pDATETIME, &nDim, &d1, &d2, &d3, &type);

       switch( nDim ){
          case 1:{
             PHB_ITEM pRows  = hb_itemArrayNew( d1 );
             long i;
             for (i=1; i<=d1; i++ ){
                PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
                switch(tCompare){
                    case 0:{
                       int nCode = hb_itemGetNInt(pARG11);
                       if(nCode>=1 && nCode<=7){
                           const char * pszTime = XU_SEMANA[nCode];
                           hb_arraySetC( pRows, i, (const char * )pszTime );
                       }else{
                           hb_arraySetC( pRows, i, (const char * )"***" );
                       }
                       break;
                   }case 1:{
                       int nCode = hb_itemGetNInt(pARG11);
                       if(nCode>=1 && nCode<=12){
                           const char * pszTime = XU_ANO[nCode];
                           hb_arraySetC( pRows, i, (const char * )pszTime );
                       }else{
                           hb_arraySetC( pRows, i, (const char * )"***" );
                       }
                       break;
                   }
                }
                hb_itemRelease(pARG11);
             }
             hb_arraySet(pSTK_ADDR, CADDR, pRows);
             hb_itemRelease(pRows);
             break;
         }case 2:{
             PHB_ITEM pRows = hb_itemArrayNew( d1 );
             long i;
             for( i=1; i<=d1; i++){
                PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
                PHB_ITEM pCols = hb_itemArrayNew( d2 );
                long j;
                for( j=1; j<=d2; j++){
                   PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
                   switch(tCompare){
                      case 0:{
                         int nCode = hb_itemGetNInt(pARG111);
                         if(nCode>=1 && nCode<=7){
                             const char * pszTime = XU_SEMANA[nCode];
                             hb_arraySetC( pCols, j, (const char * )pszTime );
                         }else{
                             hb_arraySetC( pCols, j, (const char * )"***" );
                         }
                         break;
                      }case 1:{
                         int nCode = hb_itemGetNInt(pARG111);
                         if(nCode>=1 && nCode<=12){
                             const char * pszTime = XU_ANO[nCode];
                             hb_arraySetC( pCols, j, (const char * )pszTime );
                         }else{
                             hb_arraySetC( pCols, j, (const char * )"***" );
                         }
                         break;
                      }
                   } 
                   hb_itemRelease(pARG111);
                }
                hb_arraySet( pRows, i, pCols );
                hb_itemRelease(pARG11);
                hb_itemRelease(pCols);
             }
             hb_arraySet(pSTK_ADDR, CADDR, pRows);
             hb_itemRelease(pRows);
             break;
         }case 3:{
             PHB_ITEM pRows = hb_itemArrayNew( d1 );
             long i;
             for( i=1; i<=d1; i++){
                PHB_ITEM pARG11 = hb_itemArrayGet( pDATETIME, i);
                PHB_ITEM pCols = hb_itemArrayNew( d2 );
                long j;
                for( j=1; j<=d2; j++){
                   PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, j);
                   PHB_ITEM pPag = hb_itemArrayNew( d3 );
                   long k;
                   for( k=1; k<=d3; k++){
                      PHB_ITEM pARG1111 = hb_itemArrayGet( pARG111, k);
                      switch(tCompare){
                         case 0:{
                            int nCode = hb_itemGetNInt(pARG1111);
                            if(nCode>=1 && nCode<=7){
                                const char * pszTime = XU_SEMANA[nCode];
                                hb_arraySetC( pPag, k, (const char * )pszTime );
                            }else{
                                hb_arraySetC( pPag, k, (const char * )"***" );
                            }
                            break;
                         }case 1:{
                            int nCode = hb_itemGetNInt(pARG1111);
                            if(nCode>=1 && nCode<=12){
                                const char * pszTime = XU_ANO[nCode];
                                hb_arraySetC( pPag, k, (const char * )pszTime );
                            }else{
                                hb_arraySetC( pPag, k, (const char * )"***" );
                            }
                            break;
                         }
                      }
                      hb_itemRelease(pARG1111);
                   }
                   hb_arraySet( pCols, j, pPag );
                   hb_itemRelease(pARG111);
                   hb_itemRelease(pPag);
                }
                hb_arraySet( pRows, i, pCols );
                hb_itemRelease(pARG11);
                hb_itemRelease(pCols);
             }
             hb_arraySet(pSTK_ADDR, CADDR, pRows);
             hb_itemRelease(pRows);
             break;
         }
      }

}

int fun_dayname(){
int sw=1;
if(CADDR){
   int tCompare=0;
   PHB_ITEM pDATETIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(!HB_IS_ARRAY(pDATETIME)){
       int nCode = hb_itemGetNInt(pDATETIME);
       if(nCode>=1 && nCode<=7){
           const char * pszTime = XU_SEMANA[nCode];
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
       }else{
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )"***" );
       }
   }else{  // array de enteros.
       ++CADDR;
       fun_put_names( (PHB_ITEM) pDATETIME, (int) tCompare );
   }
   hb_itemRelease(pDATETIME);
}else{
   sw=put_error((PHB_ITEM) pRET, "DAYNAME INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_monthname(){
int sw=1;
if(CADDR){
   int tCompare=1;
   PHB_ITEM pDATETIME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(!HB_IS_ARRAY(pDATETIME)){
       int nCode = hb_itemGetNInt(pDATETIME);
       if(nCode>=1 && nCode<=12){
           const char * pszTime = XU_ANO[nCode];
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
       }else{
           hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )"***" );
       }
   }else{
       ++CADDR;
       fun_put_names( (PHB_ITEM) pDATETIME, (int) tCompare );
   }
   hb_itemRelease(pDATETIME);
}else{
   sw=put_error((PHB_ITEM) pRET, "MONTHNAME INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_datenow( /*int nItem */){
int sw=1;
if( CADDR<nSizeStack ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int nCode = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   
   int iYear, iMonth, iDay, iHour, iMinute, iSeconds, iMillisec;
   hb_timeStampGetLocal( &iYear, &iMonth, &iDay,
                         &iHour, &iMinute, &iSeconds, &iMillisec );

   switch(nCode){
      case 0: case 1:{   // fecha y hora completa, codificada como dd/mm/aaaa,hh:mm:ss.mss
         char pszTime[ nCode ? 37 : 25];
         
         if( nCode )   //1 = natural
            hb_snprintf( pszTime, 37, "%02d de %s de %4d,%02d:%02d:%02d:%02d", iDay,XU_ANO[iMonth], iYear, iHour, 
                                                                               iMinute, iSeconds, iMillisec/10 );
         else          // formato ///
            hb_snprintf( pszTime, 25, "%02d/%02d/%4d,%02d:%02d:%02d:%02d", iDay,iMonth,iYear, iHour,iMinute,iSeconds, iMillisec/10 );
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
         break;
      }case 2:{  //  fecha string
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
         break;
      }case 3:{  //  hora string
         char pszTime[ 13 ];
         hb_snprintf( pszTime, 13, "%02d:%02d:%02d:%02d", iHour, iMinute, iSeconds, iMillisec/10 );
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char * )pszTime );
         break;
      }case 4: case 5:{   // fecha en stack, hora en stack, formato numero
         if( nCode==4 ){
            if( CADDR<=nSizeStack-3 ){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iYear);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iMonth);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iDay);
            }else{
               sw=put_error((PHB_ITEM) pRET, "DATENOW INNER-STACK OVERFLOW",101);
            }
         }else{
            if( CADDR<=nSizeStack-4 ){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)iMillisec/10);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iSeconds);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iMinute);
               hb_arraySetNI( pSTK_ADDR, ++CADDR, iHour);
            }else{
               sw=put_error((PHB_ITEM) pRET, "DATENOW INNER-STACK OVERFLOW",101);
            }
         }
         break;
      }case 6:case 7: case 8: case 9:case 10: case 11:{   //año, mes, dia, hora, minuto, segundos
         switch( nCode ){
            case 6: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iYear); break;}
            case 7: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iMonth); break;}
            case 8: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iDay); break;}
            case 9: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iHour); break;}
            case 10: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iMinute); break;}
            case 11: {hb_arraySetNI( pSTK_ADDR, ++CADDR, iSeconds); break;}
         }
         break;
      }case 12:{  // dia de la semana en palabras
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         if( nDow > 0){
            const char * semana = XU_SEMANA[ nDow ];
            hb_arraySetC( pSTK_ADDR, ++CADDR, semana);
         }else{
            hb_arraySetC( pSTK_ADDR, ++CADDR, cDate );
         }
         break;
      }case 13:{   // mes en palabras
         const char * mes = XU_ANO[ iMonth ];
         hb_arraySetC( pSTK_ADDR, ++CADDR, mes);
         break;
      }case 14:{    // es año bisiesto?
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) hb_isleapyear( iYear ) );
         break;
      }case 15:{    // días en el mes
         int bLeap = hb_isleapyear( iYear );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, ct_daysinmonth( iMonth, bLeap ) );
         break;
      }case 16:{   // dia de la semana en indice.
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int nDow = hb_dateJulianDOW( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, nDow );
         break;
      }case 17:{   // semana del año
         long lDate2;
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         long lDate = hb_dateUnformat( cDate, hb_setGetDateFormat() );
         if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
             lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
         else
             lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
         break;
      }case 18:{   // día del año
         char pszTime[ 11 ];
         hb_snprintf( pszTime, 11, "%02d/%02d/%4d", iDay, iMonth, iYear);
         const char *cDate = pszTime;
         int ndiadelYear = ct_doy( hb_dateUnformat( cDate, hb_setGetDateFormat() ) );
         hb_arraySetNI( pSTK_ADDR, ++CADDR, ndiadelYear );
         break;
      }case 19:{  // hora valida?
         char pszTime[ 12 ];
         hb_snprintf( pszTime, 12, "%02d:%02d:%02d:%02d", iHour, iMinute, iSeconds, iMillisec/10 );
         const char *cDate = pszTime;
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) _hb_timeValid( cDate, 11, NULL ));
         break;
      }default: sw=put_error((PHB_ITEM) pRET, "DATENOW ARGUMENT ERROR",103); break;
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "DATENOW INNER-STACK OVERFLOW",101);
}
return sw;
}


/**************************************************
     FUNCIONES DE MANEJO DE BITS, CONVERSION
     DE BASE
 ************************************************/

/**************************************************************************************/ 
/*
 * CT3 Number and bit manipulation functions:
 *       NumAnd(), NumOr(), NumXor(), NUMNOT()
 *       ClearBit(), SetBit()
 *
 * Copyright 2007 Przemyslaw Czerpak <druzus / at / priv.onet.pl>
 * Adapted by Daniel Stuardo by Hooper 2020.
 */

int bintodec(PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nLen = hb_itemGetCLen( pSource );
   const char * bin = hb_itemGetCPtr( pSource );
   hb_itemRelease(pSource);

   HB_MAXINT decimal;
   int i = 0;

    decimal = 0;
    nLen--;

    while(nLen>=0) //for(i=nLen; i>=0/*bin[i]!='\0'*/; i--)
    {
        if(bin[nLen] == '0' || bin[nLen] == '1')
           decimal += pow(2, i) * ( bin[nLen] - 48 );
        else
        {
            decimal=0;
            sw=put_error((PHB_ITEM) pRET, "BINTODEC - ARGUMENT ERROR",103);
            break;
        }
        nLen--; i++;
    }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_LONGLONG) decimal ); 
   return sw;

}
int octtodec(PHB_ITEM pSTK_ADDR ){
int sw=1;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   HB_MAXINT octal = hb_itemGetNL( pSource );
   hb_itemRelease(pSource);
   
   HB_MAXINT decimal=0;
   int i=0;
   while (octal != 0){

        decimal =  decimal +(octal % 10)* pow(8, i++);

        octal = octal / 10;

   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_LONGLONG) decimal );
   
return sw;
}

int hextodec( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   long nLen = hb_itemGetCLen( pSource );
   const char * hex = hb_itemGetCPtr( pSource );
   hb_itemRelease(pSource);

   HB_MAXINT decimal;
    int i = 0, val;

    decimal = 0;
    nLen--;

    for(i=0; hex[i]!='\0'; i++)
    {
        /* Find the decimal representation of hex[i] */
        if(hex[i]>='0' && hex[i]<='9')
        {
            val = hex[i] - 48;
        }
        else if(hex[i]>='a' && hex[i]<='f')
        {
            val = hex[i] - 97 + 10;
        }
        else if(hex[i]>='A' && hex[i]<='F')
        {
            val = hex[i] - 65 + 10;
        }
        else
        {
            decimal=0;
            sw=put_error((PHB_ITEM) pRET, "HEXTODEC - ARGUMENT ERROR",103);
            break;
        }

        decimal += val * pow(16, nLen);
        nLen--;
    }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, (HB_LONGLONG) decimal ); 
   return sw;
}

int ConvertParam( PHB_ITEM Param, HB_MAXINT * plNum )
{

   const char * szHex=NULL;// = hb_parc( iParam );
   if( HB_IS_STRING( Param )){
      szHex = hb_itemGetCPtr( Param );
   }
   if( szHex ){
      *plNum = 0;
      while( *szHex == ' ' )
         szHex++;
      while( *szHex ){
         char c = *szHex++;

         if( c >= '0' && c <= '9' )
            c -= '0';
         else if( c >= 'A' && c <= 'F' )
            c -= 'A' - 10;
         else if( c >= 'a' && c <= 'f' )
            c -= 'a' - 10;
         else
            break;
         *plNum = ( *plNum << 4 ) | c;
      }
      return 1;
   }else if( HB_IS_NUMERIC( Param ) ){
      *plNum = hb_itemGetNL( Param );//hb_parnint( iParam );
      return 1;
   }

   *plNum = -1;
   return 0;
}

int fun_andbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
// lValue es el número sobre el cual se aplicará AND
HB_MAXINT lValue = -1, lNext = 0;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
//   printf("\nLVALUE = %ld",lValue);
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;

      if( ConvertParam( pSource, &lNext ) ){
         lValue &= lNext;
  //       printf("\n\tlNEXT = %ld ==> LVALUE = %ld",lNext,lValue);
      }else{
         sw=put_error((PHB_ITEM) pRET, "ANDBIT - OPERAND ARGUMENT ERROR",103);
         hb_itemRelease(pSource);
         break;
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
  // printf("\nLVALUE = %ld",lValue);
}else{
   sw=put_error((PHB_ITEM) pRET, "ANDBIT - FIRST ARGUMENT ERROR",103);
   hb_itemRelease(pSource);
}
return sw;
}

int fun_orbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
// lValue es el número sobre el cual se aplicará AND
HB_MAXINT lValue = -1, lNext = 0;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;

      if( ConvertParam( pSource, &lNext ) ){
         lValue |= lNext;
      }else{
         sw=put_error((PHB_ITEM) pRET, "ORBIT - OPERAND ARGUMENT ERROR",103);
         hb_itemRelease(pSource);
         break;
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}else{
   sw=put_error((PHB_ITEM) pRET, "ORBIT - FIRST ARGUMENT ERROR",103);
   hb_itemRelease(pSource);
}
return sw;
}

int fun_xorbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
// lValue es el número sobre el cual se aplicará AND
HB_MAXINT lValue = -1, lNext = 0;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;

      if( ConvertParam( pSource, &lNext ) ){
         lValue ^= lNext;
      }else{
         sw=put_error((PHB_ITEM) pRET, "XORBIT - OPERAND ARGUMENT ERROR",103);
         hb_itemRelease(pSource);
         break;
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}else{
   sw=put_error((PHB_ITEM) pRET, "XORBIT - FIRST ARGUMENT ERROR",103);
   hb_itemRelease(pSource);
}
return sw;
}

int fun_notbits( PHB_ITEM pSTK_ADDR ){
int sw=1;
   HB_MAXINT lValue;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( ConvertParam( pSource, &lValue ) )
      lValue = ( ~lValue ) & 0xffffffff;//ffffffff;
   hb_itemRelease(pSource);
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
return sw;
}

int fun_clearbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;

HB_MAXINT lValue = 0, iBit;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      
      if( ConvertParam( pSource, &iBit ) ){
         if( iBit < 1 || iBit > 64 ){
            sw=put_error((PHB_ITEM) pRET, "CLEARBIT - OPERAND ARGUMENT ERROR",103);
            break;
         }
         lValue &= ~( ( ( HB_MAXINT ) 1 ) << ( iBit - 1 ) );
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}
return sw;
}

int fun_setbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;

HB_MAXINT lValue = 0, iBit;
PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

if( ConvertParam( pSource, &lValue ) ){
   hb_itemRelease(pSource);
   while( CADDR ){
      PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &iBit ) ){
         if( iBit < 1 || iBit > 64 ){
            sw=put_error((PHB_ITEM) pRET, "SETBIT - OPERAND ARGUMENT ERROR",103);
            break;
         }
         lValue |= ( ( HB_MAXINT ) 1 ) << ( iBit - 1 );
      }
      hb_itemRelease(pSource);
   }
   hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
}
return sw;
}
int fun_isbit( PHB_ITEM pSTK_ADDR, int iBit  ){
int sw=1;
   HB_MAXINT lValue;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if( ConvertParam( pSource, &lValue ) )
   {
      if( iBit )
         --iBit;
      lValue &= ( ( HB_MAXINT ) 1 ) << iBit;
   }
   else
      lValue = 0;
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)(lValue != 0) );
   hb_itemRelease(pSource);

return sw;
}

int fun_mirrorbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   HB_MAXINT lValue;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   
   if(CADDR){
      PHB_ITEM pTipo = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &lValue ) && lValue == ( lValue & 0xffff ) )
      {
         HB_USHORT usBits = hb_itemGetNI( pTipo )==0 ? 8 : 16;
         HB_USHORT usResult = ( HB_USHORT ) ( lValue >> usBits );

         do
         {
            usResult <<= 1;
            if( lValue & 1 )
               usResult |= 1;
            lValue >>= 1;
         }
         while( --usBits );

         lValue = usResult;
      }
      else{
         lValue = 0;
         sw=put_error((PHB_ITEM) pRET, "MIRROR BIT ARGUMENT ERROR",103); 
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
      hb_itemRelease(pTipo);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MIRROR BIT INNER-STACK OVERFLOW",101); 
   }
   
   hb_itemRelease(pSource);
return sw;
}

int fun_rotabits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET ){
int sw=1;
   HB_MAXINT lValue, lShift;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

   if(CADDR){
      PHB_ITEM pBit = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if( ConvertParam( pSource, &lValue ) && lValue == ( lValue & 0xffff ) && ConvertParam( pBit, &lShift )
          && lShift == ( lShift & 0xffff ) )
      {
         if(CADDR){
            PHB_ITEM pTypeRot = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
            CADDR += SWKEEP; SWKEEP = 0;
            if( hb_itemGetNI( pTypeRot ) == 0 )
            {
               HB_USHORT us = ( HB_USHORT ) ( ( lValue & 0xff ) << ( lShift & 0x07 ) );

               lValue = ( lValue & 0xff00 ) | ( us & 0xff ) | ( us >> 8 );
            }
            else
            {
               lValue <<= ( lShift & 0x0f );
               lValue = ( lValue & 0xffff ) | ( lValue >> 16 );
            }
            hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
            hb_itemRelease(pTypeRot);
         }else{
            lValue = 0;
            sw=put_error((PHB_ITEM) pRET, "ROTATION BIT -ROT TYPE ARGUMENT ERROR",103); 
         }
      }
      else{
         lValue = 0;
         sw=put_error((PHB_ITEM) pRET, "ROTATION BIT - ARGUMENT ERROR",103); 
      }
      hb_itemRelease(pBit);
   }else{
      sw=put_error((PHB_ITEM) pRET, "ROTATION BIT INNER-STACK OVERFLOW",101); 
   }
   
   hb_itemRelease(pSource);
return sw;
}

int fun_shfrbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;
   HB_MAXINT lValue, lBits;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if(CADDR){
      PHB_ITEM pBits = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &lValue ) && ConvertParam( pBits, &lBits ) )
      {
         lValue = lValue >> lBits;
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
      hb_itemRelease(pBits);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SHIFTR BIT INNER-STACK OVERFLOW",101); 
   }
   hb_itemRelease(pSource);
return sw;
}

int fun_shflbits( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET  ){
int sw=1;
   HB_MAXINT lValue, lBits;
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   if(CADDR){
      PHB_ITEM pBits = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      if( ConvertParam( pSource, &lValue ) && ConvertParam( pBits, &lBits ) )
      {
         lValue = lValue << lBits;
      }
      hb_arraySetNL( pSTK_ADDR, ++CADDR, lValue );
      hb_itemRelease(pBits);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SHIFTL BIT INNER-STACK OVERFLOW",101); 
   }
   hb_itemRelease(pSource);
return sw;
}

int fun_bit_counter(/*int nItem*/ ){
int sw=1;
// al menos deben hacer 2 elementos en el stack
if(CADDR>=1){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
   int nCode = hb_itemGetNI(pCODE);
   hb_itemRelease(pCODE);
   switch( nCode ){
         case 100: sw=(int)fun_andbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 101: sw=(int)fun_orbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 102: sw=(int)fun_xorbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 103: sw=(int)fun_notbits( (PHB_ITEM) pSTK_ADDR ); break;
         case 104: sw=(int)fun_clearbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 105: sw=(int)fun_setbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 106: sw=(int)fun_mirrorbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 107: sw=(int)fun_rotabits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET  ); break;
         case 108: sw=(int)fun_shfrbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 109: sw=(int)fun_shflbits( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 110: sw=(int)hextodec( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         case 111: sw=(int)octtodec( (PHB_ITEM) pSTK_ADDR ); break;
         case 112: sw=(int)bintodec( (PHB_ITEM) pSTK_ADDR, (PHB_ITEM) pRET ); break;
         default: {
            if( nCode>=1 && nCode<=64 )
               sw=(int)fun_isbit( (PHB_ITEM) pSTK_ADDR, (int)nCode );
            else
               sw=put_error((PHB_ITEM) pRET, "BIT FUNCTION ARGUMENT ERROR",103); 
            break;
         }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "BIT FUNCTION INNER-STACK OVERFLOW",101);
}
return sw;
}

/* JOINSTR: unir elementos del stack en un string */
int fun_jointostr(/* int nItem */){
int sw=1;
char * cJoin = (char *)calloc( 4096, 1 );
int Index = 1;
long nLen=0,tLen=strlen(TOKENIZER);
int tCompare = nPCP == 256 ? 1 : 0;
if(CADDR){
while(CADDR){
   PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, Index );
   if( HB_IS_STRING( pSource ) ){
       const char * pString = hb_itemGetCPtr( pSource );
       long nText = hb_itemGetCLen( pSource );
       strcat( cJoin, pString );
       nLen+=nText;
   }else if ( HB_IS_INTEGER ( pSource ) ){
       int pNum = hb_itemGetNI( pSource );
       char * buf = (char *)calloc(32,1);
       int size = sprintf(buf,"%d", pNum);
       const char * pString = buf;
       strncat( cJoin, pString, size );
       free(buf);
       nLen+=size;
   }else if( HB_IS_NUMERIC( pSource ) ) {
       double pDbl = hb_itemGetND( pSource );
       char * buf = (char *)calloc(64,1);
       int size;
       if( SW_PRECISION )
          size = sprintf(buf,"%.*lf", PRECISION, pDbl);
       else
          size = sprintf(buf,"%g", pDbl);
       
       //int size = sprintf(buf,"%f", pDbl);
       const char * pString = buf;
       strncat( cJoin, pString, size );
       free(buf);
       nLen+=size;
   }else if( HB_IS_LONG( pSource ) ) {
       long pLong = hb_itemGetNL( pSource );
       char * buf = (char *)calloc(64,1);
       int size = sprintf(buf,"%ld", pLong);
       const char * pString = buf;
       strncat( cJoin, pString, size );
       free(buf);
       nLen+=size;
 /*  }else if( HB_IS_LOGICAL( pSource ) ){
       HB_BOOL pBool = hb_itemGetL( pSource );
       if (pBool) strcat( cJoin, "1" );
       else strcat( cJoin, "0" );
       nLen++;*/
   }else{
       sw=put_error((PHB_ITEM) pRET, "JOIN ARRAY DETECTED - ARGUMENT ERROR",103);
   }
   if(CADDR>1)
      strcat( cJoin, TOKENIZER ); nLen+=tLen;
      
   hb_itemRelease(pSource);
   ++Index;
   --CADDR;
}

CADDR += SWKEEP; SWKEEP = 0;

cJoin[ nLen ] = '\0';
const char * cBuffer = cJoin;
if (tCompare){
   int nItem = STK_PRG[++CP];
   hb_arraySetC( pSTK_REG, nItem, (const char*) cBuffer );
}else{
//   PHB_ITEM pBuff = hb_itemPutC( NULL, (const char*) cBuffer );
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) cBuffer );
//   hb_arraySetC( pSTK_ADDR, ++CADDR, (PHB_ITEM) pBuff );
//   hb_itemRelease(pBuff);
}

free(cJoin);
}else{
   sw=put_error((PHB_ITEM) pRET, "JOIN INNER-STACK OVERFLOW",101);
}
return sw;
}

/* CALENDAR */
#define ISO_CAL 0

int days[12]    = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static char *month[12] = {"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
                   "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"};

static char *amonth[12] = {"ENE", "FEB", "MAR", "ABR", "MAY", "JUN",
                   "JUL", "AGO", "SEP", "OCT", "NOV", "DIC"};
                   
static char *daynames[8] = {"Dom", "Lun", "Mar", "Mie", "Jue", "Vie", "Sab", "Dom"};

const char *line = "";

int isleap (unsigned yr)
{
   return yr % 400 == 0 || (yr % 4 == 0 && yr % 100 != 0);
}

static unsigned months_to_days (unsigned month)
{
   return (month * 3057 - 3007) / 100;
}

static long years_to_days (unsigned yr)
{
   return yr * 365L + yr / 4 - yr / 100 + yr / 400;
}

long ymd_to_scalar (unsigned yr, unsigned mo, unsigned day)
{
   long scalar;
   scalar = day + months_to_days(mo);
   if ( mo > 2 )                         /* adjust if past February */
      scalar -= isleap(yr) ? 1 : 2;
   yr--;
   scalar += years_to_days(yr);
   return scalar;
}

/*void pone_tabs( int nTab){
int i;
for(i=1; i<=nTab; i++)
   printf("\t");
}*/

int fun_calendar(/*int nItem*/ ){
int sw=1;

int nItem = STK_PRG[++CP];
PHB_ITEM pCODE = hb_itemArrayGet( pSTK_REG, nItem);  // codigo de funcion
int nCode = hb_itemGetNI(pCODE);
hb_itemRelease(pCODE);

   
   int day, day_1, numdays, i, j;
 //  int desde=1,hasta=3;

   int yr, mo;
   
 /*
   int xml=0;
   if( (int)(nCode-1000) >= 0 ){  // pide resultado en XML
      xml=1;
      nCode = (int)(nCode-1000);
   }*/

   if( nCode == 0 ){  // today! no pide nada a stack    calendar(TODAY)
      int iDay, iHour, iMinute, iSeconds, iMillisec;  // no usado.
      hb_timeStampGetLocal( &yr, &mo, &iDay,
                            &iHour, &iMinute, &iSeconds, &iMillisec );
      
   }else if( nCode >0 && nCode <=99 ){   // +/- meses antes y después de fecha indicada en stack. calendar(BETWEEN+n)
      if(CADDR>=2){
         PHB_ITEM pYear = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pMonth = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         yr = hb_itemGetNI( pYear );
         mo = hb_itemGetNI( pMonth );
         hb_itemRelease(pYear);
         hb_itemRelease(pMonth);
         for (i = nCode; i > 0; --i){  // ajusto el mes de inicio, aplicando time machine.
            --mo;
            if (!mo){
                  mo = 12;
                  --yr;
            }
         }
         
         nCode *= 2 ;  // duplica los meses, para incluir el segundo bloque después de la fecha indicada.
         if( fmod(nCode,2) == 0) ++nCode;
      }else{
         sw=put_error((PHB_ITEM) pRET, "CALENDAR INNER-STACK OVERFLOW",101);
         return sw;
      }
   }else if( nCode>=100 && nCode<200){   // añade meses a la fecha del stack.  calendar(ADDMONTH+n)
      nCode = (int)(nCode-100);   // ajuste para los meses a incluir después de la fecha.
      if(CADDR>=2){
         PHB_ITEM pYear = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         PHB_ITEM pMonth = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
         yr = hb_itemGetNI( pYear );
         mo = hb_itemGetNI( pMonth );
         hb_itemRelease(pYear);
         hb_itemRelease(pMonth);
      }else{
         sw=put_error((PHB_ITEM) pRET, "CALENDAR INNER-STACK OVERFLOW",101);
         return sw;
      }
      
   }else{   // meses después de la fecha indicada en stack
      sw=put_error((PHB_ITEM) pRET, "CALENDAR CONSTANT ARGUMENT ERROR",103);
      return sw;
   }

   // 
   // Quiere solo despliegue (0 o nada) o array (1)?
   int print=0;
   if(CADDR){
      PHB_ITEM pItem = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      if(HB_IS_NUMERIC( pItem )){  // asume columnas
         print = hb_itemGetNI( pItem );  // asume 4 tabs por columna
         print = print != 0 ? 1 : 0;   // ajusta seleccion
      }
      hb_itemRelease(pItem);
   }
   
   CADDR += SWKEEP; SWKEEP = 0;
   
      if (!mo || 12 < mo){
         sw=put_error((PHB_ITEM) pRET, "CALENDAR MONTH ARGUMENT ERROR",103);
         return sw;
      }

      if (100 > yr)
            yr += 1900;

      if (3000 < yr || 1800 > yr){
         sw=put_error((PHB_ITEM) pRET, "CALENDAR YEAR:]1800-3000[ ARGUMENT ERROR",103);
         return sw;
      }

      if(nCode==0) nCode=1;
      
      
      PHB_ITEM pRows = hb_itemArrayNew( nCode * 8 );   // n-meses
      int nPos = 1;
      //_____________________
      for( i = 0;i<nCode*8; i++){
         PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
         hb_arraySetC( pCols, 1, (const char*) "   " );
         hb_arraySetC( pCols, 2, (const char*) "   " );
         hb_arraySetC( pCols, 3, (const char*) "   " );
         hb_arraySetC( pCols, 4, (const char*) "   " );
         hb_arraySetC( pCols, 5, (const char*) "   " );
         hb_arraySetC( pCols, 6, (const char*) "   " );
         hb_arraySetC( pCols, 7, (const char*) "   " );
         hb_arraySet(pRows,nPos++, pCols);
         hb_itemRelease(pCols);
      }
      //_____________________
      nPos = 1;

      for(i = 0; i < nCode; i++, mo++){
            /*if (!mo){
                  mo = 12;
                  --yr;
            }*/
            
            if(hb_inkey(0,0,128)==3){
               sw=put_error((PHB_ITEM) pRET, "BREAK EXECUTION BY USER (CTRL-C)",200);
               break;
            }
        
            if (12 < mo){
                  mo = 1;
                  ++yr;
            }
            numdays = days[mo - 1];
            if (2 == mo && isleap(yr))
                  ++numdays;
            day_1 = (int)((ymd_to_scalar(yr, mo, 1) - (long)ISO_CAL) % 7L);
            
            if(!print)
               printf("%s, %d\n", month[mo - 1], yr);
            else{
               PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
               hb_arraySetC( pCols, 1, (const char*) amonth[mo - 1] );
               hb_arraySetC( pCols, 2, (const char*) "   " );
               hb_arraySetC( pCols, 3, (const char*) "   " );
               hb_arraySetC( pCols, 4, (const char*) "   " );
               hb_arraySetC( pCols, 5, (const char*) "   " );
               hb_arraySetC( pCols, 6, (const char*) "   " );
               char *cAnio = (char *)calloc(11,1);
               sprintf(cAnio,"%4d",yr);
               hb_arraySetC( pCols, 7, (const char*) cAnio );
               free(cAnio);
               hb_arraySet(pRows,nPos++, pCols);
               hb_itemRelease(pCols);
            }
            
            if(!print){
               for (j = 0; j < 7; ){
                  fputs(daynames[ISO_CAL + j], stdout);
                  if (7 != ++j)
                     fputc(' ', stdout);
               }
            }else{
               PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
               int nCol=1;
               for (j = 0; j < 7; ++j){
                  hb_arraySetC( pCols, nCol++, (const char*) daynames[ISO_CAL + j] );
               }
               hb_arraySet(pRows,nPos++, pCols);
               hb_itemRelease(pCols);
            }
            if(!print) printf("\n");
            
            if(!print){
               for (day = 0; day < day_1; ++day)
                  fputs("    ", stdout);
               for (day = 1; day <= numdays; ++day, ++day_1, day_1 %= 7){
                  if (!day_1 && 1 != day)
                     printf("\n");
                  printf("%3d ", day);
               }
               for ( ; day_1; ++day_1, day_1 %= 7)
                  fputs("    ", stdout);
               fputc('\n', stdout);

            }else{
               PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
                  hb_arraySetC( pCols, 1, (const char*) "   " );
                  hb_arraySetC( pCols, 2, (const char*) "   " );
                  hb_arraySetC( pCols, 3, (const char*) "   " );
                  hb_arraySetC( pCols, 4, (const char*) "   " );
                  hb_arraySetC( pCols, 5, (const char*) "   " );
                  hb_arraySetC( pCols, 6, (const char*) "   " );
                  hb_arraySetC( pCols, 7, (const char*) "   " );

               int nCol=1;
               
               int nday=1;
               for (day = 0; /*day < 7*/; ++day){
                  if(day < day_1)
                     hb_arraySetC( pCols, nCol++, (const char*) "   " );
                  else{
                     char *cDia = (char *)calloc(11,1);
                     sprintf(cDia,"%3d",nday);
                     hb_arraySetC( pCols, nCol++, (const char*) cDia );
                     free(cDia);
                     nday++;
                     ++day_1; day_1 %= 7;
                     if(!day_1 && 1 != day) break;
                  }
               }
               hb_arraySet(pRows,nPos++, pCols);
               hb_itemRelease(pCols);
               
               //day = nday;
               int iniDay = nday;
               //day = 1;
               ++day_1;
              //________________________ 
             /* if ( day > numdays ){
                 PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
                  hb_arraySetC( pCols, 1, (const char*) "   " );
                  hb_arraySetC( pCols, 2, (const char*) "   " );
                  hb_arraySetC( pCols, 3, (const char*) "   " );
                  hb_arraySetC( pCols, 4, (const char*) "   " );
                  hb_arraySetC( pCols, 5, (const char*) "   " );
                  hb_arraySetC( pCols, 6, (const char*) "   " );
                  hb_arraySetC( pCols, 7, (const char*) "   " );
                  hb_arraySet(pRows,nPos++, pCols);
                  hb_itemRelease(pCols);
              }*/
              //________________________
               while (day <= numdays){
                  
                  if(hb_inkey(0,0,128)==3){
                     sw=put_error((PHB_ITEM) pRET, "CALENDAR BREAK EXECUTION BY USER (CTRL-C)",200);
                     return sw;
                  }
                //  printf("INIDAY = %d; DAY = %d\n",iniDay,day);
                  PHB_ITEM pCols = hb_itemArrayNew( 7 );  // 7 días de la semana
                  hb_arraySetC( pCols, 1, (const char*) "   " );
                  hb_arraySetC( pCols, 2, (const char*) "   " );
                  hb_arraySetC( pCols, 3, (const char*) "   " );
                  hb_arraySetC( pCols, 4, (const char*) "   " );
                  hb_arraySetC( pCols, 5, (const char*) "   " );
                  hb_arraySetC( pCols, 6, (const char*) "   " );
                  hb_arraySetC( pCols, 7, (const char*) "   " );
                  int nCol=1;

                  for (day = iniDay; day <= numdays; ++day, ++day_1, day_1 %= 7){
                     if (!day_1 && 1 != day){
                        char *cTerminal = (char *)calloc(11,1);

                        sprintf(cTerminal,"%3d",day);
                        hb_arraySetC( pCols, nCol++, (const char*) cTerminal );
                        free(cTerminal);
                        ++day;
                        iniDay=day;
                        
                        ++day_1;
                        day_1 %= 7;
                        break;
                     }
                     char *cDiaI = (char *)calloc(11,1);
                     sprintf(cDiaI,"%3d",day);
                     hb_arraySetC( pCols, nCol++, (const char*) cDiaI );
                     free(cDiaI);
                  }
                  hb_arraySet(pRows,nPos++, pCols);
                  hb_itemRelease(pCols);
               }
              /* PHB_ITEM pColsf = hb_itemArrayNew( 7 );  // 7 días de la semana
               nCol = 1;
               if(!day_1) day_1=1;
               for ( ; day_1; ++day_1, day_1 %= 7)
                  hb_arraySetC( pColsf, nCol++, (const char*) "   " );
                  
               hb_arraySet(pRows,nPos++, pColsf);
               hb_itemRelease(pColsf);
              */
            }
            if( fmod(nPos,8)==0 ) ++nPos;
      }
      if(print)
         hb_arraySet( pSTK_ADDR, ++CADDR, pRows );
      
      hb_itemRelease(pRows);
return sw;
}

int fun_reverse_string( /*int nItem */){
int sw=1;
if(CADDR<nSizeStack){
   long nItem = STK_PRG[++CP];
   PHB_ITEM pSTRING = hb_itemArrayGet(pSTK_REG,nItem);
   const char* cString = hb_itemGetCPtr(pSTRING);
   long nLen = hb_itemGetCLen(pSTRING);
   char *str = (char*)calloc( nLen+1,1);
   
   memcpy(str, cString, nLen);
   
      char *p1, *p2;

      if (! str || ! *str){
         hb_arraySetC( pSTK_ADDR, ++CADDR, cString );
      }else{
         for (p1 = str, p2 = str + strlen(str) - 1; p2 > p1; ++p1, --p2)
         {
            *p1 ^= *p2;
            *p2 ^= *p1;
            *p1 ^= *p2;
         }
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) str );
      }
   hb_itemRelease(pSTRING);
   free(str);
}else{
   sw=put_error((PHB_ITEM) pRET, "REVERSE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_grep(/*int nItem*/){
int sw=1;
int nItem = STK_PRG[++CP];

if(CADDR>=2){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pTEXT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

   CADDR += SWKEEP; SWKEEP = 0;

   const char * cFile = hb_itemGetCPtr(pFILE);
   const char * cSearch = hb_itemGetCPtr(pTEXT);
   long nLenFile = hb_itemGetCLen(pFILE);
   long nLenSear = hb_itemGetCLen(pTEXT);

   hb_itemRelease(pFILE);
   hb_itemRelease(pTEXT);

  // generar nombre de archivo temporal:
   srand(time(NULL));
   long numrand = 10000 + rand() % (100000001 - 10000);
   char tmpFile[100];
   int ltmpf = sprintf(tmpFile," > /tmp/tmpmSeaMurrfile%ld.tmp",numrand);
   tmpFile[ltmpf]='\0';
      
   char * cLine = (char *) calloc(nLenFile + nLenSear + 100, 1);
   memcpy(cLine, "grep -h -n -b ",14);
/*   if(strstr(cSearch,"-E")==NULL){
      memset(cLine + 14, '"', 1 );
      memcpy(cLine + 15, cSearch, nLenSear);
      memset(cLine + 15 + nLenSear, '"', 1 );
      memset(cLine + 16 + nLenSear, ' ', 1 );
      memcpy(cLine + 17 + nLenSear, cFile, nLenFile);
   }else{   // tiene expresiones regulares
   */
      memcpy(cLine + 14, cSearch, nLenSear);
      memset(cLine + 14 + nLenSear, ' ', 1 );
      memcpy(cLine + 15 + nLenSear, cFile, nLenFile);
 //  }
    memcpy(cLine + 15 + nLenSear + nLenFile, tmpFile, ltmpf); 
   //memcpy(cLine + 17 + nLenSear + nLenFile, " > /tmp/tmpmSeaMurrfile000000000000.tmp", 39); 
   //memcpy(cLine + 17 + nLenSear + nLenFile, tmpFile, ltmpf); 


  // printf("\nLINEA: %s\n",cLine);

   const char * t=cLine;
 //  printf("\nGREP: %s\n",t);

   int ret = system(t);
   if (WIFSIGNALED(ret) &&
      (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
      sw=put_error((PHB_ITEM) pRET, "SEARCH-SYSTEM CHILD TERMINATED",102);
   }

   free(cLine);
   
   if( sw ){
      FILE *fp;
   //   char ch;
      PHB_ITEM pCWM = hb_itemArrayNew( 0 ); // CWM

      ltmpf = sprintf(tmpFile,"/tmp/tmpmSeaMurrfile%ld.tmp",numrand);
      tmpFile[ltmpf]='\0';
      if( (fp=fopen(tmpFile,"r"))!=NULL ){
    ///  if( (fp=fopen("/tmp/tmpmSeaMurrfile000000000000.tmp","r"))!=NULL ){

         unsigned long linea=0,noffset=0;

         char ch;

         while ((ch = fgetc(fp)) != EOF){
            // busca numero de linea
            linea=0; noffset=0;
            while(ch!=':'){
               linea = (linea * 10) + (ch - '0');
               ch = fgetc(fp);    // avanzo un caracter.
            }
            ch = fgetc(fp);  // omite ':'
            // busca desplazamiento
            while(ch!=':'){
               noffset = (noffset * 10) + (ch - '0');
               ch = fgetc(fp);    // avanzo un caracter.
            }
            ch = fgetc(fp);  // omite ':'

            PHB_ITEM pC = hb_itemArrayNew( 2 );
            hb_arraySetNL( pC, 1, linea );
            hb_arraySetNL( pC, 2, noffset );
            hb_arrayAdd( pCWM, pC );
            hb_itemRelease(pC);
            // resto de línea hasta '\n'
            while(ch!='\n') ch = fgetc(fp);
         }

         fclose(fp);
        // rm file:
         int ltmpf = sprintf(tmpFile,"rm /tmp/tmpmSeaMurrfile%ld.tmp",numrand);
         tmpFile[ltmpf]='\0';
         int ret = system(tmpFile);
         if (WIFSIGNALED(ret) &&
            (WTERMSIG(ret) == SIGINT || WTERMSIG(ret) == SIGQUIT)){
            sw=put_error((PHB_ITEM) pRET, "SEARCH-SYSTEM CHILD TERMINATED",102);
         } 
         ///system("rm /tmp/tmpmSeaMurrfile000000000000.tmp");
      }else{
         sw=put_error((PHB_ITEM) pRET, "SEARCH TEMPFILE CREATION ERROR",107);
      }
      hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pCWM );
      hb_itemRelease(pCWM);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SEARCH INNER-STACK OVERFLOW",101);
}
return sw;
}

/* El siguiente código pertenece a:
 * Copyright 2001 IntTec GmbH, Neunlindenstr 32, 79106 Freiburg, Germany
 *        Author: Martin Vogel <vogel@inttec.de>
 */
/* defines */
#define DO_REPLACE_REPLALL      56 //0
#define DO_REPLACE_REPLLEFT     54 //1
#define DO_REPLACE_REPLRIGHT    55 //2

int fun_repl_lateral( /*int iSwitch*/ ){
int sw=1;
int iSwitch = nPCP;
if(CADDR>=3){
   PHB_ITEM pSTRING  = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pREPLACE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   PHB_ITEM pSEARCH   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );

   CADDR += SWKEEP; SWKEEP = 0;

   const char * pcString = hb_itemGetCPtr(pSTRING);
   const char * pcReplace = hb_itemGetCPtr(pREPLACE);
   const char * pcSearch = hb_itemGetCPtr(pSEARCH);

   HB_SIZE sStrLen = hb_itemGetCLen( pSTRING );
   hb_itemRelease(pSTRING);
   hb_itemRelease(pREPLACE);
   hb_itemRelease(pSEARCH);

   char *pcRet, *pc;
   char cSearch = *pcSearch, cReplace = *pcReplace;
   
   pcRet = ( char * ) calloc( sStrLen + 1, 1 );
   memcpy( pcRet, pcString, sStrLen );

   if( iSwitch != DO_REPLACE_REPLRIGHT )
   {
      pc = pcRet;
      while( *pc == cSearch && pc < pcRet + sStrLen )
      {
         *pc = cReplace;
         pc++;
      }
   }

   if( iSwitch != DO_REPLACE_REPLLEFT )
   {
      pc = pcRet + sStrLen - 1;
      while( *pc == cSearch && pc >= pcRet )
      {
         *pc = cReplace;
         pc--;
      }
   }
   const char* buffer = pcRet;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) buffer );
   free(pcRet);
   
}else{
   if( iSwitch == DO_REPLACE_REPLALL )
      sw=put_error((PHB_ITEM) pRET, "RALL INNER-STACK OVERFLOW",101);
   else if( iSwitch == DO_REPLACE_REPLLEFT )
      sw=put_error((PHB_ITEM) pRET, "RLEFT INNER-STACK OVERFLOW",101);
   else
      sw=put_error((PHB_ITEM) pRET, "RRIGHT INNER-STACK OVERFLOW",101);
}
return sw;
}

/*
  FUNCIONES DE SATURACION DE LINEAS, POR CAMPOS Y
  POR LARGO POSICIÓN.
*/
uint16_t ftokens(const char *linea, const char *buscar, uint16_t lb) {
   const char *t,*r; // son solo punteros apuntando a la cadena s.

   uint16_t n=0;
   //printf(" OBTUVE: [%s] [%s]\n",linea,buscar);
   r = linea;  // rescato primera posición
   t = strstr(r,buscar);
   while (t!=NULL) {
      r = t + lb;
      ++n;
      t = strstr(r,buscar);
   }
   if(strlen(linea)>0 && n==0) n=1;
   return n;
}

char* strpad( const char * cText, HB_MAXINT nLen, HB_MAXINT nSize, int tCompare ){

 //  const char * cText = hb_itemGetCPtr( pARG );
 //  const char * cRelleno = hb_itemGetCPtr( pRELL );
 //  HB_MAXINT nSize = hb_itemGetCLen( pARG );
 //  HB_MAXINT nLen = hb_itemGetNL( pPAD );
   char * szResult=NULL;
   if( nLen <= nSize ){
      char * Ret = (char *)calloc( nSize+1,1);
      memcpy(Ret,cText,nSize);
      return ( (char *) Ret );
   }else{

      switch( tCompare){
         case 0: {   // PADC 
            /*char * */szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = ' ';
            HB_ISIZ nPad = ( ( HB_SIZE ) nLen - nSize ) >> 1;
            memset( szResult, cPad, nPad );
            memcpy( szResult + nPad, cText, nSize );
            memset( szResult + nPad + nSize, cPad, ( HB_SIZE ) nLen - nSize - nPad );
            //const char * milenka = szResult;
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            //return (szResult);
            //free( szResult );
            break;
         }case 1: {  // PADR
            /*char * */szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = ' ';
            memcpy( szResult, cText, nSize );
            memset( szResult + nSize, cPad, ( HB_SIZE ) nLen - nSize );
            //const char * milenka = szResult;
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            //return (szResult);
           // free( szResult );
            break;
         }case 2: {  // PADL
            /*char * */szResult = ( char * ) calloc( nLen + 1, 1 );
            char cPad = ' ';
            memset( szResult, cPad, ( HB_SIZE ) nLen - nSize );
            memcpy( szResult + ( HB_SIZE ) nLen - nSize, cText, nSize );
            //const char * milenka = szResult;
            //hb_arraySetC( pSTK_ADDR, CADDR, (const char *) milenka );
            //return (szResult);
           // free( szResult );
            break;
         }
      }
      return (szResult);
   }
}

      
#define MAXBUFFER 4096

char *fsaturate( const char *tokens, const char *tok, const char *linea, int tipo){
   char *buffer;
   const char *t, *s;
   char **ltoken;     // lista de tokens
   uint16_t lentok = strlen(tok);
   uint16_t i=0,l, sizei;

   if (lentok==0) {return NULL;}

   // cuántos tokens tengo?
   
   uint16_t ntok = ftokens(tokens,tok,lentok);
   if (ntok==0) {return NULL;}   // no hay tokens
   //ltoken = (char**)malloc( sizeof(char *)*(ntok+2) );
   ltoken = (char**)calloc( ntok+1, sizeof(char *) );
   // a ntok se suma 1, pues acá necesito los tokens, no los separadores, como en strtran. 

   if (ltoken==NULL) return NULL;   // no hay memoria

   // obtengo tokens y los guardo en un arreglo para reemplazar después.
   t = tokens;
   char *temp;
   while ((s = strstr(t,tok))!=NULL) {
       l = s - t;
       
       ltoken[i] = (char*)calloc( (l+1), 1);//sizeof(char *) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           //free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           
           return NULL;     // no hay memoria para el arreglo
       }
       //strncpy(ltoken[i], t, l);
       strncpy(temp, t, l);
       t = ++s;
     //  printf("\nTOken... [%s]\n",ltoken[i]);  // OK.
       ++i;
   }

   if (t!=NULL) {           // queda un token más: lo capturo.
       ltoken[i] = (char*)calloc( (strlen(t)+1), 1);// sizeof(char *) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           ///free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           
           return NULL;     // no hay memoria para el arreglo
       }
       
       //strcpy(ltoken[i], t);
       strcpy(temp, t);
       sizei = i;
   } else sizei = i-1;

   // asigno espacio a la línea objetiva
   ///buf = (char *) malloc (sizeof(char *)*MAXBUFFER); // MAXBUFFER lo asgno por flag "512"
   buffer = (char *) calloc (MAXBUFFER,1);//sizeof(char *));
   char *buf = buffer;
   if (buf==NULL) {         // limpiar la memoria que ya fue asignada
       //free(ltoken);
       for (l=0;l<=i;++l) free(ltoken[l]);
       free(ltoken);
       free(buffer);
       
       return NULL;         // no hay memoria para el arreglo
   }
   // Reemplazo los tokens en la línea objetiva
   uint16_t ncampo=0;
   uint16_t lc=0;
   const char *c, *cc;

  // strcpy(buf,"");
   t = linea;
   while ((s = strstr(t,"$"))!=NULL) {
       l = s - t;
       strncat(buf,t,l);         // rescato porción de linea sin tocar, antes del token
       c = s+1;                  // desde el supuesto dígito en adelante
       while (isdigit(*c)) c++;  // obtengo el número del campo
       lc = c - s;               // longitud del número
       if (lc>1) {               // es un campo. 1= no es un campo
          char *cindice,*cind;        // para guardar los índices
          cindice = (char *) calloc(lc+1*10,1);//malloc (10*(lc+1));
          cind = cindice;
          if (cind==NULL) {     // limpiar la memoria que ya fue asignada
              ///free(ltoken);
              for (l=0;l<=i;++l) free(ltoken[l]);
              free(ltoken);
              free(buffer);
              
              return NULL;         // no hay memoria para el arreglo
          }
          
          strncpy(cind,s+1,lc);   // preparo el indice del arreglo para obtener token
          ncampo = atoi(cind);
          if (ncampo<=sizei) {     // es un campo válido??
             // aniadir aqui el pad, si lo hay
             const char * campo = ltoken[ncampo];
             if(*c==':'){  // aqui hay un pad
                cc = c;
                c++;  // me lo salto
                if(!isdigit(*c)){  // construcción errada
                   free(cindice);
                   for (l=0;l<=i;++l) free(ltoken[l]);
                   free(ltoken);
                   free(buffer);
                   
                   return NULL;
                }
                char *cPad/*ding*/;
                char *cPadToken;        // para guardar los índices
                int w=0;
                
                while(isdigit(*c)) {/*printf("DIG=%c, ",*c);*/c++;++w;/*printf("W=%d",w);*/}
                lc = w;// c - ( cc+w);
                cPad/*ding*/ = (char *) calloc (lc+1,1);//sizeof(char *));
                //cPadToken = (char * ) calloc (128,1);
                //char * cPad = cPadding;
          	//strncpy(cPad,(cc+w),lc);
          	strncpy(cPad,cc+1,lc);

                int nPad = atoi(cPad);
                int sizeCampo = strlen(campo);
          	//printf("\nLC = %d, CIND=%d CPAD = %s, NPAD = %d sizeCampo=%d Campo=%s",lc,ncampo,cPad,nPad,sizeCampo,campo);
                if(toupper(*c) == 'C'){  //0
                   cPadToken=strpad(campo,nPad,sizeCampo,0);
                }else if(toupper(*c) == 'L'){  //1
                   cPadToken=strpad(campo,nPad,sizeCampo,1);
                }else if(toupper(*c) == 'R'){  //2
                   cPadToken=strpad(campo,nPad,sizeCampo,2);
                }else{   // error
                   free(cindice);free(cPad);
                   for (l=0;l<=i;++l) free(ltoken[l]);
                   free(ltoken);
                   free(buffer);
                   
                   return NULL;
                }
                //printf("\nENTRA AQUI con %s\n",cPadToken);
                if (cPadToken!=NULL) 
                   strcat(buf,cPadToken);
                else
                   strcat(buf,"");

                // printf("\nESTA OK\n");
                c++;
                free(cPad/*ding*/);
                free(cPadToken);
                //printf("\nFREE OK\n");
             }else{
                //strcat(buf,campo);
                if(tipo){
                   char * cCampo = fun_alltrim( (const char*)campo, (HB_SIZE)strlen(campo));
                   if (cCampo == NULL){
                      char * cCampo = (char * )calloc(1,1);
                      cCampo[0]='\0';
                   }
                   const char * pCampo = cCampo;
              //  printf("\nENTRA AQUI con %s\n",cCampo);
                   strcat(buf, pCampo);
              //  printf("\nESTA OK\n");
                   free(cCampo);
                }else{
                   strcat(buf, campo);
                }
             }
          }
          t = c;              // siempre: por si o por no, el campo será eliminado igual
          free(cindice);
       } else {
          strncat(buf,s,1);   // rescato "$" que no es un campo
          t = ++s;            // avanzo un espacio y continúo el proceso
       }
   }
   // rescato lo último que no ha sido rescatado
   strcat (buf,t);
   int nLen = strlen(buf);
//   buf[nLen+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
   free(ltoken);
   
   char * Retorno = (char *) calloc (nLen+1,1);//sizeof(char));
   char * Ret = Retorno;
   strcpy(Ret,buf);
   
   // deguerbo resultado
   free(buffer);
   return Retorno;
/*
//   buf[strlen(buf)+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
   free(ltoken);
   
   // deguerbo resultado
   return buffer; */
}

char *fLPsaturate( const char *tokens, int *pos, int nPos, const char *linea){
   char *buffer;
   const char *t, *s;
   //char **ltoken;     // lista de tokens
   char *ltoken[nPos];
   uint16_t i=0,j=0,k=0,l=0, sizei=0;

//   ltoken = (char**)malloc((nPos+1) * sizeof(char **) );
   // a ntok se suma 1, pues acá necesito los tokens, no los separadores, como en strtran. 

//   if (ltoken==NULL) return NULL;   // no hay memoria

   // obtengo tokens y los guardo en un arreglo para reemplazar después.
   t = tokens;
   j = 0;
   const char *c,*cc;
   c = t;
//   char *temp;
   while (j<nPos){   //((s = strstr(t,tok))!=NULL) {
       k=0;
       while (k++<pos[j]) c++;
       l = c - t;
       
       //ltoken[i] = (char*)calloc( (l+1), 1);//sizeof(char) );
       char* temp = (char *)calloc( l+1,1);
       strncpy(temp, t, l);
       char* tmp2 = fun_alltrim( (const char*)temp, l);
       ltoken[i] = (char*)calloc(strlen(tmp2)+1,1);
       strcpy(ltoken[i], tmp2);
       free(temp);
       free(tmp2);

       t = c;
       ++i;
       ++j;
   }

   if (t!=NULL) {           // queda un token más: lo capturo.
       char* temp = (char *)calloc( l+1,1);
       strncpy(temp, t, l);
       char* tmp2 = fun_alltrim( (const char*)temp, l);
       ltoken[i] = (char*)calloc(strlen(tmp2)+1,1);
       strcpy(ltoken[i], tmp2);
       free(temp);
       free(tmp2);
       
       sizei = i-1;
   } else sizei = i-1;

   // asigno espacio a la línea objetiva
   buffer = (char *) calloc (MAXBUFFER,1);//sizeof(char));
   char *buf = buffer;
   if (buf==NULL) {         // limpiar la memoria que ya fue asignada
       //free(ltoken);
       for (l=0;l<=i;++l) free(ltoken[l]);
       //free(ltoken);
       free(buffer);
       return NULL;         // no hay memoria para el arreglo
   }
   
   // Reemplazo los tokens en la línea objetiva
   uint16_t ncampo=0;
   uint16_t lc=0;
   
  // strcpy(buf,"");
   t = linea;
   
   while ((s = strstr(t,"$"))!=NULL) {
       l = s - t;
       strncat(buf,t,l);         // rescato porción de linea sin tocar, antes del token
       c = s+1;                  // desde el supuesto dígito en adelante
       while (isdigit(*c)) c++;  // obtengo el número del campo
       lc = c - s;               // longitud del número
       if (lc>1) {               // es un campo. 1= no es un campo
          char *cindice, *cind;        // para guardar los índices
          cindice = (char *) malloc (1*(lc+1));
          cind = cindice;
          //cindice = (char *) calloc (3,sizeof(char *));
          if (cind==NULL) {     // limpiar la memoria que ya fue asignada
             //free(ltoken);
             for (l=0;l<=i;++l) free(ltoken[l]);
             //free(ltoken);
             free(buffer);
             return NULL;         // no hay memoria para el arreglo
          }
          
          strncpy(cind,s+1,lc);   // preparo el indice del arreglo para obtener token
          ncampo = atoi(cind);
          
          if (ncampo<=sizei) {     // es un campo válido??
             const char * campo = ltoken[ncampo];
          	 // aniadir aqui el pad, si lo hay
             if(*c==':'){  // aqui hay un pad
                 cc = c;
          	    c++;  // me lo salto
          	    char *cPad;
          	    char *cPadding;
          	    
          	    int w=0;

          	    while(isdigit(*c)) {c++;++w;}
          	    lc = w; //c - ( cc+w);
          	    cPadding = (char *) calloc (lc+1,1);//sizeof(char));
          	    cPad = cPadding;
          	    //strncpy(cPad,(cc+w),lc);
          	    strncpy(cPad,cc+1,lc);
          	    int nPad = atoi(cPad);
          	    int sizeCampo = strlen(campo);
          	    
                    //printf("\nLC = %d, CIND=%d CPAD = %s, NPAD = %d sizeCampo=%d Campo=%s",lc,ncampo,cPad,nPad,sizeCampo,campo);
          	    char *cPadToken;        // para guardar los índices
          	    if(toupper(*c) == 'C'){  //0
          	       cPadToken=strpad(campo,nPad,sizeCampo,0);
          	    }else if(toupper(*c) == 'L'){  //1
          	       cPadToken=strpad(campo,nPad,sizeCampo,1);
          	    }else if(toupper(*c) == 'R'){  //2
          	       cPadToken=strpad(campo,nPad,sizeCampo,2);
          	    }else{   // error
          	       return NULL;
          	    }
          	    if (cPadToken!=NULL) 
                        strcat(buf,cPadToken);
                    else
                        strcat(buf,"");
                   /// printf("\nCampo=[%s]\n",cPadToken);
          	    c++;
          	    free(cPadding);
          	    free(cPadToken);
             }else{
                HB_SIZE nLenC = strlen(campo);
                char * cCampo = fun_alltrim( (const char*)campo, nLenC);
                if (cCampo == NULL){
                   char * cCampo = (char * )calloc(1,1);
                   cCampo[0]='\0';
                }
                const char * pCampo = cCampo;
                strcat(buf, (const char*)pCampo);  // aqui el problema
                free(cCampo);
             }
          }
          t = c;              // siempre: por si o por no, el campo será eliminado igual
          free(cindice);
       } else {
          strncat(buf,s,1);   // rescato "$" que no es un campo
          t = ++s;            // avanzo un espacio y continúo el proceso
       }
   }
   // rescato lo último que no ha sido rescatado
   strcat (buf,t);
   int nLen = strlen(buf);
//   buf[nLen+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
//   free(ltoken);
   
   char * Retorno = (char *) calloc (nLen+1,1);//sizeof(char));
   char * Ret = Retorno;
   strcpy(Ret,buf);
   
   // deguerbo resultado
   free(buffer);
   return Retorno;
}

/* FUN_SATURATE
   Depende de la lectura de líneas desde un archivo. Cada línea leída, será
   usada para saturar otra línea, pasada como argumento a satura.
   */
int fun_saturate(){
int sw=1;
if(CADDR>=2){   // necesita 2 argumentos del stack; 1 de stackReg
   long nItem = STK_PRG[++CP];
   PHB_ITEM pSTRING = hb_itemArrayGet(pSTK_REG,nItem);  // línea a saturar
   if(!HB_IS_STRING(pSTRING)){
      hb_itemRelease(pSTRING);
      sw=put_error((PHB_ITEM) pRET, "SATURATE LINE TO SATURE ARGUMENT ERROR - MUST BE STRING",103);
      return sw;
   }
   const char * cLinea = hb_itemGetCPtr(pSTRING);
   hb_itemRelease(pSTRING);
   PHB_ITEM pSEP    = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // separador o array de posiciones
   PHB_ITEM pTOKENS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // línea con tokens
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(HB_IS_STRING(pSEP)){
      if( HB_IS_STRING(pTOKENS) ){  // debe ser un separador
         const char * cSep = hb_itemGetCPtr(pSEP);
         const char * cTokens = hb_itemGetCPtr(pTOKENS);

         if (cSep[0]==':'){
            sw=put_error((PHB_ITEM) pRET, "SATURATE ARGUMENT ERROR - TOKEN SEP ':' NOT VALID",103);
         }else{
            char * pBuffer;
      
            pBuffer = (char *)fsaturate( cTokens, cSep, cLinea, 1 );
         
            if (pBuffer==NULL){
               sw=put_error((PHB_ITEM) pRET, "SATURATE MASK ARGUMENT ERROR - BAD FORMED",103);
               pBuffer = (char * ) calloc(1,1);
               pBuffer[0]='\0';
            }
            const char * pRet = pBuffer;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pRet );
            free(pBuffer);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SATURATE SECOND ARGUMENT ERROR - MUST BE STRING",103);
      }    
   }else if(HB_IS_ARRAY(pSEP)){
      if( HB_IS_STRING(pTOKENS) ){
         const char * cTokens = hb_itemGetCPtr(pTOKENS);
         HB_SIZE nSepLen = hb_arrayLen( pSEP );
         if(nSepLen<=0){
            sw=put_error((PHB_ITEM) pRET, "SATURATE SECOND ARGUMENT ERROR - ARRAY NULL",103);
         }else{
            int pos[nSepLen];
            HB_SIZE q;
            // obtengo los elementos del array y lo llevo a array de int.
            for (q=0;q<nSepLen;q++){
               PHB_ITEM pQ = hb_itemArrayGet( pSEP, q+1);
               pos[q] = hb_itemGetNInt(pQ);
               hb_itemRelease( pQ );
            }
            char * pBuffer;
         
            pBuffer = (char *)fLPsaturate( cTokens, pos, nSepLen, cLinea);

            if (pBuffer==NULL){
               sw=put_error((PHB_ITEM) pRET, "SATURATE MASK ARGUMENT ERROR - BAD FORMED",103);
               pBuffer = (char * ) calloc(1,1);
               pBuffer[0]='\0';
            }
            const char * pRet = pBuffer;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pRet );
            free(pBuffer);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SATURATE SECOND ARGUMENT ERROR - MUST BE STRING",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SATURATE FIRST ARGUMENT ERROR - MUST BE NUM ARRAY OR STRING",103);
   }
   hb_itemRelease(pSEP);
   hb_itemRelease(pTOKENS);

}else{
   sw=put_error((PHB_ITEM) pRET, "SATURATE INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_format(){
int sw=1;
if(CADDR>=2){   // necesita 2 argumentos del stack; 1 de stackReg
   long nItem = STK_PRG[++CP];
   PHB_ITEM pSTRING = hb_itemArrayGet(pSTK_REG,nItem);  // línea a saturar
   if(!HB_IS_STRING(pSTRING)){
      hb_itemRelease(pSTRING);
      sw=put_error((PHB_ITEM) pRET, "FORMAT LINE TO FORMAT ARGUMENT ERROR - MUST BE STRING",103);
      return sw;
   }
   const char * cLinea = hb_itemGetCPtr(pSTRING);
   hb_itemRelease(pSTRING);
   PHB_ITEM pSEP    = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // separador o array de posiciones
   PHB_ITEM pTOKENS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // línea con tokens
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   if(HB_IS_STRING(pSEP)){
      if( HB_IS_STRING(pTOKENS) ){  // debe ser un separador
         const char * cSep = hb_itemGetCPtr(pSEP);
         const char * cTokens = hb_itemGetCPtr(pTOKENS);

         if (cSep[0]==':'){
            sw=put_error((PHB_ITEM) pRET, "FORMAT ARGUMENT ERROR - TOKEN SEP ':' NOT VALID",103);
         }else{
            char * pBuffer;
            
            pBuffer = (char *)fsaturate( cTokens, cSep, cLinea, 0 );
         
            if (pBuffer==NULL){
               sw=put_error((PHB_ITEM) pRET, "FORMAT MASK ARGUMENT ERROR - BAD FORMED",103);
               pBuffer = (char * ) calloc(1,1);
               pBuffer[0]='\0';
            }
            const char * pRet = pBuffer;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*) pRet );
            free(pBuffer);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "FORMAT SECOND ARGUMENT ERROR - MUST BE STRING",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "FORMAT FIRST ARGUMENT ERROR - MUST BE NUM ARRAY OR STRING",103);
   }
   hb_itemRelease(pSEP);
   hb_itemRelease(pTOKENS);

}else{
   sw=put_error((PHB_ITEM) pRET, "FORMAT INNER-STACK OVERFLOW",101);
}
return sw;
}

/*
   FUNCIONES DE SOCKET TCP.
   */
// structuras y otras definiciones generales
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
//#include <errno.h>      /* for errno and EINTR */
//#define TIMEOUT_SECS  2    /* TIMEOUT SECONDS WAIT */
/////#include <signal.h>     /* for sigaction() YA ESTA DEFINIDO */
//Se necesitan dos estructuras del tipo sockaddr
// SERVER TCP
struct sockaddr_in server;  //La primera guarda info del server
struct sockaddr_in client;  //La segunda del cliente
// CLIENT TCP
struct hostent *he;         /* estructura que recibirá información sobre el nodo remoto */
//struct sockaddr_in server_cl;  /* información sobre la dirección del servidor */

//struct sigaction myAction;       /* For setting signal handler */
//int tries = 0;    /* para intentos de TIMEOUT UDP */

////int TCP_longitud_cliente=0; //no es necesario.

/* Funciones */
int fun_socketTCP_Accept(){
int sw=1;
int fd2;   // descriptor de la conexión con el cliente, diferente del descriptor del socket.
unsigned int TCP_longitud_cliente;
TCP_longitud_cliente= sizeof(struct sockaddr_in);

long nItem = STK_PRG[++CP];
PHB_ITEM pFD = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR
int fd = hb_itemGetNI(pFD);
hb_itemRelease(pFD);

if(fd>0){
   /* A continuación la llamada a accept() */
   if ((fd2 = accept(fd,(struct sockaddr *)&client,&TCP_longitud_cliente))!=-1) {
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd2 );  // devuelve el identificador del socket del cliente TCP conectado
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - ACCEPT ERROR",120);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - DESCRIPTOR ERROR",117);
}
return sw;
}

int fun_socketTCP_Connect(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR
int fd = hb_itemGetNI(pFD);
hb_itemRelease(pFD);
if(fd>0){
   if(connect(fd, (struct sockaddr *)&server, sizeof(struct sockaddr))==-1){
      sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT TCP - CONNECT ERROR",121);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT TCP - CONNECT DESCRIPTOR ERROR",117);
}

return sw;
}

int fun_socketTCP_Recv(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(fd2>0){
   if(CADDR>=1){
      int numBytes;
      PHB_ITEM pSIZEBUFF = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // NUMERO DE BYTES QUE ESPERA RECIBIR
      unsigned int sizeBuffer=hb_itemGetNI(pSIZEBUFF);
      hb_itemRelease(pSIZEBUFF);
      
      CADDR += SWKEEP; SWKEEP = 0;
      
      if(sizeBuffer>0){
         char buffer[sizeBuffer];
         if ((numBytes=recv(fd2,buffer,sizeBuffer,0)) != -1){
            buffer[numBytes]='\0';
            if(CADDR<nSizeStack-3){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)numBytes );        // tercero: numero de bytes recibidos
               
               const char* cSource = inet_ntoa(server.sin_addr);
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cSource );  // segundo: la IP fuente

               const char* cBuffer = buffer;
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cBuffer );  // primero: el mensaje recivido

            }else{
               sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV ERROR",121);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV ARGUMENT ERROR - BYTES TO READ",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV INNER-STACK UNDERFLOW : #BYTES TO READ?",102);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - RECV DESCRIPTOR ERROR",117);
}

return sw;
}

int fun_socketTCP_Send(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(CADDR>=1){
   PHB_ITEM pMESSAGE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MENSAJE A ENVIAR
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING(pMESSAGE)){
      const char* cBuffer=hb_itemGetCPtr(pMESSAGE);
      hb_itemRelease(pMESSAGE);
      send(fd2,cBuffer,strlen(cBuffer),0);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - SEND ARGUMENT ERROR : TYPE MISMATCH",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET TCP - SEND INNER-STACK UNDERFLOW : MSG TO SEND?",102);
}
return sw;
}


/*void CatchAlarm(int ignored)     // Handler for SIGALRM 
{
    tries += 1;
}*/

int fun_socketUDP_Recvfrom(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(fd2>0){
   if(CADDR>=1){
      int numBytes;
      PHB_ITEM pSIZEBUFF = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // NUMERO DE BYTES QUE ESPERA RECIBIR
      unsigned int sizeBuffer=hb_itemGetNI(pSIZEBUFF);
      hb_itemRelease(pSIZEBUFF);
      
      CADDR += SWKEEP; SWKEEP = 0;
      
      if(sizeBuffer>0){
         char buffer[sizeBuffer];
         int addr_len = sizeof(struct sockaddr);
         if ((numBytes=recvfrom(fd2, buffer, sizeBuffer, 0, (struct sockaddr *)&client, (socklen_t *)&addr_len)) != -1){
            buffer[numBytes]='\0';
            if(CADDR<nSizeStack-3){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)numBytes );        // tercero: numero de bytes recibidos
               
               const char* cSource = inet_ntoa(client.sin_addr);
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cSource );  // segundo: la IP fuente

               const char* cBuffer = buffer;
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cBuffer );  // primero: el mensaje recivido

            }else{
               sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM ERROR",121);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM ARGUMENT ERROR - BYTES TO READ",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM INNER-STACK UNDERFLOW : #BYTES TO READ?",102);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - RECVFROM DESCRIPTOR ERROR",117);
}

return sw;
}

int fun_socketUDP_Sendto(){
int sw=1;

long nItem = STK_PRG[++CP];
PHB_ITEM pFD2 = hb_itemArrayGet(pSTK_REG,nItem);  // DESCRIPTOR CLIENTE
int fd2 = hb_itemGetNI(pFD2);
hb_itemRelease(pFD2);

if(CADDR>=1){
   PHB_ITEM pMESSAGE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MENSAJE A ENVIAR
   CADDR += SWKEEP; SWKEEP = 0;
   if(HB_IS_STRING(pMESSAGE)){
      const char* cBuffer=hb_itemGetCPtr(pMESSAGE);
      hb_itemRelease(pMESSAGE);
      int numBytes;
      
     /* Set signal handler for alarm signal */
 /*     myAction.sa_handler = CatchAlarm;
      if (sigfillset(&myAction.sa_mask) < 0){ // block everything in handler 
         sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO SIGFILLSET ERROR",122);
         return sw;
      }
      myAction.sa_flags = 0;

      if (sigaction(SIGALRM, &myAction, 0) < 0){
         sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO SIGACTION ERROR",123);
         return sw;
      }
      alarm(TIMEOUT_SECS);       // Set the timeout
      struct timeval tv;
tv.tv_sec = 3;
tv.tv_usec = 0;
if (setsockopt(fd2, SOL_SOCKET, SO_SNDTIMEO,&tv,sizeof(tv)) < 0) {
    perror("Error");
}*/

      numBytes=sendto(fd2,cBuffer,strlen(cBuffer),MSG_DONTWAIT,(struct sockaddr *)&client, sizeof(struct sockaddr));

         if(numBytes!=-1){
            if(CADDR<nSizeStack){
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)numBytes );  // numero de bytes enviados
            }else{
               sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO STACK OVERFLOW",101);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO ERROR",121);
         }

   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO ARGUMENT ERROR : TYPE MISMATCH",103);
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET UDP - SENDTO INNER-STACK UNDERFLOW : MSG TO SEND?",102);
}
return sw;
}


// función de apertura de SOCKET: CLIENTE(1) o SERVIDOR(0), CLOSE(2)
int fun_socket(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pTYPE = hb_itemArrayGet(pSTK_REG,nItem);  // tipo de socket: Server, o Client
int nType = hb_itemGetNI(pTYPE);
hb_itemRelease(pTYPE);

if(nType==0){  // TCP server
   if(CADDR>=2){
      //Primer paso, definir variables
      int fd;   // descriptor de socket

      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      if(puerto>0){
         PHB_ITEM pBACKLOG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // NUMERO MAXIMO DE CONEXIONES ENCOLADAS.
         int backLog=hb_itemGetNI(pBACKLOG);
         hb_itemRelease(pBACKLOG);
         
         CADDR += SWKEEP; SWKEEP = 0;
         
         if(backLog<=0) backLog=5;   // 5 conexiones por default
      
         //Configuracion del servidor
         server.sin_family= AF_INET;          //Familia TCP/IP
         server.sin_port = htons(puerto);     //Puerto
         server.sin_addr.s_addr = INADDR_ANY; //Cualquier cliente puede conectarse
         bzero(&(server.sin_zero),8);         //Funcion que rellena con 0's
 
         //Paso 2, definicion de socket
         if (( fd=socket(AF_INET,SOCK_STREAM,0) )<0){
            sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - OPEN SOCKET ERROR",118);
         }else{
           //Paso 3, avisar al sistema que se creo un socket. Solicita un nombre para el socket y número de puerto local
            if(bind(fd,(struct sockaddr*)&server, sizeof(struct sockaddr))==-1) {
               sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - BIND ERROR",119);
            }else{
              //Paso 4, establecer el socket en modo escucha
               if(listen(fd,backLog) == -1) {
                  sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - LISTEN ERROR",120);
               }else{  // todo ok! comienza el webeo...
                  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket TCP
               }
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - INNER-STACK UNDERFLOW : NEED A PORT",102);
   }
}else if(nType==1){  // TCP client
   if(CADDR>=2){
      int fd;
       
      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      if(puerto>0){
         PHB_ITEM pADDRESS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // DIRECCION IP TIPO "127.0.0.1"
         CADDR += SWKEEP; SWKEEP = 0;
         if(HB_IS_STRING(pADDRESS)){
            const char* ip=hb_itemGetCPtr(pADDRESS);
            hb_itemRelease(pADDRESS);
            if ((he=gethostbyname(ip))==NULL){
               sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER TCP - HOST NAME ERROR",121);
            }else{
               if ((fd=socket(AF_INET, SOCK_STREAM, 0))==-1){        //Paso 2, definicion de socket
                  sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT TCP - OPEN SOCKET ERROR",118);
               }else{
                 //Datos del servidor
                  server.sin_family = AF_INET;
                  server.sin_port = htons(puerto);
                  server.sin_addr = *((struct in_addr *)he->h_addr);
                 /*he->h_addr pasa la información de ``*he'' a "h_addr" */
                  bzero(&(server.sin_zero),8);   // rellena con 0
                  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket TCP
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT TCP - ARGUMENT ERROR : IP BAD TYPE",103);
         }            
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT TCP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
   
   }
}else if(nType==3){  // UDP server
   if(CADDR>=1){
      //Primer paso, definir variables
      int fd;   // descriptor de socket

      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      CADDR += SWKEEP; SWKEEP = 0;
      if(puerto>0){
 
         //Paso 2, definicion de socket
         if (( fd=socket(AF_INET,SOCK_DGRAM,0) )<0){
            sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - OPEN SOCKET ERROR",118);
         }else{

            //Configuracion del servidor
            server.sin_family= AF_INET;          //Familia TCP/IP
            server.sin_port = htons(puerto);     //Puerto
            server.sin_addr.s_addr = INADDR_ANY; //Cualquier cliente puede conectarse
            bzero(&(server.sin_zero),8);         //Funcion que rellena con 0's
           //Paso 3, avisar al sistema que se creo un socket. Solicita un nombre para el socket y número de puerto local
            if(bind(fd,(struct sockaddr*)&server, sizeof(struct sockaddr))==-1) {
               sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - BIND ERROR",119);
            }else{
               hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket
            }
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET SERVER UDP - INNER-STACK UNDERFLOW : NEED A PORT",102);
   }
}else if(nType==4){   // UDP cliente
   if(CADDR>=2){
      int fd;
       
      PHB_ITEM pPORT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PUERTO
      int puerto=hb_itemGetNI(pPORT);
      hb_itemRelease(pPORT);
      if(puerto>0){
         PHB_ITEM pADDRESS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // DIRECCION IP TIPO "127.0.0.1"
         CADDR += SWKEEP; SWKEEP = 0;
         if(HB_IS_STRING(pADDRESS)){
            const char* ip=hb_itemGetCPtr(pADDRESS);
            hb_itemRelease(pADDRESS);
            if ((he=gethostbyname(ip))==NULL){
               sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT UDP - HOST NAME ERROR",121);
            }else{
               if ((fd=socket(AF_INET, SOCK_DGRAM, 0))==-1){        //Paso 2, definicion de socket
                  sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT UDP - OPEN SOCKET ERROR",118);
               }else{
                 //Datos del servidor
                  client.sin_family = AF_INET;
                  client.sin_port = htons(puerto);
                  client.sin_addr = *((struct in_addr *)he->h_addr);
                 /*he->h_addr pasa la información de ``*he'' a "h_addr" */
                  bzero(&(client.sin_zero),8);   // rellena con 0
                  hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)fd );  // devuelve el identificador del socket TCP
               }
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT UDP - ARGUMENT ERROR : IP BAD TYPE",103);
         }
                 
      }else{
         sw=put_error((PHB_ITEM) pRET, "SOCKET CIENT UDP - ARGUMENT ERROR : BAD PORT",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "SOCKET CLIENT UDP - INNER-STACK UNDERFLOW",102);
   }
}else if(nType==2){  //  TCP close
   PHB_ITEM pFD = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // DECRIPTOR A CERRAR
   int fd=hb_itemGetNI(pFD);
   hb_itemRelease(pFD);
   CADDR += SWKEEP; SWKEEP = 0;
   if(fd>0)
      close(fd);
   else
      sw=put_error((PHB_ITEM) pRET, "SOCKET TCP CLOSE - DESCRIPTOR ERROR",117);
}else{
   sw=put_error((PHB_ITEM) pRET, "SOCKET TCP TYPE ARGUMENT ERROR - MUST BE 0|1",103);
}

return sw;
}

/************************/

/****************************
   MESSSAGE QUEUE SYSTEM V
 ****************************/
///#include <sys/types.h>   // ya existe
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/stat.h>
 
int fun_qcreate(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int key = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int flags=0,permisos;
if(key==0){   // crea clave privada
   key = IPC_PRIVATE;
   flags |= IPC_CREAT;
}else{
   flags |= IPC_CREAT; // | IPC_EXCL;
}
if(CADDR){ // busca por permisos.
   PHB_ITEM pPERMISOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PERMISOS
   permisos=hb_itemGetNI(pPERMISOS);
   hb_itemRelease(pPERMISOS);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   permisos=(S_IRUSR | S_IWUSR); //0666;
}
if(permisos>0){
   int msqid = msgget(key, flags | permisos);
   if (msqid == -1){
      sw=put_error((PHB_ITEM) pRET, "QCREATE - CAN'T CREATE QUEUE",122);
   }else{
      hb_arraySetNI( pSTK_ADDR, ++CADDR, (int)msqid );  // devuelve key.
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "QCREATE - PERMS ARGUMENT ERROR",103);
}
return sw;
}

int fun_qset(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int msg_qbytes;

if(CADDR>=1){   // debe haber: {__msg_cbytes,msg_qbytes}
   PHB_ITEM pMSG_QBYTES = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MSG_QBYTES: total de bytes de la cola
   msg_qbytes=hb_itemGetNI(pMSG_QBYTES);
   hb_itemRelease(pMSG_QBYTES);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   msg_qbytes=16384;
}
if(sw){

 /*     if(CADDR){ // busca por permisos.
         PHB_ITEM pPERMISOS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // PERMISOS
         permisos=hb_itemGetNI(pPERMISOS);
         hb_itemRelease(pPERMISOS);
      }else{
         permisos=(S_IRUSR | S_IWUSR); //600 // mejor si 0666;
      }*/
      struct msqid_ds ds;
      if (msgctl(msqid, IPC_STAT, &ds) == -1){
            sw=put_error((PHB_ITEM) pRET, "QSET - RETRIEVE QUEUE INFO ERROR",123);
      }else{
         ds.msg_qbytes = msg_qbytes;
      
          /* Actualiza la estructura de datos en el kernel */
   
         if (msgctl(msqid, IPC_SET, &ds) == -1)
            sw=put_error((PHB_ITEM) pRET, "QSET - UPDATE DATA KERNEL ERROR",123);
      }
}
return sw;
}

int fun_qsend(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int maxLong,mType=1;
int flags=0;
const char* message;
if(CADDR>=3){   // {msgType, maxlong,message}
   PHB_ITEM pMSG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MESSAGE
   message=hb_itemGetCPtr(pMSG);
   hb_itemRelease(pMSG);
   PHB_ITEM pMAXLONG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MAXLONG
   maxLong = hb_itemGetNI(pMAXLONG);
   hb_itemRelease(pMAXLONG);
   PHB_ITEM pMTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MSGTYPE
   mType = hb_itemGetNI(pMTYPE);
   hb_itemRelease(pMTYPE);
}else if(CADDR==2){  // {maxlong,message}
   PHB_ITEM pMSG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MESSAGE
   message=hb_itemGetCPtr(pMSG);
   hb_itemRelease(pMSG);
   PHB_ITEM pMAXLONG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MAXLONG
   maxLong = hb_itemGetNI(pMAXLONG);
   hb_itemRelease(pMAXLONG);
   
}else{
   sw=put_error((PHB_ITEM) pRET, "QSEND - INNER-STACK UNDERFLOW",102);
}
CADDR += SWKEEP; SWKEEP = 0;
if(sw){
   struct mbuf {
      long mtype;                       /* Message type */
      char mtext[maxLong];              /* Message body */
   };
   struct mbuf msg;
   
   flags |= IPC_NOWAIT ;
   int msgLen = strlen(message) + 1;
   if(msgLen > maxLong)
      sw=put_error((PHB_ITEM) pRET, "QSEND - MESSAGE TOO LONG",124);
   else{
      memcpy(msg.mtext, message, msgLen);
      msg.mtype = mType;
      if (msgsnd(msqid, &msg, msgLen, flags) == -1)
         sw=put_error((PHB_ITEM) pRET, "QSEND - CAN'T SEND TO QUEUE",122);
   }
}
return sw;
}

int fun_qrecv(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);
int maxLong,msgLen,mType=1,flags=0;
if(CADDR>=2){   // {maxlong}
   PHB_ITEM pMAXLONG = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MAXLONG
   maxLong = hb_itemGetNI(pMAXLONG);
   hb_itemRelease(pMAXLONG);
   PHB_ITEM pMTYPE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // MSGTYPE
   mType = hb_itemGetNI(pMTYPE);
   hb_itemRelease(pMTYPE);
   
   CADDR += SWKEEP; SWKEEP = 0;
   
   flags |= IPC_NOWAIT;
   struct mbuf {
      long mtype;                       /* Message type */
      char mtext[maxLong];              /* Message body */
   };
   struct mbuf msg;


///   permisos=(S_IRUSR | S_IWUSR); //0666;

   msg.mtype=mType;
   msgLen = msgrcv(msqid, &msg, maxLong, mType,flags);
   if (msgLen == -1)
      sw=put_error((PHB_ITEM) pRET, "QRECV - CAN'T RECEIVE FROM QUEUE",122);
   else{
      const char* cBuffer = msg.mtext;
      hb_arraySetC( pSTK_ADDR, ++CADDR, (const char*)cBuffer );  // 
   }

}else{
   sw=put_error((PHB_ITEM) pRET, "QRECV - INNER-STACK UNDERFLOW",102);
}
return sw;
}

int fun_qremove(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pKEY = hb_itemArrayGet(pSTK_REG,nItem);  // KEY
int msqid = hb_itemGetNI(pKEY);
hb_itemRelease(pKEY);

if (msgctl(msqid, IPC_RMID, NULL) == -1)
   sw=put_error((PHB_ITEM) pRET, "QREMOVE - CAN'T REMOVE QUEUE",122);

return sw;
}

/* existe archivo y drectorio*/

int fun_exist_file(){
int sw=1;
if( CADDR < nSizeStack ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * szFile = hb_itemGetCPtr( pFILE );
   hb_arraySetNI( pSTK_ADDR, ++CADDR, szFile ? hb_spFile( szFile, NULL ) : 0 );
   hb_itemRelease( pFILE );
}else{
   sw=put_error((PHB_ITEM) pRET, "EXIST INNER-STACK OVERFLOW",101);
}
return sw;
}

int fun_exist_dir(){
int sw=1;
if( CADDR < nSizeStack ){
   PHB_ITEM pFILE = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // archivo
   CADDR += SWKEEP; SWKEEP = 0;
   const char * szFile = hb_itemGetCPtr( pFILE );
   struct stat sb;

   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (stat(szFile, &sb) == 0 && S_ISDIR(sb.st_mode) ));
   hb_itemRelease( pFILE );
}else{
   sw=put_error((PHB_ITEM) pRET, "EXISTDIR INNER-STACK OVERFLOW",101);
}

return sw;
}

/* PARSER Y UNPARSER DE EXPRESIONES HTML */
                              
int fun_doParser(){
int sw=1;
if(CADDR>=4){
   PHB_ITEM pUNICO   = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // indica 0=ONLYTAG tag; 1=NORMALTAG
   PHB_ITEM pCONTENT = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // contenido del tag. Acepta ""
   PHB_ITEM pATTRIBS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // contenido de atributos. Acepta ""
   PHB_ITEM pNAME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // nombre del tag
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pCONTENT) && HB_IS_STRING(pATTRIBS) && HB_IS_STRING(pNAME) ){
      const char* cName    = hb_itemGetCPtr(pNAME);
      const char* cContent = hb_itemGetCPtr(pCONTENT);
      const char* cAttribs = hb_itemGetCPtr(pATTRIBS);
      int nUnicoTag = hb_itemGetNI(pUNICO);

      long nLenAttr = hb_itemGetCLen(pATTRIBS);
      long nLen = hb_itemGetCLen(pCONTENT);
      long nLenName = hb_itemGetCLen(pNAME);
      char* cTemp = (char*)calloc( nLenAttr + nLenName + nLenName + nLen + 50, 1);
      memset(cTemp,0,nLenAttr + nLenName + nLenName + nLen + 50);  // relleno con 0.
      memcpy(cTemp,"<",1);

      memcpy(cTemp + 1,cName,nLenName);
      
      int spc = 1;
      if( nLenAttr > 0 ){  // hay atributos
         memcpy(cTemp + 1 + nLenName," ",1);
         spc=2;
      }
      memcpy(cTemp + nLenName + spc,cAttribs,nLenAttr);
      int lcTemp = 0;
      
     // verificar si es un unico tag y añadieron contenido:
      if(nLen && nUnicoTag) nLen=0;  // anula el contenido
       
      if(!nLen){      // es etiqueta vacía, sin contenido?
         if(nUnicoTag){        // del tipo <nombre [attrib]/>
            memcpy(cTemp + nLenName + spc + nLenAttr,"/>",2);
            cTemp[nLenName + spc + 2 + nLenAttr]='\0';
         }else{           // del tipo <nombre [attrib]>
            memcpy(cTemp + nLenName + spc + nLenAttr,">",1);
         }
      }else{                                // tiene contenidos
         memcpy(cTemp + nLenName + spc + nLenAttr,">",1);
         memcpy(cTemp + nLenName + spc + 1 + nLenAttr,cContent,nLen);
      }
      if(!nUnicoTag){  // añado cierre de tag
         memcpy(cTemp + nLenName + spc + 1 + nLenAttr + nLen,"</",2);
         memcpy(cTemp + nLenName + spc + 3 + nLenAttr + nLen,cName,nLenName);
         memcpy(cTemp + nLenName + spc + 3 + nLenAttr + nLen + nLenName,">",1);
         cTemp[nLenName + spc + 4 + nLenAttr + nLen + nLenName]='\0';
      }

      long nItem = STK_PRG[++CP];
      PHB_ITEM pVARS = hb_itemArrayGet(pSTK_REG,nItem);  // VAR STRING DE PARSEO
      long nLenVar = hb_itemGetCLen(pVARS);
      const char* cVarStr = hb_itemGetCPtr(pVARS);
      hb_itemRelease(pVARS);
      
      lcTemp = strlen( cTemp );
      char* cStrFinal=(char*)calloc( lcTemp + nLenVar + 1, 1 );
      memset(cStrFinal,0,lcTemp + nLenVar + 1);
      memcpy(cStrFinal, cVarStr, nLenVar );        // concateno nuevo registro a var existente.
      memcpy(cStrFinal + nLenVar, cTemp, lcTemp);
      cStrFinal[nLenVar+lcTemp]='\0';
      const char* cBuffer = cStrFinal;
      hb_arraySetC( pSTK_REG, nItem, (const char *)  cBuffer );
      free(cStrFinal);
      free(cTemp);

   }else{
      sw=put_error((PHB_ITEM) pRET, "PARSER - ARGUMENT ERROR",103);
   }
   hb_itemRelease(pCONTENT);
   hb_itemRelease(pATTRIBS);
   hb_itemRelease(pNAME);
   hb_itemRelease(pUNICO);
}else{
   sw=put_error((PHB_ITEM) pRET, "PARSER - INNER-STACK UNDERFLOW",102);
}
return sw;
}

/* UNPARSER 
   Requisitos: debe ser un campo con o sin atributos, y puede o no tener contenidos.
   Asimismo, puede ser un campo del tipo <field/> o <field attr=valor...>
   Además, no deben existir campos anidados con el mismo nombre.
   */
int fun_unparser(){
int sw=1;
if(CADDR)
{
   PHB_ITEM pNAME = hb_itemArrayGet( pSTK_ADDR, CADDR-- );  // nombre del campo. Debe ser simple, sin atributos.
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pNAME) )
   {
      const char* cName    = hb_itemGetCPtr(pNAME);
      long nLenName = hb_itemGetCLen(pNAME);
     // obtengo variable que contiene HTML 
      long nItem = STK_PRG[++CP];
      PHB_ITEM pVARS = hb_itemArrayGet(pSTK_REG,nItem);  // VAR STRING DE PARSEO
      long nLenVar = hb_itemGetCLen(pVARS);
      const char* cVarStr = hb_itemGetCPtr(pVARS);
      hb_itemRelease(pVARS);
     //
      char* cField = (char*)calloc(nLenName + 100,1); // campo a buscar. Podría incluir lista de atributos
      memset(cField,0,nLenName + 100);
      memcpy(cField,"<",1);                // armamos el campo a buscar en cVarStr
      memcpy(cField + 1,cName,nLenName);
      memcpy(cField + 1 + nLenName,">",1);
      cField[nLenName + 2]='\0';       // "<field>"
      int es_vacio=0;
      int tieneAtrib=0;
      char* iniF = strstr(cVarStr,cField);  // primera ocurrencia del campo
      char* atributos=(char*)calloc(100,1);   // por si encuentra atributos más adelante.
      int ctaAtrib=0;        // para saber cuántos atributos hay en el campo, de existir.
      if (iniF==NULL)
      {  // no lo encontró. Puede ser un campo solitario.
         cField[nLenName + 1]='/';cField[nLenName + 2]='>';cField[nLenName + 3]='\0';  // "<field/>"
         iniF = strstr(cVarStr,cField);   // busco otra vez.
         if(iniF==NULL)
         {  // no lo encontró. Podría ser un tag con atributos...
            cField[nLenName + 1]=' ';cField[nLenName + 2]='\0';  // "<field "
            iniF = strstr(cVarStr,cField);   // busco otra vez.
            if(iniF==NULL)
            {
               sw=put_error((PHB_ITEM) pRET, "UNPARSER - MISSING FIELD",124);
            }
            else
            {  // tiene atributos
               tieneAtrib=1;
               // debo completar el campo, para incluir los atributos, y luego, obtenerlos afuera
               char* tiniF = iniF + strlen(cField);
               int i = nLenName + 2;
               int j=0;
               do
               {  // busca por el final del tag
                  cField[i] = *tiniF;
                  if(*tiniF!='/' && *tiniF!='>')   // solo necesito el contenido, no el campo completo.
                  {
                     atributos[j] = *tiniF; j++;
                  }
                  if(*tiniF=='=') ctaAtrib++;
                  tiniF++; i++;
               }
               while(*tiniF!='>');

               atributos[j]='\0';  // aqui solo debería tener la lista de atributos.

               if(*tiniF=='>') {cField[i] = *tiniF; i++;} // el rezagado.
               cField[i]='\0';
             //  printf("\nCFIELD = %s, i=%d,cfield[i-2]=%c\n",cField,i,cField[i-2]);
               if(cField[i-2]=='/')
               {  // es un tag unico.
                  es_vacio=1;
                  hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "" ); // devuelve al stack un string nulo
               }
            }
         }
         else
         {
            es_vacio=1;
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "" ); // devuelve al stack un string nulo
         }
      }
      // procesar la salida.
      if(sw)
      {
         if(!es_vacio)
         {  // obtengo el contenido
            char* tiniF = iniF;   // rescato posicion original del campo.
            tiniF += strlen(cField); // ubico en el inicio del contenido
            // armo el final del campo:
            char* cFieldEnd = (char*)calloc(nLenName + 100,1); // campo a buscar
            memset(cFieldEnd,0,nLenName + 100);
            memcpy(cFieldEnd,"</",2);
            memcpy(cFieldEnd + 2,cName,nLenName);
            memcpy(cFieldEnd + 2 + nLenName,">",1);
            cFieldEnd[nLenName + 3]='\0';
            //busco campo final! Primera ocurrencia.
            char* iniFE = strstr(cVarStr,cFieldEnd);
            int porcion = iniFE - tiniF;
            //armo string de contenido y guardo en Stack
          //  printf("\nPORCION=%d\n",porcion);
            if(porcion>0){
               char* cFieldContent = (char*)calloc(porcion + 1,1);
               memset(cFieldContent,0,porcion + 1);
               memcpy(cFieldContent,tiniF,porcion);
               cFieldContent[porcion]='\0';
               const char* cBuffer = cFieldContent;
             //  printf("\nBUFFER=%s\n",cBuffer);
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  cBuffer ); // devuelve al stack
               free(cFieldContent);
            }else{
               hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  "" ); // devuelve al stack un string nulo
            }
            //borro "porcion" de la variable cVarStr:
         //   printf("\nPASO!\nENTRA A PREPARAR VARIABLE");
            char* cNewVar = (char*)calloc(nLenVar + 10, 1); // preparo nueva variable
            memset(cNewVar,0,nLenVar+10);
            porcion = iniF-cVarStr;
            int i=0;
            while(porcion--)
            {
               cNewVar[i] = cVarStr[i];i++;
            }
            char* final = iniFE + strlen(cFieldEnd);
            while(*final)
            {
               cNewVar[i] = *final; final++;i++;
            }
            cNewVar[i]='\0';
            const char* cBufferNew = cNewVar;
            hb_arraySetC( pSTK_REG, nItem, (const char *)  cBufferNew );
            free(cNewVar);
            
            free(cFieldEnd);
         //   printf("\nPASO!\nSALE!");
         }
         else
         {
            //borro "porcion" de la variable cVarStr:
            char* cNewVar = (char*)calloc(nLenVar + 10, 1);
            memset(cNewVar,0,nLenVar+10);
            int porcion = iniF-cVarStr;
            int tp = porcion;
            int i=0;
            while(porcion--)
            {
               cNewVar[i] = cVarStr[i];i++;
            }
            const char* final = cVarStr + ( tp + strlen(cField));
            while(*final)
            {
               cNewVar[i] = *final; final++;i++;
            }
            cNewVar[i]='\0';
            
            const char* cBufferNew = cNewVar;
            hb_arraySetC( pSTK_REG, nItem, (const char *)  cBufferNew );
            free(cNewVar);
         }
      }
      free(cField);
      // procesar lista de atributos.
      if(tieneAtrib)
      {  // obtiene los atributos y guardo en array, y el resto del proceso queda igual
         if(ctaAtrib)
         {  // puede que se escribió: <field >, o <field />: debe dejar pasar como campo normal.
            PHB_ITEM pARRATR = hb_itemArrayNew(ctaAtrib);
            int i=0;
            int indArray=0;
          //  printf("\nENTRA A ATRIBUTOS DESDE: %s",atributos);
            while(atributos[i]!='\0')
            {
               if(atributos[i]==' ') {i++;continue;}  // salte los espacios en blanco.
               if(atributos[i]=='=')  // encontré un valor.
               {
                  i++;  // avanzo, y veo qué tiene: numero, string, u otra cosa.
               //   printf("\nENTRA A GUARDAR VALOR");
                  while(atributos[i]!='\0' && atributos[i]==' ') i++;   // quita espacios en blanco.
                  int j=0;
                  char* cValor = (char*)calloc(100, 1);
                  if(atributos[i]==34)  // hay un string.
                  {
                     i++;    // no guarda comillas.
                     do{
                        cValor[j] = atributos[i];  // guardo todo lo que hay dentro de la cadena.
                        i++; j++;
                     }while(atributos[i]!='\0' && atributos[i]!=34);
                  }else{   // es otra cosa. Termina con espacio en blanco.
                     do{
                        cValor[j] = atributos[i];  // guardo todo lo que hay hasta espacio en blanco.
                        i++; j++;
                     }while(atributos[i]!='\0' && atributos[i]!=' ');
                  }
                  cValor[j]='\0';
              //    printf("\nVALOR OBTENIDO: %s",cValor);
                  // guarda en array:
                  ++indArray;
                  const char* cBuffer = cValor;
                  hb_arraySetC(pARRATR, indArray, (const char*) cBuffer);
                  free(cValor);
               }
               i++;
            }
          //  printf("\nSALE DE ATRIBUTOS");
            // guardo en stack, a continuación del contenido.
            hb_arraySet( pSTK_ADDR, ++CADDR, (PHB_ITEM)pARRATR );
            hb_itemRelease(pARRATR);
         }
      }
      free(atributos);
   }
   else
   {
      sw=put_error((PHB_ITEM) pRET, "UNPARSER - ARGUMENT ERROR",103);
   }
   hb_itemRelease(pNAME);
}
else
{
   sw=put_error((PHB_ITEM) pRET, "UNPARSER - INNER-STACK UNDERFLOW",102);
}
return sw;
}

/* REGEX */

#define MAX_ERROR_MSG  0x1000
#define TOPE_REGEX     15
#include <regex.h>

int aIndexREGEX=-1;
static regex_t aREGEX[TOPE_REGEX];
int validREGEX[TOPE_REGEX];

int fun_regcompile(){
int sw=1;
if(CADDR>=2){
  int error;
  ///char pattern[1024];
  //regex_t compiled_pattern;
//  PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
  PHB_ITEM pPATTERN = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PATRON
  PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
  CADDR += SWKEEP; SWKEEP = 0;
  if( HB_IS_STRING(pPATTERN) && HB_IS_NUMERIC(pFLAGS)){
     long nLenPat = hb_itemGetCLen(pPATTERN);
     ///long nLenStr = hb_itemGetCLen(pSTRING);
     if (nLenPat){
        const char* cPattern = hb_itemGetCPtr(pPATTERN);
        int nFlags = hb_itemGetNI(pFLAGS);
        ++aIndexREGEX;
        if(aIndexREGEX>=TOPE_REGEX){  // buscar alguno que haya sido eliminado
           int i;
           for(i=0;i<TOPE_REGEX;i++){
              if(!validREGEX[i]){
                 aIndexREGEX=i;
                 break;
              }
           }
        }
        if(aIndexREGEX>=0 && aIndexREGEX<TOPE_REGEX){
           //aREGEX[aIndexREGEX]=malloc(sizeof(regex_t));
           validREGEX[aIndexREGEX]=1;
           error = regcomp(&(aREGEX[aIndexREGEX]), cPattern, nFlags);
         //  printf("\nERROR= %d\n",error);
           if (error==0) {  // compiló bien. Ahora, a validar!
           //   printf("\nQUE HAY = %d\n",aREGEX[aIndexREGEX].re_nsub);
              long nItem = STK_PRG[++CP];
              //aREGEX[aIndexREGEX] = //(regex_t)malloc(sizeof(regex_t));
              ///aREGEX[aIndexREGEX] = compiled_pattern;
              hb_arraySetNI( pSTK_REG, nItem, (int)  aIndexREGEX );
           }else{
              validREGEX[aIndexREGEX]=0;
              char error_message[MAX_ERROR_MSG];
              char* ERROR = (char*)calloc(MAX_ERROR_MSG,1); 
              regerror (error, &aREGEX[aIndexREGEX], error_message, MAX_ERROR_MSG);
	      memcpy(ERROR,"REGCOMPILE COMPILATION ERROR: ",30);
	      memcpy(ERROR + 30,error_message,strlen(error_message));
              sw=put_error((PHB_ITEM) pRET, ERROR,error);
              free(ERROR);
           }
        }else{
           sw=put_error((PHB_ITEM) pRET, "REGCOMPILE #PATTERN OVERFLOW",129);
        }
     }else{
        sw=put_error((PHB_ITEM) pRET, "REGCOMPILE PATTERN MUST BE NOT NULL|0",127);
     } 
  }else{
     sw=put_error((PHB_ITEM) pRET, "REGCOMPILE ARGUMENT TYPE ERROR",103);
  }
  hb_itemRelease(pPATTERN);
//  hb_itemRelease(pSTRING);
  hb_itemRelease(pFLAGS);
}else{
  sw=put_error((PHB_ITEM) pRET, "REGCOMPILE STACK UNDERFLOW",102); 
}
return sw;
}

int fun_regfree(){
int sw=1;
long nItem = STK_PRG[++CP];
PHB_ITEM pVARS = hb_itemArrayGet(pSTK_REG,nItem);  // VAR INDICE REGEX
int nIndex = hb_itemGetNI(pVARS);
hb_itemRelease(pVARS);
if( (nIndex >= 0 && nIndex < TOPE_REGEX) ){
   if(validREGEX[nIndex]){
      regfree(&aREGEX[nIndex]);
      validREGEX[nIndex]=0;
   }  // no hace nada.
}else{
   sw=put_error((PHB_ITEM) pRET, "REGFREE INDEX REGEX ERROR",130);
}
return sw;
}

int fun_regvalid(){
int sw=1;
if(CADDR>=3){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
   PHB_ITEM pINDEX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // INDICE
   PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
   CADDR += SWKEEP; SWKEEP = 0;
   int swREGEX=0;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   if(HB_IS_STRING(pSTRING)) {
      swREGEX=1;
   }else if(HB_IS_ARRAY(pSTRING)){
      get_size( (PHB_ITEM) pSTRING, &nDim, &d1, &d2, &d3, &type);
      if (type==10 && nDim==1){
         swREGEX=2;
      }
   }
   if( (HB_IS_STRING(pSTRING) || HB_IS_ARRAY(pSTRING)) && HB_IS_NUMERIC(pINDEX) && HB_IS_NUMERIC(pFLAGS)){
      int nIndex = hb_itemGetNI(pINDEX);
      if( nIndex>=0 && nIndex<=aIndexREGEX ){
      /// verificar indice
         if(validREGEX[nIndex]){
            int nFlags = hb_itemGetNI(pFLAGS);
            
            if(swREGEX==1){
               const char* test_pattern = hb_itemGetCPtr(pSTRING);
               int   error = regexec(&aREGEX[nIndex], test_pattern, (size_t) 0, NULL, nFlags);
               if (error == 0) {
                  hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
               } else if (error == REG_NOMATCH) {
                  hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
               } else {
                  hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
               }
            }else if(swREGEX==2){
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               PHB_ITEM retArray = hb_itemArrayNew(0);
               int i;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pITEMSTR = hb_itemArrayGet( pSTRING, i);
                  const char* test_pattern = hb_itemGetCPtr(pITEMSTR);
                  int   error = regexec(&aREGEX[nIndex], test_pattern, (size_t) 0, NULL, nFlags);
                  if (error == 0) {
                     hb_arrayAdd(retArray,pITEMSTR);
                     hb_arraySetNI(pRows, i, (int) 1);
                  } else if (error == REG_NOMATCH) {
                     hb_arraySetNI(pRows, i, (int) 0);
                  } else {
                     hb_arraySetNI(pRows, i, (int) 0);
                  }
                  hb_itemRelease(pITEMSTR);
               }
               hb_arraySet(pSTK_ADDR, ++CADDR, retArray);
               hb_arraySet(pSTK_ADDR, ++CADDR, pRows);
               hb_itemRelease(pRows);
               hb_itemRelease(retArray);
            }else{
               sw=put_error((PHB_ITEM) pRET, "REGVALID STRING|ARRAY 1D STRING EXPECTED",103);
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REGVALID COMPILATION NOT EXIST",131);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "REGVALID #PATTERN OVERFLOW",129);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "REGVALID ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pINDEX);
   hb_itemRelease(pSTRING);
   hb_itemRelease(pFLAGS);
}else{
   sw=put_error((PHB_ITEM) pRET, "REGVALID STACK UNDERFLOW",102); 
}
return sw;
}

int fun_regmatch(){
int sw=1;
if(CADDR>=4){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
   PHB_ITEM pINDEX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // INDICE
   PHB_ITEM pNMATCHES = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // N-MATCHES
   PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
   CADDR += SWKEEP; SWKEEP = 0;
   if( HB_IS_STRING(pSTRING) && HB_IS_NUMERIC(pNMATCHES) && HB_IS_NUMERIC(pINDEX) && HB_IS_NUMERIC(pFLAGS)){
      int nIndex = hb_itemGetNI(pINDEX);
      if( nIndex>=0 && nIndex<=aIndexREGEX ){
      /// verificar indice
         if(validREGEX[nIndex]){
            int nFlags = hb_itemGetNI(pFLAGS);
            int n_matches = hb_itemGetNI(pNMATCHES);
            regmatch_t m[n_matches];
            
            const char* to_match = hb_itemGetCPtr(pSTRING);
            const char * p = to_match;
            PHB_ITEM retArray = hb_itemArrayNew(0);
            int swBucle=1;
            while (swBucle) {
               int i = 0;
               int nomatch = regexec (&aREGEX[nIndex], p, n_matches, m, nFlags);
               //printf("pasa por aqui: %d\n",nomatch);
               if (nomatch) {
                  hb_arraySet(pSTK_ADDR, ++CADDR, retArray);
                  hb_itemRelease(retArray);
                  break;
               }else{
                  for (i = 0; i < n_matches; i++) {
                     //printf("---FOR---pasa por aqui: %d\n",i);
                     
                     int start;
                     int finish;
                     if (m[i].rm_so == -1) {
                        //if(i==0) swBucle=0;
                        break;
                     }
                     start = m[i].rm_so + (p - to_match);
                     finish = m[i].rm_eo + (p - to_match);
                     ///printf("start=%d, finish=%d\n",start,finish);
                     if(finish && start){
                        PHB_ITEM pRows = hb_itemArrayNew(3);
                        hb_arraySetNI(pRows,1,start+1);
                        hb_arraySetNI(pRows,2,finish);
                        char* buffer = (char*)calloc((finish - start) + 1, 1);
                        sprintf(buffer, "%.*s",(finish - start),to_match + start);
                        const char* cBuffer = buffer;
                        hb_arraySetC(pRows,3,cBuffer);
                        free(buffer);
                        hb_arrayAdd(retArray,pRows);
                        hb_itemRelease(pRows);
                     }else{
                        hb_arraySet(pSTK_ADDR, ++CADDR, retArray);
                        hb_itemRelease(retArray);
                        swBucle=0;
                        break;
                     }
                  }
               }
               p += m[0].rm_eo;
               //if(++swBucle==3) break;
            }
         }else{
            sw=put_error((PHB_ITEM) pRET, "REGMATCH COMPILATION NOT EXIST",131);
         }
      }else{
         sw=put_error((PHB_ITEM) pRET, "REGMATCH #PATTERN OVERFLOW",129);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "REGMATCH ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pINDEX);
   hb_itemRelease(pSTRING);
   hb_itemRelease(pNMATCHES);
   hb_itemRelease(pFLAGS);
}else{
   sw=put_error((PHB_ITEM) pRET, "REGMATCH STACK UNDERFLOW",102); 
}
return sw;
}

/*int fun_regmatch(){
int sw=1;
if(CADDR>=3){
   
   PHB_ITEM pSTRING = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // STRING
   PHB_ITEM pPATTERN = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // PATRON
   PHB_ITEM pFLAGS = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // FLAGS
   if( HB_IS_STRING(pSTRING) && HB_IS_STRING(pPATTERN) && HB_IS_NUMERIC(pFLAGS)){
      //int nIndex = hb_itemGetNI(pINDEX);
      //if( nIndex>=0 && nIndex<=aIndexREGEX ){
      regex_t patron_compilado[5];   
      //int nFlags = REG_NOSUB;
      int nFlags = hb_itemGetNI(pFLAGS);
         
         const char* cPatron = hb_itemGetCPtr(pPATTERN);
         //char* test_pattern = (char*)calloc(1024,1);
         //memset(test_pattern,0,1024);
         const char* test_pattern = hb_itemGetCPtr(pSTRING);
//         char txt[strlen(test_pattern)+1];
//         memcpy(txt,test_pattern,strlen(test_pattern));
//         txt[strlen(test_pattern)]='\0';
//         printf("\n%s, -- HAY = %d\n",test_pattern,aREGEX[nIndex].re_nsub);
         int error = regcomp(&patron_compilado[0], cPatron, nFlags);
         if(error!=0){
              char error_message[MAX_ERROR_MSG];
              char* ERROR = (char*)calloc(MAX_ERROR_MSG+100,1); 
              regerror (error, &patron_compilado[0], error_message, MAX_ERROR_MSG);
	      memcpy(ERROR,"REGVALID COMPILATION ERROR: ",28);
	      memcpy(ERROR + 28,error_message,strlen(error_message));
              sw=put_error((PHB_ITEM) pRET, ERROR,error);
              free(ERROR);
         }else{
            error = regexec(&patron_compilado[0], test_pattern, (size_t) 0, NULL, 0);
            if (error == 0) {
               hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 1);
            } else if (error == REG_NOMATCH) {
               hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) 0);
            } else {
               hb_arraySetNI(pSTK_ADDR, ++CADDR, (int) -1);
            }
         }
         regfree(&patron_compilado[0]);
      //}else{
      //   sw=put_error((PHB_ITEM) pRET, "REGVALID #PATTERN OVERFLOW",129);
      //}
   }else{
      sw=put_error((PHB_ITEM) pRET, "REGVALID ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pPATTERN);
   hb_itemRelease(pSTRING);
   hb_itemRelease(pFLAGS);
}else{
   sw=put_error((PHB_ITEM) pRET, "REGVALID STACK UNDERFLOW",102); 
}
return sw;
}*/


/************************/

int returnProgram(){
int sw=1;
              HB_MAXINT nDim=0,d1=0,d2=0,d3=0/*,d4=0*/,type=0;
              if (CADDR>0){
                 PHB_ITEM pSource = hb_itemArrayGet( pSTK_ADDR, CADDR--);
                 PHB_ITEM pTemp = pSource;
                 
                 // evaluacion de resultado escalar. Después: arrays
                 
                 if( HB_IS_ARRAY( pSource ) ){   // es un ARRAY
                     get_size( (PHB_ITEM) pSource, &nDim, &d1, &d2, &d3, &type); 
                     hb_arraySet( pRET, 1, (PHB_ITEM) pTemp );//pTemp );   // asigna puntero a pRET.
                     switch(type){
                        case 10: hb_arraySetC( pRET, 2, (const char *)  "AC"  ); break;
                        case 11: hb_arraySetC( pRET, 2, (const char *)  "AN"  ); break;
                        case 12: hb_arraySetC( pRET, 2, (const char *)  "AL"  ); break;
                     }
                 }else{
                      get_item_type( (PHB_ITEM) pSource, &type);
                      switch( type ){
                          case 10: {   // string
                              const char * pString = hb_itemGetCPtr( pSource );
                              hb_arraySetC( pRET, 1, (const char *)  pString  );
                              hb_arraySetC( pRET, 2, (const char *)  "C"  );
                              break;
                          }case 11: {  // numint
                              HB_MAXINT pNum = hb_itemGetNInt( pSource );
                              hb_arraySetNInt( pRET, 1, (HB_MAXINT)  pNum  );
                              hb_arraySetC( pRET, 2, (const char *)  "N"  );
                              break;
                          }case 12: {  // double
                              double pDbl = hb_itemGetND( pSource );
                              hb_arraySetND( pRET, 1, (double) pDbl );
                              hb_arraySetC( pRET, 2, (const char *)  "N"  );
                              break;
                          }case 13: {  // long
                              long pLong = hb_itemGetNL( pSource );
                              hb_arraySetNL( pRET, 1, (long) pLong );
                              hb_arraySetC( pRET, 2, (const char *)  "N"  ); 
                              break;
                        /*  }case 14: {   // logical
                              HB_BOOL pBool = hb_itemGetL( pSource );
                              hb_arraySetL( pRET, 1, (HB_BOOL) pBool ) ;
                              hb_arraySetC( pRET, 2, (const char *)  "L"  );
                              break;*/
                          }
                      }
                 }
                 hb_arraySetNInt( pRET, 3, (HB_MAXINT)  nDim  );
                 hb_arraySetNInt( pRET, 4, (HB_MAXINT)  d1  );
                 hb_arraySetNInt( pRET, 5, (HB_MAXINT)  d2  );
                 hb_arraySetNInt( pRET, 6, (HB_MAXINT)  d3  );
                 //hb_arraySetNInt( pRET, 7, (HB_MAXINT)  0  );
                 sw = 0;
                 hb_itemRelease(pSource);
              }else{    // ERROR!!!
                 sw=put_error((PHB_ITEM) pRET, "RET STACK UNDERFLOW",102); 
              }
return sw;
}

int fun_assert(){
int sw=1;
if(CADDR){
   PHB_ITEM pASSERT = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   CADDR += SWKEEP; SWKEEP = 0;
   int bAssert = hb_itemGetNI( pASSERT );
   hb_itemRelease(pASSERT);
   int nItem = STK_PRG[++CP];
   PHB_ITEM pMESS=hb_itemArrayGet( pSTK_REG, nItem);
   const char * pString = hb_itemGetCPtr( pMESS );
   int cLen = hb_itemGetCLen(pMESS);
   hb_itemRelease(pMESS);
   char mensajeErr[150];
   memset(mensajeErr,0,150);
   memcpy(mensajeErr,"ASSERT: ",8);
   memcpy(mensajeErr+8,pString,cLen);
   mensajeErr[cLen+8+1]='\0';
   
   if( !bAssert )
      sw=put_error((PHB_ITEM) pRET, mensajeErr,300); 
   
}else{
   sw=put_error((PHB_ITEM) pRET, "ASSERT STACK UNDERFLOW",102); 
}

return sw;
}

int fun_getserror(){
int sw=1;
if(CADDR<=nSizeStack){
   PHB_ITEM pSTRERR = hb_itemArrayGet( pRET, 2);
   const char* strError = hb_itemGetCPtr(pSTRERR);
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *)  strError  );
   hb_itemRelease(pSTRERR);
}else{
   sw=put_error((PHB_ITEM) pRET, "GETESTRRROR STACK UNDERFLOW",102);
}   
return sw;
}

int put_argcnt(){
int sw=1;
if(CADDR<nSizeStack)
   hb_arraySetNInt( pSTK_ADDR, ++CADDR, (unsigned int) LENDS );
else
   sw=put_error((PHB_ITEM) pRET, "TOTALARG STACK UNDERFLOW",102); 
return sw;
}

int fun_clamp_matrix( PHB_ITEM pINICIAL, PHB_ITEM pFINAL, PHB_ITEM pVAR ) {
int sw=1;
   HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
   get_size( (PHB_ITEM) pVAR, &nDim, &d1, &d2, &d3, &type);
   if (type==11){
   switch( nDim ){
      case 1:{
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         int i;
         for (i=1; i<=d1; i++ ){
            PHB_ITEM pARG1 = hb_itemArrayGet( pVAR, i);
            double nVar = hb_itemGetND(pARG1);
            hb_itemRelease(pARG1);
            if( nVar>nFinal )
               hb_arraySetNL( pVAR, i, (HB_LONGLONG) nFinal );
            else if( nVar<nInicial)
               hb_arraySetNL( pVAR, i, (HB_LONGLONG) nInicial );
         }
         break;
      }case 2:{
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pVAR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               double nVar = hb_itemGetND(pARG11);
               hb_itemRelease(pARG11);
               if( nVar>nFinal )
                  hb_arraySetNL( pARG1, j, (HB_LONGLONG) nFinal );
               else if( nVar<nInicial)
                  hb_arraySetNL( pARG1, j, (HB_LONGLONG) nInicial );
               
            }
            hb_itemRelease(pARG1);
         }
         break;
      }case 3:{
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         int i;
         for( i=1; i<=d1; i++){
            PHB_ITEM pARG1 = hb_itemArrayGet( pVAR, i);
            int j;
            for( j=1; j<=d2; j++){
               PHB_ITEM pARG11 = hb_itemArrayGet( pARG1, j);
               int k;
               for( k=1; k<=d3; k++){
                  PHB_ITEM pARG111 = hb_itemArrayGet( pARG11, k);
                  double nVar = hb_itemGetND(pARG111);
                  hb_itemRelease(pARG111);
                  if( nVar>nFinal )
                     hb_arraySetNL( pARG11, k, (HB_LONGLONG) nFinal );
                  else if( nVar<nInicial)
                     hb_arraySetNL( pARG11, k, (HB_LONGLONG) nInicial );

               }
               hb_itemRelease(pARG11);
            }
            hb_itemRelease(pARG1);
         }
         break;
      }default:{
         sw=0;
      }
   }
   }else{
      sw=0;
   }
return sw;
}

int fun_clamp(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pFINAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // final
   PHB_ITEM pINICIAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // inicial
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pVAR=hb_itemArrayGet( pSTK_REG, nItem);
   
   if( HB_IS_NUMERIC(pFINAL) && HB_IS_NUMERIC(pINICIAL) ){
      if( HB_IS_NUMERIC(pVAR) ){
         double nVar = hb_itemGetND( pVAR );
         double nFinal = hb_itemGetND( pFINAL );
         double nInicial = hb_itemGetND( pINICIAL );
         if( nVar>nFinal )
            hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pFINAL );
         else if( nVar<nInicial)
            hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pINICIAL );
      }else if(HB_IS_ARRAY(pVAR)){
         sw=fun_clamp_matrix( (PHB_ITEM) pINICIAL, (PHB_ITEM) pFINAL, (PHB_ITEM)pVAR );
      }else{
         sw=put_error((PHB_ITEM) pRET, "CLAMP TARGET ARGUMENT TYPE ERROR",103);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "CLAMP RANGE ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pVAR);
   hb_itemRelease(pFINAL);
   hb_itemRelease(pINICIAL);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLAMP STACK UNDERFLOW",102); 
}
return sw;
}

/*int fun_clamp(){
int sw=1;
if(CADDR>=2){
   PHB_ITEM pFINAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // final
   PHB_ITEM pINICIAL = hb_itemArrayGet( pSTK_ADDR, CADDR--); // inicial
   CADDR += SWKEEP; SWKEEP = 0;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pVAR=hb_itemArrayGet( pSTK_REG, nItem);
   if( HB_IS_NUMERIC(pVAR) && HB_IS_NUMERIC(pFINAL) && HB_IS_NUMERIC(pINICIAL) ){
      double nVar = hb_itemGetND( pVAR );
      double nFinal = hb_itemGetND( pFINAL );
      double nInicial = hb_itemGetND( pINICIAL );
      if( nVar>nFinal )
         hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pFINAL );
      else if( nVar<nInicial)
         hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pINICIAL );
         
   }else{
      sw=put_error((PHB_ITEM) pRET, "CLAMP ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pVAR);
   hb_itemRelease(pFINAL);
   hb_itemRelease(pINICIAL);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLAMP STACK UNDERFLOW",102); 
}
return sw;
}*/
int fun_fill_box(){
int sw=1;
if(CADDR>=3){
   PHB_ITEM pANCHO = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pALTO = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pCHAR = hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   
   HB_SIZE nAncho = hb_itemGetNI( pANCHO );
   HB_SIZE nAlto = hb_itemGetNI( pALTO );
   
   const char * cChar = hb_itemGetCPtr(pCHAR);
   char * space = (char *)calloc(nAncho*3+1,1);
   HB_SIZE i=0;
   for (i = 0; i<nAncho; ++i){
      //space[i]=cChar[0];
      strcat(space,cChar);
   }
   //space[nAncho]='\0';
   int nRow = SCREEN_ROW;
   
   for (i=1; i<=nAlto; ++i){
      printf("\033[%d;%dH%s",nRow++,SCREEN_COL,space);
   }
   SCREEN_ROW = nRow;
   free(space);
   hb_itemRelease(pCHAR);
   hb_itemRelease(pANCHO);
   hb_itemRelease(pALTO);
}else{
   sw=put_error((PHB_ITEM) pRET, "CLRBOX STACK UNDERFLOW",102); 
}
return sw;
}

int fun_cposx(){
  int nItem = STK_PRG[++CP];
  PHB_ITEM pSCRROW = hb_itemPutNInt( NULL, (int) SCREEN_ROW );
  hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSCRROW );
  hb_itemRelease(pSCRROW);
return 1;
}
int fun_cposy(){
  int nItem = STK_PRG[++CP];
  PHB_ITEM pSCRCOL = hb_itemPutNInt( NULL, (int) SCREEN_COL );
  hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSCRCOL );
  hb_itemRelease(pSCRCOL);
return 1;
}

int fun_updateCol(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor a sumar-restar columna
   int nPosy = hb_itemGetNI( pPOSY );
   hb_itemRelease(pPOSY);
   SCREEN_COL = SCREEN_COL + nPosy;
   printf("\033[%d;%dH",SCREEN_ROW,SCREEN_COL);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "UPDATE COL STACK UNDERFLOW",102); 
}
return sw;
}

int fun_updateRow(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor a sumar-restar fila
   int nPosx = hb_itemGetNI( pPOSX );
   hb_itemRelease(pPOSX);
   SCREEN_ROW = SCREEN_ROW + nPosx;
   printf("\033[%d;%dH",SCREEN_ROW,SCREEN_COL);
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "UPDATE ROW STACK UNDERFLOW",102); 
}
return sw;
}

int fun_goCol(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosy = hb_itemGetNI( pPOSY );
   hb_itemRelease(pPOSY);
   printf("\033[%d;%dH",SCREEN_ROW,nPosy);
   SCREEN_COL = nPosy;
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "GOY STACK UNDERFLOW",102); 
}
return sw;
}
int fun_goRow(){
int sw=1;
if( CADDR>=1 ){
   PHB_ITEM pPOSX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosx = hb_itemGetNI( pPOSX );
   hb_itemRelease(pPOSX);
   printf("\033[%d;%dH",nPosx,SCREEN_COL);
   SCREEN_ROW = nPosx;
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "GOX STACK UNDERFLOW",102); 
}
return sw;
}

int fun_goxy(){
int sw=1;
if( CADDR>=2 ){
   PHB_ITEM pPOSY = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosy = hb_itemGetNI( pPOSY );
   hb_itemRelease(pPOSY);
   PHB_ITEM pPOSX = hb_itemArrayGet( pSTK_ADDR, CADDR--);  // valor true o false
   int nPosx = hb_itemGetNI( pPOSX );
   hb_itemRelease(pPOSX);
   printf("\033[%d;%dH",nPosx,nPosy);
   SCREEN_ROW = nPosx;
   SCREEN_COL = nPosy;
   CADDR += SWKEEP; SWKEEP = 0;
}else{
   sw=put_error((PHB_ITEM) pRET, "GOXY STACK UNDERFLOW",102); 
}
return sw;
}

int empty_stack(){
              if( CADDR ){
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 0 );
              }else{
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) 1 );
              }
return 1;
}

/*int put_PI( PHB_ITEM pSTK_ADDR, PHB_ITEM pRET){ //, int PRECISION ){
int sw=1;
if( CADDR<nSizeStack ){
//   PHB_ITEM pSEC = hb_itemPutND( NULL, (double) 3.14159265358979323846 );
   hb_arraySetND( pSTK_ADDR, ++CADDR, (double) SW_PRECISION ? xu_funprecision(3.14159265358979323846,PRECISION) : 3.14159265358979323846 );
//   hb_itemRelease(pSEC);
}else{
   sw=put_error((PHB_ITEM) pRET, "PI INNER-STACK OVERFLOW");
}   
return sw;
}
*/
int dspush(){
int sw=1;
   int nItem = STK_PRG[++CP];
   pSTK_OBJ[++nINDEXOBJ]=hb_itemArrayGet( pSTK_REG, nItem);
/*   if(STK_PRG[CP+1]==289){
      ++CP;
      sw=dspush();
   }*/

return sw;
}
int dspop(){
int sw=1;
   int nItem = STK_PRG[++CP];
   hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSTK_OBJ[nINDEXOBJ] );
   hb_itemRelease(pSTK_OBJ[nINDEXOBJ]);
   --nINDEXOBJ;
/*   if(STK_PRG[CP+1]==290){
      ++CP;
      sw=dspop();
   }*/
//              sw=STK_PRG[CP+1]==290? dspop() : 1 ;
return sw;
}

int dstop(){
int sw=1;
if(nINDEXOBJ>=0){
   int nItem = STK_PRG[++CP];
   hb_arraySet( pSTK_REG, nItem, (PHB_ITEM) pSTK_OBJ[nINDEXOBJ] );
}else{
   sw=put_error((PHB_ITEM) pRET, "ITOP(INNER-STACK-NOT-USER) STACK UNDERFLOW",102); 
}
return sw;
}

int replicate_by(){
int sw=1;
              if ( CADDR>=1 ){
                 sw=(int)fun_replicate(/*STK_PRG[ ++CP ]*/); // TODO: DEBO ASIGNAR A VAR GLOBAL, SEGUN nPNP
              }else{
                 sw=put_error((PHB_ITEM) pRET, "REPLICATE STACK UNDERFLOW",102); 
              }
return sw;
}
int replicate(){
int sw=1;
              if ( CADDR>=2 ){
                 sw=(int)fun_replicate(/*0*/);
              }else{
                 sw=put_error((PHB_ITEM) pRET, "REPLICATE STACK UNDERFLOW",102); 
              }
return sw;
}

int fun_minusplus(){
int sw=1;
if(CADDR<nSizeStack){
   int nReg = STK_PRG[ ++CP ];
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nReg );
   int tIncDec = nPCP == 384? -1 : nPCP == 385? 1 : nPCP == 386? -2: 2;
   if( HB_IS_LONG(pSTACK)) {
      hb_arraySetNL(pSTK_ADDR, ++CADDR, (long)hb_itemGetNL(pSTACK)+tIncDec);
   }else if(HB_IS_INTEGER(pSTACK)){
      hb_arraySetNInt(pSTK_ADDR, ++CADDR, (int)hb_itemGetNInt(pSTACK)+tIncDec);
   }else if(HB_IS_DOUBLE(pSTACK)){
      hb_arraySetND(pSTK_ADDR, ++CADDR, (double)hb_itemGetND(pSTACK)+tIncDec);
   }else{
      sw=put_error((PHB_ITEM) pRET, "MINUS|PLUS ONE|TWO TYPE MISMATCH",104);
   }
   hb_itemRelease(pSTACK);
}else{
   sw=put_error((PHB_ITEM) pRET, "MINUS|PLUS ONE|TWO STACK OVERFLOW",103);
}
return sw;
}

int fun_isnumeric(){
int sw=1;
if(CADDR){
   int tCompare=nPCP==150?1:0;
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   if(!HB_IS_ARRAY(pKEY)){
      if(tCompare)
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (HB_IS_NUMERIC(pKEY) ? 1 : 0) );
      else
         hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (HB_IS_STRING(pKEY) ? 1 : 0) );
   }else{
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pKEY, &nDim, &d1, &d2, &d3, &type);
      //if (type>10){
         switch( nDim ){
            case 1:{
               PHB_ITEM pRows  = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for (i=1; i<=d1; i++ ){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pKEY, i);
                  if(tCompare)
                     hb_arraySetNI( pRows, i, (int) (HB_IS_NUMERIC(pARG22) ? 1 : 0) );
                  else
                     hb_arraySetNI( pRows, i, (int) (HB_IS_STRING(pARG22) ? 1 : 0) );
                  hb_itemRelease(pARG22);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 2:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pKEY, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     if(tCompare)
                        hb_arraySetNI( pCols, j, (int) (HB_IS_NUMERIC(pARG222) ? 1 : 0) );
                     else
                        hb_arraySetNI( pCols, j, (int) (HB_IS_STRING(pARG222) ? 1 : 0) );
                     hb_itemRelease(pARG222);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }case 3:{
               PHB_ITEM pRows = hb_itemArrayNew( d1 );
               int i;
               ++CADDR;
               for( i=1; i<=d1; i++){
                  PHB_ITEM pARG22 = hb_itemArrayGet( pKEY, i);
                  PHB_ITEM pCols = hb_itemArrayNew( d2 );
                  int j;
                  for( j=1; j<=d2; j++){
                     PHB_ITEM pARG222 = hb_itemArrayGet( pARG22, j);
                     PHB_ITEM pPag = hb_itemArrayNew( d3 );
                     int k;
                     for( k=1; k<=d3; k++){
                        PHB_ITEM pARG2222 = hb_itemArrayGet( pARG222, k);
                        if(tCompare)
                           hb_arraySetNI( pPag, k, (int) (HB_IS_NUMERIC(pARG2222) ? 1 : 0) );
                        else
                           hb_arraySetNI( pPag, k, (int) (HB_IS_STRING(pARG2222) ? 1 : 0) );
                        hb_itemRelease(pARG2222);
                     }
                     hb_arraySet( pCols, j, pPag );
                     hb_itemRelease(pARG222);
                     hb_itemRelease(pPag);
                  }
                  hb_arraySet( pRows, i, pCols );
                  hb_itemRelease(pARG22);
                  hb_itemRelease(pCols);
               }
               hb_arraySet(pSTK_ADDR, CADDR, pRows);
               hb_itemRelease(pRows);
               break;
            }default:{
               sw=0;
            }
         }
     // }else{
     //    sw=put_error((PHB_ITEM) pRET, "ISNUMERIC|STRING? TYPE MISMATCH",104);
     // }
   }
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "ISNUMERIC|STRING? STACK UNDERFLOW",102); 
}
return sw;
}

/*int fun_isstring(){
int sw=1;
if(CADDR){
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   hb_arraySetL( pSTK_ADDR, ++CADDR, (HB_BOOL) (HB_IS_STRING(pKEY) ? 1 : 0) );
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "ISSTRING? STACK UNDERFLOW",102); 
}
return sw;
}*/
int fun_isarray(){
int sw=1;
if(CADDR){
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (HB_IS_ARRAY(pKEY) ? 1 : 0) );
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "ISARRAY? STACK UNDERFLOW",102); 
}
return sw;
}
int fun_length(){
int sw=1;
if(CADDR){
   PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   CADDR += SWKEEP; SWKEEP = 0;
   int nLen=1;
   if(HB_IS_ARRAY(pKEY)){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pKEY, &nDim, &d1, &d2, &d3, &type);
      nLen *= nDim==1 ? d1 : nDim==2 ? d1*d2 : d1*d2*d3;
   }
   // si pKEY no es array, longitud=1.
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) nLen );
   hb_itemRelease(pKEY);   
}else{
   sw=put_error((PHB_ITEM) pRET, "LENGTH STACK UNDERFLOW",102); 
}
return sw;
}

int fun_seed(){
int sw=1;
   if(CADDR){
      PHB_ITEM pSEED = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
      CADDR += SWKEEP; SWKEEP = 0;
      unsigned int nSeed = hb_itemGetNI( pSEED );
      srand( nSeed ? ( unsigned ) nSeed : ( unsigned ) hb_dateMilliSeconds() );
      s_fInit = 1;
      hb_itemRelease(pSEED);
   }else{
      sw=put_error((PHB_ITEM) pRET, "SEED STACK UNDERFLOW",102);
   }
return sw;
}

int keyboard_free(){
     //fflush(stdin);
     //
     hb_inkeyReset();
     hb_inkeySetLast( 0 );  // elimina teclas presionadas
   /*  int k=1;
     while( !k ){
        k = hb_inkeyNext( hb_setGetEventMask() );
     }*/
return 1;
}
int keyboard_put(){
              if(CADDR){
                 PHB_ITEM pKEY = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
                 CADDR += SWKEEP; SWKEEP = 0;
                 hb_inkeyPut(hb_itemGetNI(pKEY));
                 hb_itemRelease(pKEY);
              }
return 1;
}
int keyboard_hit(){
              hb_inkey(0,0,128);
              if(CADDR<nSizeStack)
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (hb_inkeyLast(128)!=0) );
return 1;
}
int keyboard_ctrlc(){
              hb_inkey(0,0,128);
              if(CADDR<nSizeStack)
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (hb_inkeyLast(128)==3) );
              hb_inkeySetLast( 0 );  // borro, porque sé que es ctrl-c.
return 1;
}
int keyboard_esc(){
              hb_inkey(0,0,128);
              if(CADDR<nSizeStack)
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) (hb_inkeyLast(128)==27) );
              hb_inkeySetLast( 0 );  // borro, porque sé que es escape.
return 1;
}

int fun_lastkey(){
              //hb_inkey(0,0,128);
              //hb_arraySetNL( pSTK_REG, STK_PRG[ ++CP ], hb_inkey( 0,0,hb_setGetEventMask() ) );
              hb_arraySetNL( pSTK_REG, STK_PRG[ ++CP ], hb_inkeyLast( hb_setGetEventMask() ) );
              //hb_arraySetNL( pSTK_REG, STK_PRG[ ++CP ], getc(stdin) );
return 1;
}

int put_pausa(){
              //hb_idleState();
              hb_inkey((HB_BOOL) HB_TRUE,0,128);
return 1;
}

#define HB_MAX_UTF8        3

int fun_get_char_utf8(){
int sw=1;
if(CADDR){
   PHB_ITEM pCHAR=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   CADDR += SWKEEP; SWKEEP = 0;
   HB_WCHAR c = hb_itemGetNI( pCHAR );
   hb_itemRelease(pCHAR);

/*   int iLen;
   char utf8Char[ HB_MAX_UTF8 ];
   iLen = hb_cdpU16CharToUTF8( utf8Char, ( HB_WCHAR ) c );
   //hb_retclen( utf8Char, iLen );
   const char * chrutf8 = utf8Char;
   hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) chrutf8 );
  */ 
   switch(c){
      case 126: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "~" );
            break;

      }case 129: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "A" );
            break;

      }case 137: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "E" );
            break;

      }case 141: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "I" );
            break;

      }case 145: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "Ñ" );
            break;

      }case 147: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "O" );
            break;

      }case 154: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "U" );
            break;

      }case 160: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "à" );
            break;

      }case 161: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "á" );
            break;

      }case 164: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ä" );
            break;

      }case 168: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "è" );
            break;

      }case 169: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "é" );
            break;

      }case 171: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ë" );
            break;

      }case 172: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ì" );
            break;

      }case 173: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "í" );
            break;

      }case 175: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ï" );
            break;

      }case 176: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ù" );
            break;

      }case 177: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ñ" );
            break;

      }case 178: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ò" );
            break;

      }case 179: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ó" );
            break;

      }case 182: {
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ö" );
            break;

      }case 186: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ú" );
            break;

      }case 188: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "ü" );
            break;

      }case 191: { 
            hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) "¿" );
            break;

      }default:{
         char * cChar = (char *) calloc(10,1);
         cChar[0] = c;
         cChar[1] = '\0';
         const char *buff = cChar;
         hb_arraySetC( pSTK_ADDR, ++CADDR, (const char *) buff );
         free(cChar);
      }
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "CHRUTF8 STACK UNDERFLOW",102);
}
return sw;
}

int true_instruccion(){
              if( CADDR<nSizeStack )
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, 1 );
return 1;
}
int false_instruccion(){
              if( CADDR<nSizeStack )
                 hb_arraySetNI( pSTK_ADDR, ++CADDR, 0 );
return 1;
}
int multipass_on(){
              MULTIPASS=1;
return 1;
}
int multipass_off(){
              MULTIPASS=0;
return 1;
}

/* la variable estará en STACK; luego, sólo debo retener la direccion
   de la misma en el stack antes de la ejecucion de la orden */
int fun_pushvar(){

   PUSH_VAR = STK_PRG[++CP];

return 1;
}

int declara_puntero(){
              SW_PUNTERO=1;
return 1;
}

int clear_stack(){
int sw=1;
   CADDR=0;
   int i;
//   hb_itemRelease(pSTK_ADDR);
//   pSTK_ADDR = hb_itemArrayNew( nSizeStack );
   for(i=1; i<=nSizeStack; i++) hb_arrayDel(pSTK_ADDR,1);

   hb_itemRelease(pSTK_ADDR);
   pSTK_ADDR = hb_itemArrayNew( nSizeStack );

   hb_ret();   
   hb_gcCollect();   
   hb_idleState();
return sw;
}

int kpop(){  // kill
int sw=1;
if( CADDR>0 ){
   hb_arrayDel(pSTK_ADDR,CADDR);
 //  hb_ret();
   
 //  hb_gcCollect();
 //  hb_idleState();
   CADDR--;
}// aquí no hay "else", dado que si no hay datos, no pasa ná.
return sw;
}
int clear_var(){
int sw=1;
              int nReg = STK_PRG[ ++CP ];
             // hb_arrayDel(pSTK_REG, nReg);
             // hb_arrayIns(pSTK_REG, nReg);
             // hb_arraySetNI( pSTK_REG, nReg, (int)0 );
              if(hb_arrayDel(pSTK_REG, nReg)){
                 hb_arrayIns(pSTK_REG, nReg);
                 hb_arraySetNL( pSTK_REG, nReg, (long)0 );
              }else{
                 sw=put_error((PHB_ITEM) pRET, "CLEAR VAR NOT DELETE",104);
              }
              hb_ret();

              hb_gcCollect();
              hb_idleState();
return sw;
}

int fun_keep(){
int sw=1;
   ++SWKEEP;
/*   if(STK_PRG[CP+1]==194){
      ++CP;
      sw=fun_keep();
   }*/
return sw;
}

int fun_keeparg(){
int sw=1;
   int nItem = STK_PRG[++CP];
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
   SWKEEP+=hb_itemGetNI(pSTACK);
   hb_itemRelease(pSTACK);
/*   if(STK_PRG[CP+1]==317){
      ++CP;
      sw=fun_keeparg();
   } */
return sw;
}

int fun_sizestack(){
int sw=1;
int SIZE=CADDR;
if(CADDR+1<nSizeStack){
   hb_arraySetNI( pSTK_ADDR, ++CADDR, SIZE );
   hb_arraySetNI( pSTK_ADDR, ++CADDR, nINDEXOBJ+1 );
}else
   sw=put_error((PHB_ITEM) pRET, "SIZESTACK INNER-STACK OVERFLOW",102); 
return sw;
}

int funDuplicateStack(){
int sw=1;
if(CADDR>0){
   PHB_ITEM pLASTITEM = hb_itemArrayGet( pSTK_ADDR, CADDR );
   hb_arraySet( pSTK_ADDR, ++CADDR, pLASTITEM );
   hb_itemRelease(pLASTITEM);
}else{
   sw=put_error((PHB_ITEM) pRET, "DUP INNER-STACK OVERFLOW",102); 
}
return sw;
}

/*int set_video(){
int sw=1;
int iRows, iCols;
hb_gtScrDim( &iRows, &iCols );
if(CADDR>=1){
   PHB_ITEM pROWS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   iRows = hb_itemGetNInt(pROWS);
}
if(CADDR>=1){   
   PHB_ITEM pCOLS = hb_itemArrayGet( pSTK_ADDR, CADDR-- );
   iCols = hb_itemGetNInt(pCOLS);
}
   //hb_retl( hb_gtSetMode( iRows, iCols ) == HB_SUCCESS );
hb_gtSetMode( iRows, iCols );

return sw;
}*/
/*int fun_setmode()
{
int sw=0;
if(CADDR>=2){
   PHB_ITEM pNEWCOL=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   PHB_ITEM pNEWROW=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   unsigned int iRows = hb_itemGetNInt(pNEWROW);
   unsigned int iCols = hb_itemGetNInt(pNEWCOL);
   hb_itemRelease(pNEWCOL);
   hb_itemRelease(pNEWROW);
   
   PHB_GT pGT;
   pGT = hb_gt_Base();
   if( pGT )
   {
      if( HB_GTSELF_SETMODE( pGT, iRows, iCols ) )
         sw = HB_SUCCESS;
      hb_gt_BaseFree( pGT );
   }
}else{
   sw=put_error((PHB_ITEM) pRET, "VIDEO INNER-STACK OVERFLOW",102);
}
return sw;
}*/



int fun_push(){
              int nItem = STK_PRG[++CP];
              if(CADDR){
                 PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
                 PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, CADDR--);
                 CADDR += SWKEEP; SWKEEP = 0;
                 hb_arrayAdd( pSTACK, pDATO );
               //  hb_arraySet( pSTK_REG, nItem, pSTACK );
                 hb_itemRelease(pSTACK);
                 hb_itemRelease(pDATO);
              }
return 1;
}
int fun_pop(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              long ulLen = hb_arrayLen( pSTACK );
              PHB_ITEM pLast = hb_itemNew( NULL );
              if(CADDR<nSizeStack){
                 if( ulLen ){
                    hb_arrayLast( pSTACK, pLast );
                    hb_arrayDel( pSTACK, ulLen );
                    --ulLen;
                    hb_arraySize( pSTACK, HB_MAX( ulLen, 0 ) );
                    hb_arraySet( pSTK_ADDR, ++CADDR, pLast );
                 }else{
                    sw=put_error((PHB_ITEM) pRET, "DEQUE-POP STACK OVERFLOW",103); 
                 }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "DEQUE-POP INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pLast);
              hb_itemRelease(pSTACK);
return sw;
}
int fun_qpop(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              long ulLen = hb_arrayLen( pSTACK );
              if(CADDR<nSizeStack){
                 if( ulLen ){
                    PHB_ITEM pFirst = hb_itemArrayGet( pSTACK, 1);
                    hb_arrayDel( pSTACK, 1 );
                    --ulLen;
                    hb_arraySize( pSTACK, HB_MAX( ulLen, 0 ) );
                    hb_arraySet( pSTK_ADDR, ++CADDR, pFirst );
                    hb_itemRelease(pFirst);
                 }else{
                    sw=put_error((PHB_ITEM) pRET, "QUEUE-POP STACK OVERFLOW",103); 
                 }
              }else{
                 sw=put_error((PHB_ITEM) pRET, "QUEUE-POP INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pSTACK);
return sw;
}
int print_matrix2D( PHB_ITEM pSource, unsigned PRECISION, const char *tokenizer, unsigned int ROW, unsigned int COL, unsigned int d1, unsigned int d2 ){

int sw=1;
int swOffset=0;
   int i, NR=ROW;
  /* Verifica rangos de impresion */
   int nIniR=1, nFinR=d1;
   int nIniC=1, nFinC=d2;
   // printf("\nPASA 1\nROW=%d, COL=%d, OFFSET_ROW=%d, OFFSET_COL=%d\n",MARK_ROW,MARK_COL,OFFSET_ROW,OFFSET_COL);
   if( MARK_ROW ) {
      if( MARK_ROW == 999999999 ) MARK_ROW=d1;
      if( MARK_ROW>d1 ){
         sw=put_error((PHB_ITEM) pRET, "PRINT TABLE ROW'MARK OVERFLOW",101);
         hb_itemRelease(pSource);
         return sw;               
      }
      nIniR=MARK_ROW;nFinR=MARK_ROW;
      if( OFFSET_ROW ){
         if( OFFSET_ROW == 999999999 ) OFFSET_ROW=d1;
         if( OFFSET_ROW<=d1 ){
            nFinR=OFFSET_ROW;
         }else{   // es mayor! ERROR
            sw=put_error((PHB_ITEM) pRET, "PRINT TABLE ROW'OFFSET OVERFLOW",101);
            hb_itemRelease(pSource);
            return sw;
         }
      }
   }else{  // asume todas las filas
      swOffset=1;
      OFFSET_ROW=nFinR;
   }
   if( MARK_COL ) {
      if( MARK_COL == 999999999 ) MARK_COL=d2;
      if( MARK_COL>d2 ){
         sw=put_error((PHB_ITEM) pRET, "PRINT TABLE COL'MARK OVERFLOW",101);
         hb_itemRelease(pSource);
         return sw;               
      }
      nIniC=MARK_COL;nFinC=MARK_COL;
      if( OFFSET_COL ){
         if( OFFSET_COL == 999999999 ) OFFSET_COL=d2;
         if( OFFSET_COL<=d2 ){
            nFinC=OFFSET_COL;
         }else{   // es mayor! ERROR
            sw=put_error((PHB_ITEM) pRET, "PRINT TABLE COL'OFFSET OVERFLOW",101);
            hb_itemRelease(pSource);
            return sw;
         }
      }
   }else{  // asume todas las columnas
      swOffset=1;
      OFFSET_COL=nFinC;
   }
   /* verifica incremento por intervalo seteado */
   int nIncR=SET_INTERVAL_ROW;
   int nIncC=SET_INTERVAL_COL;
   for( i=nIniR; i<=nFinR; i+=nIncR ){
      PHB_ITEM pDato2D = hb_itemArrayGet( pSource, i);
      int j, NC=COL;
      printf("\033[%d;%dH",NR,NC);
      for( j=nIniC; j<=nFinC; j+=nIncC ){
         PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
         
         print_single( (PHB_ITEM) pPrint, PRECISION );
         
         hb_itemRelease(pPrint);
         //++NC;
         if( d2-j ) printf( "%s",tokenizer );
      }
      ++NR;
      hb_itemRelease(pDato2D);
   }
   if( swOffset ) { OFFSET_ROW=0; OFFSET_COL=0; }
   printf( "\n" );
return sw;
}

int fun_print_array(){
int sw=1;

if(CADDR>=1 ){
//   PHB_ITEM pCOL=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // columna
//   PHB_ITEM pROW=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fila
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // array
   int nCol = SCREEN_COL;//hb_itemGetNInt(pCOL);
   int nRow = SCREEN_ROW;//hb_itemGetNInt(pROW);

   if( HB_IS_ARRAY(pARRAY) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      if( nDim == 2 ){
         int nPrecision = SW_PRECISION ? PRECISION : 13;
         const char * tokenizer=TOKENIZER;
         sw = print_matrix2D( pARRAY, nPrecision, tokenizer, nRow, nCol, d1, d2 );
      }else{
         sw=put_error((PHB_ITEM) pRET, "PRINT 2D DIMENSION ERROR",104);
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "PRINT 2D TYPE MISMATCH",104);
   }
 //  hb_itemRelease(pCOL);
 //  hb_itemRelease(pROW);
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "PRINT 2D INNER-STACK OVERFLOW",102); 
}
return sw;
}

int fun_draw_table(){
int sw=1;

if(CADDR>=1 ){
//   PHB_ITEM pCOL=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // columna
//   PHB_ITEM pROW=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // fila
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_ADDR, CADDR--);  // array
   //int nCol = SCREEN_COL;//hb_itemGetNInt(pCOL);
   //int nRow = SCREEN_ROW;//hb_itemGetNInt(pROW);

   if( HB_IS_ARRAY(pARRAY) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      
      switch(nDim){
      case 2:{
         
         int nIniR=1, nFinR=d1;
         int nIniC=1, nFinC=d2;
         int i,NR = SCREEN_ROW;
         for( i=nIniR; i<=nFinR; i++ ){
            PHB_ITEM pDato2D = hb_itemArrayGet( pARRAY, i);
            int j, NC=SCREEN_COL;
            printf("\033[%d;%dH",NR,NC);
            for( j=nIniC; j<=nFinC; j++ ){
               PHB_ITEM pPrint = hb_itemArrayGet( pDato2D, j);
               //int pixel = hb_itemGetNI(pPrint);
               //print_single( (PHB_ITEM) pPrint, PRECISION );
               printf("\033[48;5;%dm ",hb_itemGetNI(pPrint));
               
               hb_itemRelease(pPrint);
               //++NC;
               //if( d2-j ) printf( "%s",tokenizer );
            }
            ++NR;
            hb_itemRelease(pDato2D);
         }
         fflush(stdout);
         break;
      }case 1:{
         //sw=put_error((PHB_ITEM) pRET, "DRWTBL DIMENSION ERROR",104);
         int nIniR=1, nFinR=d1;
         int i;
         printf("\033[%d;%dH",SCREEN_ROW,SCREEN_COL);
         for( i=nIniR; i<=nFinR; i++ ){
            PHB_ITEM pDato2D = hb_itemArrayGet( pARRAY, i);
            printf("\033[48;5;%dm ",hb_itemGetNI(pDato2D));
            hb_itemRelease(pDato2D);
         }
         fflush(stdout);
         break;
      }default:{
         sw=put_error((PHB_ITEM) pRET, "DRWTBL DIMENSION ERROR",104);
      }
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "DRWTBL TYPE MISMATCH",104);
   }
 //  hb_itemRelease(pCOL);
 //  hb_itemRelease(pROW);
   hb_itemRelease(pARRAY);
}else{
   sw=put_error((PHB_ITEM) pRET, "DRWTBL INNER-STACK OVERFLOW",102); 
}
return sw;
}


int fun_look(){
int sw=1;

if(CADDR>=1 ){
   int nItem = STK_PRG[++CP];
   PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
   long ulLen = hb_arrayLen( pSTACK );
   PHB_ITEM pLast = NULL;

   PHB_ITEM pDATO=hb_itemArrayGet( pSTK_ADDR, CADDR--);
   long nDato = hb_itemGetNL(pDATO);
   hb_itemRelease(pDATO);
   if( CADDR<nSizeStack){
      if( nDato > 0 && nDato <= ulLen ){
          pLast = hb_itemArrayGet( pSTACK, nDato );
          hb_arraySet( pSTK_ADDR, ++CADDR, pLast );
      }else{
          sw=put_error((PHB_ITEM) pRET, "LOOK ARGUMENT ERROR - INDEX OVERFLOW",103); 
      }
   }else{
      sw=put_error((PHB_ITEM) pRET, "LOOK INNER-STACK OVERFLOW",102); 
   }
   hb_itemRelease(pLast);              
   hb_itemRelease(pSTACK);
}else{
   sw=put_error((PHB_ITEM) pRET, "LOOK INNER-STACK UNDERFLOW",102); 
}
return sw;
}

int fun_tail(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              long ulLen = hb_arrayLen( pSTACK );
              PHB_ITEM pLast = hb_itemNew( NULL );
              if(CADDR<nSizeStack){
                 if( ulLen )  hb_arrayLast( pSTACK, pLast );
                 hb_arraySet( pSTK_ADDR, ++CADDR, pLast );
              }else{
                 sw=put_error((PHB_ITEM) pRET, "TAIL INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pLast);              
              hb_itemRelease(pSTACK);
return sw;
}
int fun_head(){
int sw=1;
              int nItem = STK_PRG[++CP];
              PHB_ITEM pSTACK=hb_itemArrayGet( pSTK_REG, nItem);
              //long ulLen = hb_arrayLen( pSTACK );
              if(CADDR<nSizeStack){
                 PHB_ITEM pFirst = hb_itemArrayGet( pSTACK, 1);
                 hb_arraySet( pSTK_ADDR, ++CADDR, pFirst );
                 hb_itemRelease(pFirst);
              }else{
                 sw=put_error((PHB_ITEM) pRET, "HEAD INNER-STACK OVERFLOW",102); 
              }
              hb_itemRelease(pSTACK);
return sw;
}

int fun_swap(){
int sw=1;
  int nItem1 = STK_PRG[++CP];
  int nItem2 = STK_PRG[++CP];
  PHB_ITEM pREG1=hb_itemArrayGet( pSTK_REG, nItem1);
  PHB_ITEM pREG2=hb_itemArrayGet( pSTK_REG, nItem2);
  PHB_ITEM SWAP_REG=pREG1;
  hb_arraySet( pSTK_REG, nItem1, (PHB_ITEM)pREG2 );
  hb_arraySet( pSTK_REG, nItem2, (PHB_ITEM)SWAP_REG );

 // hb_itemRelease(SWAP_REG);
  hb_itemRelease(pREG1);
  hb_itemRelease(pREG2);
  
return sw;
}

int fun_get_size_terminal(){
int sw=1;
if(CADDR<nSizeStack-2){
   struct winsize w;
   ioctl(STDOUT_FILENO, TIOCGWINSZ, &w);

   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) w.ws_row);
   hb_arraySetNI( pSTK_ADDR, ++CADDR, (int) w.ws_col);
    //printf ("lines %d\n", w.ws_row);
    //printf ("columns %d\n", w.ws_col);
}else{
   sw=put_error((PHB_ITEM) pRET, "GETSIZSCR INNER-STACK OVERFLOW",102); 
}
return sw;
}

int fun_nothing(){return 1;}

/*  GRAFICAS SIMPLES EN MODO TEXTO */


void plotPoints(int xc, int yc, int x1, int y1) {    
    printf("\033[%d;%dH ",(int)floorf(xc+x1),(int)floorf(yc+y1));
    printf("\033[%d;%dH ",(int)floorf(xc-x1),(int)floorf(yc+y1));
    printf("\033[%d;%dH ",(int)floorf(xc+x1),(int)floorf(yc-y1));
    printf("\033[%d;%dH ",(int)floorf(xc-x1),(int)floorf(yc-y1));
    printf("\033[%d;%dH ",(int)floorf(xc+y1),(int)floorf(yc+x1));
    printf("\033[%d;%dH ",(int)floorf(xc-y1),(int)floorf(yc+x1));
    printf("\033[%d;%dH ",(int)floorf(xc+y1),(int)floorf(yc-x1));
    printf("\033[%d;%dH ",(int)floorf(xc-y1),(int)floorf(yc-x1));
}
  
int  fun_txt_circle (){

int sw=1;
if( CADDR>=3 ){
    PHB_ITEM pRAD=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pYC=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pXC=hb_itemArrayGet( pSTK_ADDR, CADDR--);

    int xc = hb_itemGetNI(pXC);
    int yc = hb_itemGetNI(pYC);
    int r = hb_itemGetNI(pRAD);

    hb_itemRelease(pXC);
    hb_itemRelease(pYC);
    hb_itemRelease(pRAD);
    
    int x=0,y=r,p;

    plotPoints(xc, yc, x, y);
    p = 1-r;
    while (x<y){
       if (p<0){
          ++x;
          p = p+2*x+1;
       }else{
          ++x;
          --y;
          p=p+2*(x-y)+1;
       }
       plotPoints(xc, yc, x, y);
    }
    fflush(stdout);
}else{
   sw=put_error((PHB_ITEM) pRET, "CIRCLE INNER-STACK OVERFLOW",102); 
}
return sw;
}

void inner_draw_line(float x1, float y1, float x2, float y2){
    int  i=0;
    float dx=0, dy=0, luz=0, DX=0, DY=0;
    
    dx = x2-x1; dy = y2-y1; //Sub(x2, x1), Sub (y2, y1), Move to ' dx, dy '
    DX = fabs(dx); DY = fabs(dy);
    luz = fabs(dx) >= fabs(dy) ? DX : DY; // Greater equal ( Abs(dx) » (DX), Abs(dy)»(DY) ), DX, DY ) )

  // incremento:
    dx = dx/luz; dy = dy/luz;
    //Div(dx, paso), Div(dy, paso), Move to ( dx, dy )

  //  Color back (13)
  // dibuja línea:
    for ( i=0; i < (int)luz ; ++i){
     //Loop if ( Less equal (i, paso) )
        printf("\033[%d;%dH ",(int)floorf(x1),(int)floorf(y1));
        x1 = x1+dx; y1=y1+dy;
    }
    fflush(stdout);
}

int fun_txt_line()
{
int sw=1;
if( CADDR>=4 ){
    PHB_ITEM pDY=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pDX=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pOY=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pOX=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    
    float x1 = (float) hb_itemGetND(pOX);
    float y1 = (float) hb_itemGetND(pOY);
    float x2 = (float) hb_itemGetND(pDX);
    float y2 = (float) hb_itemGetND(pDY);
    
    hb_itemRelease(pOX);
    hb_itemRelease(pOY);
    hb_itemRelease(pDX);
    hb_itemRelease(pDY);
    
    inner_draw_line(x1,y1,x2,y2);

}else{
    sw=put_error((PHB_ITEM) pRET, "LINE INNER-STACK OVERFLOW",102); 
}
return sw;
}

// entrego un array bidimensional, no dos arrays
//  draw(array)
int fun_nbr(){
int sw=1;
   int count=0;
   int nItem1 = STK_PRG[++CP];
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_REG, nItem1);

   PHB_ITEM pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW-1);
   PHB_ITEM pVERTC = hb_itemArrayGet( pVERTR, MARK_COL-1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);
   
   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW-1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW-1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL+1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);
   
   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL-1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);
   
   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL+1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW+1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL-1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW+1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   pVERTR = hb_itemArrayGet( pARRAY, MARK_ROW+1);
   pVERTC = hb_itemArrayGet( pVERTR, MARK_COL+1);
   if(hb_itemGetNI(pVERTC)) ++count;
   hb_itemRelease(pVERTR);hb_itemRelease(pVERTC);

   hb_itemRelease(pARRAY);
   hb_arraySetNI( pSTK_ADDR, ++CADDR, count );

return sw;
}

int fun_txt_drawPoligon(){
int sw=1;

   int nItem1 = STK_PRG[++CP];
   PHB_ITEM pARRAY=hb_itemArrayGet( pSTK_REG, nItem1);

   if( HB_IS_ARRAY(pARRAY) ){
      HB_MAXINT nDim=0,d1=0,d2=0,d3=0,type=0;
      get_size( (PHB_ITEM) pARRAY, &nDim, &d1, &d2, &d3, &type);
      if( nDim == 2 ){
    
         int i;

         for (i = 2; i<=d1; ++i) {
             PHB_ITEM pVERT1 = hb_itemArrayGet( pARRAY, i-1);
             PHB_ITEM pVX1 = hb_itemArrayGet( pVERT1, 1);
             PHB_ITEM pVY1 = hb_itemArrayGet( pVERT1, 2);
             
             PHB_ITEM pVERT = hb_itemArrayGet( pARRAY, i);
             PHB_ITEM pVX = hb_itemArrayGet( pVERT, 1);
             PHB_ITEM pVY = hb_itemArrayGet( pVERT, 2);
                          
             inner_draw_line( hb_itemGetNI(pVX1), hb_itemGetNI(pVY1), hb_itemGetNI(pVX), hb_itemGetNI(pVY) );
             hb_itemRelease(pVX);hb_itemRelease(pVY);hb_itemRelease(pVERT);
             hb_itemRelease(pVX1);hb_itemRelease(pVY1);hb_itemRelease(pVERT1);
         }
         PHB_ITEM pVERT1 = hb_itemArrayGet( pARRAY, d1);
         PHB_ITEM pVX1 = hb_itemArrayGet( pVERT1, 1);
         PHB_ITEM pVY1 = hb_itemArrayGet( pVERT1, 2);
             
         PHB_ITEM pVERT = hb_itemArrayGet( pARRAY, 1);
         PHB_ITEM pVX = hb_itemArrayGet( pVERT, 1);
         PHB_ITEM pVY = hb_itemArrayGet( pVERT, 2);
                          
         inner_draw_line( hb_itemGetNI(pVX1), hb_itemGetNI(pVY1), hb_itemGetNI(pVX), hb_itemGetNI(pVY) );
         hb_itemRelease(pVX);hb_itemRelease(pVY);hb_itemRelease(pVERT);
         hb_itemRelease(pVX1);hb_itemRelease(pVY1);hb_itemRelease(pVERT1);

      }else{
          sw=put_error((PHB_ITEM) pRET, "DRAW DIMENSION ERROR",104);
      }
   }else{
       sw=put_error((PHB_ITEM) pRET, "DRAW ARGUMENT TYPE ERROR",103);
   }
   hb_itemRelease(pARRAY);
   return sw;
}

void inner_draw_poligon( float verticesx[], float verticesy[], int N ){


  int  i;
    for (i = 1; i<N; ++i){
        inner_draw_line( verticesx[ (i-1)], verticesy [(i-1)], verticesx [i], verticesy [i] );
    }
    inner_draw_line( verticesx [N-1], verticesy [N-1], verticesx [0], verticesy [0] );

}

int fun_txt_poligon(){
int sw=1;
if( CADDR>=4 ){
    PHB_ITEM pRAD=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pNVERT=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pCY=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    PHB_ITEM pCX=hb_itemArrayGet( pSTK_ADDR, CADDR--);
    
    
    int N = hb_itemGetNI(pNVERT);
    int radio = hb_itemGetNI(pRAD);
    int cx = hb_itemGetNI(pCX);
    int cy = hb_itemGetNI(pCY);
    
    hb_itemRelease(pCY);hb_itemRelease(pCX);hb_itemRelease(pNVERT);hb_itemRelease(pRAD);

    float alfa;
    int i;

    alfa = (2* 3.141592) / N;
    float verticesx[N];
    float verticesy[N];
    for (i= 0; i<N ; ++i){
       verticesx[ i] = cx + radio * cos( i*alfa );
       verticesy[ i] = cy + radio * sin( i*alfa );
    }
    inner_draw_poligon( verticesx, verticesy,  N );

}else{
    sw=put_error((PHB_ITEM) pRET, "POLIGON INNER-STACK OVERFLOW",102);
}
return sw;
}


/*
static volatile sig_atomic_t keep_running = 1;
//int keep_running = 1;

//static void sig_handler(int _){
//    (void)_;
//    keep_running = 0;
//}
void sig_handler(int signo)
{
  if (signo == SIGINT){
     printf("\nreceived SIGINT\n");
     keep_running = 0;
  }
} */

 // estructuras para punteros a función:


    struct {
        int (*p)();
    }funCall[405] = { /*    0: */{PushReg},          
                      /*    1: */{PushCopyReg},      
                      /*    2: */{PushDS},           
                      /*    3: */{LetReg},           
                      /*    4: */{LetMacro},         
                      /*    5: */{LetDS},            
                      /*    6: */{jumpSingle},       
                      /*    7: */{jumpEQ},           
                      /*    8: */{jumpNEQ},          
                      /*    9: */{jumpLT},           
                      /*   10: */{jumpLTE},          
                      /*   11: */{jumpGT},
                      /*   12: */{jumpGTE}, 
                      /*   13: */{jumpT},
                      /*   14: */{jumpNT},
                      /*   15: */{jumpV},           
                      /*   16: */{jumpNV},
                      /*   17: */{jumpZ},
                      /*   18: */{jumpNZ},
                      /*   19: */{jumpNEG},
                      /*   20: */{jumpPOS},         
                      /*   21: */{jumpGOSUB},
                      /*   22: */{jumpJSUB},
                      /*   23: */{logicalCompare},
                      /*   24: */{logicalCompare},
                      /*   25: */{logicalCompare},
                      /*   26: */{logicalCompare},
                      /*   27: */{logicalCompare},
                      /*   28: */{logicalCompare},
                      /*   29: */{logicalCompare},
                      /*   30: */{logicalCompare},
                      /*   31: */{logicalCompare},
                      /*   32: */{logicalCompare}, 
                      /*   33: */{logicalCompare},
                      /*   34: */{logicalEmpty},
                      /*   35: */{between},
                      /*   36: */{empty_stack},
                      /*   37: */{fun_ifenv},
                      /*   38: */{fun_exist_file},
                      /*   39: */{fun_getserror},
                      /*   40: */{computo},
                      /*   41: */{computo},
                      /*   42: */{computo},
                      /*   43: */{computo},
                      /*   44: */{computo},
                      /*   45: */{computo},
                      /*   46: */{computo},
                      /*   47: */{computo},
                      /*   48: */{computo}, 
                      /*   49: */{computo},
                      /*   50: */{jumpCase},
                      /*   51: */{logicalCompare},
                      /*   52: */{keyboard_free},
                      /*   53: */{keyboard_put},
                      /*   54: */{fun_repl_lateral},
                      /*   55: */{fun_repl_lateral},
                      /*   56: */{fun_repl_lateral},
                      /*   57: */{fun_isnaninf},
                      /*   58: */{fun_isnaninf},
                      /*   59: */{fun_cut_single},
                      /*   60: */{funStrOneArg},
                      /*   61: */{funStrOneArg},
                      /*   62: */{funStrOneArg},
                      /*   63: */{funStrOneArg},
                      /*   64: */{funStrOneArg},
                      /*   65: */{funStrOneArg},
                      /*   66: */{funStrOneArg},
                      /*   67: */{funStrOneArg},
                      /*   68: */{fun_isanyall},
                      /*   69: */{fun_isanyall},
                      /*   70: */{NULL}, //{fun_clear_marks},
                      /*   71: */{fun_trycatch},
                      /*   72: */{get_elaptime},
                      /*   73: */{get_daysdiff},
                      /*   74: */{get_dateadd},
                      /*   75: */{stack_gettoken},
                      /*   76: */{stack_modtoken},
                      /*   77: */{fun_cut_single},
                      /*   78: */{fun_regvalid},
                      /*   79: */{fun_regmatch},
                      /*   80: */{funNumOneArg},
                      /*   81: */{funNumOneArg},
                      /*   82: */{funNumOneArg},
                      /*   83: */{funNumOneArg},
                      /*   84: */{funNumOneArg},
                      /*   85: */{funNumOneArg},
                      /*   86: */{funNumOneArg},
                      /*   87: */{funNumOneArg},
                      /*   88: */{funNumOneArg},
                      /*   89: */{funNumOneArg},
                      /*   90: */{funNumOneArg},
                      /*   91: */{funNumOneArg},
                      /*   92: */{funNumOneArg},
                      /*   93: */{funNumOneArg},
                      /*   94: */{funNumOneArg},
                      /*   95: */{funNumOneArg},
                      /*   96: */{funNumOneArg},
                      /*   97: */{funNumOneArg},
                      /*   98: */{funNumOneArg},
                      /*   99: */{funNumOneArg},
                      /*  100: */{funNumOneArg},
                      /*  101: */{funNumOneArg},
                      /*  102: */{funNumOneArg},
                      /*  103: */{funNumOneArg},
                      /*  104: */{funNumOneArg},
                      /*  105: */{funNumOneArg},
                      /*  106: */{funNumOneArg},
                      /*  107: */{funNumOneArg},
                      /*  108: */{funNumOneArg},
                      /*  109: */{funNumOneArg},
                      /*  110: */{funNumOneArg},
                      /*  111: */{funNumOneArg},
                      /*  112: */{funNumOneArg},
                      /*  113: */{fun_nothing},  // no tocar: usado por NOP
                      /*  114: */{funDuplicateStack},
                      /*  115: */{type_item_char},
                      /*  116: */{fun_sizestack},
                      /*  117: */{fun_clear_range},
                      /*  118: */{fun_cartesian},
                      /*  119: */{put_coordinates_2D},
                      /*  120: */{put_coordinates_1D},
                      /*  121: */{fun_interval},       
                      /*  122: */{fun_interval},
                      /*  123: */{fun_interval},
                      /*  124: */{fun_show},
                      /*  125: */{boolean_compare},
                      /*  126: */{boolean_compare},
                      /*  127: */{boolean_compare},    
                      /*  128: */{boolean_compare},
                      /*  129: */{boolean_compare},
                      /*  130: */{boolean_not},
                      /*  131: */{put_argcnt},
                      /*  132: */{type_item},               
                      /*  133: */{fun_ferror},
                      /*  134: */{put_pausa},
                      /*  135: */{put_microseconds},
                      /*  136: */{returnProgram},
                      /*  137: */{fun_transform},      
                      /*  138: */{fun_getenv},
                      /*  139: */{pop_label},
                      /*  140: */{keyboard_hit},
                      /*  141: */{keyboard_esc},
                      /*  142: */{fun_echo},
                      /*  143: */{fun_replace},
                      /*  144: */{fun_print},     
                      /*  145: */{funSubstr},
                      /*  146: */{put_offset},
                      /*  147: */{true_instruccion},
                      /*  148: */{get_sectotime},
                      /*  149: */{keyboard_ctrlc},     
                      /*  150: */{fun_isnumeric},
                      /*  151: */{fun_isnumeric},  // isstring
                      /*  152: */{fun_isarray},
                      /*  153: */{fun_length},
                      /*  154: */{kpop},
                      /*  155: */{clear_stack},
                      /*  156: */{funCountAt}, 
                      /*  157: */{funIndexAt},
                      /*  158: */{funAt},
                      /*  159: */{fun_mask},
                      /*  160: */{fun_money},
                      /*  161: */{multipass_on},
                      /*  162: */{multipass_off},
                      /*  163: */{settokenizer},
                      /*  164: */{get_seconds},
                      /*  165: */{false_instruccion},
                      /*  166: */{fun_matrix_mul},
                      /*  167: */{fun_pad},
                      /*  168: */{fun_pad},
                      /*  169: */{fun_pad},
                      /*  170: */{fun_cat},
                      /*  171: */{replicate},
                      /*  172: */{fun_setenv},
                      /*  173: */{fun_unsetenv},
                      /*  174: */{fun_dayname},
                      /*  175: */{fun_onlychar},   
                      /*  176: */{fun_compact},
                      /*  177: */{put_offset2D},
                      /*  178: */{declara_puntero},
                      /*  179: */{fun_insert},
                      /*  180: */{fun_delete},
                      /*  181: */{fun_count_lines}, 
                      /*  182: */{fun_str2utf8},
                      /*  183: */{fun_utf82str},
                      /*  184: */{fun_char_rem},
                      /*  185: */{fun_get_error},
                      /*  186: */{fun_loadmat},
                      /*  187: */{fun_savemat}, 
                      /*  188: */{fun_exec},
                      /*  189: */{put_sleep},
                      /*  190: */{fun_draw_table},
                      /*  191: */{fun_char_one},
                      /*  192: */{fun_char_pos},
                      /*  193: */{fun_printusingtoken},
                      /*  194: */{fun_keep},      
                      /*  195: */{fun_putstack},
                      /*  196: */{fun_goxy},
                      /*  197: */{fun_clock_per_sec},
                      /*  198: */{fun_exec},
                      /*  199: */{fun_clear_interval},
                      /*  200: */{fun_size_binary},
                      /*  201: */{move_stack_reg},
                      /*  202: */{funInc_one},
                      /*  203: */{funDec_one},
                      /*  204: */{put_precision},
                      /*  205: */{fun_create_array},
                      /*  206: */{tottoken}, 
                      /*  207: */{funInc_much},
                      /*  208: */{put_coordinates_2D},
                      /*  209: */{funDec_much},
                      /*  210: */{fun_create_fun_array},
                      /*  211: */{fun_reverse_string}, 
                      /*  212: */{put_coordinates_1D},
                      /*  213: */{fun_readline},
                      /*  214: */{fun_lastkey},
                      /*  215: */{put_precision},
                      /*  216: */{add_item_row},
                      /*  217: */{put_array},
                      /*  218: */{get_array},
                      /*  219: */{getrow},
                      /*  220: */{getcol},
                      /*  221: */{catrow},
                      /*  222: */{catcol},
                      /*  223: */{getpage},
                      /*  224: */{putpage},  
                      /*  225: */{size_array},
                      /*  226: */{type_item},
                      /*  227: */{gettoken},
                      /*  228: */{modtoken},
                      /*  229: */{fun_fopen},
                      /*  230: */{fun_emptyarray},   
                      /*  231: */{fun_create_fun_array},
                      /*  232: */{fun_create_fun_array},
                      /*  233: */{fun_create_fun_array},
                      /*  234: */{fun_create_fun_array},
                      /*  235: */{fun_fclose},
                      /*  236: */{fun_writeline},
                      /*  237: */{fun_readline},
                      /*  238: */{fun_seek},
                      /*  239: */{fun_eof},
                      /*  240: */{fun_create},
                      /*  241: */{put_switch}, 
                      /*  242: */{fun_writeline},
                      /*  243: */{put_sequenceSpaced},
                      /*  244: */{put_sequence},
                      /*  245: */{move_stack_reg},
                      /*  246: */{fun_reshape},       
                      /*  247: */{fun_bool},
                      /*  248: */{fun_bool},
                      /*  249: */{fun_datenow},
                      /*  250: */{fun_stat_especial},
                      /*  251: */{fun_set_especial},
                      /*  252: */{fun_array_especial},
                      /*  253: */{fun_date_time},
                      /*  254: */{fun_socket},
                      /*  255: */{NULL},  // no tocar!
                      /*  256: */{fun_jointostr},
                      /*  257: */{computo_especial},
                      /*  258: */{computo_especial},
                      /*  259: */{computo_especial},
                      /*  260: */{computo_especial},
                      /*  261: */{computo_especial},
                      /*  262: */{computo_especial},
                      /*  263: */{computo_especial},
                      /*  264: */{fun_trycatch},    
                      /*  265: */{fun_trycatch},
                      /*  266: */{fun_trycatch},
                      /*  267: */{logical_espCompare},
                      /*  268: */{logical_espCompare},
                      /*  269: */{logical_espCompare}, 
                      /*  270: */{logical_espCompare},
                      /*  271: */{logical_espCompare},
                      /*  272: */{logical_espCompare},
                      /*  273: */{clear_var},
                      /*  274: */{fun_push},   
                      /*  275: */{logical_espCompare},
                      /*  276: */{logical_espCompare},
                      /*  277: */{computo_especial},
                      /*  278: */{fun_bit_counter},
                      /*  279: */{fun_calendar},  
                      /*  280: */{fun_loadstring},
                      /*  281: */{fun_getarraystring},
                      /*  282: */{fun_getstringarray},
                      /*  283: */{fun_savestring},
                      /*  284: */{fun_linestring},
                      /*  285: */{fun_countstring},
                      /*  286: */{fun_grep},
                      /*  287: */{fun_timer},
                      /*  288: */{fun_putstr},
                      /*  289: */{dspush},
                      /*  290: */{dspop},
                      /*  291: */{fun_pop},
                      /*  292: */{fun_qpop},  
                      /*  293: */{fun_tail},
                      /*  294: */{fun_head},
                      /*  295: */{replicate_by},
                      /*  296: */{fun_writestring},
                      /*  297: */{fun_readstring},
                      /*  298: */{fun_saturate},
                      /*  299: */{fun_socketTCP_Accept},
                      /*  300: */{fun_socketTCP_Recv},
                      /*  301: */{fun_socketTCP_Send},
                      /*  302: */{fun_socketTCP_Connect},
                      /*  303: */{fun_socketUDP_Recvfrom},
                      /*  304: */{fun_socketUDP_Sendto},
                      /*  305: */{fun_opeCode},
                      /*  306: */{fun_qcreate},
                      /*  307: */{fun_qset},
                      /*  308: */{fun_qsend},
                      /*  309: */{fun_qrecv},
                      /*  310: */{fun_qremove},
                      /*  311: */{fun_assert},
                      /*  312: */{fun_doParser},
                      /*  313: */{fun_unparser},
                      /*  314: */{fun_regcompile},
                      /*  315: */{fun_regfree},
                      /*  316: */{fun_clamp},
                      /*  317: */{fun_keeparg},
                      /*  318: */{fun_timecpu},
                      /*  319: */{fun_range},
                      /*  320: */{fun_voidarray},
                      /*  321: */{fun_create_fun_array},
                      /*  322: */{funNumOneArg},
                      /*  323: */{funNumOneArg},
                      /*  324: */{funNumOneArg},
                      /*  325: */{funNumOneArg},
                      /*  326: */{funNumOneArg},
                      /*  327: */{funNumOneArg},
                      /*  328: */{fun_emptyarray},
                      /*  329: */{fun_goRow},
                      /*  330: */{fun_goCol},
                      /*  331: */{fun_monthname}, //{fun_clrmarksall},  // retoma acceso a stack unicamente
                      /*  332: */{fun_seed},
                      /*  333: */{fun_getseptok},
                      /*  334: */{fun_sqrcompute},
                      /*  335: */{fun_sqrcompute},
                      /*  336: */{fun_sqrcompute},
                      /*  337: */{fun_sqrcompute},
                      /*  338: */{fun_sqrcompute},
                      /*  339: */{fun_eqarr}, // eqarr
                      /*  340: */{fun_eqarr}, // neqarr
                      /*  341: */{fun_swap},  // analizar para cambiar el stack de trabajo
                      /*  342: */{fun_print_array},
                      /*  343: */{computo},
                      /*  344: */{computo},
                      /*  345: */{fun_get_size_terminal},
                      /*  346: */{type_item_string},  // revisa hasta que no concuerde con lo esperado
                      /*  347: */{type_item_string},  // revisa hasta que encuentre algo que espera
                      /*  348: */{fun_get_char_utf8},  // obtiene version utf8 de caracter especial  
                      /*  349: */{fun_get_notation},  // verifica si un string es notacion cientifica, y convierte.
                      /*  350: */{fun_jointostr},   // JOIN pero deja en stack
                      /*  351: */{fun_updateRow},
                      /*  352: */{fun_updateCol},
                      /*  353: */{fun_fill_box},
                      /*  354: */{fun_dump_array}, //{fun_clearall},
                      /*  355: */{fun_exist_dir},
                      /*  356: */{fun_getenv_num},
                      /*  357: */{fun_outbetween},
                      /*  358: */{fun_txt_line},
                      /*  359: */{fun_txt_circle},
                      /*  360: */{fun_txt_poligon},
                      /*  361: */{funNumOneArg},   // nneg
                      /*  362: */{funNumOneArg},    // npos
                      /*  363: */{fun_mklist},
                      /*  364: */{NULL},
                      /*  365: */{NULL},
                      /*  366: */{NULL},
                      /*  367: */{NULL},
                      /*  368: */{NULL},
                      /*  369: */{NULL},
                      /*  370: */{dstop},
                      /*  371: */{fun_format},  // retoma modo acceso a memoria (funcion)
                      /*  372: */{fun_pushall},
                      /*  373: */{get_ewarray},
                      /*  374: */{put_ewarray},
                      /*  375: */{fun_eqarr}, // eqarrto
                      /*  376: */{fun_eqarr},  // neqarrto
                      /*  377: */{jumpSpecialNT},
                      /*  378: */{jumpSpecialT},
                      /*  379: */{fun_look},
                      /*  380: */{fun_get_dims},
                      /*  381: */{fun_get_rows},
                      /*  382: */{fun_get_cols},
                      /*  383: */{fun_get_pages},
                      /*  384: */{fun_minusplus},   // minus one
                      /*  385: */{fun_minusplus},   // plus one
                      /*  386: */{fun_minusplus},   // minus two
                      /*  387: */{fun_minusplus},   // plus two
                      /*  388: */{fun_cposx},
                      /*  389: */{fun_cposy},
                      /*  390: */{fun_txt_drawPoligon},
                      /*  391: */{jumpNNeg},
                      /*  392: */{jumpNPos},
                      /*  393: */{fun_nbr},
                      /*  394: */{fun_getsomething}, // get positives
                      /*  395: */{fun_getsomething}, // get negatives
                      /*  396: */{fun_getsomething}, // get non zeros
                      /*  397: */{fun_getsomething}, // get non void
                      /*  398: */{fun_pushvar},
                      /*  399: */{fun_delcols},
                      /*  400: */{fun_delrows},
                      /*  401: */{fun_delpags},
                      /*  402: */{fun_inscols},
                      /*  403: */{fun_insrows},
                      /*  404: */{fun_inspags}
                      } ;



HB_FUNC ( XFUNCALL ){
/*  declarar punteros a funcion que devuelvan INT: que será el numero de error, o 0 si sale bien
    enumerar todo desde el 1. Los registros jamás serán colocados en el área de una funcion
    Con esto, me evito el switch 
    DEJAR ESTE LENGUAJE INDPENDIENTE. NOMBRE CLAVE: XI
    
    OBSERVACIONES:
    - Solo se permite asignar datos sobre matrices 3D, y sobre porciones de estas, pero los computos son sobre matrices
      2D, y completas.
    - Computos sobre matrices 3D, usar getpage, putpage, y computar sbre una matriz 2D.  
    - Para calcular sobre una porción de una matriz 2D, usar [],offset y get/put. Y que hueá.
*/


 // programa principal. Main Loop:

    pSTK_DS  = hb_param( 1, HB_IT_ARRAY ); // dataseg
    pSTK_PRG = hb_param( 2, HB_IT_ARRAY ); // program
    pSTK_DBG = hb_param( 3, HB_IT_ARRAY ); // lineas del programa
    
 //   long uiArrayLenDS = ( long ) hb_arrayLen( pSTK_DS );
    long uiArrayLenPRG = ( long ) hb_arrayLen( pSTK_PRG );    
    
    CP=0;
    CADDR=0;
    swErr=0;
    SW_PRECISION=0;   // por defecto, no hay precisión
    int sw=1;      // ciclo principal
    CTE_NAN = asin(90);
    
//    char *TOKENIZER;
    TOKENIZER = (char*)calloc(2,1);
    TOKENIZER[0]=',';
    TOKENIZER[1]='\0';

    //PHB_ITEM pRET = hb_itemArrayNew( 7 );   // respuesta: 5 elementos. Si aumento dimensiones de arrays, deben ser 7
    pRET = hb_itemArrayNew( 7 );   // respuesta: 5 elementos. Si aumento dimensiones de arrays, deben ser 7
//    PHB_ITEM pSTK_REG = hb_itemArrayNew( nNumVar );   // stack de registros ax=1, bx=2,... zx=26

   //verificacion de total de argumentos pasados por pSTK_DS
    LENDS = ( unsigned int ) hb_arrayLen( pSTK_DS );

 // Carga el programa en un array int: ¿cambiará la velocidad?
 // ATENCION!!!
 // --- Los datos constantes de otro tipo distinto a int, son mal transformados: no cambiar parámetro pSTK_PRG
 //     en esos casos, solo en los casos donde SE SABE que se obtendrá un ENTERO INDICE.
//    int STK_DBG[ uiArrayLenPRG + 1 ];

   // defino a -1 el vector que permite controlar
    int i;
    for(i=0;i<TOPE_REGEX;i++)
       validREGEX[i]=0;
 
    
   // int STK_PRG[ uiArrayLenPRG + 1 ];
    STK_PRG = (int *)realloc(STK_PRG, (uiArrayLenPRG + 1)*sizeof(int));
     
    for(CP=1; CP<=uiArrayLenPRG; CP++){
       PHB_ITEM pCP = hb_itemArrayGet( pSTK_PRG, CP);
       STK_PRG[ CP ] = (int) hb_itemGetNInt( pCP );
       hb_itemRelease(pCP);
    }
    
    CP=1;
    // busco metadata: numero de variables declaradas, y otras cosas que necesite
    unsigned int nNumVar=STK_PRG[ CP ];
    
  //  PHB_ITEM pSTK_vREG[1];
  //  pSTK_vREG[0] = hb_itemArrayNew( nNumVar );   // stack de registros
    
///    PHB_ITEM pSTK_REG = hb_itemArrayNew( nNumVar );   // stack de registrosNULL;
    pSTK_REG = hb_itemArrayNew( nNumVar );   // stack de registrosNULL;
    
    // busco tamaño del stack de trabajo:
    nSizeStack=STK_PRG[ ++CP ]; 
//    PHB_ITEM pSTK_ADDR = hb_itemArrayNew( nSizeStack );   // stack de direcciones
    pSTK_ADDR = hb_itemArrayNew( nSizeStack );   // stack de direcciones

    // DATO RESERVADO PARA FUTUROS USOS. Contemplar otras posiciones.
    iLOCAL_INI = STK_PRG[ ++CP ];
    
    // Habilita CTRL+C
    short SW_CTRL_C = STK_PRG[ ++CP ];
    
   // con esto, guardaré los datos que se deseen guardar antes de un salto a otra función, y serán recuperados
   // con el regreso. Se usa con DSPUSH y DSPOP (Data Stack). Implementado en 289 y 290
   // PHB_ITEM pSTK_OBJ[nSizeStack*2]; // original: hecho global
    nINDEXOBJ=-1;
//    printf("\nSIZE pSTK_OBJ = %ld\n",sizeof(pSTK_OBJ));
   // for(nINDEXOBJ=0;nINDEXOBJ<nSizeStack;nINDEXOBJ++) pSTK_OBJ[nINDEXOBJ]=hb_itemNew( NULL );
   // nINDEXOBJ=-1;
    
//    PHB_ITEM SWITCH_VAR=hb_itemArrayNew( 2 );  // dato de switch: 1=number, 2=string
    SWITCH_VAR=hb_itemArrayNew( 2 );  // dato de switch: 1=number, 2=string
    hb_arraySetND( SWITCH_VAR, 1, (double) 0 );
    hb_arraySetC( SWITCH_VAR, 2, (const char*) "" );

    // busca constantes y variables; las guarda en STK_REG:

    while(CP<=uiArrayLenPRG){
       if(STK_PRG[ ++CP ]==0){ //(-2)){   // es una constante
          PHB_ITEM pCP = hb_itemArrayGet( pSTK_PRG, ++CP);   // indice
          int index = (int) hb_itemGetNInt( pCP );
          hb_itemRelease(pCP);
          PHB_ITEM pCP2 = hb_itemArrayGet( pSTK_PRG, ++CP);   // dato:
          if( HB_IS_INTEGER( pCP2 ) ){
             hb_arraySetNInt( pSTK_REG, index, hb_itemGetNInt( pCP2 ) );
          }else if( HB_IS_LONG( pCP2 ) ){
             hb_arraySetNL( pSTK_REG, index, hb_itemGetNL( pCP2 ) );
          }else if( HB_IS_NUMERIC( pCP2 ) ){
             hb_arraySetND( pSTK_REG, index, hb_itemGetND( pCP2 ) );
          }else if( HB_IS_STRING( pCP2 ) ){
             hb_arraySetC( pSTK_REG, index, hb_itemGetCPtr( pCP2 ) );
          }
          hb_itemRelease(pCP2);
       }else if(STK_PRG[ CP ] == 255){
          ++CP;  // para no contabilizarlo más.
          break;
       }
    }
    
   // INICIO DE EJECUCION VIENE INMEDIATAMENTE LUEGO DE CONSTANTES.
    if (STK_PRG[ CP ]!=255){
       sw=put_error((PHB_ITEM) pRET, "-MAIN- MUST BE FIRST LABEL",120);
    }


    //int nPCP=0; // dejarlo global
    nPCP = 0;

    if(SW_CTRL_C){
       // para empezar, solo trabajará con valores atómicos, no arrays
       for ( ;; ) {    // ciclo principal

         /* CTRL-C.  solo para debug */
          if(hb_inkey(0,0,128)==3){
             sw=put_error((PHB_ITEM) pRET, "BREAK EXECUTION BY USER (CTRL-C)",200);
             break;
          }

          nPCP = STK_PRG[ ++CP ];
          sw=(int)(*funCall[nPCP].p)();
        
          // atrapar error con try catch.
          if(!sw) {
             if( cabezaTry )
                sw=(int) read_try();
             else
                break;
          }
       } // while
    }else{
       // para empezar, solo trabajará con valores atómicos, no arrays
       for ( ;; ) {    // ciclo principal

          nPCP = STK_PRG[ ++CP ];
          ///nPCPNext = STK_PRG[ CP + 1];
          sw=(int)(*funCall[nPCP].p)();
        
          // atrapar error con try catch.
          if(!sw) {
             if( cabezaTry )
                sw=(int) read_try();
             else
                break;
          }
       } // while
    }
    
    if ( swErr ){   // defino array resultado con error:
       PHB_ITEM pSource = hb_itemArrayGet( pSTK_DBG, CP);
       int LineaError = hb_itemGetNI( pSource );
       hb_itemRelease(pSource);

       hb_arraySetNInt( pRET, 1, (int)  LineaError );
       hb_arraySetNInt( pRET, 3, (HB_MAXINT)  0  );
       hb_arraySetNInt( pRET, 4, (HB_MAXINT)  0  );
       hb_arraySetNInt( pRET, 5, (HB_MAXINT)  0  );
       hb_arraySetNInt( pRET, 6, (HB_MAXINT)  0  );
       //hb_arraySetNInt( pRET, 7, (HB_MAXINT)  0  );
    }
    hb_itemRelease(pSTK_ADDR);  // borra stack de trabajo
    hb_itemRelease(pSTK_REG);   // borra stack de registros variables y constantes
    
    //hb_itemRelease(pSTK_OBJ);   // borra stack de parametros locales.

    //   int i;
    //   for(i=0;i<nSizeStack;i++) 
    //      if(pSTK_OBJ[i]) 
    //          hb_itemRelease(pSTK_OBJ[i]);
    int ndxReg;
    for(ndxReg=0; ndxReg<TOPE_REGEX; ndxReg++){
       if(validREGEX[ndxReg]){
      //    printf("\nLIBERADO %d\n",ndxReg);
          regfree(&aREGEX[ndxReg]);
       } 
    }
    
    free(TOKENIZER);
    if( SWITCH_VAR ) hb_itemRelease( SWITCH_VAR );
    
    while(cabeza!=NULL){
       jumpLabel *nodo = cabeza;
       cabeza=nodo->siguiente;
       free(nodo);
    }
    while(cabezaTry!=NULL){
       tryLabel *nodo = cabezaTry;
       cabezaTry=nodo->siguiente;
       free(nodo);
    }
    i=0;
    while(i<=nINDEXOBJ){
       if(pSTK_OBJ[i])
           hb_itemRelease(pSTK_OBJ[i]);
       ++i;
    }
    free(STK_PRG);  // por global STK_PRG realloc.
    //printf("\033[?25h");
    hb_inkeySetLast( 0 );
    hb_itemReturnRelease( pRET );           // define retorno de puntero pRET

}


#pragma ENDDUMP

